{
  "schemaVersion": "2.2",
  "description": "Use this document to run Chef recipes on AWS Systems Manager managed instances. This document supports Chef Client versions 11 through 18. It can be run on the following operating systems: Amazon Linux, Amazon Linux 2, Amazon Linux 2023, Ubuntu, Red Hat Enterprise Linux 7, Red Hat Enterprise Linux 8, Microsoft Windows Server 2016, Microsoft Windows Server 2019, Microsoft Windows Server 2022. The document supports Amazon S3, GitHub, Git, and HTTP as cookbook sources.",
  "parameters": {
    "SourceType": {
      "description": "(Required) The source repository type for your Chef cookbooks.",
      "type": "String",
      "allowedValues": [
        "Git",
        "GitHub",
        "HTTP",
        "S3"
      ],
      "default": "S3"
    },
    "SourceInfo": {
      "description": "(Required) Information about the source repository, such as repository, branch, username if Git, repository name, owner, branch if on GitHub, url if HTTP, or path if Amazon S3. If source type is Git, you can specify any of the following: 'repository', 'privateSSHKey', 'getOptions', 'skipHostKeyChecking', 'username', 'password'. If source type is GitHub, you can specify any of the following: 'owner', 'repository', 'path', 'getOptions', 'tokenInfo'. If source type is HTTP, you can specify any of the following: 'url', 'allowInsecureDownload', 'authMethod', 'username', 'password'. If source type is S3, you can specify 'path'. Example GitHub parameters: {\"owner\":\"awslabs\",\"repository\":\"amazon-ssm\",\"path\":\"Compliance/InSpec/PortCheck\",\"getOptions\":\"branch:master\"}.",
      "type": "StringMap",
      "displayType": "textarea",
      "default": {
        "path": "https://aws-applychefrecipes-examples.s3.amazonaws.com/apply-chef-recipes-example-cookbook.tar.gz"
      },
      "allowedPattern": "^.+$"
    },
    "RunList": {
      "type": "String",
      "description": "(Optional) The Chef recipes to apply. For example, recipe[cookbook_name1::recipe_name],recipe[cookbook_name2::recipe_name]",
      "allowedPattern": "^(recipe\\[[^'\";&\\|><\\*\\?`\\$\\(\\)\\{\\}\\[\\]!#\\\\]+\\])(\\,recipe\\[[^'\";&\\|><\\*\\?`\\$\\(\\)\\{\\}\\[\\]!#\\\\]+\\])*$|^\\s*$",
      "default": "recipe[apply-chef-recipes-example-cookbook::default]"
    },
    "JsonAttributesSources": {
      "description": "(Optional) Sequence of sources that contain JSON Attributes to be passed to the Chef client applies your recipes. The arguments from the first source listed will override arguments from the second source, if both sources contain same arguments. Parameters specified in 'JsonAttributesContent' will override the values from all sources. You should provide space or new line separated JSON objects: {\"sourceType\":\"s3\", \"sourceInfo\":\"someS3URL1\"} {\"sourceType\":\"s3\", \"sourceInfo\":\"someS3URL2\"}.",
      "type": "String",
      "displayType": "textarea",
      "default": "",
      "allowedPattern": "(^$|^.+$)"
    },
    "JsonAttributesContent": {
      "description": "(Optional) Attributes JSON to pass to the Chef client that applies your recipes. Attributes defined here will override the same attributes if they are defined it JsonAttributesSources parameter.",
      "type": "String",
      "displayType": "textarea",
      "default": "{\"filepath\":\"example.txt\", \"content\":\"Hello, World!\"}",
      "allowedPattern": "(^$|^.+$)"
    },
    "ChefClientVersion": {
      "type": "String",
      "description": "(Optional) The Chef client version to install on instances before recipes are applied. If you provide the Chef client version, Systems Manager downloads Chef client binaries by using the Chef Omnitruck API. If you specify None as the client version, Systems Manager does not install the Chef client before applying your recipes.",
      "default": "14",
      "allowedValues": [
        "None",
        "11",
        "12",
        "13",
        "14",
        "15",
        "16",
        "17",
        "18"
      ]
    },
    "ChefClientArguments": {
      "type": "String",
      "description": "(Optional) Extra arguments to be passed to the Chef client that applies your recipes. For more information about available arguments, run chef-client -h from an instance that has the Chef client installed.",
      "default": "",
      "allowedPattern": "^[^'\";&\\|><\\*\\?`\\$\\(\\)\\{\\}\\[\\]!#\\\\]*$"
    },
    "WhyRun": {
      "type": "String",
      "description": "(Optional) When set to true, enables why-run mode, which shows what will happen if the recipes are run, but does not modify target instances.",
      "allowedValues": [
        "True",
        "False"
      ],
      "default": "False"
    },
    "ComplianceSeverity": {
      "type": "String",
      "description": "(Optional) The severity of drift between your Chef recipes and instance resources that is shown in Systems Manager compliance reports. To skip compliance reporting, specify None.",
      "allowedValues": [
        "None",
        "Critical",
        "High",
        "Medium",
        "Low",
        "Informational",
        "Unspecified"
      ],
      "default": "None"
    },
    "ComplianceType": {
      "type": "String",
      "description": "(Optional) The compliance type that you want reported in compliance results.",
      "default": "Custom:Chef",
      "allowedPattern": "^$|^Custom\\:[a-zA-Z0-9\\-_\\.]{1,93}$"
    },
    "ComplianceReportBucket": {
      "type": "String",
      "description": "(Optional) The name of an existing Amazon S3 bucket in which to store details about every Chef run executed by this document, including resource configuration and compliance results.",
      "default": "",
      "allowedPattern": "^[^'\";&\\|><\\*\\?`\\$\\(\\)\\{\\}\\[\\]!#\\\\]*$"
    },
    "ChefExecutionTimeout": {
      "type": "String",
      "description": "(Optional) Number of seconds allowed for the Chef recipes to complete execution. Minimum allowed value is 5 seconds.",
      "default": "3600",
      "allowedPattern": "([1-9][0-9]{0,3})|(1[0-9]{1,4})|(2[0-7][0-9]{1,3})|(28[0-7][0-9]{1,2})|(28800)"
    }
  },
  "mainSteps": [
    {
      "action": "aws:runShellScript",
      "name": "setKnownHostsLinux",
      "precondition": {
        "StringEquals": [
          "platformType",
          "Linux"
        ]
      },
      "inputs": {
        "onFailure": "exit",
        "runCommand": [
          "#!/bin/bash",
          "# MIT No Attribution",
          "#",
          "# Copyright 2024 Amazon.com, Inc. or its affiliates. All Rights Reserved.",
          "#",
          "# Permission is hereby granted, free of charge, to any person obtaining a copy of this",
          "# software and associated documentation files (the \"Software\"), to deal in the Software",
          "# without restriction, including without limitation the rights to use, copy, modify,",
          "# merge, publish, distribute, sublicense, and/or sell copies of the Software, and to",
          "# permit persons to whom the Software is furnished to do so.",
          "#",
          "# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,",
          "# INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A",
          "# PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT",
          "# HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION",
          "# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE",
          "# SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.",
          "#",
          "",
          "",
          "function report_info() {",
          "    echo \"INFO: $*\"",
          "}",
          "",
          "function report_error() {",
          "    echo \"ERROR: $*\" 1>&2",
          "}",
          "",
          "function throw_error() {",
          "    report_error \"$*\"",
          "    exit 1",
          "}",
          "",
          "function add_to_known_hosts() {",
          "    local server=\"$1\"",
          "    mkdir -p ~/.ssh",
          "    touch ~/.ssh/known_hosts",
          "    tmpfile=$(mktemp)",
          "    ssh-keyscan $server 2> /dev/null > $tmpfile",
          "    if [[ $(diff --new-line-format=\"\" --unchanged-line-format=\"\" <(sort $tmpfile) <(sort ~/.ssh/known_hosts)) ]]; then",
          "       diff --new-line-format=\"\" --unchanged-line-format=\"\" <(sort $tmpfile) <(sort ~/.ssh/known_hosts) >> ~/.ssh/known_hosts",
          "       report_info \"$server has been added to known_hosts.\"",
          "    else",
          "       report_info \"$server already exists in known_hosts.\"",
          "    fi",
          "    rm $tmpfile",
          "}",
          "",
          "if [[ \"{{SourceType}}\" == \"Git\" ]]; then",
          "   source_info=$(cat \"${BASH_SOURCE[0]}\" | awk -v RS='^$' -F 'AWSAPPLYCHEF_RECIPES_SOURCE_INFO' '{print $3}' | tr -d \\')",
          "   if [[ -n $(echo \"$source_info\" | grep -o '\"privateSSHKey\"') ]]; then",
          "       repository=$(echo \"$source_info\" | grep -o '\"repository\":\\s*\"[^\"]*' | grep -o '[^\"]*$')",
          "       if [[ -z $repository ]]; then",
          "           throw_error \"Repository for Git resources type must be specified.\"",
          "       fi",
          "       server=$(echo \"$repository\" | grep -o \"@[^/]*\" | tr -d '@' | awk -F ':' '{print $1}')",
          "       add_to_known_hosts $server",
          "   else",
          "       report_info \"This step will be skipped since connection to Git server will not be made via SSH.\"",
          "   fi",
          "else",
          "   report_info \"This step will be skipped since cookbook source is not Git.\"",
          "fi",
          "exit $?",
          "AWSAPPLYCHEF_RECIPES_SOURCE_INFO'",
          "{{ SourceInfo }}",
          "'"
        ]
      }
    },
    {
      "action": "aws:runPowerShellScript",
      "name": "setKnownHostsWindows",
      "precondition": {
        "StringEquals": [
          "platformType",
          "Windows"
        ]
      },
      "inputs": {
        "onFailure": "exit",
        "runCommand": [
          "# MIT No Attribution",
          "#",
          "# Copyright 2024 Amazon.com, Inc. or its affiliates. All Rights Reserved.",
          "#",
          "# Permission is hereby granted, free of charge, to any person obtaining a copy of this",
          "# software and associated documentation files (the \"Software\"), to deal in the Software",
          "# without restriction, including without limitation the rights to use, copy, modify,",
          "# merge, publish, distribute, sublicense, and/or sell copies of the Software, and to",
          "# permit persons to whom the Software is furnished to do so.",
          "#",
          "# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,",
          "# INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A",
          "# PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT",
          "# HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION",
          "# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE",
          "# SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.",
          "#",
          "",
          "",
          "function report_info($message) {",
          "    echo \"INFO: $message\"",
          "}",
          "",
          "function report_error($message) {",
          "    echo \"ERROR: $message\" 2>&1",
          "}",
          "",
          "function throw_error($message) {",
          "    report_error \"$message\"",
          "    exit 1",
          "}",
          "",
          "function validate_openssh_bundle_checksum() {",
          "      $expected_openssh_bundle_hash=\"BD48FE985D400402C278C485DB20E6A82BC4C7F7D8E0EF5A81128F523096530C\"",
          "      $openssh_bundle_path=\"$env:Temp\\openssh.zip\"",
          "      try{",
          "         $actual_openssh_bundle_hash=$(Get-FileHash \"$openssh_bundle_path\" | select -ExpandProperty Hash)",
          "      }",
          "      catch{",
          "         throw_error \"An error has occurred during checksum calculation.\"",
          "      }",
          "      if ( \"$actual_openssh_bundle_hash\" -ne \"$expected_openssh_bundle_hash\") {",
          "         rm \"$openssh_bundle_path\"",
          "         throw_error \"Checksum verification for $openssh_bundle_path failed.\"",
          "      }",
          "}",
          "",
          "function download_openssh(){",
          "    if ( \"$env:PROCESSOR_ARCHITECTURE\" -eq 'AMD64') {",
          "       $platform=\"Win64\"",
          "    } else {",
          "       $platform=\"Win32\"",
          "    }",
          "    $open_ssh_path=\"C:\\Windows\\System32\\OpenSSH\"",
          "    if (($env:Path | Select-String \"C:\\\\Windows\\\\System32\\\\OpenSSH\\\\OpenSSH-$platform\\\\;\").Length -eq 0){",
          "       $env:Path += \";$open_ssh_path\\OpenSSH-$platform\\;\"",
          "    }",
          "    try {",
          "       Get-Command ssh -ErrorAction 'Stop' | Out-Null",
          "    }",
          "    catch {",
          "       [Net.ServicePointManager]::SecurityProtocol = \"Tls12, Tls13\"",
          "       Invoke-WebRequest -Uri \"https://github.com/PowerShell/Win32-OpenSSH/releases/download/v9.5.0.0p1-Beta/OpenSSH-$platform.zip\" -OutFile \"$env:Temp\\openssh.zip\"",
          "       validate_openssh_bundle_checksum",
          "       Add-Type -Assembly \"System.IO.Compression.Filesystem\"",
          "       if ((test-path \"$open_ssh_path\\OpenSSH-$platform\\\")) {",
          "           rm -r \"$open_ssh_path\\OpenSSH-$platform\\\"",
          "       }",
          "       [System.IO.Compression.ZipFile]::ExtractToDirectory(\"$env:Temp\\openssh.zip\",\"$open_ssh_path\")",
          "       rm \"$env:Temp\\openssh.zip\"",
          "   }",
          "}",
          "function add_to_known_hosts($server){",
          "    $new_host=$(ssh-keyscan $server 2> $null)",
          "    $existing_hosts=''",
          "    if (!(test-path \"$env:userprofile\\.ssh\")) {",
          "       md \"$env:userprofile\\.ssh\"",
          "    }",
          "    if ((test-path \"$env:userprofile\\.ssh\\known_hosts\")) {",
          "       $existing_hosts=Get-Content \"$env:userprofile\\.ssh\\known_hosts\"",
          "    }",
          "    $host_added=0",
          "    foreach ($line in $new_host) {",
          "       if (!($existing_hosts -contains $line)) {",
          "           Add-Content -Path \"$env:userprofile\\.ssh\\known_hosts\" -Value $line",
          "           $host_added=1",
          "       }",
          "    }",
          "   if ($host_added) {",
          "       report_info \"$server has been added to known_hosts.\"",
          "   } else {",
          "       report_info \"$server already exists in known_hosts.\"",
          "   }",
          "}",
          "",
          "if ((\"{{ SourceType }}\" -eq \"Git\")) {",
          "   $PS_SCRIPT_NAME=$MyInvocation.MyCommand.Name",
          "   $DELIMITER=\"AWSAPPLYCHEF_RECIPES_SOURCE_INFO\"",
          "   $DELIMITER_INDEX=$(Select-String -Path \"$PSScriptRoot\\$PS_SCRIPT_NAME\" -Pattern \"$DELIMITER\")[-1].LineNumber",
          "   $source_info=(Get-Content \"$PSScriptRoot\\$PS_SCRIPT_NAME\"  | where {$_.readcount -gt ($DELIMITER_INDEX-1)}).Replace(\"$DELIMITER\",'').Trim(\"'\") | ConvertFrom-Json",
          "   if ($source_info.privateSSHKey) {",
          "       $repository=$source_info.repository",
          "       if (! $source_info.repository) {",
          "           throw_error \"Repository for Git resources type must be specified.\"",
          "       }",
          "       $git_server=([regex]::Match($repository,\"@(.*?)/\").Groups[1].Value).split(':')[0]",
          "       download_openssh",
          "       add_to_known_hosts $git_server",
          "   } else {",
          "       report_info \"This step will be skipped since connection to Git server will not be made via SSH.\"",
          "   }",
          "} else {",
          "    report_info \"This step will be skipped since cookbook source is not Git.\"",
          "}",
          "exit $LASTEXITCODE",
          "AWSAPPLYCHEF_RECIPES_SOURCE_INFO'",
          "{{ SourceInfo }}",
          "'"
        ]
      }
    },
    {
      "action": "aws:downloadContent",
      "name": "downloadCookbooks",
      "inputs": {
        "onFailure": "exit",
        "SourceType": "{{ SourceType }}",
        "SourceInfo": "{{ SourceInfo }}",
        "destinationPath": "customer_cookbooks"
      }
    },
    {
      "action": "aws:runShellScript",
      "name": "setCustomJsonLinux",
      "precondition": {
        "StringEquals": [
          "platformType",
          "Linux"
        ]
      },
      "inputs": {
        "onFailure": "exit",
        "runCommand": [
          "#!/bin/bash",
          "# MIT No Attribution",
          "#",
          "# Copyright 2024 Amazon.com, Inc. or its affiliates. All Rights Reserved.",
          "#",
          "# Permission is hereby granted, free of charge, to any person obtaining a copy of this",
          "# software and associated documentation files (the \"Software\"), to deal in the Software",
          "# without restriction, including without limitation the rights to use, copy, modify,",
          "# merge, publish, distribute, sublicense, and/or sell copies of the Software, and to",
          "# permit persons to whom the Software is furnished to do so.",
          "#",
          "# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,",
          "# INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A",
          "# PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT",
          "# HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION",
          "# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE",
          "# SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.",
          "#",
          "",
          "set -e",
          "",
          "function report_info() {",
          "    echo \"INFO: $*\"",
          "}",
          "",
          "function report_error() {",
          "    echo \"ERROR: $*\" 1>&2",
          "}",
          "",
          "function throw_error() {",
          "    report_error \"$*\"",
          "    exit 1",
          "}",
          "",
          "function get_s3_region() {",
          "    local s3_host=\"$1\"",
          "    region=\"\"",
          "    if [[ \"$s3_host\" == *\"amazonaws.com.cn\"* ]]; then",
          "       region_part=$(echo $s3_host | rev | cut -d \".\" -f4 | rev)",
          "    else",
          "       region_part=$(echo $s3_host | rev | cut -d \".\" -f3 | rev)",
          "    fi",
          "    region=$region_part",
          "    if [[ $region_part == \"s3\" ]]; then",
          "       region=\"us-east-1\"",
          "    fi",
          "    if [[ $region_part == s3-* ]]; then",
          "     region=$(echo \"${region/s3-/}\")",
          "    fi",
          "    echo $region",
          "}",
          "",
          "function get_s3_bucket_properties() {",
          "    local s3_url=\"$1\"",
          "    host=\"\"",
          "    region=\"\"",
          "    bucket_name=\"\"",
          "    bucket_key=\"\"",
          "    if [[ $s3_url == https://* ]] || [[ $s3_url == http://* ]]; then",
          "       if [[ $s3_url == https://* ]]; then",
          "           s3_url_without_protocol=$(echo \"${s3_url/https:\\/\\//}\")",
          "       else",
          "           s3_url_without_protocol=$(echo \"${s3_url/http:\\/\\//}\")",
          "       fi",
          "       s3_url_first_part=$(echo \"${s3_url_without_protocol}\" | cut -d \"/\" -f1)",
          "       s3_url_second_part=$(echo \"${s3_url_without_protocol}\" | cut -d \"/\" -f2-)",
          "       s3_url_first_subpart=${s3_url_first_part%s3*}",
          "       last_index_of_s3=${#s3_url_first_subpart}",
          "       s3_url_first_part_length=${#s3_url_first_part}",
          "       if [[ $last_index_of_s3 == 0 ]]; then",
          "           host=$s3_url_first_part",
          "           bucket_name=$(echo $s3_url_second_part | cut -d \"/\" -f1)",
          "           bucket_key=$(echo $s3_url_second_part | cut -d  \"/\" -f2-)",
          "       else",
          "           host=$(echo ${s3_url_first_part:$last_index_of_s3:$s3_url_first_part_length})",
          "           bucket_name=$(echo ${s3_url_first_part:0:$last_index_of_s3-1})",
          "           bucket_key=$s3_url_second_part",
          "       fi",
          "       region=$(get_s3_region $host)",
          "    else",
          "       throw_error \"S3 file reference should be in URL format, starting with https:// or http://.\"",
          "    fi",
          "    echo \"$host\"",
          "    echo \"$region\"",
          "    echo \"$bucket_name\"",
          "    echo \"$bucket_key\"",
          "}",
          "",
          "function sha256() {",
          "    local data=\"$1\"",
          "    printf \"${data}\" | openssl dgst -binary -sha256 | od -An -vtx1 | tr -d '[:space:]'",
          "}",
          "function hmac_sha256_hexdigest() {",
          "    local key=\"$1\"",
          "    local data=\"$2\"",
          "    printf \"${data}\" | openssl dgst -binary -hex -sha256 -mac HMAC -macopt \"hexkey:${key}\" | sed 's/^.* //'",
          "}",
          "",
          "function hmac_sha256_digest () {",
          "    local key=\"$1\"",
          "    local data=\"$2\"",
          "    printf \"${data}\" | openssl dgst -binary -sha256 -mac HMAC -macopt \"hexkey:${key}\" | od -An -vtx1 | tr -d '[:space:]'",
          "}",
          "",
          "function create_canonical_request() {",
          "    local s3_address=\"$1\"",
          "    local cnanonical_headers=\"$2\"",
          "    local payload_sha256=\"$3\"",
          "    local headers=\"$4\"",
          "    printf \"GET\\n/${s3_address}\\n\\n${canonical_headers}\\n\\n${headers}\\n${payload_sha256}\"",
          "}",
          "function create_string_to_sign() {",
          "    local date1=\"$1\"",
          "    local date2=\"$2\"",
          "    local region=\"$3\"",
          "    local request_sha256=\"$4\"",
          "    local service=\"$5\"",
          "    printf \"AWS4-HMAC-SHA256\\n${date2}\\n${date1}/${region}/${service}/aws4_request\\n${request_sha256}\"",
          "}",
          "",
          "function calculate_signature() {",
          "    local access_key=\"$1\"",
          "    local date=\"$2\"",
          "    local region=\"$3\"",
          "    local service=\"$4\"",
          "    local sign_string=\"$5\"",
          "    kSecret=$(printf \"AWS4${access_key}\" | od -An -vtx1 | tr -d '[:space:]')",
          "    kDate=\"$(hmac_sha256_digest \"${kSecret}\" \"${date}\")\"",
          "    kRegion=\"$(hmac_sha256_digest \"${kDate}\" \"${region}\")\"",
          "    kService=\"$(hmac_sha256_digest \"${kRegion}\" \"${service}\")\"",
          "    kSigning=\"$(hmac_sha256_digest \"${kService}\" \"aws4_request\")\"",
          "    signature=\"$(hmac_sha256_hexdigest \"${kSigning}\" \"${sign_string}\")\"",
          "    echo \"${signature}\"",
          "}",
          "",
          "function download_s3_files() {",
          "    local s3_url=\"$1\"",
          "    local file_suffix=\"$2\"",
          "    {",
          "       read -r host",
          "       read -r region",
          "       read -r bucket_name",
          "       read -r bucket_key",
          "    } <<< \"$(get_s3_bucket_properties \"$s3_url\")\"",
          "    if [[ -z \"$bucket_name\" ]]; then",
          "       throw_error \"Unable to detect bucket name for ${s3_url}.\"",
          "    fi",
          "    if [[ -z \"$bucket_key\" ]]; then",
          "       throw_error \"Unable to detect bucket key for ${bucket_name} bucket.\"",
          "    fi",
          "    if [[ -z \"$region\" ]]; then",
          "       throw_error \"Unable to detect region for ${bucket_name} bucket.\"",
          "    fi",
          "    if [[ -z \"$host\" ]]; then",
          "       throw_error \"Unable to detect host for ${bucket_name} bucket.\"",
          "    fi",
          "    resource_name=\"$bucket_name/$bucket_key\"",
          "    if [[ ! -x \"$(command -v aws)\" ]]; then",
          "       token=`curl -s -X PUT \"http://169.254.169.254/latest/api/token\" -H \"X-aws-ec2-metadata-token-ttl-seconds: 21600\"`",
          "       instance_profile=`curl -s -H \"X-aws-ec2-metadata-token: $token\" -v http://169.254.169.254/latest/meta-data/iam/security-credentials/ 2>/dev/null`",
          "       aws_access_key_id=`curl -s -H \"X-aws-ec2-metadata-token: $token\" -v  http://169.254.169.254/latest/meta-data/iam/security-credentials/${instance_profile} 2>/dev/null | grep AccessKeyId | cut -d':' -f2 | sed 's/[^0-9A-Z]*//g'`",
          "       aws_secret_access_key=`curl -s -H \"X-aws-ec2-metadata-token: $token\" -v http://169.254.169.254/latest/meta-data/iam/security-credentials/${instance_profile} 2>/dev/null| grep SecretAccessKey | cut -d':' -f2 | sed 's/[^0-9A-Za-z/+=]*//g'`",
          "       aws_security_token=`curl -s -H \"X-aws-ec2-metadata-token: $token\" -v http://169.254.169.254/latest/meta-data/iam/security-credentials/${instance_profile} 2>/dev/null | sed -n '/Token/{p;}' | cut -f4 -d'\"'`",
          "       service=\"s3\"",
          "       dateValue1=`TZ=GMT date \"+%Y%m%d\"`",
          "       dateValue2=`TZ=GMT date \"+%Y%m%dT%H%M%SZ\"`",
          "       request_payload=\"\"",
          "       request_payload_sha256=\"$(sha256 \"${request_payload}\")\"",
          "       signed_headers=\"host;x-amz-content-sha256;x-amz-date;x-amz-security-token\"",
          "       canonical_headers=\"host:${host}\\nx-amz-content-sha256:${request_payload_sha256}\\nx-amz-date:${dateValue2}\\nx-amz-security-token:${aws_security_token}\"",
          "       canonical_request=\"$(create_canonical_request \"${resource_name}\" \"${canonical_headers}\" \"${request_payload_sha256}\" \"${signed_headers}\")\"",
          "       canonical_request_sha256=\"$(sha256 \"${canonical_request}\")\"",
          "       string_to_sign=\"$(create_string_to_sign \"${dateValue1}\" \"${dateValue2}\" \"${region}\" \"${canonical_request_sha256}\" \"${service}\")\"",
          "       signature=\"$(calculate_signature \"${aws_secret_access_key}\" \"${dateValue1}\" \"${region}\" \"${service}\" \"${string_to_sign}\")\"",
          "       curl --fail --silent --show-error --request GET \\",
          "       -H \"Authorization: AWS4-HMAC-SHA256 Credential=${aws_access_key_id}/${dateValue1}/${region}/${service}/aws4_request, SignedHeaders=${signed_headers}, Signature=${signature}\" \\",
          "       -H \"Host: ${host}\" \\",
          "       -H \"X-Amz-Content-SHA256: ${request_payload_sha256}\"\\",
          "       -H \"X-Amz-Date: ${dateValue2}\" \\",
          "       -H \"X-Amz-Security-Token: ${aws_security_token}\" \\",
          "       \"https://${host}/${resource_name}\"\\",
          "       -o \"$TMP_CUSTOM_JSON_DIR/file$file_suffix.json\"",
          "       report_info \"Object ${resource_name} is downloaded to $TMP_CUSTOM_JSON_DIR/file$file_suffix.json.\"",
          "    else",
          "       aws s3 cp \"s3://$resource_name\" \"$TMP_CUSTOM_JSON_DIR/file$file_suffix.json\" --region \"${region}\"",
          "       report_info \"Object ${resource_name} is downloaded to $TMP_CUSTOM_JSON_DIR/file$file_suffix.json.\"",
          "    fi",
          "}",
          "",
          "function download_from_json_sources() {",
          "    for i in \"${!JSON_SOURCES[@]}\"; do",
          "       source_type=$(echo ${JSON_SOURCES[$i]} | grep -o '\"sourceType\":\\s*\"[^\"]*' | grep -o '[^\"]*$' | tr '[:upper:]' '[:lower:]')",
          "       source_info=$(echo ${JSON_SOURCES[$i]} | grep -o '\"sourceInfo\":\\s*\"[^\"]*' | grep -o '[^\"]*$' | xargs)",
          "       file_suffix=$(($JSON_SOURCES_NUMBER-$i-1))",
          "       if [[ \"$source_type\" == \"s3\" ]]; then",
          "           download_s3_files \"$source_info\" $file_suffix",
          "       fi",
          "    done",
          "}",
          "",
          "function validate_json_sources() {",
          "    for source_info in \"${JSON_SOURCES[@]}\"; do",
          "       if [ -z $(echo \"$source_info\" | grep -o '\"sourceType\":') ] || [ -z $(echo \"$source_info\" | grep -o '\"sourceInfo\":') ]; then",
          "           throw_error \"Json Attributes Source must have both sourceType and sourceInfo fields.\"",
          "       fi",
          "    done",
          "}",
          "",
          "function merge_json_files() {",
          "    if [[ -x \"$(command -v python3)\" ]]; then",
          "        python=\"python3\"",
          "    elif [[ -x \"$(command -v python)\" ]]; then",
          "        python=\"python\"",
          "    else",
          "        throw_error \"python is not installed.\"",
          "    fi",
          "$python - << EOF",
          "import os",
          "import json",
          "import re",
          "",
          "json_files_directory=os.getenv('TMP_CUSTOM_JSON_DIR')",
          "file_names = [file_name for file_name in os.listdir(json_files_directory) if re.match('^file\\d+.json$', file_name)]",
          "file_names.sort(key=lambda x: int(x.replace('.json','').strip('file')))",
          "custom_json_attributes = {}",
          "for file_name in file_names:",
          "    file_path = '{0}/{1}'.format(json_files_directory, file_name)",
          "    with open(file_path) as json_file:",
          "        raw_file_content = json_file.read()",
          "        if raw_file_content.split():",
          "            file_content = json.loads(raw_file_content)",
          "            custom_json_attributes.update(file_content)",
          "if custom_json_attributes:",
          "    with open ('json_attributes.json','w+') as json_file:",
          "        json.dump(custom_json_attributes, json_file)",
          "EOF",
          "}",
          "",
          "if [[ -z ${BASH_SOURCE[0]} ]]; then",
          "    throw_error \"Bash script source is empty.\"",
          "fi",
          "",
          "if [[ ! -x \"$(command -v awk)\" ]]; then",
          "    throw_error \"awk is not installed.\"",
          "fi",
          "",
          "export TMP_CUSTOM_JSON_DIR=\"customjson\"",
          "mkdir -p $TMP_CUSTOM_JSON_DIR",
          "< \"${BASH_SOURCE[0]}\" awk -v RS='^$' -F 'AWSAPPLYCHEF_RECIPES_JSONDELIM' '{print $4}' | awk -v RS='^$' -F 'AWSAPPLYCHEF_RECIPES_S3_URLS' '{print $2}' >\"$TMP_CUSTOM_JSON_DIR/s3_urls.text\"",
          "raw_json_sources=$(cat \"$TMP_CUSTOM_JSON_DIR/s3_urls.text\")",
          "JSON_SOURCES=()",
          "while read -r source; do",
          "   if [[ -n \"$source\" ]]; then",
          "       JSON_SOURCES+=(\"${source}\")",
          "   fi",
          "done <<< \"$(echo $raw_json_sources | grep -o '{[^}]*}')\"",
          "JSON_SOURCES_NUMBER=${#JSON_SOURCES[@]}",
          "validate_json_sources",
          "< \"${BASH_SOURCE[0]}\" awk -v RS='^$' -F 'AWSAPPLYCHEF_RECIPES_JSONDELIM' '{print $4}' | awk -v RS='^$' -F 'AWSAPPLYCHEF_RECIPES_S3_URLS' '{print $1}' >\"$TMP_CUSTOM_JSON_DIR/file$JSON_SOURCES_NUMBER.json\"",
          "download_from_json_sources",
          "merge_json_files",
          "rm -rf \"$TMP_CUSTOM_JSON_DIR\"",
          "report_info \"Custom json is set up.\"",
          "",
          "exit 0",
          "AWSAPPLYCHEF_RECIPES_JSONDELIM{{ JsonAttributesContent }}",
          "AWSAPPLYCHEF_RECIPES_S3_URLS{{ JsonAttributesSources }}"
        ]
      }
    },
    {
      "action": "aws:runPowerShellScript",
      "name": "setCustomJsonWindows",
      "precondition": {
        "StringEquals": [
          "platformType",
          "Windows"
        ]
      },
      "inputs": {
        "onFailure": "exit",
        "runCommand": [
          "# MIT No Attribution",
          "#",
          "# Copyright 2024 Amazon.com, Inc. or its affiliates. All Rights Reserved.",
          "#",
          "# Permission is hereby granted, free of charge, to any person obtaining a copy of this",
          "# software and associated documentation files (the \"Software\"), to deal in the Software",
          "# without restriction, including without limitation the rights to use, copy, modify,",
          "# merge, publish, distribute, sublicense, and/or sell copies of the Software, and to",
          "# permit persons to whom the Software is furnished to do so.",
          "#",
          "# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,",
          "# INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A",
          "# PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT",
          "# HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION",
          "# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE",
          "# SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.",
          "#",
          "",
          "",
          "function report_info($message) {",
          "    echo \"INFO: $message\"",
          "}",
          "",
          "function report_error($message) {",
          "    echo \"ERROR: $message\" 2>&1",
          "}",
          "",
          "function throw_error($message) {",
          "    report_error \"$message\"",
          "    exit 1",
          "}",
          "",
          "function join_json_properties($source, $extend){",
          "    if ($source.GetType().Name -eq \"PSCustomObject\" -and $extend.GetType().Name -eq \"PSCustomObject\") {",
          "        foreach($Property in $source | Get-Member -type NoteProperty, Property){",
          "            if ($extend.$($Property.Name) -eq $null) {",
          "              continue",
          "            }else {",
          "            $source.$($Property.Name) = $extend.$($Property.Name)",
          "        }",
          "    }",
          "    return $source",
          "   }",
          "}",
          "",
          "function add_json_properties($source, $toExtend){",
          "    if ($source.GetType().Name -eq \"PSCustomObject\") {",
          "        foreach($Property in $source | Get-Member -type NoteProperty, Property){",
          "            if ($toExtend.$($Property.Name) -eq $null) {",
          "              $toExtend | Add-Member -MemberType NoteProperty -Value $source.$($Property.Name) -Name $Property.Name",
          "            }",
          "        }",
          "    }",
          "    return $toExtend",
          "}",
          "",
          "function validate_json_sources($json_sources){",
          "    foreach ($source in $json_sources){",
          "       try{",
          "          $json_source=$source | ConvertFrom-Json",
          "       } catch {",
          "           throw_error \"Invalid JSON primitive: $source\"",
          "       }",
          "       if (!$json_source.sourceType -or !$json_source.sourceInfo){",
          "           throw_error \"Json Attributes Source must have both sourceType and sourceInfo fields.\"",
          "       }",
          "    }",
          "}",
          "",
          "function get_s3_region($s3_host) {",
          "    $region=\"\"",
          "    if (\"$s3_host\"  -like '*amazonaws.com.cn*') {",
          "       $region_part=$(\"$s3_host\" -split '\\.')[-4]",
          "    } else {",
          "       $region_part=$(\"$s3_host\" -split '\\.')[-3]",
          "    }",
          "    $region=$region_part",
          "    if (\"$region_part\" -eq \"s3\") {",
          "       $region=\"us-east-1\"",
          "    }",
          "    if ($region_part.StartsWith(\"s3-*\")) {",
          "     $region=$region_part -replace 's3-'",
          "    }",
          "    return $region",
          "}",
          "",
          "function get_s3_bucket_properties($s3_url){",
          "    $bucket_name=\"\"",
          "    $bucket_key=\"\"",
          "    $s3_host=\"\"",
          "    $region=\"\"",
          "    if ($s3_url.StartsWith(\"https://\") -or $s3_url.StartsWith(\"http://\")) {",
          "       if ($s3_url.StartsWith(\"https://\")) {",
          "           $protocol='https'",
          "           $s3_url_without_protocol=$s3_url -replace 'https://'",
          "       } else {",
          "           $protocol='http'",
          "           $s3_url_without_protocol=$s3_url -replace 'http://'",
          "       }",
          "       $s3_url_parts=$s3_url_without_protocol -replace 'https://', '' -split '/',2",
          "       $s3_url_first_part=$s3_url_parts[0]",
          "       $s3_url_second_part=$s3_url_parts[1]",
          "       $last_index_of_s3=$s3_url_first_part.LastIndexOf(\"s3\")",
          "       if ($last_index_of_s3 -eq 0) {",
          "           $bucket_parts=$s3_url_second_part -split '/',2",
          "           $s3_host=$s3_url_first_part",
          "           $bucket_name=$bucket_parts[0]",
          "           $bucket_key=$bucket_parts[1]",
          "       } else {",
          "           $s3_host=$s3_url_first_part.Substring($last_index_of_s3,$s3_url_first_part.Length-$last_index_of_s3)",
          "           $bucket_name=$s3_url_first_part.Substring(0,$last_index_of_s3-1)",
          "           $bucket_key=$s3_url_second_part",
          "       }",
          "       $region=$(get_s3_region $s3_host)",
          "    } else {",
          "       throw_error \"S3 file reference should be in URL format, starting with https:// or http://.\"",
          "    }",
          "    return $protocol, $s3_host, $region, $bucket_name, $bucket_key",
          "}",
          "",
          "function download_from_json_sources($json_sources, $number_of_files, $destination){",
          "    for($i=0; $i -lt $number_of_files; $i++) {",
          "       $json_source=$json_sources[$i] | ConvertFrom-Json",
          "       $source_type=$json_source.sourceType.ToLower()",
          "       $source_info=$json_source.sourceInfo.Trim()",
          "       $file_suffix=$number_of_files-$i-1",
          "       if ($source_type -eq \"s3\") {",
          "           $protocol, $s3_host, $region, $bucket_name, $bucket_key=$(get_s3_bucket_properties \"$source_info\")",
          "           if (!$bucket_name) {",
          "               throw_error \"Unable to detect bucket name for ${source_info}.\"",
          "           }",
          "           if (!$bucket_key) {",
          "               throw_error \"Unable to detect bucket key for ${bucket_name} bucket.\"",
          "           }",
          "           if (!$s3_host) {",
          "               throw_error \"Unable to detect host for ${bucket_name} bucket.\"",
          "           }",
          "           if (!$region) {",
          "               throw_error \"Unable to detect host for ${region} bucket.\"",
          "           }",
          "           if ($protocol -eq 'http' -and (Get-S3BucketEncryption -BucketName \"$bucket_name\" -Region \"$region\").ServerSideEncryptionRules) {",
          "               $protocol='https'",
          "           }",
          "           Copy-S3Object -EndpointUrl \"${protocol}://${s3_host}\" -BucketName \"${bucket_name}\" -Key \"${bucket_key}\" -Region \"${region}\" -LocalFile \"$destination\\file$file_suffix.json\"",
          "           report_info \"Object $bucket_name\\${bucket_key} is downloaded to $TMP_CUSTOM_JSON_DIR/file$file_suffix.json.\"",
          "       }",
          "       ((Get-Content -path \"$destination\\file$file_suffix.json\" -Raw) -replace '\\\\','\\\\') | Set-Content -Path \"$destination\\file$file_suffix.json\" -Encoding UTF8",
          "    }",
          "}",
          "",
          "function merge_json_files($total_files_number, $files_directory){",
          "    for($i=0; $i -lt $total_files_number; $i++) {",
          "        $json=(Get-Content \"$files_directory\\file$i.json\" -Raw | ConvertFrom-Json)",
          "        if ($i -eq 0) {",
          "            $i+=1",
          "            $jsonfirst=$json",
          "            $jsonsecond=(Get-Content \"$files_directory\\file$i.json\" -Raw | ConvertFrom-Json)",
          "        }else{",
          "            $jsonfirst=$result",
          "            $jsonsecond=$json",
          "        }",
          "        $merged=join_json_properties $jsonfirst $jsonsecond",
          "        $result=add_json_properties $merged $jsonsecond",
          "   }",
          "   $result | ConvertTo-Json -Depth 5 | Out-File -FilePath \"$files_directory\\combined.json\"",
          "}",
          "",
          "function fix_and_encode_json_file($filepath){",
          "   $utf8 = New-Object System.Text.UTF8Encoding $false",
          "   $json_attr_cont = Get-Content \"$filepath\" -Raw",
          "   Set-Content -Value $utf8.GetBytes($json_attr_cont) -Encoding Byte -Path 'json_attributes.json'",
          "}",
          "",
          "$PS_SCRIPT_NAME=$MyInvocation.MyCommand.Name",
          "$TMP_CUSTOM_JSON_DIR=\"customjson\"",
          "md $TMP_CUSTOM_JSON_DIR | Out-Null",
          "$DELIMITER_RECIPES='AWSAPPLYCHEF_RECIPES_JSONDELIM'",
          "$DELIMITER_JSON_SOURCES='AWSAPPLYCHEF_RECIPES_JSON_SOURCES'",
          "$DELIMITER_RECIPES_INDEX=$(Select-String -Path \"$PSScriptRoot\\$PS_SCRIPT_NAME\"-Pattern \"$DELIMITER_RECIPES\")[-1].LineNumber",
          "$DELIMITER_JSON_SOURCES_INDEX=$(Select-String -Path \"$PSScriptRoot\\$PS_SCRIPT_NAME\"-Pattern \"$DELIMITER_JSON_SOURCES\")[-1].LineNumber",
          "((Get-Content \"$PSScriptRoot\\$PS_SCRIPT_NAME\") | where {$_.readcount -gt ($DELIMITER_JSON_SOURCES_INDEX-1)}).Replace(\"$DELIMITER_JSON_SOURCES\",'').Trim(\"'\") | Out-File \"$TMP_CUSTOM_JSON_DIR\\jsonsources.txt\"",
          "$JSON_SOURCES=@( $(([regex]'{[^}]*}').Matches($(Get-Content \"$TMP_CUSTOM_JSON_DIR\\jsonsources.txt\"))).Value | Where { $_ -and $_.Trim() })",
          "$JSON_SOURCES_NUMBER = $JSON_SOURCES.Count",
          "if ($JSON_SOURCES_NUMBER) {",
          "   validate_json_sources $JSON_SOURCES",
          "}",
          "$TOTAL_JSON_FILES_NUMBER = $JSON_SOURCES_NUMBER",
          "((Get-Content \"$PSScriptRoot\\$PS_SCRIPT_NAME\" ) | where {$_.readcount -gt ($DELIMITER_RECIPES_INDEX-1) -and $_.readcount -lt $DELIMITER_JSON_SOURCES_INDEX}).Replace(\"$DELIMITER_RECIPES\",'').Trim(\"'\") | Out-File \"$TMP_CUSTOM_JSON_DIR\\file$JSON_SOURCES_NUMBER.json\" -Encoding UTF8",
          "if (! [String]::IsNullOrWhiteSpace((Get-Content \"$TMP_CUSTOM_JSON_DIR\\file$JSON_SOURCES_NUMBER.json\"))){ $TOTAL_JSON_FILES_NUMBER+=1 }",
          "",
          "Import-Module -Name AWSPowerShell",
          "try{",
          "   download_from_json_sources $JSON_SOURCES $JSON_SOURCES_NUMBER $TMP_CUSTOM_JSON_DIR",
          "}",
          "catch{",
          "   throw_error $error[0]",
          "}",
          "if ($TOTAL_JSON_FILES_NUMBER -gt 1) {",
          "   try{",
          "       merge_json_files $TOTAL_JSON_FILES_NUMBER $TMP_CUSTOM_JSON_DIR",
          "   }",
          "   catch{",
          "       throw_error $error[0]",
          "   }",
          "}else{",
          "   Copy-Item \"$TMP_CUSTOM_JSON_DIR\\file0.json\" -Destination \"$TMP_CUSTOM_JSON_DIR\\combined.json\"",
          "}",
          "",
          "try{",
          "   fix_and_encode_json_file \"$TMP_CUSTOM_JSON_DIR\\combined.json\"",
          "}",
          "catch{",
          "   throw_error \"Can't finalize json_attributes.json file.\"",
          "}",
          "",
          "Remove-Item -LiteralPath $TMP_CUSTOM_JSON_DIR -Force -Recurse",
          "report_info \"Custom json is set up.\"",
          "",
          "exit 0",
          "AWSAPPLYCHEF_RECIPES_JSONDELIM'{{ JsonAttributesContent }}'",
          "AWSAPPLYCHEF_RECIPES_JSON_SOURCES'{{ JsonAttributesSources }}'"
        ]
      }
    },
    {
      "action": "aws:runShellScript",
      "name": "executeRecipesLinux",
      "precondition": {
        "StringEquals": [
          "platformType",
          "Linux"
        ]
      },
      "inputs": {
        "timeoutSeconds": "{{ ChefExecutionTimeout }}",
        "onFailure": "exit",
        "runCommand": [
          "#!/bin/bash",
          "# MIT No Attribution",
          "#",
          "# Copyright 2024 Amazon.com, Inc. or its affiliates. All Rights Reserved.",
          "#",
          "# Permission is hereby granted, free of charge, to any person obtaining a copy of this",
          "# software and associated documentation files (the \"Software\"), to deal in the Software",
          "# without restriction, including without limitation the rights to use, copy, modify,",
          "# merge, publish, distribute, sublicense, and/or sell copies of the Software, and to",
          "# permit persons to whom the Software is furnished to do so.",
          "#",
          "# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,",
          "# INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A",
          "# PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT",
          "# HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION",
          "# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE",
          "# SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.",
          "#",
          "",
          "set -e",
          "",
          "SSM_CHEF_EXECUTION_BASE_DIR=\"$(pwd)\"",
          "export SSM_CHEF_EXECUTION_BASE_DIR",
          "export SSM_CHEF_SOURCE_TYPE=\"{{ SourceType }}\"",
          "export SSM_CHEF_RUN_LIST=\"{{ RunList }}\"",
          "export SSM_CHEF_WHY_RUN=\"{{ WhyRun }}\"",
          "export SSM_CHEF_CLIENT_ARGUMENTS=({{ ChefClientArguments }})",
          "export SSM_CHEF_CLIENT_VERSION=\"{{ ChefClientVersion }}\"",
          "export SSM_CHEF_COMPLIANCE_SEVERITY=\"{{ ComplianceSeverity }}\"",
          "export SSM_CHEF_COMPLIANCE_TYPE=\"{{ ComplianceType }}\"",
          "export SSM_CHEF_COMPLIANCE_REPORT_BUCKET=\"{{ ComplianceReportBucket }}\"",
          "",
          "CHEF_RUN_LOCK_DIR=\"/tmp/aws/chef_run_locks\"",
          "CHEF_RUN_LOCK_FILE=\"$CHEF_RUN_LOCK_DIR/aws-apply-chef-recipes.lock\"",
          "SSM_CHEF_RUN_ASSETS_BUCKET=\"aws-ssm-$AWS_SSM_REGION_NAME\"",
          "COMPLIANCE_REPORT_COOKBOOK_SHA_256=\"7bd335b078fd8cf68d8b36d164165b5e0d33eb9d53cb6ec8e309abec11181fe4\"",
          "",
          "function report_info() {",
          "    echo \"INFO: $*\"",
          "}",
          "",
          "function report_warning() {",
          "    echo \"WARNING: $*\"",
          "}",
          "",
          "function report_error() {",
          "    echo \"ERROR: $*\" 1>&2",
          "}",
          "",
          "function throw_error() {",
          "    report_error \"$*\"",
          "    exit 1",
          "}",
          "",
          "function get_installed_chef_version() {",
          "    local chef_version",
          "    chef_version=$(chef-client --version) || true",
          "    echo \"$chef_version\" | grep -E -o '[0-9]+\\.[0-9]+\\.[0-9]+'",
          "}",
          "",
          "function get_installed_chef_major_version() {",
          "    local chef_version",
          "    chef_version=$(get_installed_chef_version)",
          "    if [[ -z \"$chef_version\" ]]; then",
          "        throw_error \"Chef client is not installed. Install Chef client and then run the command again.\"",
          "    fi",
          "",
          "    echo \"$chef_version\" | grep -E -o '^[0-9]+'",
          "}",
          "",
          "function validate_certificate() {",
          "    if [ -e /opt/chef/embedded/ssl/cert.pem ]; then",
          "        (grep -qxF 'DST Root CA X3' /opt/chef/embedded/ssl/cert.pem && sudo sed -i '/DST Root CA X3/,+19d' /opt/chef/embedded/ssl/cert.pem);",
          "        (grep -qxF 'ISRG Root X1' /opt/chef/embedded/ssl/cert.pem || printf '\nISRG Root X1\n============\n-----BEGIN CERTIFICATE-----\nMIIFazCCA1OgAwIBAgIRAIIQz7DSQONZRGPgu2OCiwAwDQYJKoZIhvcNAQELBQAwTzELMAkGA1UE\nBhMCVVMxKTAnBgNVBAoTIEludGVybmV0IFNlY3VyaXR5IFJlc2VhcmNoIEdyb3VwMRUwEwYDVQQD\nEwxJU1JHIFJvb3QgWDEwHhcNMTUwNjA0MTEwNDM4WhcNMzUwNjA0MTEwNDM4WjBPMQswCQYDVQQG\nEwJVUzEpMCcGA1UEChMgSW50ZXJuZXQgU2VjdXJpdHkgUmVzZWFyY2ggR3JvdXAxFTATBgNVBAMT\nDElTUkcgUm9vdCBYMTCCAiIwDQYJKoZIhvcNAQEBBQADggIPADCCAgoCggIBAK3oJHP0FDfzm54r\nVygch77ct984kIxuPOZXoHj3dcKi/vVqbvYATyjb3miGbESTtrFj/RQSa78f0uoxmyF+0TM8ukj1\n3Xnfs7j/EvEhmkvBioZxaUpmZmyPfjxwv60pIgbz5MDmgK7iS4+3mX6UA5/TR5d8mUgjU+g4rk8K\nb4Mu0UlXjIB0ttov0DiNewNwIRt18jA8+o+u3dpjq+sWT8KOEUt+zwvo/7V3LvSye0rgTBIlDHCN\nAymg4VMk7BPZ7hm/ELNKjD+Jo2FR3qyHB5T0Y3HsLuJvW5iB4YlcNHlsdu87kGJ55tukmi8mxdAQ\n4Q7e2RCOFvu396j3x+UCB5iPNgiV5+I3lg02dZ77DnKxHZu8A/lJBdiB3QW0KtZB6awBdpUKD9jf\n1b0SHzUvKBds0pjBqAlkd25HN7rOrFleaJ1/ctaJxQZBKT5ZPt0m9STJEadao0xAH0ahmbWnOlFu\nhjuefXKnEgV4We0+UXgVCwOPjdAvBbI+e0ocS3MFEvzG6uBQE3xDk3SzynTnjh8BCNAw1FtxNrQH\nusEwMFxIt4I7mKZ9YIqioymCzLq9gwQbooMDQaHWBfEbwrbwqHyGO0aoSCqI3Haadr8faqU9GY/r\nOPNk3sgrDQoo//fb4hVC1CLQJ13hef4Y53CIrU7m2Ys6xt0nUW7/vGT1M0NPAgMBAAGjQjBAMA4G\nA1UdDwEB/wQEAwIBBjAPBgNVHRMBAf8EBTADAQH/MB0GA1UdDgQWBBR5tFnme7bl5AFzgAiIyBpY\n9umbbjANBgkqhkiG9w0BAQsFAAOCAgEAVR9YqbyyqFDQDLHYGmkgJykIrGF1XIpu+ILlaS/V9lZL\nubhzEFnTIZd+50xx+7LSYK05qAvqFyFWhfFQDlnrzuBZ6brJFe+GnY+EgPbk6ZGQ3BebYhtF8GaV\n0nxvwuo77x/Py9auJ/GpsMiu/X1+mvoiBOv/2X/qkSsisRcOj/KKNFtY2PwByVS5uCbMiogziUwt\nhDyC3+6WVwW6LLv3xLfHTjuCvjHIInNzktHCgKQ5ORAzI4JMPJ+GslWYHb4phowim57iaztXOoJw\nTdwJx4nLCgdNbOhdjsnvzqvHu7UrTkXWStAmzOVyyghqpZXjFaH3pO3JLF+l+/+sKAIuvtd7u+Nx\ne5AW0wdeRlN8NwdCjNPElpzVmbUq4JUagEiuTDkHzsxHpFKVK7q4+63SM1N95R1NbdWhscdCb+ZA\nJzVcoyi3B43njTOQ5yOf+1CceWxG1bQVs5ZufpsMljq4Ui0/1lvh+wjChP4kqKOJ2qxq4RgqsahD\nYVvTH9w7jXbyLeiNdd8XM2w9U/t7y0Ff/9yi0GE44Za4rF2LN9d11TPAmRGunUHBcnWEvgJBQl9n\nJEiU0Zsnvgc/ubhPgXRR4Xq37Z0j4r7g1SgEEzwxA57demyPxgcYxn/eR44/KJ4EBs+lVDR3veyJ\nm+kXQ99b21/+jh5Xos1AnX5iItreGCc=\n-----END CERTIFICATE-----\n' | sudo tee -a /opt/chef/embedded/ssl/cert.pem);",
          "        if (! grep -qxF 'DST Root CA X3' /opt/chef/embedded/ssl/cert.pem && grep -qxF 'ISRG Root X1' /opt/chef/embedded/ssl/cert.pem); then",
          "            echo \"Lets Encrypt certificate fixed\"",
          "        fi",
          "    fi",
          "}",
          "",
          "function validate_compliance_parameters() {",
          "    if [[ -z \"$SSM_CHEF_COMPLIANCE_SEVERITY\" ]]; then",
          "        throw_error \"ComplianceSeverity cannot be empty. Use 'None' to skip compliance reporting.\"",
          "    fi",
          "",
          "    if [[ \"$SSM_CHEF_COMPLIANCE_SEVERITY\" == \"None\" ]]; then",
          "        if [[ -n \"$SSM_CHEF_COMPLIANCE_REPORT_BUCKET\" ]]; then",
          "            report_warning \"Compliance reports S3 bucket is set, but compliance severity is set to 'None'. No compliance reports will be generated.\"",
          "        fi",
          "",
          "        if [[ -n \"$SSM_CHEF_COMPLIANCE_TYPE\" ]]; then",
          "            report_warning \"Compliance type is not empty but compliance severity is set to 'None'. No compliance reports will be generated.\"",
          "        fi",
          "    else",
          "        if [[ -z \"$SSM_CHEF_COMPLIANCE_REPORT_BUCKET\" ]]; then",
          "            report_info \"ComplianceReportBucket is not set. Sending the compliance report to S3 will be skipped.\"",
          "        fi",
          "",
          "        if [[ -z \"$SSM_CHEF_COMPLIANCE_TYPE\" ]]; then",
          "            throw_error \"ComplianceType is not set. ComplianceType must be set when ComplianceSeverity is not 'None'.\"",
          "        fi",
          "",
          "        if [[ \"$SSM_CHEF_CLIENT_VERSION\" != \"None\" ]] && [[ \"$SSM_CHEF_CLIENT_VERSION\" -le 11 ]]; then",
          "            throw_error \"Compliance reporting is supported for Chef client versions 12 and newer. Set the compliance severity to 'None'.\"",
          "        elif [[ \"$SSM_CHEF_CLIENT_VERSION\" == \"None\" ]]; then",
          "            local chef_version",
          "            chef_version=$(get_installed_chef_major_version) || chef_version=\"\"",
          "",
          "            if [[ -n \"$chef_version\" ]] && [[ \"$chef_version\" -le 11 ]]; then",
          "                throw_error \"Compliance reporting is supported for Chef client versions 12 and newer. Set the compliance severity to 'None'.\"",
          "            fi",
          "        fi",
          "    fi",
          "}",
          "",
          "function validate_folder_checksums() {",
          "    local folder=\"$1\"",
          "    local sha_256_checksum=\"$2\"",
          "",
          "    if [[ ! -x \"$(command -v sha256sum)\" ]]; then",
          "        throw_error \"Failed to verify checksum. sha256sum is not installed.\"",
          "    fi",
          "",
          "    if [[ ! -x \"$(command -v realpath)\" ]]; then",
          "        throw_error \"Failed to verify checksum. realpath is not installed.\"",
          "    fi",
          "",
          "    if [[ ! -x \"$(command -v sort)\" ]]; then",
          "        throw_error \"Failed to verify checksum. sort is not installed.\"",
          "    fi",
          "",
          "    (",
          "        local folder_full_path",
          "        folder_full_path=$(realpath \"$folder\") || throw_error \"Failed to get full path for $folder\"",
          "",
          "        cd \"$folder_full_path\"",
          "",
          "        local dir_check_sum",
          "        dir_check_sum=$(find \"$folder_full_path\" -type f -exec realpath --relative-to \"$folder_full_path\" {} \\; |",
          "            sort -s -f | xargs -n1 sha256sum | sha256sum) || throw_error \"An error has occurred during checksum calculation.\"",
          "        if [[ \"$dir_check_sum\" != \"$sha_256_checksum  -\" ]]; then",
          "            throw_error \"Checksum verification for $folder_full_path failed.\"",
          "        fi",
          "    ) || throw_error \"Failed to validate checksum for $folder.\"",
          "}",
          "",
          "function download_file() {",
          "    local url=\"$1\"",
          "    local destination=\"$2\"",
          "",
          "    if [[ -x \"$(command -v curl)\" ]]; then",
          "        curl -L -o \"$destination\" \"$url\" || throw_error \"Failed to download file. curl exited with $?.\"",
          "        return",
          "    fi",
          "",
          "    if [[ -x \"$(command -v wget)\" ]]; then",
          "        wget -O \"$destination\" \"$url\" || throw_error \"Failed to download file. wget exited with $?.\"",
          "        return",
          "    fi",
          "",
          "    throw_error \"Failed to download file. Neither curl nor wget are installed.\"",
          "}",
          "",
          "function download_from_s3() {",
          "    local bucket_name=\"$1\"",
          "    local keyname=\"$2\"",
          "    local destination=\"$3\"",
          "    local url=\"\"",
          "",
          "    if [[ \"$AWS_SSM_REGION_NAME\" == cn-* ]]; then",
          "        url=\"https://s3.$AWS_SSM_REGION_NAME.amazonaws.com.cn/$bucket_name/$keyname\"",
          "    elif [[ \"$AWS_SSM_REGION_NAME\" == us-gov-* ]]; then",
          "        url=\"https://s3-fips-$AWS_SSM_REGION_NAME.amazonaws.com/$bucket_name/$keyname\"",
          "    elif [[ \"$AWS_SSM_REGION_NAME\" == \"us-east-1\" ]]; then",
          "        url=\"https://s3.amazonaws.com/$bucket_name/$keyname\"",
          "    else",
          "        url=\"https://s3.$AWS_SSM_REGION_NAME.amazonaws.com/$bucket_name/$keyname\"",
          "    fi",
          "",
          "    download_file \"$url\" \"$destination\"",
          "}",
          "",
          "function should_install_chef() {",
          "    if [[ \"$SSM_CHEF_CLIENT_VERSION\" == \"None\" ]] || [[ -z \"$SSM_CHEF_CLIENT_VERSION\" ]]; then",
          "        return 1",
          "    fi",
          "",
          "    if [[ -z \"$(command -V chef-client 2>/dev/null)\" ]] || different_chef_version_installed; then",
          "        return 0",
          "    else",
          "        return 1",
          "    fi",
          "}",
          "",
          "function get_fully_qualified_chef_version() {",
          "    if [[ \"$SSM_CHEF_CLIENT_VERSION\" == \"11\" ]]; then",
          "        echo \"11.18.12\"",
          "    elif [[ \"$SSM_CHEF_CLIENT_VERSION\" == \"12\" ]]; then",
          "        echo \"12.22.5\"",
          "    elif [[ \"$SSM_CHEF_CLIENT_VERSION\" == \"13\" ]]; then",
          "        echo \"13.12.14\"",
          "    elif [[ \"$SSM_CHEF_CLIENT_VERSION\" == \"14\" ]]; then",
          "        echo \"14.15.6\"",
          "    elif [[ \"$SSM_CHEF_CLIENT_VERSION\" == \"15\" ]]; then",
          "        echo \"15.17.4\"",
          "    elif [[ \"$SSM_CHEF_CLIENT_VERSION\" == \"16\" ]]; then",
          "        echo \"16.18.30\"",
          "    elif [[ \"$SSM_CHEF_CLIENT_VERSION\" == \"17\" ]]; then",
          "        echo \"17.10.163\"",
          "    elif [[ \"$SSM_CHEF_CLIENT_VERSION\" == \"18\" ]]; then",
          "        echo \"18.7.6\"",
          "    fi",
          "}",
          "",
          "function different_chef_version_installed() {",
          "    local installed_chef_version",
          "    installed_chef_version=$(get_installed_chef_version)",
          "",
          "    local user_requested_version",
          "    user_requested_version=\"$(get_fully_qualified_chef_version)\"",
          "",
          "    if [[ \"$installed_chef_version\" == \"$user_requested_version\" ]]; then",
          "        return 1",
          "    else",
          "        return 0",
          "    fi",
          "}",
          "",
          "function install_libxcrypt_compat() {",
          "    OS_NAME=$(grep -s '^NAME' /etc/os-release | cut -d '=' -f2 | tr -d '\"')",
          "    OS_VERSION=$(grep -s '^VERSION_ID=' /etc/os-release | cut -d '=' -f2 | tr -d '\"')",
          "    if [[ $OS_NAME == \"Amazon Linux\" ]] && [[ $OS_VERSION == \"2023\" ]]; then",
          "        echo \"Installing libxcrypt-compat library.\"",
          "        sudo yum install -y libxcrypt-compat",
          "    fi",
          "}",
          "function install_chef() {",
          "    if should_install_chef; then",
          "        install_libxcrypt_compat",
          "        download_file \"https://omnitruck.chef.io/install.sh\" \"$SSM_CHEF_EXECUTION_BASE_DIR/install-chef.sh\"",
          "        sed -i '/download_url=`awk '\\''$1 == \"url\" { print $2 }'\\'' \"$metadata_filename\"`/a \\ \\ download_url=$download_url?cachebust=1' \"$SSM_CHEF_EXECUTION_BASE_DIR/install-chef.sh\"",
          "        sed -i '/\"2022\"|\"2023\")/{n; /platform=\"amazon\"/{n; s/platform_version=$platform_version/platform_version=\"8\"/}}' \"$SSM_CHEF_EXECUTION_BASE_DIR/install-chef.sh\"",
          "        sed -i '/\"2022\"|\"2023\")/{n; s/platform=\"amazon\"/platform=\"el\"/}' \"$SSM_CHEF_EXECUTION_BASE_DIR/install-chef.sh\"",
          "        sudo bash \"$SSM_CHEF_EXECUTION_BASE_DIR/install-chef.sh\" -d \"/opt/aws/chef-binaries-cache\" -v \"$(get_fully_qualified_chef_version)\"",
          "",
          "        if [[ ! -x \"$(command -v chef-client)\" ]]; then",
          "            # On SUSE Enterprise Linux the installation sometimes succeeds but fails internally. The following performs a reinstallation in this case",
          "            sudo bash \"$SSM_CHEF_EXECUTION_BASE_DIR/install-chef.sh\" -d \"/opt/aws/chef-binaries-cache\" -v \"$(get_fully_qualified_chef_version)\"",
          "        fi",
          "    fi",
          "}",
          "",
          "function validate_installed_chef_version() {",
          "    local chef_version",
          "    chef_version=$(get_installed_chef_major_version) || throw_error \"Failed to get the Chef client version.\"",
          "",
          "    if [[ \"$chef_version\" -gt \"18\" ]]; then",
          "        throw_error \"Chef client version $(get_installed_chef_version) is not supported. Only versions 18 and older are supported.\"",
          "    fi",
          "}",
          "",
          "function validate_run_list() {",
          "    if [[ -z \"${SSM_CHEF_RUN_LIST// }\" ]]; then",
          "        report_warning \"Run list is empty. The Chef client will not be run. If you need Chef client to run, use the RunList parameter to specify recipes to run. For example: \\\"recipe[cb1::recipe_name],recipe[cb2::recipe]\\\"\"",
          "        exit 0",
          "    fi",
          "}",
          "",
          "function obtain_compliance_reporter_cookbook() {",
          "    if [[ \"$SSM_CHEF_COMPLIANCE_SEVERITY\" == \"None\" ]]; then",
          "        return",
          "    fi",
          "",
          "    (",
          "        cd \"$SSM_CHEF_EXECUTION_BASE_DIR\"",
          "        download_from_s3 \"$SSM_CHEF_RUN_ASSETS_BUCKET\" \"statemanagerdocumentspayload/AWS-ApplyChefRecipes/aws-ssm-cookbooks-v0.1.tar.gz\" \"aws-ssm-cookbooks.tar.gz\"",
          "        mkdir -p \"aws-ssm-cookbooks\"",
          "        tar xf \"aws-ssm-cookbooks.tar.gz\" --strip-components=1 -C \"aws-ssm-cookbooks\"",
          "        validate_folder_checksums \"aws-ssm-cookbooks\" \"$COMPLIANCE_REPORT_COOKBOOK_SHA_256\"",
          "    ) || exit $?",
          "",
          "    echo \"$SSM_CHEF_EXECUTION_BASE_DIR/aws-ssm-cookbooks/cookbooks/\"",
          "    return",
          "}",
          "",
          "function extract_cookbooks() {",
          "    local archive=\"$1\"",
          "    local destination=\"$2\"",
          "",
          "    mkdir -p \"$destination\"",
          "",
          "    if (tar xf \"$archive\" -C \"$destination\" >/dev/null); then",
          "        return",
          "    fi",
          "",
          "    report_error \"Cookbooks could not be extracted with tar. Trying with unzip...\"",
          "",
          "    if [[ ! -x \"$(command -v unzip)\" ]]; then",
          "        throw_error \"'unzip' is not installed. Failed to extract cookbooks.\"",
          "    fi",
          "",
          "    if (unzip -o \"$archive\" -d \"$destination\" >/dev/null); then",
          "        return",
          "    fi",
          "",
          "    throw_error \"Failed to extract the cookbooks with 'unzip'. The file should be a compressed tarball (.tar.gz) or a zip file (.zip).\"",
          "}",
          "",
          "function prepare_cookbooks_directory() {",
          "    if [ -d \"$SSM_CHEF_EXECUTION_BASE_DIR/customer_cookbooks_prepared\" ]; then",
          "       rm -rf \"$SSM_CHEF_EXECUTION_BASE_DIR/customer_cookbooks_prepared\" ",
          "    fi",
          "    mkdir -p \"$SSM_CHEF_EXECUTION_BASE_DIR/customer_cookbooks_prepared/cookbooks\"",
          "    cd \"$SSM_CHEF_EXECUTION_BASE_DIR/customer_cookbooks_extracted\"",
          "    find \"$SSM_CHEF_EXECUTION_BASE_DIR/customer_cookbooks_extracted\" -type d -name \"data_bags\" -exec cp -R {} \"$SSM_CHEF_EXECUTION_BASE_DIR/customer_cookbooks_prepared\" \\;",
          "    meta_array=()",
          "    while IFS=  read -r -d $'\\0'; do",
          "       meta_array+=(\"$REPLY\")",
          "    done < <(find . -name \"metadata.json\" -print0)",
          "    while IFS=  read -r -d $'\\0'; do",
          "       meta_array+=(\"$REPLY\")",
          "    done < <(find . -name \"metadata.rb\" -execdir test ! -f metadata.json \\; -print0)",
          "    for meta_file in \"${meta_array[@]}\"",
          "    do",
          "       meta_file_root_folder=$(echo \"${meta_file/metadata.*/}\")",
          "       if [[ $meta_file == *.rb ]]; then",
          "           cookbook_name=$(cat $meta_file | sed \"s/'/\\\"/g\" | grep -o 'name\\s\\+\".*\"' | grep -o '\"[^\"]*\"$' | sed \"s/\\\"\\([^\\\"]*\\)\\\"$/\\1/\")",
          "       else",
          "           cookbook_name=$(cat $meta_file | grep -o '\"name\":\\s*\"[^\"]*\"' | grep -o '\"[^\"]*\"$' | sed \"s/\\\"\\([^\\\"]*\\)\\\"$/\\1/\")",
          "       fi",
          "       mkdir -p \"$SSM_CHEF_EXECUTION_BASE_DIR/customer_cookbooks_prepared/cookbooks/$cookbook_name\"",
          "       cp -a \"$meta_file_root_folder/.\" \"$SSM_CHEF_EXECUTION_BASE_DIR/customer_cookbooks_prepared/cookbooks/$cookbook_name\"",
          "    done",
          "    cd \"$SSM_CHEF_EXECUTION_BASE_DIR\"",
          "    echo \"$SSM_CHEF_EXECUTION_BASE_DIR/customer_cookbooks_prepared/cookbooks/\"",
          "}",
          "",
          "function extract_downloaded_customer_cookbooks() {",
          "    if [[ -z \"$SSM_CHEF_SOURCE_TYPE\" ]]; then",
          "        throw_error \"Cookbook source type must not be empty.\"",
          "    fi",
          "",
          "    if [[ -f \"$SSM_CHEF_EXECUTION_BASE_DIR/customer_cookbooks\" ]]; then",
          "        extract_cookbooks \"$SSM_CHEF_EXECUTION_BASE_DIR/customer_cookbooks\" \"$SSM_CHEF_EXECUTION_BASE_DIR/customer_cookbooks_extracted\"",
          "    elif [[ -d \"$SSM_CHEF_EXECUTION_BASE_DIR/customer_cookbooks\" ]]; then",
          "        mv \"$SSM_CHEF_EXECUTION_BASE_DIR/customer_cookbooks\" \"$SSM_CHEF_EXECUTION_BASE_DIR/customer_cookbooks_extracted/\" >/dev/null",
          "    fi",
          "",
          "   prepare_cookbooks_directory",
          "}",
          "",
          "function generate_config_rb() {",
          "    local customer_cookbooks_location=\"$1\"",
          "    local compliance_report_cookbooks_location=\"$2\"",
          "",
          "    (",
          "        cd \"$SSM_CHEF_EXECUTION_BASE_DIR\"",
          "        {",
          "            echo \"cookbook_path [\"",
          "            if [[ \"$SSM_CHEF_COMPLIANCE_SEVERITY\" != \"None\" ]]; then",
          "",
          "                # Sanity check",
          "                if [[ ! -d \"$compliance_report_cookbooks_location/aws-ssm-report-handler\" ]]; then",
          "                    throw_error \"Compliance reporting cookbook is not present.\"",
          "                fi",
          "",
          "                if [[ \"$(get_installed_chef_major_version)\" -ge \"12\" ]] && [[ \"$(get_installed_chef_major_version)\" -le \"13\" ]]; then",
          "                    echo \"  '$compliance_report_cookbooks_location/3rd-party-cookbooks/chef12-13',\"",
          "                fi",
          "",
          "                echo \"  '$compliance_report_cookbooks_location',\"",
          "            fi",
          "",
          "            echo \"  '$customer_cookbooks_location'\"",
          "            echo \"]\"",
          "",
          "            echo \"local_mode true\"",
          "        } >>config.rb",
          "",
          "    ) || exit $?",
          "}",
          "",
          "function execute_chef() {",
          "    local customer_cookbooks_location=\"$1\"",
          "    local compliance_report_cookbooks_location=\"$2\"",
          "",
          "    validate_installed_chef_version",
          "    local json_attributes_argument=()",
          "",
          "    # Chef 14.11 and above needs the HOME variable to be set:",
          "    if [[ -z $HOME ]]; then",
          "        export HOME=\"$SSM_CHEF_EXECUTION_BASE_DIR\"",
          "    fi",
          "",
          "    if [[ -f \"$SSM_CHEF_EXECUTION_BASE_DIR/json_attributes.json\" ]]; then",
          "        if (grep -q '[^[:space:]]' \"$SSM_CHEF_EXECUTION_BASE_DIR/json_attributes.json\"); then",
          "            json_attributes_argument=(--json-attributes \"$SSM_CHEF_EXECUTION_BASE_DIR/json_attributes.json\")",
          "        fi",
          "    fi",
          "    generate_config_rb \"$customer_cookbooks_location\" \"$compliance_report_cookbooks_location\"",
          "",
          "    # For Chef Versions greater than 14, accepting the license is needed to execute cookbooks or recipes",
          "    if [[ \"$(get_installed_chef_major_version)\" -ge \"14\" ]]; then",
          "        chef-client --chef-license accept  > /dev/null",
          "    fi",
          "",
          "    local chef_command_exit_code=0",
          "    local install_compliance_gems_exit_code=0",
          "    local why_run_exit_code=0",
          "    # Make mutating run when why-run is not requested",
          "    if [[ \"$SSM_CHEF_WHY_RUN\" != \"True\" ]]; then",
          "        chef-client -c \"$SSM_CHEF_EXECUTION_BASE_DIR/config.rb\" \"${SSM_CHEF_CLIENT_ARGUMENTS[@]}\" \"${json_attributes_argument[@]}\" -o \"$SSM_CHEF_RUN_LIST\" || chef_command_exit_code=$?",
          "        if [[ \"$chef_command_exit_code\" != \"0\" ]]; then",
          "            report_error \"User-specified recipes could not be run.\"",
          "        else",
          "            report_info \"User-specified recipes ran successfully.\"",
          "        fi",
          "    else",
          "        report_info \"Skipping a mutating run because only 'why-run' was requested.\"",
          "    fi",
          "",
          "    # Make why-run if requested or if compliance should be reported",
          "    if [[ \"$SSM_CHEF_WHY_RUN\" == \"True\" ]] || [[ \"$SSM_CHEF_COMPLIANCE_SEVERITY\" != \"None\" ]]; then",
          "        WHYRUN_CHEF_RUN_LIST=\"$SSM_CHEF_RUN_LIST\"",
          "        if [[ \"$SSM_CHEF_COMPLIANCE_SEVERITY\" != \"None\" ]]; then",
          "            report_info \"Installing required gems for compliance reporting...\"",
          "",
          "            # A mutating run is used to install required gems for compliance reporting",
          "            chef-client -c \"$SSM_CHEF_EXECUTION_BASE_DIR/config.rb\" \"${SSM_CHEF_CLIENT_ARGUMENTS[@]}\" -o \"aws-ssm-report-handler::compliance-gems\" || install_compliance_gems_exit_code=$?",
          "            if [[ \"$install_compliance_gems_exit_code\" != \"0\" ]]; then",
          "                report_error \"Failed to install compliance reporting gems. Compliance won't be reported.\"",
          "            else",
          "                report_info \"Performing compliance check with severity '$SSM_CHEF_COMPLIANCE_SEVERITY' in a why-run.\"",
          "                WHYRUN_CHEF_RUN_LIST=\"aws-ssm-report-handler::compliance-handler,$WHYRUN_CHEF_RUN_LIST\"",
          "            fi",
          "        fi",
          "",
          "        # Performing the actual why-run",
          "        SSM_CHEF_WHY_RUN=True chef-client -W -c \"$SSM_CHEF_EXECUTION_BASE_DIR/config.rb\" \"${SSM_CHEF_CLIENT_ARGUMENTS[@]}\" \"${json_attributes_argument[@]}\" -o \"$WHYRUN_CHEF_RUN_LIST\" || why_run_exit_code=$?",
          "        if [[ \"$why_run_exit_code\" != \"0\" ]]; then",
          "            report_error \"Chef client execution failed.\"",
          "        else",
          "            report_info \"Chef client execution succeeded.\"",
          "        fi",
          "    fi",
          "",
          "    return $((chef_command_exit_code || why_run_exit_code || install_compliance_gems_exit_code))",
          "}",
          "",
          "function main() {",
          "",
          "    validate_run_list",
          "    validate_compliance_parameters",
          "",
          "    local compliance_report_cookbooks_location",
          "    compliance_report_cookbooks_location=$(obtain_compliance_reporter_cookbook) || throw_error \"Failed to obtain compliance reporting cookbook.\"",
          "",
          "    local customer_cookbooks_location",
          "    customer_cookbooks_location=$(extract_downloaded_customer_cookbooks) || throw_error \"Failed to extract or copy the user cookbook.\"",
          "",
          "    if should_install_chef; then",
          "        report_info \"The requested Chef client version is not installed. Installing Chef client.\"",
          "        install_chef || exit $?",
          "    fi",
          "",
          "    validate_certificate",
          "",
          "    report_info \"Executing chef client...\"",
          "    execute_chef \"$customer_cookbooks_location\" \"$compliance_report_cookbooks_location\" || exit $?",
          "}",
          "",
          "mkdir -p \"$CHEF_RUN_LOCK_DIR\"",
          "(",
          "    set -e",
          "    flock -e 200",
          "    main || exit $?",
          "",
          ") 200>\"$CHEF_RUN_LOCK_FILE\" || exit $?"
        ]
      }
    },
    {
      "action": "aws:runPowerShellScript",
      "name": "executeRecipesWindows",
      "precondition": {
        "StringEquals": [
          "platformType",
          "Windows"
        ]
      },
      "inputs": {
        "timeoutSeconds": "{{ ChefExecutionTimeout }}",
        "onFailure": "exit",
        "runCommand": [
          "# MIT No Attribution",
          "#",
          "# Copyright 2024 Amazon.com, Inc. or its affiliates. All Rights Reserved.",
          "#",
          "# Permission is hereby granted, free of charge, to any person obtaining a copy of this",
          "# software and associated documentation files (the \"Software\"), to deal in the Software",
          "# without restriction, including without limitation the rights to use, copy, modify,",
          "# merge, publish, distribute, sublicense, and/or sell copies of the Software, and to",
          "# permit persons to whom the Software is furnished to do so.",
          "#",
          "# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,",
          "# INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A",
          "# PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT",
          "# HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION",
          "# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE",
          "# SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.",
          "#",
          "",
          "",
          "$SSM_CHEF_EXECUTION_BASE_DIR=$(pwd).Path",
          "$env:SSM_CHEF_SOURCE_TYPE='{{SourceType}}'",
          "$env:SSM_CHEF_RUN_LIST='{{RunList}}'",
          "$env:SSM_CHEF_WHY_RUN='{{WhyRun}}'",
          "$SSM_CHEF_CLIENT_ARGUMENTS=@( '{{ChefClientArguments}}' -split '\\s+' | Where { $_ -and $_.Trim() } )",
          "$env:SSM_CHEF_CLIENT_VERSION='{{ChefClientVersion}}'",
          "$env:SSM_CHEF_COMPLIANCE_SEVERITY='{{ComplianceSeverity}}'",
          "$env:SSM_CHEF_COMPLIANCE_TYPE='{{ComplianceType}}'",
          "$env:SSM_CHEF_COMPLIANCE_REPORT_BUCKET='{{ComplianceReportBucket}}'",
          "",
          "$CHEF_RUN_LOCK_DIR=\"$env:temp\\aws\\chef_run_locks\"",
          "$CHEF_RUN_LOCK_FILE=\"$CHEF_RUN_LOCK_DIR\\aws-apply-chef-recipes.lock\"",
          "$SSM_CHEF_RUN_ASSETS_BUCKET='aws-ssm-{0}' -f $env:AWS_SSM_REGION_NAME",
          "$COMPLIANCE_REPORT_COOKBOOK_SHA_256=\"1F2A7D6D3B86823D44D00ADA9120AFF7B1150DE169F32092CB968339AB4E1E12\"",
          "",
          "function report_info($message) {",
          "    echo \"INFO: $message\"",
          "}",
          "",
          "function report_warning($message) {",
          "    echo \"WARNING: $message\"",
          "}",
          "",
          "function report_error($message) {",
          "    echo \"ERROR: $message\" 2>&1",
          "}",
          "",
          "function throw_error($message) {",
          "    report_error \"$message\"",
          "    exit 1",
          "}",
          "",
          "function add_chef_path_to_environment_variable() {",
          "    if (($env:Path | Select-String \"C:\\\\opscode\\\\chef\\\\bin\\\\;\").Length -eq 0){",
          "       $env:Path += \";C:\\opscode\\chef\\bin;\"",
          "    }",
          "}",
          "",
          "function add_tar_path_to_environment_variable() {",
          "    if($(get_installed_chef_major_version) -ge \"17\"){",
          "        if (($env:Path | Select-String \"C:\\\\opscode\\\\chef\\\\embedded\\\\msys64\\\\usr\\\\bin\\\\;\").Length -eq 0){",
          "           $env:Path += \";C:\\opscode\\chef\\embedded\\msys64\\usr\\bin;\"",
          "        }",
          "    }",
          "}",
          "",
          "function get_installed_chef_version() {",
          "    try{",
          "       $chef_version=$(chef-client --version)",
          "    }",
          "    catch{",
          "       $chef_version=''",
          "    }",
          "    $version_regex='[\\d\\.]+'",
          "    $matched_version=[Regex]::Matches($chef_version, $version_regex)",
          "    echo $matched_version[0].Value",
          "}",
          "",
          "function get_installed_chef_major_version() {",
          "    $chef_version=$(get_installed_chef_version)",
          "    if (!$chef_version) {",
          "        throw_error \"Chef client is not installed. Install Chef client and then run the command again.\"",
          "    }",
          "",
          "    echo $chef_version.Split('.')[0]",
          "}",
          "",
          "function validate_certificate() {",
          "    $certificate_path=\"C:\\opscode\\chef\\embedded\\ssl\\cert.pem\"",
          "    if (test-path -Path \"$certificate_path\" -PathType leaf) {",
          "       $dst_ca_index=(Select-String -Path \"$certificate_path\" -Pattern 'DST Root CA X3' -CaseSensitive | Select-Object -ExpandProperty LineNumber -First 1)",
          "       while ($dst_ca_index) {",
          "           (Get-Content \"$certificate_path\") | where {$_.readcount -lt $dst_ca_index-1 -or $_.readcount -gt $dst_ca_index+18} | Set-Content \"$certificate_path\"",
          "           $dst_ca_index=(Select-String -Path \"$certificate_path\" -Pattern 'DST Root CA X3' -CaseSensitive | Select-Object -ExpandProperty LineNumber -First 1)",
          "       }",
          "       if (! $(Select-String -Path \"$certificate_path\" -Pattern 'ISRG Root X1' -CaseSensitive)) {",
          "           echo \"`n`nISRG Root X1`n============`n-----BEGIN CERTIFICATE-----`nMIIFazCCA1OgAwIBAgIRAIIQz7DSQONZRGPgu2OCiwAwDQYJKoZIhvcNAQELBQAwTzELMAkGA1UE`nBhMCVVMxKTAnBgNVBAoTIEludGVybmV0IFNlY3VyaXR5IFJlc2VhcmNoIEdyb3VwMRUwEwYDVQQD`nEwxJU1JHIFJvb3QgWDEwHhcNMTUwNjA0MTEwNDM4WhcNMzUwNjA0MTEwNDM4WjBPMQswCQYDVQQG`nEwJVUzEpMCcGA1UEChMgSW50ZXJuZXQgU2VjdXJpdHkgUmVzZWFyY2ggR3JvdXAxFTATBgNVBAMT`nDElTUkcgUm9vdCBYMTCCAiIwDQYJKoZIhvcNAQEBBQADggIPADCCAgoCggIBAK3oJHP0FDfzm54r`nVygch77ct984kIxuPOZXoHj3dcKi/vVqbvYATyjb3miGbESTtrFj/RQSa78f0uoxmyF+0TM8ukj1`n3Xnfs7j/EvEhmkvBioZxaUpmZmyPfjxwv60pIgbz5MDmgK7iS4+3mX6UA5/TR5d8mUgjU+g4rk8K`nb4Mu0UlXjIB0ttov0DiNewNwIRt18jA8+o+u3dpjq+sWT8KOEUt+zwvo/7V3LvSye0rgTBIlDHCN`nAymg4VMk7BPZ7hm/ELNKjD+Jo2FR3qyHB5T0Y3HsLuJvW5iB4YlcNHlsdu87kGJ55tukmi8mxdAQ`n4Q7e2RCOFvu396j3x+UCB5iPNgiV5+I3lg02dZ77DnKxHZu8A/lJBdiB3QW0KtZB6awBdpUKD9jf`n1b0SHzUvKBds0pjBqAlkd25HN7rOrFleaJ1/ctaJxQZBKT5ZPt0m9STJEadao0xAH0ahmbWnOlFu`nhjuefXKnEgV4We0+UXgVCwOPjdAvBbI+e0ocS3MFEvzG6uBQE3xDk3SzynTnjh8BCNAw1FtxNrQH`nusEwMFxIt4I7mKZ9YIqioymCzLq9gwQbooMDQaHWBfEbwrbwqHyGO0aoSCqI3Haadr8faqU9GY/r`nOPNk3sgrDQoo//fb4hVC1CLQJ13hef4Y53CIrU7m2Ys6xt0nUW7/vGT1M0NPAgMBAAGjQjBAMA4G`nA1UdDwEB/wQEAwIBBjAPBgNVHRMBAf8EBTADAQH/MB0GA1UdDgQWBBR5tFnme7bl5AFzgAiIyBpY`n9umbbjANBgkqhkiG9w0BAQsFAAOCAgEAVR9YqbyyqFDQDLHYGmkgJykIrGF1XIpu+ILlaS/V9lZL`nubhzEFnTIZd+50xx+7LSYK05qAvqFyFWhfFQDlnrzuBZ6brJFe+GnY+EgPbk6ZGQ3BebYhtF8GaV`n0nxvwuo77x/Py9auJ/GpsMiu/X1+mvoiBOv/2X/qkSsisRcOj/KKNFtY2PwByVS5uCbMiogziUwt`nhDyC3+6WVwW6LLv3xLfHTjuCvjHIInNzktHCgKQ5ORAzI4JMPJ+GslWYHb4phowim57iaztXOoJw`nTdwJx4nLCgdNbOhdjsnvzqvHu7UrTkXWStAmzOVyyghqpZXjFaH3pO3JLF+l+/+sKAIuvtd7u+Nx`ne5AW0wdeRlN8NwdCjNPElpzVmbUq4JUagEiuTDkHzsxHpFKVK7q4+63SM1N95R1NbdWhscdCb+ZA`nJzVcoyi3B43njTOQ5yOf+1CceWxG1bQVs5ZufpsMljq4Ui0/1lvh+wjChP4kqKOJ2qxq4RgqsahD`nYVvTH9w7jXbyLeiNdd8XM2w9U/t7y0Ff/9yi0GE44Za4rF2LN9d11TPAmRGunUHBcnWEvgJBQl9n`nJEiU0Zsnvgc/ubhPgXRR4Xq37Z0j4r7g1SgEEzwxA57demyPxgcYxn/eR44/KJ4EBs+lVDR3veyJ`nm+kXQ99b21/+jh5Xos1AnX5iItreGCc=`n-----END CERTIFICATE-----`n\" | Out-File -FilePath \"$certificate_path\" -Append",
          "       }",
          "       if (! $(Select-String -Path \"$certificate_path\" -Pattern 'DST Root CA X3' -CaseSensitive) -and $(Select-String -Path \"$certificate_path\" -Pattern 'ISRG Root X1' -CaseSensitive)) {",
          "           echo \"Lets Encrypt certificate fixed\"",
          "       }",
          "    }",
          "}",
          "function validate_compliance_parameters() {",
          "    if (!$env:SSM_CHEF_COMPLIANCE_SEVERITY){ ",
          "        throw_error \"ComplianceSeverity cannot be empty. Use 'None' to skip compliance reporting.\"",
          "    }",
          "",
          "    if ($env:SSM_CHEF_COMPLIANCE_SEVERITY -eq \"None\") {",
          "        if ($env:SSM_CHEF_COMPLIANCE_REPORT_BUCKET){",
          "            report_warning \"Compliance reports S3 bucket is set, but compliance severity is set to 'None'. No compliance reports will be generated.\"",
          "        }",
          "",
          "        if ($env:SSM_CHEF_COMPLIANCE_TYPE) {",
          "            report_warning \"Compliance type is not empty but compliance severity is set to 'None'. No compliance reports will be generated.\"",
          "        }",
          "    }else {",
          "        if (!$env:SSM_CHEF_COMPLIANCE_REPORT_BUCKET) {",
          "            report_info \"ComplianceReportBucket is not set. Sending the compliance report to S3 will be skipped.\"",
          "        }",
          "",
          "        if (!$env:SSM_CHEF_COMPLIANCE_TYPE) {",
          "            throw_error \"ComplianceType is not set. ComplianceType must be set when ComplianceSeverity is not 'None'.\"",
          "        }",
          "",
          "        if ($env:SSM_CHEF_CLIENT_VERSION -ne \"None\" -and $env:SSM_CHEF_CLIENT_VERSION -le 11) {",
          "            throw_error \"Compliance reporting is supported for Chef client versions 12 and newer. Set the compliance severity to 'None'.\"",
          "        }",
          "        elseif ($env:SSM_CHEF_CLIENT_VERSION -eq \"None\") {",
          "           try{",
          "               $chef_version=$(get_installed_chef_major_version)",
          "           }",
          "           catch{",
          "               $chef_version=''",
          "           }",
          "",
          "           if ($chef_version -and $chef_version -le 11){",
          "                throw_error \"Compliance reporting is supported for Chef client versions 12 and newer. Set the compliance severity to 'None'.\"",
          "           }",
          "        }",
          "    }",
          "}",
          "",
          "function validate_folder_checksums($folder,$sha_256_checksum) {",
          "",
          "    if (! (Get-Command Get-FileHash)) {",
          "        throw_error \"Failed to verify checksum. Get-FileHash is not working.\"",
          "    }",
          "",
          "    if (! (Get-Command Resolve-Path)) {",
          "        throw_error \"Failed to verify checksum. Resolve-Path is not working.\"",
          "    }",
          "",
          "    if (! (Get-Command Sort-Object)) {",
          "        throw_error \"Failed to verify checksum. Sort-Object is not working.\"",
          "    }",
          "",
          "    try{",
          "        try{",
          "             $folder_full_path=Resolve-Path $folder",
          "        }",
          "        catch{",
          "             throw_error \"Failed to get full path for $folder\"",
          "        }",
          "",
          "        subst X: $folder_full_path",
          "        cd X:",
          "",
          "        try{",
          "           $dir_check_sum=Get-ChildItem -Path X: -Recurse -File | where {$_.FullName -notlike \"*\\nodes\\*\"} | Resolve-Path -Relative | Sort-Object",
          "           $temp_file=[System.IO.Path]::GetTempFileName()",
          "           Get-FileHash $dir_check_sum | select -ExpandProperty Hash | Out-File $temp_file",
          "           $dir_final_hash=$(Get-FileHash $temp_file | select -ExpandProperty Hash)",
          "           Remove-Item $temp_file",
          "           subst X: /d",
          "        }",
          "        catch{",
          "           throw_error \"An error has occurred during checksum calculation.\"",
          "        }",
          "        if ( \"$dir_final_hash\" -ne \"$sha_256_checksum\") {",
          "            throw_error \"Checksum verification for $folder_full_path failed.\"",
          "        }",
          "    }",
          "    catch{",
          "       throw_error \"Failed to validate checksum for $folder.\"",
          "    }",
          "}",
          "",
          "function download_file($url, $destination) {",
          "",
          "    try{",
          "       Invoke-WebRequest -Uri $url -OutFile $destination",
          "    }",
          "    catch{",
          "       throw_error \"Failed to download file.\"",
          "    }",
          "}",
          "",
          "function download_from_s3($bucket_name, $keyname, $destination) {",
          "    $url=\"\"",
          "",
          "    if ($env:AWS_SSM_REGION_NAME.StartsWith('cn-')){",
          "        $url=\"https://s3.$env:AWS_SSM_REGION_NAME.amazonaws.com.cn/$bucket_name/$keyname\"",
          "    }",
          "    elseif ($env:AWS_SSM_REGION_NAME.StartsWith('us-gov-')) {",
          "        $url=\"https://s3-fips-$env:AWS_SSM_REGION_NAME.amazonaws.com/$bucket_name/$keyname\"",
          "    }",
          "    elseif ($env:AWS_SSM_REGION_NAME -eq \"us-east-1\") {",
          "        $url=\"https://s3.amazonaws.com/$bucket_name/$keyname\"",
          "    }",
          "    else{",
          "        $url=\"https://s3.$env:AWS_SSM_REGION_NAME.amazonaws.com/$bucket_name/$keyname\"",
          "    }",
          "",
          "    download_file $url $destination",
          "}",
          "",
          "function should_install_chef() {",
          "    if ($env:SSM_CHEF_CLIENT_VERSION -eq \"None\" -or !$env:SSM_CHEF_CLIENT_VERSION) {",
          "        return 0",
          "    }",
          "",
          "    if (!$(get_installed_chef_version) -or $(different_chef_version_installed)) {",
          "        return 1",
          "    }",
          "    else{",
          "        return 0",
          "    }",
          "}",
          "",
          "function get_fully_qualified_chef_version() {",
          "   switch ( $env:SSM_CHEF_CLIENT_VERSION )",
          "   {",
          "       \"11\" {echo \"11.18.12\"}",
          "       \"12\" {echo \"12.22.5\"}",
          "       \"13\" {echo \"13.12.14\"}",
          "       \"14\" {echo \"14.15.6\"}",
          "       \"15\" {echo \"15.17.4\"}",
          "       \"16\" {echo \"16.18.30\"}",
          "       \"17\" {echo \"17.10.163\"}",
          "       \"18\" {echo \"18.7.6\"}",
          "   }",
          "}",
          "",
          "function different_chef_version_installed() {",
          "    $installed_chef_version=$(get_installed_chef_version)",
          "",
          "    $user_requested_version=$(get_fully_qualified_chef_version)",
          "",
          "    if ( $installed_chef_version -eq $user_requested_version ){",
          "        return 0",
          "    }else{",
          "        return 1",
          "    }",
          "}",
          "",
          "function install_chef() {",
          "    if ($(get_installed_chef_version)) {",
          "       $installed_chef_major_version=get_installed_chef_major_version",
          "       if ($env:SSM_CHEF_CLIENT_VERSION -lt $installed_chef_major_version){",
          "           wmic product where \"Name like 'Chef Infra Client%%' or Name like 'Chef Client%%'\" call uninstall",
          "       }",
          "    }",
          "    . { iwr -useb https://omnitruck.chef.io/install.ps1 } | iex; install -version \"$(get_fully_qualified_chef_version)\"",
          "    ",
          "}",
          "",
          "function validate_installed_chef_version() {",
          "    try{",
          "       $chef_version=$(get_installed_chef_major_version)",
          "    }",
          "    catch{",
          "       throw_error \"Failed to get the Chef client version.\"",
          "    }",
          "",
          "    if ($chef_version -gt \"18\"){",
          "        throw_error \"Chef client version $(get_installed_chef_version) is not supported. Only versions 18 and older are supported.\"",
          "    }",
          "}",
          "",
          "function validate_run_list() {",
          "    if ([string]::IsNullOrWhiteSpace($env:SSM_CHEF_RUN_LIST)) {",
          "       report_warning \"Run list is empty. The Chef client will not be run. If you need Chef client to run, use the RunList parameter to specify recipes to run. For example: \"\"recipe[cb1::recipe_name],recipe[cb2::recipe]\"\"\"",
          "       exit 0",
          "    }",
          "}",
          "",
          "function obtain_compliance_reporter_cookbook() {",
          "    if ($env:SSM_CHEF_COMPLIANCE_SEVERITY -eq \"None\") {",
          "        return",
          "    }",
          "",
          "    try{",
          "        cd $SSM_CHEF_EXECUTION_BASE_DIR",
          "        download_from_s3 \"$SSM_CHEF_RUN_ASSETS_BUCKET\" \"statemanagerdocumentspayload\\AWS-ApplyChefRecipes/aws-ssm-cookbooks-v0.1.tar.gz\" \"aws-ssm-cookbooks.tar.gz\"",
          "        New-Item -Name \"aws-ssm-cookbooks\" -ItemType \"directory\" | Out-Null",
          "        tar xf \"aws-ssm-cookbooks.tar.gz\" --strip-components=1 -C \"aws-ssm-cookbooks\"",
          "        validate_folder_checksums \"aws-ssm-cookbooks\" \"$COMPLIANCE_REPORT_COOKBOOK_SHA_256\"",
          "    }",
          "     catch{",
          "        exit 1",
          "    }",
          "",
          "    echo \"$SSM_CHEF_EXECUTION_BASE_DIR\\aws-ssm-cookbooks\\cookbooks\\\"",
          "    return",
          "}",
          "",
          "function extract_cookbooks($archive,$destination) {",
          "",
          "    if (!(test-path $destination)) {",
          "        md \"$destination\" | Out-Null",
          "    }",
          "    cd $destination",
          "",
          "    try{",
          "       tar -xf \"$archive\"",
          "    }",
          "    catch{",
          "       throw_error \"Failed to extract the cookbooks with 'tar'. The file should be a compressed tarball (.tar.gz) or a zip file (.zip).\"",
          "    }",
          "}",
          "",
          "function prepare_cookbooks_directory() {",
          "",
          "    subst X: \"$SSM_CHEF_EXECUTION_BASE_DIR\"",
          "    if (test-path -Path \"X:\\customer_cookbooks_prepared\") {",
          "        Remove-Item -LiteralPath \"X:\\customer_cookbooks_prepared\" -Force -Recurse | Out-Null",
          "    }",
          "    New-Item -Path \"X:\\customer_cookbooks_prepared\\cookbooks\" -ItemType \"directory\" | Out-Null",
          "    cd \"X:\\customer_cookbooks_extracted\"",
          "    Get-ChildItem -Path \"X:\\customer_cookbooks_extracted\" -Recurse -Directory -Filter \"data_bags\" | Copy-Item -Destination \"X:\\customer_cookbooks_prepared\" -Force -Recurse",
          "    $meta_array=$(Get-ChildItem . -Recurse -Include \"metadata.json\", \"metadata.rb\" | Select -expand FullName)",
          "    foreach ($meta_file in $meta_array) {",
          "       $meta_file_root_folder=$(Split-Path $meta_file -Parent)",
          "       if ($meta_file.EndsWith(\".rb\")) {",
          "           if (Test-Path \"$meta_file_root_folder\\metadata.json\") { continue }",
          "           $cookbook_name=$(([regex]'name\\s+[\"'']([^''\"]+)[\"'']').Matches($(Get-Content \"$meta_file\"))).Groups[1].Value",
          "       } else {",
          "           $cookbook_name=(Get-Content -Raw \"$meta_file\" | ConvertFrom-Json).name",
          "       }",
          "       New-Item -Path \"X:\\customer_cookbooks_prepared\\cookbooks\\$cookbook_name\" -ItemType \"directory\" | Out-Null",
          "       Copy-Item \"$meta_file_root_folder\\*\" -Destination \"X:\\customer_cookbooks_prepared\\cookbooks\\$cookbook_name\" -Force -Recurse",
          "    }",
          "    subst X: /d",
          "    cd \"$SSM_CHEF_EXECUTION_BASE_DIR\"",
          "    echo \"$SSM_CHEF_EXECUTION_BASE_DIR\\customer_cookbooks_prepared\\cookbooks\\\"",
          "}",
          "",
          "function extract_downloaded_customer_cookbooks() {",
          "    if (!$env:SSM_CHEF_SOURCE_TYPE) {",
          "        throw_error \"Cookbook source type must not be empty.\"",
          "    }",
          "",
          "    if (test-path -Path \"$SSM_CHEF_EXECUTION_BASE_DIR\\customer_cookbooks\" -PathType leaf) {",
          "        extract_cookbooks \"$SSM_CHEF_EXECUTION_BASE_DIR\\customer_cookbooks\" \"$SSM_CHEF_EXECUTION_BASE_DIR\\customer_cookbooks_extracted\"",
          "    }",
          "    elseif (test-path -Path \"$SSM_CHEF_EXECUTION_BASE_DIR\\customer_cookbooks\") {",
          "        Move-Item \"$SSM_CHEF_EXECUTION_BASE_DIR\\customer_cookbooks\" \"$SSM_CHEF_EXECUTION_BASE_DIR\\customer_cookbooks_extracted\\\"",
          "    }",
          "",
          "    prepare_cookbooks_directory",
          "}",
          "",
          "function generate_config_rb($cookbooks_location, $compliance_cookbooks_location) {",
          "",
          "    $customer_cookbooks_location_double_backslash=$cookbooks_location.Replace('\\','\\\\')",
          "    if ($compliance_cookbooks_location) {$compliance_cookbooks_location_double_backslash=$compliance_cookbooks_location.Replace('\\','\\\\')}",
          "",
          "    try{",
          "       cd \"$SSM_CHEF_EXECUTION_BASE_DIR\"",
          "       New-Item config.rb -ItemType \"file\"",
          "       echo \"cookbook_path [\" | Out-File config.rb -Encoding UTF8",
          "       if ($env:SSM_CHEF_COMPLIANCE_SEVERITY -ne \"None\") {",
          "           if(!(test-path \"$compliance_cookbooks_location\\aws-ssm-report-handler\")){",
          "               throw_error \"Compliance reporting cookbook is not present.\"",
          "           }",
          "           if($(get_installed_chef_major_version) -ge \"12\" -and $(get_installed_chef_major_version) -le \"13\"){",
          "               echo \"  `\"$compliance_cookbooks_location_double_backslash\\\\3rd-party-cookbooks\\\\chef12-13`\" ,\" | Out-File config.rb -Append -Encoding UTF8",
          "           }",
          "           echo \"  `\"$compliance_cookbooks_location_double_backslash`\" ,\" | Out-File config.rb -Append -Encoding UTF8",
          "           }",
          "       echo \"  `\"$customer_cookbooks_location_double_backslash`\"\" | Out-File config.rb -Append -Encoding UTF8",
          "       echo \"]\" | Out-File config.rb -Append -Encoding UTF8",
          "",
          "       echo \"local_mode true\" | Out-File config.rb -Append -Encoding UTF8",
          "    }",
          "    catch{",
          "       exit 1",
          "    }",
          "}",
          "",
          "function execute_chef($customer_cookbooks_location,$compliance_report_cookbooks_location) {",
          "",
          "    validate_installed_chef_version",
          "",
          "    generate_config_rb \"$customer_cookbooks_location\" \"$compliance_report_cookbooks_location\"",
          "",
          "    # For Chef Versions greater than 14, accepting the license is needed to execute cookbooks or recipes",
          "    if($(get_installed_chef_major_version) -ge \"14\"){",
          "        chef-client --chef-license accept",
          "    }",
          "",
          "    $json_attributes = @()",
          "    if (! [String]::IsNullOrWhiteSpace((Get-Content \"$SSM_CHEF_EXECUTION_BASE_DIR\\json_attributes.json\"))) {",
          "       $json_attributes=@( \"--json-attributes\", \"$SSM_CHEF_EXECUTION_BASE_DIR\\json_attributes.json\")",
          "    }",
          "    # Make mutating run when why-run is not requested",
          "    if ($env:SSM_CHEF_WHY_RUN -ne \"True\"){",
          "       try{",
          "           chef-client -c \"$SSM_CHEF_EXECUTION_BASE_DIR\\config.rb\" $SSM_CHEF_CLIENT_ARGUMENTS $json_attributes -o \"$env:SSM_CHEF_RUN_LIST\" ",
          "           if (!$?) {",
          "             throw_error \"User-specified recipes could not be run.\"",
          "           }else{",
          "             report_info \"User-specified recipes ran successfully.\"",
          "           }",
          "       }",
          "       catch{",
          "           throw_error \"User-specified recipes could not be run.\"",
          "       }",
          "    }else{",
          "        report_info \"Skipping a mutating run because only 'why-run' was requested.\"",
          "    }",
          "",
          "    # Make why-run if requested or if compliance should be reported",
          "    if($env:SSM_CHEF_WHY_RUN -eq \"True\" -or $env:SSM_CHEF_COMPLIANCE_SEVERITY -ne \"None\"){",
          "        $WHYRUN_CHEF_RUN_LIST=$env:SSM_CHEF_RUN_LIST",
          "        if ($env:SSM_CHEF_COMPLIANCE_SEVERITY -ne \"None\"){",
          "            report_info \"Installing required gems for compliance reporting...\"",
          "",
          "            # A mutating run is used to install required gems for compliance reporting",
          "           try{",
          "               chef-client -c \"$SSM_CHEF_EXECUTION_BASE_DIR\\config.rb\" $SSM_CHEF_CLIENT_ARGUMENTS -o \"aws-ssm-report-handler::compliance-gems\"",
          "               if (!$?) {",
          "                   throw_error \"Failed to install compliance reporting gems. Compliance won't be reported.\"",
          "               }else{",
          "                   report_info \"Performing compliance check with severity '$env:SSM_CHEF_COMPLIANCE_SEVERITY' in a why-run.\"",
          "                   $WHYRUN_CHEF_RUN_LIST=\"aws-ssm-report-handler::compliance-handler,$WHYRUN_CHEF_RUN_LIST\"",
          "               }",
          "           }",
          "           catch{",
          "               throw_error \"Failed to install compliance reporting gems. Compliance won't be reported.\"",
          "           }",
          "        }",
          "",
          "        # Performing the actual why-run",
          "        try{",
          "               $env:SSM_CHEF_WHY_RUN=$true",
          "               chef-client -W -c \"$SSM_CHEF_EXECUTION_BASE_DIR\\config.rb\" $SSM_CHEF_CLIENT_ARGUMENTS $json_attributes -o \"$WHYRUN_CHEF_RUN_LIST\"",
          "               if (!$?) {",
          "                   throw_error \"Chef client execution failed.\"",
          "               }else{",
          "                   report_info \"Chef client execution succeeded.\"",
          "               }",
          "           }",
          "           catch{",
          "               throw_error \"Chef client execution failed.\"",
          "        }",
          "    }",
          "",
          "}",
          "",
          "function main() {",
          "",
          "    add_chef_path_to_environment_variable",
          "    validate_run_list",
          "    validate_compliance_parameters",
          "",
          "    if (should_install_chef) {",
          "        report_info \"The requested Chef client version is not installed. Installing Chef client.\"",
          "        try{",
          "           install_chef",
          "        }",
          "        catch{",
          "           throw_error \"Failed to install chef client.\"",
          "        }",
          "    }",
          "    add_tar_path_to_environment_variable",
          "",
          "    try {",
          "       $compliance_report_cookbooks_location=obtain_compliance_reporter_cookbook",
          "    }",
          "    catch{",
          "       throw_error \"Failed to obtain compliance reporting cookbook.\"",
          "    }",
          "",
          "",
          "    try {",
          "       $customer_cookbooks_location=extract_downloaded_customer_cookbooks",
          "    }",
          "    catch{",
          "       throw_error \"Failed to extract or copy the user cookbook.\"",
          "    }",
          "",
          "    validate_certificate",
          "",
          "    report_info \"Executing chef client...\"",
          "    try {",
          "       execute_chef \"$customer_cookbooks_location\" \"$compliance_report_cookbooks_location\"",
          "    }",
          "    catch{",
          "       throw_error \"Failed to execute chef client.\"",
          "    }",
          "}",
          "",
          "function invoke_action_with_mutex() {",
          "",
          "    $mutex=$null",
          "",
          "    try {",
          "       $created_new=$false",
          "       $mutex=New-Object System.Threading.Mutex($true, \"Global\\MainExecution\", [ref]$created_new)",
          "       if (-not $created_new) {",
          "           try {",
          "               $mutex.WaitOne() | Out-Null",
          "           }",
          "           catch [System.Threading.AbandonedMutexException]{",
          "               echo \"Another thread exit without releasing the mutex.\"",
          "           }",
          "       }",
          "       Invoke-Command -ScriptBlock ${function:main} -NoNewScope",
          "    }",
          "    finally{",
          "       if ($mutex -ne $null) {",
          "           $mutex.ReleaseMutex()",
          "           $mutex.Dispose()",
          "       }",
          "    }",
          "}",
          "",
          "try {",
          "   invoke_action_with_mutex",
          "}",
          "catch{",
          "   exit ",
          "}"
        ]
      }
    }
  ]
}
