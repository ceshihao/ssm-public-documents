{
  "description": "The **AWSSupport-TroubleshootPatchManagerLinux** runbook helps in evaluating and diagnosing failed executions of the **AWS-RunPatchBaseline** AWS Systems Manager document against Linux based AWS Systems Manager managed instances. AWS-RunPatchBaseline is the default AWS Systems Manager document used by the Patch Manager. The runbook analyzes the patching logs present on the instance to try to find the cause of the failure and provide recommended remediation steps for the errors found.\n\n### Supported operating systems:\n - Amazon Linux 2, and 2023\n - Red Hat Enterprise Linux 8.X 9.X and 10.X\n - Centos 8.X, and 9.X\n - Ubuntu 18.04-24.04\n - SUSE 15.X\n### Prerequisites:\n\n- The instance must be Linux-based and managed by AWS Systems Manager.\n- The following packages must be available on the instance: **Python 3.7 or later, wget or curl, and unzip**. **Note:** We recommend upgrading to Python 3.11 or later to minimize impact of future update operations. Refer to this [public documentation](https://aws.amazon.com/blogs/developer/python-support-policy-updates-for-aws-sdks-and-tools/) for more information. \n- The instance can connect to the Amazon Simple Storage Service (Amazon S3) service endpoints to download the code from AWS owned bucket `arn:aws:s3:::aws-ssm-document-attachments-region/`.\n\n**Note**: The input parameter **RunCommandId** is optional. If you do not provide a specific Command ID to evaluate, the automation looks for last unsuccessful execution of `AWS-RunPatchBaseline` for the instance. If you provide a Command ID as the input, the Command ID must have been executed in last **30 days**. This is because the Run Command history retention period is 30 days.",
  "schemaVersion": "0.3",
  "assumeRole": "{{ AutomationAssumeRole }}",
  "outputs": [
    "GenerateReport.output"
  ],
  "parameters": {
    "AutomationAssumeRole": {
      "type": "AWS::IAM::Role::Arn",
      "description": "(Optional) The Amazon Resource Name (ARN) of the AWS Identity and Access Management (IAM) role that allows Systems Manager Automation to perform the actions on your behalf. If no role is specified, Systems Manager Automation uses the permissions of the user that starts this runbook.",
      "default": ""
    },
    "InstanceId": {
      "type": "AWS::EC2::Instance::Id",
      "description": "(Required) The ID of the Linux-based AWS Systems Manager managed node (EC2 or Hybrid Activated) for which a previous AWS-RunPatchBaseline document execution failed."
    },
    "RunCommandId": {
      "type": "String",
      "description": "(Optional) The Run Command ID of AWS-RunPatchBaseline. If not provided, the automation looks for the latest unsuccessful execution of AWS-RunPatchBaseline for the instance and evaluate it. To confirm the Command ID, look under Command History tab in the Run Command Console under AWS Systems Manager.",
      "default": "",
      "allowedPattern": "^(?:|[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12})$",
      "maxChars": 36
    }
  },
  "mainSteps": [
    {
      "name": "AssertInstanceIsSsmManaged",
      "action": "aws:assertAwsResourceProperty",
      "description": "Ensures the target EC2 instance is managed by AWS Systems Manager, otherwise the automation ends.",
      "maxAttempts": 3,
      "onFailure": "Abort",
      "timeoutSeconds": 300,
      "inputs": {
        "Service": "ssm",
        "Api": "DescribeInstanceInformation",
        "InstanceInformationFilterList": [
          {
            "key": "InstanceIds",
            "valueSet": [
              "{{ InstanceId }}"
            ]
          }
        ],
        "PropertySelector": "$.InstanceInformationList[0].PingStatus",
        "DesiredValues": [
          "Online"
        ]
      },
      "nextStep": "CheckConcurrency"
    },
    {
      "name": "CheckConcurrency",
      "action": "aws:executeScript",
      "description": "Ensures there is only one execution of this runbook targeting the same Instance. If the runbook finds another in progress execution targeting the same Instance, it returns an error and ends.",
      "timeoutSeconds": 600,
      "onFailure": "Abort",
      "inputs": {
        "InputPayload": {
          "TargetResourceId": "{{ InstanceId }}",
          "ParameterName": "InstanceId"
        },
        "Handler": "script_handler",
        "Runtime": "python3.11",
        "Script": "# Copyright 2022 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n# SPDX-License-Identifier: LicenseRef-.amazon.com.-AmznSL-1.0\n# Licensed under the Amazon Software License  http://aws.amazon.com/asl/\n\nimport time\nfrom datetime import datetime, timedelta, timezone\n\nimport boto3\nfrom botocore.config import Config\n\nMAX_ATTEMPTS = 10\n\nconfig = Config(retries={\"max_attempts\": 10, \"mode\": \"standard\"})\nssm_client = boto3.client(\"ssm\", config=config)\n\n\ndef script_handler(events, context):\n    try:\n        # Get the current execution details\n        attempt = 0\n        while attempt < MAX_ATTEMPTS:\n            try:\n                current_execution = ssm_client.describe_automation_executions(\n                    Filters=[{\"Key\": \"ExecutionId\", \"Values\": [context[\"automation:EXECUTION_ID\"]]}]\n                )[\"AutomationExecutionMetadataList\"][0]\n                break\n            except Exception as error:\n                attempt += 1\n                print(\n                    f\"Failed to get current execution details for {context['automation:EXECUTION_ID']} - {str(error)}. Retrying...\"\n                )\n                time.sleep(10)\n                continue\n        else:\n            raise RuntimeError(\n                f\"Failed to get current execution details for {context['automation:EXECUTION_ID']}\"\n            ) from None\n\n        # Check for other previous/older running automation for the same current document that are not in a final status\n        current_execution_start_time = datetime.fromtimestamp(\n            current_execution[\"ExecutionStartTime\"].timestamp(), timezone.utc\n        )\n\n        # Add 5 seconds to 'StartTimeBefore' to capture executions that started exactly at the same time\n        current_execution_start_time += timedelta(seconds=10)\n\n        attempt = 0\n        while attempt < MAX_ATTEMPTS:\n            try:\n                # Describe executions that are not in terminal status\n                document_executions = ssm_client.describe_automation_executions(\n                    Filters=[\n                        {\"Key\": \"DocumentNamePrefix\", \"Values\": [current_execution[\"DocumentName\"]]},\n                        {\"Key\": \"ExecutionStatus\", \"Values\": [\"InProgress\", \"Pending\", \"Cancelling\", \"Waiting\"]},\n                        {\n                            \"Key\": \"StartTimeBefore\",\n                            \"Values\": [current_execution_start_time.strftime(\"%Y-%m-%dT%H:%M:%SZ\")],\n                        },\n                    ]\n                )[\"AutomationExecutionMetadataList\"]\n                break\n            except Exception as error:\n                attempt += 1\n                print(\n                    f\"Failed to get current execution details for {context['automation:EXECUTION_ID']} - {str(error)}. Retrying...\"\n                )\n                time.sleep(10)\n                continue\n        else:\n            raise RuntimeError(\n                f\"Failed to get current execution details for {context['automation:EXECUTION_ID']}\"\n            ) from None\n\n        # Check for other previous executions targeting the same resource ID. If any, return an error\n        for execution in document_executions:\n            execution_id = execution[\"AutomationExecutionId\"]\n            if execution_id != current_execution[\"AutomationExecutionId\"]:\n                if execution.get(\"Target\", \"\") == events.get(\"TargetResourceId\"):\n                    raise RuntimeError(\n                        f\"There is another execution of this document already in progress for {events.get('TargetResourceId')} with id {execution['AutomationExecutionId']}\",\n                    ) from None\n                attempt = 0\n                while attempt < MAX_ATTEMPTS:\n                    try:\n                        execution_details = ssm_client.get_automation_execution(AutomationExecutionId=execution_id)[\n                            \"AutomationExecution\"\n                        ]\n                        break\n                    except Exception as error:\n                        attempt += 1\n                        print(f\"Failed to get execution details for {execution_id} - {str(error)}. Retrying...\")\n                        time.sleep(10)\n                        continue\n                else:\n                    raise RuntimeError(f\"Failed to get execution details for {execution_id}\") from None\n\n                execution_resource_id = next(iter(execution_details), \"\")\n                if execution_resource_id == events.get(\"TargetResourceId\"):\n                    raise RuntimeError(\n                        f\"There is another execution of this document already in progress for {events.get('TargetResourceId')} with id {execution['AutomationExecutionId']}\",\n                    ) from None\n\n    except Exception as e:\n        raise RuntimeError(f\"An error occurred when checking concurrent executions: {str(e)}\") from None\n\n    return {\n        \"NoExecutionFound\": f\"No Automation executions were found in progress for {current_execution.get('DocumentName')} runbook targeting {events.get('TargetResourceId')}\"\n    }\n"
      },
      "outputs": [
        {
          "Name": "NoExecutionFound",
          "Selector": "$.Payload.NoExecutionFound",
          "Type": "String"
        }
      ],
      "nextStep": "ValidateCommandID"
    },
    {
      "name": "ValidateCommandID",
      "description": "Validates if RunCommandId is provided as input parameter. If not, finds the latest execution of AWS-RunPatchBaseline for the Instance which is in Failed status.",
      "action": "aws:executeScript",
      "nextStep": "BranchOnCommandStatus",
      "onFailure": "Abort",
      "inputs": {
        "Attachment": "attachment.zip",
        "InputPayload": {
          "Instance": "{{ InstanceId }}",
          "CommandID": "{{ RunCommandId }}"
        },
        "Script": "# Copyright 2023 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n# SPDX-License-Identifier: LicenseRef-.amazon.com.-AmznSL-1.0\n# Licensed under the Amazon Software License  http://aws.amazon.com/asl/\n\nfrom datetime import datetime\n\nimport boto3\nfrom botocore.exceptions import ClientError\n\nERROR_ICON = \" \\u274C [ERROR]:\"\nINFO_ICON = \" \\u2705 [INFO]:\"\nWARN_ICON = \" \\u26A0 [WARNING]:\"\nNON_FAILED_STATUSES = [\"Pending\", \"InProgress\", \"Success\"]\nDOCUMENT_NAME = \"AWS-RunPatchBaseline\"\n\n\nssm_client = boto3.client(\"ssm\")\n\n\ndef script_handler(events, context=None):\n    instance_id = events[\"Instance\"]\n    command_id = events[\"CommandID\"]\n\n    if command_id:\n        print(\n            f\"{INFO_ICON} Looking for the execution '{command_id}' of '{DOCUMENT_NAME}' on the instance '{instance_id}'.\"\n        )\n\n        # Get command invocation details\n        result = get_command_invocation(instance_id, command_id)\n\n        # Check for concurrent executions when command_id is provided\n        concurrent_command = check_concurrent_patch_executions(\n            instance_id, command_id, result[\"start_time\"], result[\"end_time\"]\n        )\n        if concurrent_command:\n            result[\"concurrent_command_id\"] = concurrent_command\n        else:\n            result[\"concurrent_command_id\"] = \"None\"\n\n        return result\n    else:\n        print(\n            f\"{INFO_ICON} No RunCommandID provided. Looking for latest failed execution of '{DOCUMENT_NAME}' on the instance.\"\n        )\n\n        # First get the latest failed command invocation\n        result = get_latest_failed_command_invocation(instance_id)\n        failed_command_id = result.get(\"command\")\n\n        # Then check for concurrent executions using the retrieved command ID\n        concurrent_command = check_concurrent_patch_executions(\n            instance_id, failed_command_id, result[\"start_time\"], result[\"end_time\"]\n        )\n        if concurrent_command:\n            print(f\"{WARN_ICON} Found concurrent execution of '{DOCUMENT_NAME}' with command ID: {concurrent_command}\")\n            result[\"concurrent_command_id\"] = concurrent_command\n        else:\n            result[\"concurrent_command_id\"] = \"None\"\n\n        return result\n\n\ndef check_concurrent_patch_executions(instance_id: str, command_id: str, start_time: str, end_time: str):\n    \"\"\"\n    Check for concurrent executions of AWS-RunPatchBaseline on the same instance.\n    Returns the command ID of concurrent execution if found, None otherwise.\n    \"\"\"\n    try:\n        # Convert ISO format strings to datetime objects\n        original_start_time = datetime.fromisoformat(start_time) if start_time != \"Unknown\" else None\n        original_end_time = datetime.fromisoformat(end_time) if end_time != \"Unknown\" else None\n\n        if not original_start_time:\n            print(f\"{WARN_ICON} Could not determine start time of the original command for concurrent execution check.\")\n            return None\n\n        # If command hasn't finished, use current time as end time\n        if not original_end_time:\n            original_end_time = datetime.now(original_start_time.tzinfo)\n\n        # Look for other executions in this time window\n        paginator = ssm_client.get_paginator(\"list_command_invocations\")\n        response_iterator = paginator.paginate(\n            InstanceId=instance_id,\n            Filters=[\n                {\n                    \"key\": \"DocumentName\",\n                    \"value\": DOCUMENT_NAME,\n                },\n            ],\n            Details=True,\n        )\n\n        for page in response_iterator:\n            for invocation in page.get(\"CommandInvocations\", []):\n                # Skip the original command\n                if invocation.get(\"CommandId\") == command_id:\n                    continue\n\n                # Check each command's timing\n                command_plugins = invocation.get(\"CommandPlugins\", [])\n                for plugin in command_plugins:\n                    if plugin.get(\"Name\") == \"PatchLinux\":\n                        other_start_time = plugin.get(\"ResponseStartDateTime\")\n                        other_end_time = plugin.get(\"ResponseFinishDateTime\")\n\n                        if not other_start_time:\n                            continue\n\n                        if not other_end_time:\n                            other_end_time = datetime.now(other_start_time.tzinfo)\n\n                        # Check for overlap\n                        if other_start_time <= original_end_time and other_end_time >= original_start_time:\n                            print(\n                                f\"{WARN_ICON} Found concurrent execution of '{DOCUMENT_NAME}' \"\n                                f\"(Command ID: {invocation.get('CommandId')})\"\n                            )\n                            return invocation.get(\"CommandId\")\n\n        print(f\"{INFO_ICON} No concurrent executions found.\")\n        return None\n\n    except ClientError as e:\n        print(f\"{WARN_ICON} Error checking for concurrent executions: {str(e)}\")\n        return None\n\n\ndef get_command_invocation(instance_id: str, command_id: str) -> dict:\n    try:\n        # Use get_command_invocation for most of the information\n        response = ssm_client.get_command_invocation(InstanceId=instance_id, CommandId=command_id)\n        if not response or response.get(\"DocumentName\") != DOCUMENT_NAME:\n            raise RuntimeError(f\"{ERROR_ICON} Command ID {command_id} was not executed for {DOCUMENT_NAME}.\") from None\n\n        status = response.get(\"Status\", \"Unknown\")\n\n        # Get both start and end time from ListCommandInvocations with details flag\n        start_time = \"Unknown\"\n        end_time = \"Unknown\"\n\n        invocations = ssm_client.list_command_invocations(\n            CommandId=command_id, InstanceId=instance_id, Details=True\n        ).get(\"CommandInvocations\", [])\n\n        if invocations:\n            invocation = invocations[0]\n            # Get start and end time from PatchLinux plugin\n            command_plugins = invocation.get(\"CommandPlugins\", [])\n            for plugin in command_plugins:\n                if plugin.get(\"Name\") == \"PatchLinux\":\n                    response_start_time = plugin.get(\"ResponseStartDateTime\")\n                    response_finish_time = plugin.get(\"ResponseFinishDateTime\")\n                    if response_start_time and isinstance(response_start_time, datetime):\n                        start_time = response_start_time.isoformat()\n                    if response_finish_time and isinstance(response_finish_time, datetime):\n                        end_time = response_finish_time.isoformat()\n                    break\n\n        print(f\"{INFO_ICON} Found '{DOCUMENT_NAME}' '{command_id}' execution for the instance in status {status}.\")\n        return {\"command\": command_id, \"status\": status, \"start_time\": start_time, \"end_time\": end_time}\n\n    except ClientError as e:\n        raise RuntimeError(f\"{ERROR_ICON} Failed to get command invocation for '{command_id}': {str(e)}\") from None\n\n\ndef get_latest_failed_command_invocation(instance_id: str) -> dict:\n    print(\n        f\"{INFO_ICON} No RunCommandID provided. Looking for the latest failed execution of '{DOCUMENT_NAME}' targeting the instance.\"\n    )\n    try:\n        paginator = ssm_client.get_paginator(\"list_command_invocations\")\n        response_iterator = paginator.paginate(\n            InstanceId=instance_id,\n            Filters=[\n                {\n                    \"key\": \"DocumentName\",\n                    \"value\": DOCUMENT_NAME,\n                },\n            ],\n            Details=True,  # Changed to True to get plugin details\n        )\n\n        latest_failed_command_invocation = None\n        latest_start_time = None\n        command_result = {\"command\": None, \"status\": \"Unknown\", \"start_time\": \"Unknown\", \"end_time\": \"Unknown\"}\n\n        for page in response_iterator:\n            command_invocations = page.get(\"CommandInvocations\", [])\n            for invocation in command_invocations:\n                if invocation.get(\"Status\") not in NON_FAILED_STATUSES:\n                    # Get start and end time from PatchLinux plugin\n                    command_plugins = invocation.get(\"CommandPlugins\", [])\n                    for plugin in command_plugins:\n                        if plugin.get(\"Name\") == \"PatchLinux\":\n                            response_start_time = plugin.get(\"ResponseStartDateTime\")\n                            if response_start_time and isinstance(response_start_time, datetime):\n                                # Get the most recent execution based on ResponseStartDateTime\n                                if not latest_start_time or response_start_time > latest_start_time:\n                                    latest_start_time = response_start_time\n                                    latest_failed_command_invocation = invocation\n                                    command_result[\"command\"] = invocation.get(\"CommandId\")\n                                    command_result[\"status\"] = invocation.get(\"Status\", \"Unknown\")\n                                    command_result[\"start_time\"] = response_start_time.isoformat()\n\n                                    response_finish_time = plugin.get(\"ResponseFinishDateTime\")\n                                    if response_finish_time and isinstance(response_finish_time, datetime):\n                                        command_result[\"end_time\"] = response_finish_time.isoformat()\n                            break\n\n        if latest_failed_command_invocation:\n            print(\n                f\"{INFO_ICON} Found '{DOCUMENT_NAME}' '{command_result['command']}' execution on the instance with status '{command_result['status']}'.\"\n            )\n            return command_result\n        else:\n            raise RuntimeError(\n                f\"{ERROR_ICON} No failed RunCommandID of {DOCUMENT_NAME} found for '{instance_id}'. Rerun this automation providing a RunCommandID that has failed execution.\"\n            ) from None\n\n    except ClientError as e:\n        raise RuntimeError(\n            f\"{ERROR_ICON} Failed to get the latest failed execution of '{DOCUMENT_NAME}' on the instance: {str(e)}\"\n        ) from None\n",
        "Handler": "script_handler",
        "Runtime": "python3.11"
      },
      "outputs": [
        {
          "Name": "commandId",
          "Selector": "$.Payload.command",
          "Type": "String"
        },
        {
          "Name": "status",
          "Selector": "$.Payload.status",
          "Type": "String"
        },
        {
          "Name": "concurrent_command_id",
          "Selector": "$.Payload.concurrent_command_id",
          "Type": "String"
        },
        {
          "Type": "String",
          "Name": "startime",
          "Selector": "$.Payload.start_time"
        },
        {
          "Type": "String",
          "Name": "endtime",
          "Selector": "$.Payload.end_time"
        }
      ]
    },
    {
      "name": "BranchOnCommandStatus",
      "description": "Branches depending on the status of the Command.",
      "action": "aws:branch",
      "onFailure": "Abort",
      "isEnd": true,
      "inputs": {
        "Choices": [
          {
            "NextStep": "VerifyPrerequisites",
            "Variable": "{{ ValidateCommandID.status }}",
            "StringEquals": "Failed"
          }
        ],
        "Default": "GenerateReport"
      }
    },
    {
      "name": "VerifyPrerequisites",
      "action": "aws:runCommand",
      "description": "Verifies if the target EC2 instance is connected with AWS Systems Manager and if prerequisites softwares are present on the Instance.",
      "onFailure": "step:GenerateReport",
      "nextStep": "GetPlatformDetails",
      "isCritical": true,
      "maxAttempts": 1,
      "timeoutSeconds": 300,
      "inputs": {
        "InstanceIds": [
          "{{InstanceId}}"
        ],
        "DocumentName": "AWS-RunShellScript",
        "TimeoutSeconds": 300,
        "Parameters": {
          "commands": [
            "#!/bin/bash",
            "# Copyright 2023 Amazon.com, Inc. or its affiliates. All Rights Reserved.",
            "# SPDX-License-Identifier: LicenseRef-.amazon.com.-AmznSL-1.0",
            "# Licensed under the Amazon Software License  http://aws.amazon.com/asl/",
            "",
            "prerequisite_failed=\"false\"",
            "",
            "command_exists() {",
            "    command -v \"$1\" >/dev/null 2>&1",
            "}",
            "",
            "# Determine AWS region, partition, and S3 endpoint with support for both IMDSv2 and AWS CLI",
            "determine_environment_details() {",
            "    printf \"Determining region...\\n\"",
            "    ",
            "    # Try IMDSv2 first (session-oriented approach)",
            "    TOKEN=\"\"",
            "    TOKEN=$(curl -s -X PUT \"http://169.254.169.254/latest/api/token\" -H \"X-aws-ec2-metadata-token-ttl-seconds: 21600\" 2>/dev/null)",
            "    if [ -n \"$TOKEN\" ]; then",
            "        # Use the token to get the region",
            "        REGION=$(curl -s -H \"X-aws-ec2-metadata-token: $TOKEN\" http://169.254.169.254/latest/meta-data/placement/region 2>/dev/null)",
            "        printf \"Region from IMDSv2: %s\\n\" \"$REGION\"",
            "    fi",
            "    ",
            "    # If IMDSv2 failed, try IMDSv1",
            "    if [ -z \"$REGION\" ]; then",
            "        REGION=$(curl -s http://169.254.169.254/latest/meta-data/placement/region 2>/dev/null)",
            "        printf \"Region from IMDSv1: %s\\n\" \"$REGION\"",
            "    fi",
            "    ",
            "    # If metadata service failed, try to get from AWS CLI config",
            "    if [ -z \"$REGION\" ] && command -v aws >/dev/null 2>&1; then",
            "        REGION=$(aws configure get region 2>/dev/null)",
            "        printf \"Region from AWS CLI: %s\\n\" \"$REGION\"",
            "    fi",
            "    ",
            "    # Default to us-east-1 if we couldn't determine the region",
            "    if [ -z \"$REGION\" ]; then",
            "        REGION=\"us-east-1\"",
            "        printf \"Using default region: %s\\n\" \"$REGION\"",
            "    fi",
            "    ",
            "    # Determine partition and S3 endpoint based on region prefix",
            "    case \"$REGION\" in",
            "        us-iso-*)",
            "            PARTITION=\"aws-iso\"",
            "            S3_ENDPOINT=\"https://s3.$REGION.c2s.ic.gov\"",
            "            ;;",
            "        us-isob-*)",
            "            PARTITION=\"aws-iso-b\"",
            "            S3_ENDPOINT=\"https://s3.$REGION.sc2s.sgov.gov\"",
            "            ;;",
            "        us-isof-*)",
            "            PARTITION=\"aws-iso-f\"",
            "            S3_ENDPOINT=\"https://s3.$REGION.csp.hci.ic.gov\"",
            "            ;;",
            "        eu-isoe-*)",
            "            PARTITION=\"aws-iso-e\"",
            "            S3_ENDPOINT=\"https://s3.$REGION.cloud.adc-e.uk\"",
            "            ;;",
            "        us-gov-*)",
            "            PARTITION=\"aws-us-gov\"",
            "            S3_ENDPOINT=\"https://s3.amazonaws.com\"",
            "            ;;",
            "        cn-*)",
            "            PARTITION=\"aws-cn\"",
            "            S3_ENDPOINT=\"https://s3.amazonaws.com\"",
            "            ;;",
            "        *)",
            "            PARTITION=\"aws\"",
            "            S3_ENDPOINT=\"https://s3.amazonaws.com\"",
            "            ;;",
            "    esac",
            "    ",
            "    printf \"Using region: %s, partition: %s\\n\" \"$REGION\" \"$PARTITION\"",
            "    printf \"S3 endpoint: %s\\n\" \"$S3_ENDPOINT\"",
            "}",
            "",
            "check_s3_access() {",
            "    local httpclient=\"$1\"",
            "    ",
            "    # Determine region, partition, and S3 endpoint",
            "    determine_environment_details",
            "",
            "    if [ \"$httpclient\" = \"curl\" ]; then",
            "        if curl -s -f -o /dev/null \"$S3_ENDPOINT\"; then",
            "            echo \"Check2: [PASSED] Connectivity to the S3 endpoint is established.\"",
            "        else",
            "            echo \"Check2: [FAILED] Connectivity to the S3 endpoint could not be established. This is required for Patch Manager to work and also for this automation to continue. Ensure the S3 connectivity is present on the Instance.\"",
            "            prerequisite_failed=\"true\"",
            "        fi",
            "    else",
            "        if wget -q -O /dev/null \"$S3_ENDPOINT\"; then",
            "            echo \"Check2: [PASSED] Connectivity to the S3 endpoint is established.\"",
            "        else",
            "            echo \"Check2: [FAILED] Connectivity to the S3 endpoint could not be established. This is required for Patch Manager to work and also for this automation to continue. Ensure the S3 connectivity is present on the Instance.\"",
            "            prerequisite_failed=\"true\"",
            "        fi",
            "    fi",
            "}",
            "",
            "check_http_client() {",
            "    if command_exists curl; then",
            "        echo \"Check1: [PASSED] curl is present on the System.\"",
            "        check_s3_access curl",
            "    elif command_exists wget; then",
            "        echo \"Check1: [PASSED] wget is present on the System.\"",
            "        check_s3_access wget",
            "    else",
            "        echo \"Check1: [FAILED] Neither curl nor wget is installed.\"",
            "        echo \"Check2: [FAILED] Unable to check S3 Connectivity as neither curl or wget is installed on the instance.\"",
            "        prerequisite_failed=\"true\"",
            "    fi",
            "}",
            "",
            "check_unzip() {",
            "    if command_exists unzip; then",
            "        echo \"Check3: [PASSED] unzip is present on the System.\"",
            "    else",
            "        echo \"Check3: [FAILED] unzip is not present. Please install unzip to continue.\"",
            "        prerequisite_failed=\"true\"",
            "    fi",
            "}",
            "",
            "# More robust version comparison for Python",
            "version_greater_equal() {",
            "    local version1=\"$1\"",
            "    local version2=\"$2\"",
            "    ",
            "    # Extract major and minor versions",
            "    local v1_major=$(echo \"$version1\" | cut -d. -f1)",
            "    local v1_minor=$(echo \"$version1\" | cut -d. -f2)",
            "    local v2_major=$(echo \"$version2\" | cut -d. -f1)",
            "    local v2_minor=$(echo \"$version2\" | cut -d. -f2)",
            "    ",
            "    if [ \"$v1_major\" -gt \"$v2_major\" ] || ([ \"$v1_major\" -eq \"$v2_major\" ] && [ \"$v1_minor\" -ge \"$v2_minor\" ]); then",
            "        return 0",
            "    else",
            "        return 1",
            "    fi",
            "}",
            "",
            "check_python3() {",
            "    # Check if python3 is available",
            "    if command_exists python3; then",
            "        python3_version=$(python3 --version 2>&1 | cut -d \" \" -f 2)",
            "        if version_greater_equal \"$python3_version\" \"3.7\"; then",
            "            echo \"Check4: [PASSED] Python $python3_version is present on the System.\"",
            "        else",
            "            echo \"Check4: [PASSED] Installed Python version is $python3_version. Minimum version required for the runbook to work is 3.7. We recommend upgrading to Python 3.8 or later to minimize impact of future update campaigns. Refer to AWS documentation for more info on Python support policy updates for AWS SDKs and tools.\"",
            "        fi",
            "    else",
            "        echo \"Check4: [FAILED] Python3 is not present on the System. Please install Python 3.7 or later.\"",
            "        prerequisite_failed=\"true\"",
            "    fi",
            "}",
            "",
            "# Run Checks sequentially",
            "echo -e \"---------------------------\"",
            "echo \"Prerequisites Checks Summary\"",
            "echo -e \"---------------------------\"",
            "",
            "check_http_client",
            "check_unzip",
            "check_python3",
            "",
            "# Check if any prerequisite are not met.",
            "if [ \"$prerequisite_failed\" = \"true\" ]; then",
            "    echo -e \"\\nOne or more Prerequisites failed for this Automation to continue. Exiting...\"",
            "    exit 1",
            "else",
            "    echo -e \"\\nAll Prerequisites are met for this Automation to continue.\"",
            "    exit 0",
            "fi"
          ]
        }
      }
    },
    {
      "name": "GetPlatformDetails",
      "description": "Gets the platform details of the Instance.",
      "action": "aws:executeAwsApi",
      "maxAttempts": 2,
      "timeoutSeconds": 180,
      "nextStep": "GetDownloadURL",
      "onFailure": "Abort",
      "inputs": {
        "Service": "ssm",
        "Api": "DescribeInstanceInformation",
        "InstanceInformationFilterList": [
          {
            "key": "InstanceIds",
            "valueSet": [
              "{{ InstanceId }}"
            ]
          }
        ]
      },
      "outputs": [
        {
          "Name": "OperatingSystem",
          "Selector": "$.InstanceInformationList[0].PlatformName",
          "Type": "String"
        },
        {
          "Name": "PlatformVersion",
          "Selector": "$.InstanceInformationList[0].PlatformVersion",
          "Type": "String"
        }
      ]
    },
    {
      "name": "GetDownloadURL",
      "description": "Gathers the download URL for the PatchManagerLogAnalyzer package. ",
      "action": "aws:executeAwsApi",
      "onFailure": "Abort",
      "nextStep": "EvaluatePatchManagerLogs",
      "inputs": {
        "Service": "ssm",
        "Api": "GetDocument",
        "Name": "AWSSupport-TroubleshootPatchManagerLinux"
      },
      "outputs": [
        {
          "Name": "URL",
          "Selector": "$.AttachmentsContent[0].Url",
          "Type": "String"
        }
      ]
    },
    {
      "name": "EvaluatePatchManagerLogs",
      "action": "aws:runCommand",
      "description": "Downloads and executes the PatchManagerLogAnalyzer python package on the instance to evaluate the log file.",
      "onFailure": "Abort",
      "nextStep": "GenerateReport",
      "isCritical": true,
      "maxAttempts": 3,
      "timeoutSeconds": 180,
      "inputs": {
        "InstanceIds": [
          "{{InstanceId}}"
        ],
        "DocumentName": "AWS-RunShellScript",
        "TimeoutSeconds": 300,
        "Parameters": {
          "commands": [
            "#!/bin/bash",
            "# Copyright 2023 Amazon.com, Inc. or its affiliates. All Rights Reserved.",
            "# SPDX-License-Identifier: LicenseRef-.amazon.com.-AmznSL-1.0",
            "# Licensed under the Amazon Software License  http://aws.amazon.com/asl/",
            "",
            "command_exists() {",
            "    $(which \"$1\" > /dev/null 2>&1 )",
            "    return $?",
            "}",
            "",
            "OS=\"{{GetPlatformDetails.OperatingSystem}}\"",
            "PLATFORM=\"{{GetPlatformDetails.PlatformVersion}}\"",
            "URL=\"{{GetDownloadURL.URL}}\"  # The URL to download",
            "INSTANCE_ID=\"{{InstanceId}}\"",
            "RUNCOMMAND_ID=\"{{ValidateCommandID.commandId}}\"",
            "CONCURRENT_RUNCOMMAND_ID=\"{{ValidateCommandID.concurrent_command_id}}\"",
            "START_TIME=\"{{ValidateCommandID.startime}}\"",
            "END_TIME=\"{{ValidateCommandID.endtime}}\"",
            "",
            "TMP_DIRECTORY=\"/var/lib/amazon/ssm/PatchManagerLogAnalyzer\"",
            "# Check if the PatchManagerLogAnalyzer exists",
            "if [ ! -d \"$TMP_DIRECTORY\" ]; then",
            "    # Create the PatchManagerLogAnalyzer dir",
            "    mkdir -p /var/lib/amazon/ssm/PatchManagerLogAnalyzer",
            "fi",
            "",
            "cd $TMP_DIRECTORY",
            "UnzippedDirectory=\"/var/lib/amazon/ssm/PatchManagerLogAnalyzer/Automation-{{automation:EXECUTION_ID}}\"",
            "",
            "# Check if curl or wget is available",
            "if command_exists curl; then",
            "    curl -s \"$URL\" --output attachments.zip",
            "elif command_exists wget; then",
            "    wget -q \"$URL\" -O attachments.zip",
            "else",
            "    echo \"Error: Neither curl nor wget is installed. Unable to download file.\" >&2",
            "    exit 1",
            "fi",
            "",
            "unzip -qq -o -d $UnzippedDirectory attachments.zip",
            "[ $? -ne 0 ] && echo \"Error unzipping the file\" >&2 && exit 1",
            "",
            "cd $UnzippedDirectory",
            "",
            "# Find the latest Python 3 version available on the system",
            "find_latest_python() {",
            "    # Try to find all python3.x executables in PATH",
            "    local python_versions=()",
            "    local IFS=:",
            "    for path_dir in $PATH; do",
            "        if [ -d \"$path_dir\" ]; then",
            "            for py_exec in \"$path_dir\"/python3*; do",
            "                if [ -x \"$py_exec\" ] && [[ \"$py_exec\" =~ python3[.][0-9]+$ ]]; then",
            "                    python_versions+=(\"$py_exec\")",
            "                fi",
            "            done",
            "        fi",
            "    done",
            "",
            "    # If specific versions were found, sort them and use the latest",
            "    if [ ${#python_versions[@]} -gt 0 ]; then",
            "        # Sort versions and get the latest",
            "        local latest_python=$(printf '%s\\n' \"${python_versions[@]}\" | sort -V | tail -n 1)",
            "        echo \"$latest_python\"",
            "        return 0",
            "    fi",
            "",
            "    # If no specific version found, try the default python3",
            "    if command_exists python3; then",
            "        echo \"python3\"",
            "        return 0",
            "    fi",
            "",
            "    # No Python 3 found",
            "    echo \"No Python 3 installation found on the system.\" >&2",
            "    return 1",
            "}",
            "",
            "# Get the latest Python 3 executable",
            "PYTHON_EXEC=$(find_latest_python)",
            "if [ $? -ne 0 ]; then",
            "    exit 1",
            "fi",
            "",
            "echo \"Starting '$PYTHON_EXEC main.py $INSTANCE_ID $RUNCOMMAND_ID $OS $PLATFORM $CONCURRENT_RUNCOMMAND_ID' \"",
            "ARGS=(",
            "    \"$INSTANCE_ID\"",
            "    \"$RUNCOMMAND_ID\"",
            "    \"$OS\"",
            "    \"$PLATFORM\"",
            "    \"$CONCURRENT_RUNCOMMAND_ID\"",
            "    \"$START_TIME\"",
            "    \"$END_TIME\"",
            ")",
            "\"$PYTHON_EXEC\" main.py \"${ARGS[@]}\"",
            "",
            "",
            "# Clean up directory. Wait for 5 seconds in case of file locks.",
            "sleep 5",
            "rm -rf $TMP_DIRECTORY"
          ]
        }
      }
    },
    {
      "name": "GenerateReport",
      "description": "Creates the final output for the Automation Execution.",
      "action": "aws:executeScript",
      "onFailure": "Abort",
      "isEnd": true,
      "inputs": {
        "InputPayload": {
          "Instance": "{{ InstanceId }}",
          "FailedCommandStatus": "{{ ValidateCommandID.status }}",
          "FailedCommandID": "{{ ValidateCommandID.commandId }}",
          "EvaluatePatchManagerLogsCommandID": "{{ EvaluatePatchManagerLogs.CommandId }}",
          "EvaluatePatchManagerLogsOutput": "{{ EvaluatePatchManagerLogs.Output }}",
          "VerifyPrerequisitesCommandStatus": "{{ VerifyPrerequisites.Status }}",
          "VerifyPrerequisitesCommandOutput": "{{ VerifyPrerequisites.Output }}"
        },
        "Script": "# Copyright 2023 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n# SPDX-License-Identifier: LicenseRef-.amazon.com.-AmznSL-1.0\n# Licensed under the Amazon Software License  http://aws.amazon.com/asl/\nimport boto3\nfrom botocore.exceptions import ClientError\n\nERROR_ICON = \" \\u274C [ERROR]:\"\nINFO_ICON = \" \\u2705 [INFO]:\"\nWARN_ICON = \" \\u26A0 [WARNING]:\"\n\nConnectionLost_info = f\"{ERROR_ICON} VerifyPrerequisites step status is Timed Out. The Instance is currently in Connection Lost state and therefore not SSM Managed. For this Automation to proceed, the Instance should to be SSM Managed. \\nAlso, for AWS-RunPatchBaseline document to successfully patch the instance, the Instance must be SSM managed.\\n\\nTo Troubleshoot why the instance is not SSM managed, you can use the below resources:\\n\\n1.From your instance, run the below command to verify the status of ssm agent prerequisites:\\nssm-cli get-diagnostics\\n\\nTo understand the output of this command, refer to https://docs.aws.amazon.com/systems-manager/latest/userguide/ssm-cli.html\\n\\n2. Run the AWSSupport-TroubleshootManagedInstance Systems Manager Automation document.\\n\\nFor more details on this Automation document, refer to https://docs.aws.amazon.com/systems-manager-automation-runbooks/latest/userguide/automation-awssupport-troubleshoot-managed-instance.html\\n\\n3. Repost Article : https://repost.aws/knowledge-center/systems-manager-ec2-instance-not-appear\"\n\nCommandNotAccepting_info = f\"{ERROR_ICON} VerifyPrerequisites step status is timed out. Failed to deliver commands to Instance. Check if the Instance is SSM Managed and the PingStatus is Online. Next, verify if all the prerequisites are met on the instance for ssm agent to work properly by running the below commands:\\n\\nssm-cli get-diagnostics \\n\\nTo understand the output of this command, refer to https://docs.aws.amazon.com/systems-manager/latest/userguide/ssm-cli.html\"\n\nAccessDenied_info = f\"{INFO_ICON} The Command failed with Status Access Denied. The AWS Identity and Access Management (IAM) user or role initiating the command doesn't have access to the targeted managed node. Ensure the user or role have necessary permissions to use the Run Command feature. For more details, see https://docs.aws.amazon.com/systems-manager/latest/userguide/security-iam.html\"\n\nExecutionTimedOut_info = f\"{INFO_ICON} The Command failed with Execution Timed Out. Command started on the managed node, but the command wasn’t completed before the execution timeout expired. \\n You can check the Agent logs for more information on the delay or alternatively, you can increase the Execution Time Out value. For more details on command statuses, see https://docs.aws.amazon.com/systems-manager/latest/userguide/monitor-commands.html#monitor-about-status-timeouts\"\n\nDeliveryTimedOut_info = f\"{INFO_ICON} The Command failed with Delivery Timed Out. The command wasn't delivered to the managed node before the total timeout expired. \\n\\nPossible reason would be the Instance is not available or the SSM agent running on the instance is not able to receive the Command. The later can be due to SSM agent not working properly or network issues. Check the SSM agent Logs and confirm SSM agent was running at the time of Command Invocation.  For more details about command statuses, see https://docs.aws.amazon.com/systems-manager/latest/userguide/monitor-commands.html#monitor-about-status-timeouts\"\n\nUndeliverable_info = f\"{INFO_ICON} The Command failed with Undeliverable Status. The command couldn't be delivered to the managed node. The node might not exist or it might not be responding. \\n\\nPossible reason would be the Instance is not available, stopped or terminated. This can also happen if the Instance was in Connection Lost when command was attempted to send to the Instance. \\n Other possibles reasons are SSM agent is not working properly or network issues on the instance. Check the SSM agent Logs at /var/log/amazon/ssm and confirm SSM agent was running at the time of Command Invocation.  For more details, see https://docs.aws.amazon.com/systems-manager/latest/userguide/monitor-commands.html#monitor-about-status-timeouts\"\n\nSuccess_info = f\"{INFO_ICON} The Command Status is Success.\"\n\nCancelled_info = f\"{INFO_ICON} The Command Status is Cancelled. The command was cancelled before it was completed.\"\n\nTerminated_info = f\"{INFO_ICON} The Command invocation is in Terminated status. This happens when the parent command exceeded its max-errors limit and subsequent command invocations were canceled by the system. To understand more about error controls, refer https://docs.aws.amazon.com/systems-manager/latest/userguide/send-commands-multiple.html#send-commands-rate\"\n\nNoexec_info = f\"{ERROR_ICON} VerifyPrerequisites step status failed. Permission denied occurred when accessing the _script.sh file under /var/lib/amazon/. This can happen if /var/lib/amazon/ is mounted with noexec permissions. SSM Agent requires access to /var/lib/amazon directory to successfully execute Run Command scripts.\\n\\nFore more details, see https://docs.aws.amazon.com/systems-manager/latest/userguide/patch-manager-troubleshooting.html#patch-manager-troubleshooting-linux-3\"\n\nOther_info = f\"{INFO_ICON} The Command is not in a terminal status or the status not supported. Please provide a valid 'RunCommandId' in failed status and try again. For more details about command statuses, see https://docs.aws.amazon.com/systems-manager/latest/userguide/monitor-commands.html\"\n\n\ndef get_command_invocation_output(command, instance):\n    \"\"\"\n    This function initializes calls the GetCommandInvocation API to get the stdout content of the Run Command.\n    ARGS:\n        command: string : Run Command ID\n        instance: string: Instance ID\n    returns :\n        stdout_content of the command. Type:String\n    \"\"\"\n    try:\n        client = boto3.client(\"ssm\")\n        response = client.get_command_invocation(CommandId=command, InstanceId=instance)\n        stdout_content = response.get(\"StandardOutputContent\")\n        return stdout_content\n    except ClientError as e:\n        raise Exception(f\"{ERROR_ICON} {str(e)}\")\n\n\ndef get_instance_pingstatus(instance):\n    \"\"\"\n    This function checks for the SSM Ping status of the Instance.\n    ARGS:\n        instance: string: Instance ID\n    returns :\n         Text as Online or ConnectionLost.Type:String.\n    \"\"\"\n    try:\n        client = boto3.client(\"ssm\")\n        response = client.describe_instance_information(\n            InstanceInformationFilterList=[\n                {\n                    \"key\": \"InstanceIds\",\n                    \"valueSet\": [\n                        instance,\n                    ],\n                },\n            ]\n        )\n        if \"InstanceInformationList\" in response:\n            instance_info_list = response[\"InstanceInformationList\"]\n            if instance_info_list and len(instance_info_list) > 0:\n                ping_status = instance_info_list[0].get(\"pingstatus\")\n            else:\n                # Handle the case where the list is empty\n                ping_status = None\n        else:\n            # Handle the case where \"InstanceInformationList\" is not in the response\n            ping_status = None\n\n        if ping_status == \"Online\":\n            return \"Online\"\n        else:\n            return \"ConnectionLost\"\n\n    except ClientError as e:\n        raise Exception(f\"{ERROR_ICON}\", e)\n\n\ndef script_handler(events, context=None):\n    instanceid = events[\"Instance\"]\n    failed_patching_command_id = events[\"FailedCommandID\"]\n    failed_patching_command_status = events[\"FailedCommandStatus\"]\n    evaluate_patchmanager_logs_command_id = events[\"EvaluatePatchManagerLogsCommandID\"]\n    verify_prerequisites_command_status = events[\"VerifyPrerequisitesCommandStatus\"]\n    verify_prerequisites_command_output = events[\"VerifyPrerequisitesCommandOutput\"]\n    text_remove_output = \"----------ERROR-------\\nfailed to run commands: exit status 1\"\n    pre_output_text = f\"=======================\\nTROUBLESHOOTING RESULTS\\n=======================\\n\\nChecking Command ID {failed_patching_command_id} for Instance {instanceid} :\\n\\n\"\n\n    # Validates Command ID Status.\n    if failed_patching_command_status == \"AccessDenied\":\n        return {\"Output\": pre_output_text + AccessDenied_info}\n    elif failed_patching_command_status == \"Undeliverable\":\n        return {\"Output\": pre_output_text + Undeliverable_info}\n    elif failed_patching_command_status == \"DeliveryTimedOut\":\n        return {\"Output\": pre_output_text + DeliveryTimedOut_info}\n    elif failed_patching_command_status == \"ExecutionTimedOut\":\n        return {\"Output\": pre_output_text + ExecutionTimedOut_info}\n    elif failed_patching_command_status == \"Success\":\n        return {\"Output\": pre_output_text + Success_info}\n    elif failed_patching_command_status == \"Terminated\":\n        return {\"Output\": pre_output_text + Terminated_info}\n    elif failed_patching_command_status == \"Cancelled\":\n        return {\"Output\": pre_output_text + Cancelled_info}\n    elif failed_patching_command_status == \"Failed\":\n        # Continue to validate prerequisites\n        pass\n    else:\n        return {\"Output\": pre_output_text + Other_info}\n\n    # Validates the VerifyPrerequisites step output\n    if \"VerifyPrerequisites.Status\" in verify_prerequisites_command_status:\n        pingstatus = get_instance_pingstatus(instanceid)\n        if pingstatus == \"ConnectionLost\":\n            return {\"Output\": ConnectionLost_info}\n        else:\n            return {\"Output\": CommandNotAccepting_info}\n    # In progress, this will mostly happen when the status has not changed to connection Lost but the agent is offline. It takes 15 minutes for it reflect as Connection Lost.\n    elif verify_prerequisites_command_status == \"InProgress\":\n        return {\"Output\": CommandNotAccepting_info}\n    elif \"One or more Prerequisites failed for this Automation to continue.\" in verify_prerequisites_command_output:\n        return {\n            \"Output\": verify_prerequisites_command_output.replace(text_remove_output, \"\").replace(\n                \"One or more Prerequisites failed for this Automation to continue.\",\n                \"\\u274C One or more Prerequisites failed for this Automation to continue.\",\n            )\n        }\n    elif (\n        \"_script.sh: Permission denied\" in verify_prerequisites_command_output\n        and \"failed to run commands: exit status 126\" in verify_prerequisites_command_output\n    ):\n        return {\"Output\": Noexec_info}\n\n    if \"Failed\" in verify_prerequisites_command_status:\n        return {\n            \"Output\": \"\\u274C VerifyPrerequisites step failed with unknown error. Check if Instance is online and managed by Systems Manager. Run the following command on the instance to confirm:\\n\\n ssm-cli get-diagnostics --output table\"\n        }\n    # Getting full evaluate_patchmanager_logs_command_id output. There is limitation in the the output characters of aws:runCommand Automation Action to 2K.\n    output = get_command_invocation_output(evaluate_patchmanager_logs_command_id, instanceid)\n    return {\"Output\": output}\n",
        "Handler": "script_handler",
        "Runtime": "python3.11"
      },
      "outputs": [
        {
          "Name": "output",
          "Selector": "$.Payload.Output",
          "Type": "String"
        }
      ]
    }
  ],
  "files": {
    "attachment.zip": {
      "checksums": {
        "SHA256": "0c96f81a9109d84026f574047e6d1848abfe48f8238a3a1ac60cf7a6f42f1866"
      }
    }
  }
}
