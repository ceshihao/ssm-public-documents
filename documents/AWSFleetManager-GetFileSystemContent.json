{
  "schemaVersion": "2.2",
  "description": "Performs user account related actions",
  "parameters": {
    "Action": {
      "type": "String",
      "description": "(Optional) The action to perform",
      "default": "GetFiles",
      "allowedValues": [
        "GetFiles"
      ]
    },
    "Path": {
      "type": "String",
      "description": "If the Action parameter is set to GetFiles, this is the path to process.",
      "allowedPattern": "^\\w:$|^\\w:\\\\[^\"'|\\r\\n]*$|^\\/[^\"'|\\r\\n]*$|^([A-Za-z0-9-_\\/+]{4})*([A-Za-z0-9-_\\/+]{4}|[A-Za-z0-9-_\\/+]{3}=|[A-Za-z0-9-_\\/+]{2}==)$"
    },
    "NextToken": {
      "type": "String",
      "description": "(Optional) Used for the pagination of data. To return all results, specify a value of *. When used with the GetFiles action, set this value to the last file name returned from the previous execution.",
      "default": "*",
      "allowedPattern": "^\\*$|^([A-Za-z0-9-_\\/+]{4})*([A-Za-z0-9-_\\/+]{4}|[A-Za-z0-9-_\\/+]{3}=|[A-Za-z0-9-_\\/+]{2}==)$",
      "minChars": 1,
      "maxChars": 255
    },
    "AllowTruncatedOutput": {
      "type": "String",
      "description": "(Optional) Specifies whether the standard output can be truncated or not. If set to 'No', the standard output size will be limited to stay with Systems Manager API limits. If set to 'Yes', the standard output will not be limited.",
      "default": "Yes",
      "allowedValues": [
        "No",
        "Yes"
      ]
    },
    "CompressOutput": {
      "type": "String",
      "description": "(Optional) Defines whether output is compressed. If set to \"No\", the output will be a JSON string. If set to \"Yes\", the output will be a JSON string, that is gzipped and BASE64 encoded.",
      "default": "No",
      "allowedValues": [
        "No",
        "Yes"
      ]
    }
  },
  "mainSteps": [
    {
      "precondition": {
        "StringEquals": [
          "platformType",
          "Windows"
        ]
      },
      "action": "aws:runPowerShellScript",
      "name": "InvokeWindowsScript",
      "inputs": {
        "runCommand": [
          "$ErrorActionPreference = 'Stop'\n\nFunction ParseInputParameter {\n    param (\n        [string]$Name,\n        [string]$Value,\n        [string]$Regex\n    )\n\n    $ValidParameterRegex = '^--%[ +{|{].*}( +)?$'\n    if ($Value -notmatch $ValidParameterRegex) {\n        ExitWithFailureMessage -Message \"Invalid syntax for the parameter $Name\"\n    }\n    $parameterValue = $Value.Substring(3)\n\n    $trimmedParameterValue = $parameterValue.TrimStart().TrimEnd()\n    $trimmedParameterValue = $trimmedParameterValue.Substring(1)\n    $trimmedParameterValue = $trimmedParameterValue.Substring(0, $trimmedParameterValue.Length - 1)\n\n    if ($Regex -and $trimmedParameterValue -notmatch $Regex) {\n        ExitWithFailureMessage -Message \"Invalid syntax for the parameter $Name\"\n    } else {\n        $trimmedParameterValue\n    }\n}\n\nfunction ExitWithFailureMessage {\n    param (\n        [string]$Message,\n        [string]$ExceptionMessage,\n        [Switch]$PrintJson\n    )\n    if ([string]::IsNullOrWhitespace($ExceptionMessage)) {\n        $errorMessage = $Message\n    } else {\n        $errorMessage = '{0} {1}' -f $Message, $ExceptionMessage\n    }\n    if ($PrintJson) {ConvertTo-Json -InputObject @{error = $errorMessage} -Compress}\n    WriteStandardError -Message $errorMessage\n    [System.Environment]::Exit(1)\n}\n\nfunction ExitWithSuccessMessage {\n    param (\n        [string]$Message\n    )\n    Write-Host $Message\n    [System.Environment]::Exit(0)\n}\n\nfunction WriteStandardError {\n    param (\n        [string]$Message\n    )\n    $Host.UI.WriteErrorLine($Message)\n}\n\n$script:ResultProperty = 'results'\n$script:DataProperty = 'data'\n$script:NextTokenProperty = 'nextToken'\n\nfunction ConvertBase64ToString {\n    param (\n        [string]$Base64\n    )\n    $bytes = [System.Convert]::FromBase64String($Base64)\n    [System.Text.Encoding]::UTF8.GetString($bytes)\n}\n\nfunction ConvertStringToBase64 {\n    param (\n        [string]$String\n    )\n    $bytes = [System.Text.Encoding]::UTF8.GetBytes($String)\n    [System.Convert]::ToBase64String($bytes)\n}\n\nfunction GetCompressionBoolean {\n    param (\n        [ValidateSet('No','Yes')]\n        [string]$CompressOutput\n    )\n    if ($CompressOutput -eq 'Yes') {\n        $true\n    } else {\n        $false\n    }\n}\n\nfunction GetJson {\n    param ($InputObject)\n    ConvertTo-Json -InputObject $InputObject -Compress -Depth 5\n}\n\nfunction GetBase64EncodedGzipString {\n    param ($InputString)\n\n    $inputBytes = [System.Text.Encoding]::UTF8.GetBytes($InputString)\n\n    try {\n        $memoryStream = New-Object -TypeName 'System.IO.MemoryStream'\n        $compressionMode = [System.IO.Compression.CompressionMode]::Compress\n        $gzipStream = New-Object -TypeName 'System.IO.Compression.GzipStream' -ArgumentList @($memoryStream, $compressionMode)\n\n        $gzipStream.Write($inputBytes, 0, $inputBytes.Length)\n        $gzipStream.Close()\n        $memoryStream.Close()\n\n        [System.Convert]::ToBase64String($memoryStream.ToArray())\n    } finally {\n        $gzipStream.Dispose()\n        $memoryStream.Dispose()\n    }\n}\n\nfunction GetResultAsString {\n    param (\n        [PSObject]$Object,\n        [bool]$Completed,\n        [switch]$ConvertNextTokenToBase64,\n        [bool]$EnableCompression,\n        [bool]$ForceEmptyNextToken,\n        [string]$NextToken,\n        [string]$PaginationProperty,\n        [array]$StringReplacementRegex\n    )\n\n    if ([string]::IsNullOrWhiteSpace($NextToken)) {\n        if ($Completed -eq $false -and $Object.Count -ge 1 -and $ForceEmptyNextToken -ne $true) {\n            if ($PaginationProperty -eq '.') {\n                $NextToken = $Object[-1]\n            } else {\n                $NextToken = $Object[-1].$PaginationProperty\n            }\n        }\n    }\n\n    if ($ForceEmptyNextToken) {\n        $NextToken = [string]::Empty\n    } elseif ($ConvertNextTokenToBase64) {\n        $NextToken = ConvertStringToBase64 -String $NextToken\n    }\n\n    $data = @{\n        $script:ResultProperty    = $Object\n        $script:NextTokenProperty = $NextToken\n    }\n\n    if ($EnableCompression -eq $true) {\n        $string = GetJson -InputObject $data\n\n        if ($StringReplacementRegex.Count -eq 2) {\n            $string = $string -replace $StringReplacementRegex\n        }\n\n        $data = GetBase64EncodedGzipString -InputString $string\n    }\n\n    $output = GetJson -InputObject @{\n        $script:DataProperty = $data\n    }\n    if ($StringReplacementRegex.Count -eq 2) {\n        $output -replace $StringReplacementRegex\n    } else {\n        $output\n    }\n}\n\nfunction GetMaximumOutputBytes {\n    param (\n        $AllowTruncatedOutput,\n        [int]$MaximumOutputSize = 2500\n    )\n    if ($AllowTruncatedOutput -eq 'Yes') {\n        0\n    } else {\n        $padding = (GetResultAsString -Object @() -Completed $false -EnableCompression $false).length\n        $MaximumOutputSize - $padding\n    }\n}\n\nfunction ProcessItems {\n    param (\n        [scriptblock]$ScriptBlock,\n        [switch]$ConvertNextTokenToBase64,\n        [int]$ChunksPerLoop = 1,\n        [bool]$EnableCompression,\n        [int]$MaximumOutputBytes,\n        [string]$PaginationProperty,\n        [string]$PropertyToRemove,\n        [string]$NextToken,\n        [switch]$SetNextTokenBeforeAdding,\n        [array]$StringReplacementRegex\n    )\n\n    $chunkedOutputArray = New-Object -TypeName 'System.Collections.ArrayList'\n\n    $outputResult = [string]::Empty\n\n    $outputTooBig = $false\n    $counter = 0\n\n    $getResultString = @{\n        EnableCompression = $EnableCompression\n        PaginationProperty = $PaginationProperty\n        StringReplacementRegex = $StringReplacementRegex\n    }\n\n    foreach ($item in (& $ScriptBlock)) {\n        if ($outputTooBig -eq $true) { break }\n\n        if ($NextToken -ne '*') {\n            if ($PaginationProperty -eq '.' -and $item -le $NextToken) {\n                continue\n            } elseif ($PaginationProperty -ne '.' -and $item.$PaginationProperty -le $NextToken) {\n                continue\n            }\n        }\n\n        if ($SetNextTokenBeforeAdding) {\n            if ($PaginationProperty -eq '.') {\n                $newNextToken = $item\n            } else {\n                $newNextToken = $item.$PaginationProperty\n            }\n        }\n\n        if ($PropertyToRemove) {\n            $item.PSObject.properties.remove($PropertyToRemove)\n        }\n\n        $null = $chunkedOutputArray.Add($item)\n\n        if ($counter -lt $ChunksPerLoop) {\n            $counter++\n            continue\n        }\n\n        $counter = 0\n\n        $properties = @{\n            Object = $chunkedOutputArray\n            Completed = $outputTooBig\n        }\n        if ($ConvertNextTokenToBase64) {\n            $properties.Add('ConvertNextTokenToBase64', $ConvertNextTokenToBase64)\n        }\n        if ($SetNextTokenBeforeAdding) {\n            $properties.Add('NextToken', $newNextToken)\n        }\n        $tempResult = GetResultAsString @properties @getResultString\n\n        if ($MaximumOutputBytes -eq 0 -or $tempResult.Length -le $MaximumOutputBytes) {\n            $outputResult = $tempResult\n        } else {\n            $outputTooBig = $true\n            break\n        }\n    }\n\n    # Processing remaining items if the output isn't too big yet\n    if ($outputTooBig -eq $false) {\n        $properties = @{\n            Object = $chunkedOutputArray\n            Completed = $outputTooBig\n            ForceEmptyNextToken = $true\n        }\n        if ($ConvertNextTokenToBase64) {\n            $properties.Add('ConvertNextTokenToBase64', $ConvertNextTokenToBase64)\n        }\n        if ($SetNextTokenBeforeAdding) {\n            $properties.Add('NextToken', $newNextToken)\n        }\n        $tempResult = GetResultAsString @getResultString @properties\n        if ($MaximumOutputBytes -eq 0 -or $tempResult.Length -le $MaximumOutputBytes) {\n            $outputResult = $tempResult\n        }\n    }\n\n    $outputResult\n}\n\n$Action = Write-Output --%{{{ Action }}}\n$Action = ParseInputParameter -Name 'Action' -Value $Action\n\n$Path = Write-Output --%{{{ Path }}}\n$Path = ParseInputParameter -Name 'Path' -Value $Path\n\n$NextToken = Write-Output --%{{{ NextToken }}}\n$NextToken = ParseInputParameter -Name 'NextToken' -Value $NextToken\n\n$AllowTruncatedOutput = Write-Output --%{{{ AllowTruncatedOutput }}}\n$AllowTruncatedOutput = ParseInputParameter -Name 'AllowTruncatedOutput' -Value $AllowTruncatedOutput -Regex '(Yes|No)'\n\n$CompressOutput = Write-Output --%{{{ CompressOutput }}}\n$CompressOutput = ParseInputParameter -Name 'CompressOutput' -Value $CompressOutput -Regex '(Yes|No)'\n\n$base64Regex = '^([A-Za-z0-9-_\\/+]{4})*([A-Za-z0-9-_\\/+]{4}|[A-Za-z0-9-_\\/+]{3}=|[A-Za-z0-9-_\\/+]{2}==)$'\nif ($Path -match $base64Regex) {\n    $Path = ConvertBase64ToString -Base64 $Path\n}\n\nif ($Path -match '^\\w:$') {\n    $Path = $Path + \"\\\"\n}\n\nif ($NextToken -ne '*') {\n    try {\n        $NextToken = ConvertBase64ToString -Base64 $NextToken\n    } catch {\n        ExitWithFailureMessage -Message 'The specified NextToken is invalid.' -PrintJson\n    }\n}\n\ntry {$resolvedPath = (Resolve-Path -Path $Path).Path}\ncatch {ExitWithFailureMessage -Message 'The specified Path is invalid.' -PrintJson}\n\n$enableCompression = GetCompressionBoolean -CompressOutput $CompressOutput\n$maximumOutputBytes = GetMaximumOutputBytes -AllowTruncatedOutput $AllowTruncatedOutput\n\nswitch ($Action) {\n    'GetFiles' {\n        $paginationProperty = 'CustomSort'\n        [scriptblock]$scriptblock = {\n            if ($Path -eq '/') {\n                Get-Partition | Select-Object -Property DriveLetter | Where-Object DriveLetter | ForEach-Object {\n                    [ordered]@{\n                        Name = $_.DriveLetter + \":\";\n                        Mode = '-'; Length = '-';\n                        LastWriteTimeUTC = '-'\n                    };\n                }\n            } else {\n                $properties = @(\n                    'Name'\n                    'Mode'\n                    'Length'\n                    'LastWriteTimeUTC'\n                    @{\n                        Name=$paginationProperty\n                        Expression={if ($_.PSIsContainer) {\"d_$($_.Name)\"} else {\"f_$($_.Name)\"}}\n                    }\n                )\n                # When Mode is 'd--hsl', the file is \"Hidden\", \"System\" and a \"ReparsePoint\". These files\n                # cannot be browsed using PowerShell or Windows Explorer. They are being excluded from the output.\n                $firstFilter = {$_.Mode -ne 'd--hsl' -or ($_.CustomSort -gt $NextToken -and $_.Mode -ne 'd--hsl')}\n\n                $pathsToRemove = @('^\\w:\\\\\\$Recycle\\.Bin')\n                $secondFilter = {$_.FullName -notmatch $pathsToRemove}\n                Get-ChildItem -Path $resolvedPath -Force | Where-Object $firstFilter | Where-Object $secondFilter | Select-Object $properties\n            }\n        }\n\n        $processItems = @{\n            ScriptBlock              = $scriptblock\n            ConvertNextTokenToBase64 = $true\n            ChunksPerLoop            = 10\n            EnableCompression        = $enableCompression\n            MaximumOutputBytes       = $maximumOutputBytes\n            PaginationProperty       = $paginationProperty\n            PropertyToRemove         = $paginationProperty\n            NextToken                = $NextToken\n            SetNextTokenBeforeAdding = $true\n            StringReplacementRegex   = @('\\\"\\\\\\/Date\\((\\d+)\\)\\\\\\/\\\"', '\"$1\"')\n        }\n    }\n}\n\nProcessItems @processItems\n"
        ]
      }
    },
    {
      "precondition": {
        "StringEquals": [
          "platformType",
          "Linux"
        ]
      },
      "action": "aws:runShellScript",
      "name": "InvokeLinuxScript",
      "inputs": {
        "runCommand": [
          "#!/bin/bash\nset -e\n\nif [ -f /etc/os-release ]; then\n    . /etc/os-release\n    OS_RELEASE=\"$ID${VERSION_ID:+.${VERSION_ID}}\"\nelif [ -f /etc/centos-release ]; then\n    OS_RELEASE=\"centos.$(awk '{print $3}' /etc/centos-release)\"\nelif [ -f /etc/redhat-release ]; then\n    OS_RELEASE=\"rhel.$(lsb_release -r | awk '{print $2}')\"\nfi\n\ncase \"$OS_RELEASE\" in\n    amzn.2|centos.7*|centos.8*|fedora.*|rhel.7*|rhel.8*|sles*|ubuntu.20*)\n        command_path='/usr/bin/'\n        ;;\n    amzn.2018.03|centos.6*|debian.*|rhel.6*|ubuntu.16*|ubuntu.18*)\n        command_path='/bin/'\n        ;;\n    *)\n        # Catch all without the full path for untested platforms\n        command_path=''\nesac\n\nExitWithFailureMessage() {\n    MESSAGE=\"$1\"\n    JSON=\"$2\"\n    if [[ \"$JSON\" == \"PRINT_JSON\" ]]; then\n        \"${command_path}echo\" \"{\\\"error\\\":\\\"$MESSAGE\\\"}\"\n    fi\n    WriteStandardError \"$MESSAGE\"\n    exit 1\n}\n\nExitWithSuccessMessage() {\n    \"${command_path}echo\" \"$1\"\n    exit 0\n}\n\nWriteStandardError() {\n    MESSAGE=\"$1\"\n    (>&2 \"${command_path}echo\" \"$MESSAGE\")\n}\n\nJQ=\"jq\"\nVERSION=\"1.6\"\nPRODUCT_PATH=\"/opt/amazon/ssm/fleet_manager\"\nJQ_BINARY=\"$PRODUCT_PATH/$JQ-$VERSION\"\n\nCheckSha256FileHash() {\n    FILE_PATH=\"$1\"\n    SHA256=\"$2\"\n\n    if [ -f \"$FILE_PATH\" ]; then\n        TEST=$(\"${command_path}echo\" \"$SHA256  $FILE_PATH\" | /usr/bin/sha256sum -c 2>&1) || return 1\n        return 0\n    fi\n\n    return 1\n}\n\nSetLockedDownPermissions() {\n    \"${command_path}chmod\" u+rwx \"$1\"\n    \"${command_path}chmod\" go-rwx \"$1\"\n    \"${command_path}chown\" \"$(/usr/bin/whoami)\":\"$(/usr/bin/id --group --name)\" \"$1\"\n}\n\nCreateLockedDownFolder() {\n    \"${command_path}mkdir\" -p \"$1\"\n    SetLockedDownPermissions \"$1\"\n}\n\nDownloadFile() {\n    SOURCE=\"$1\"\n    DESTINATION=\"$2\"\n    if [ -f /usr/bin/curl ]; then\n        /usr/bin/curl -s \"$SOURCE\" -o \"$DESTINATION\"\n    elif [ -f /usr/bin/wget ]; then\n        /usr/bin/wget -q \"$SOURCE\" -O \"$DESTINATION\"\n    else\n        ExitWithFailureMessage \"Unable to download the source using 'curl' or 'wget'. Failing execution.\" 'PRINT_JSON'\n    fi\n}\n\nIfRunningKernelVersion2() {\n    \"${command_path}uname\" -r | grep -q '^2\\.' || return 1\n}\n\nGetJQSHA256Hash() {\n    case \"$1\" in\n        'aarch64')\n            \"${command_path}echo\" \"a6e84e979b91b26763c700d4ba6c616554444bbbf0cf1863e96611b0e68b88f2\"\n            ;;\n        'armv6l')\n            \"${command_path}echo\" \"4717f1350a963e5ae5446e61eb21e3936754f84dd13586d494dcd6b497b267c1\"\n            ;;\n        'armv7l')\n            \"${command_path}echo\" \"e097be6c7ef954d581a359ad2d7aa4ec19c89bd3b9ab55919c826a1d30373a5c\"\n            ;;\n        'i686')\n            \"${command_path}echo\" \"062902c5a177cb80866d556a07e10331d9f8b8b676ffb1b7cd2985a9c2e539c8\"\n            ;;\n        'x86_64')\n            \"${command_path}echo\" \"15d1d1b093481c737603247a785731b7f32f3b4dccd63f77186de8bfe4f6fd68\"\n            ;;\n        'x86_64_kernel2')\n            \"${command_path}echo\" \"af986793a515d500ab2d35f8d2aecd656e764504b789b66d7e1a0b727a124c44\"\n            ;;\n        *)\n            ExitWithFailureMessage \"The CPU architecture '$1' is not supported. Failing execution.\" 'PRINT_JSON'\n            ;;\n    esac\n}\n\nRandomString() {\n    \"${command_path}cat\" /dev/urandom | /usr/bin/tr -dc 'a-zA-Z0-9' | /usr/bin/fold -w ${1:-32} | /usr/bin/head -n 1\n}\n\nInstallJQ() {\n    CreateLockedDownFolder \"$PRODUCT_PATH\"\n\n    CPU_ARCH=$(\"${command_path}uname\" -m)\n    IfRunningKernelVersion2 && CPU_ARCH=\"${CPU_ARCH}_kernel2\"\n    JQ_SHA256=$(GetJQSHA256Hash \"$CPU_ARCH\")\n\n    CheckSha256FileHash \"$JQ_BINARY\" \"$JQ_SHA256\" || {\n        JQ_TEMP_BINARY=\"$PRODUCT_PATH/$(RandomString)\"\n\n        OS_NAME=$(\"${command_path}uname\" -s)\n        REGION=\"us-east-1\"\n        S3_BUCKET=\"aws-fleet-manager-artifacts-us-east-1\"\n        S3_DNS=\"s3.us-east-1.amazonaws.com\"\n        SOURCE=\"https://$S3_BUCKET.$S3_DNS/$JQ/$VERSION/$OS_NAME/$CPU_ARCH/$JQ\"\n        DownloadFile \"$SOURCE\" \"$JQ_TEMP_BINARY\"\n\n        CheckSha256FileHash \"$JQ_TEMP_BINARY\" \"$JQ_SHA256\" || {\n            \"${command_path}rm\" --force \"$JQ_TEMP_BINARY\"\n            ExitWithFailureMessage \"Downloading the $JQ binary failed. Failing execution.\"\n        }\n\n        \"${command_path}mv\" \"$JQ_TEMP_BINARY\" \"$JQ_BINARY\"\n    }\n\n    SetLockedDownPermissions \"$JQ_BINARY\"\n}\n\nInstallJQ\n\nConvertBase64ToString() {\n    \"${command_path}echo\" \"$1\" | /usr/bin/base64 --decode\n}\n\nConvertStringToBase64() {\n    \"${command_path}echo\" \"$1\" | /usr/bin/base64 --wrap=0\n}\n\nGetBase64EncodedGzipString() {\n    \"${command_path}echo\" \"$1\" | \"${command_path}gzip\" -f --best | /usr/bin/base64 --wrap=0\n}\n\nGetResultAsString() {\n    TempString=\"$1\"\n    ItemCount=\"$2\"\n    OutputTooBig=\"$3\"\n    EnableCompression=\"$4\"\n    ForceEmptyNextToken=\"$5\"\n    ConvertToBase64=\"$6\"\n\n    nextToken='\"\"'\n    if [ \"$OutputTooBig\" == \"0\" ] && [ \"$ItemCount\" -ge 1 ] && [ \"$ForceEmptyNextToken\" != \"Yes\" ]; then\n        nextToken=$(\"${command_path}echo\" \"$TempString\" | \"$JQ_BINARY\" '.[-1].Name' | \"$JQ_BINARY\" -r .)\n    fi\n\n    if [ \"$ConvertToBase64\" == \"CONVERT_NEXT_TOKEN_TO_BASE64\" ] && [ \"$nextToken\" != '\"\"' ]; then\n        nextToken=\"\\\"$(\"${command_path}echo\" \"$nextToken\" | /usr/bin/base64 --wrap=0)\\\"\"\n    fi\n\n    data=$(\"${command_path}echo\" [\"$nextToken\", \"$TempString\"] | \"$JQ_BINARY\" -c '{nextToken: .[0], results: .[1]}')\n\n    if [ \"$EnableCompression\" == \"Yes\" ]; then\n        compressed=$(GetBase64EncodedGzipString \"$data\")\n        \"$JQ_BINARY\" -n -c \"{data:\\\"$compressed\\\"}\"\n    else\n        \"${command_path}echo\" \"$data\" | \"$JQ_BINARY\" -c '{data: .}'\n    fi\n}\n\nGetMaximumOutputBytes() {\n    AllowTruncatedOutput=\"$1\"\n    MAXIMUM_OUTPUT_SIZE=2500\n\n    if [[ \"$AllowTruncatedOutput\" == 'Yes' ]]; then\n        \"${command_path}echo\" 0\n    else\n        padding=$(\"${command_path}echo\" '{\"data\":{\"nextToken\":\"\",\"results\":\"\"}}' | /usr/bin/awk '{print length}')\n        \"${command_path}echo\" \"$((MAXIMUM_OUTPUT_SIZE-padding))\"\n    fi\n}\n\nProcessItems() {\n    ITEMS=\"$1\"\n    CONVERT_TO_BASE64=\"$2\"\n\n    declare -a chunkedArray\n\n    counter=0\n    chunksPerLoop=5\n    outputTooBig=0\n\n    OIFS=\"$IFS\"\n    IFS=$'\\n'\n    for item in $(\"${command_path}echo\" \"$ITEMS\" | \"$JQ_BINARY\" -c '.[]'); do\n        if [[ \"$outputTooBig\" == 1 ]]; then\n            break\n        fi\n\n        chunkedArray+=(\"$item\")\n\n        if [ \"$counter\" -lt \"$chunksPerLoop\" ]; then\n            counter=$((counter+1))\n            continue\n        fi\n\n        counter=0\n\n        tempString=$(\"${command_path}echo\" \"${chunkedArray[@]}\" | \"$JQ_BINARY\" -c --slurp .)\n        arrayLength=$(\"${command_path}echo\" \"$tempString\" | \"$JQ_BINARY\" '. | length')\n        tempContent=$(GetResultAsString \"$tempString\" \"$arrayLength\" \"$outputTooBig\" \"$CompressOutput\" 'No' \"$CONVERT_TO_BASE64\")\n\n        tempContentLength=$(\"${command_path}echo\" \"$tempContent\" | /usr/bin/awk '{print length}')\n        if [ \"$MaximumOutputBytes\" -eq 0 ] || [ \"$tempContentLength\" -le \"$MaximumOutputBytes\" ]; then\n            outputContent=$tempContent\n        else\n            outputTooBig=1\n        fi\n    done\n    IFS=\"$OIFS\"\n\n    # If the output is not too large, processing any remaining items\n    if [ $outputTooBig -eq 0 ]; then\n        tempString=$(\"${command_path}echo\" \"${chunkedArray[@]}\" | \"$JQ_BINARY\" -c --slurp .)\n        arrayLength=$(\"${command_path}echo\" \"$tempString\" | \"$JQ_BINARY\" '. | length')\n        tempContent=$(GetResultAsString \"$tempString\" \"$arrayLength\" \"$outputTooBig\" \"$CompressOutput\" 'Yes' \"$CONVERT_TO_BASE64\")\n\n        tempContentLength=$(\"${command_path}echo\" \"$tempContent\" | /usr/bin/awk '{print length}')\n        if [ \"$MaximumOutputBytes\" -eq 0 ] || [ \"$tempContentLength\" -le \"$MaximumOutputBytes\" ]; then\n            outputContent=\"$tempContent\"\n        fi\n    fi\n\n    \"${command_path}echo\" \"$outputContent\"\n}\n\nAction='{{ Action }}'\nFilePath='{{ Path }}'\nNextToken='{{ NextToken }}'\nAllowTruncatedOutput='{{ AllowTruncatedOutput }}'\nCompressOutput='{{ CompressOutput }}'\n\nMaximumOutputBytes=$(GetMaximumOutputBytes \"$AllowTruncatedOutput\")\n\nbase64Regex='^(?!\\/)([A-Za-z0-9-_\\/+]{4})*([A-Za-z0-9-_\\/+]{4}|[A-Za-z0-9-_\\/+]{3}=|[A-Za-z0-9-_\\/+]{2}==)$'\nif [ $(\"${command_path}echo\" \"$FilePath\" | \"${command_path}grep\" -P \"$base64Regex\") ]; then\n    FilePath=$(ConvertBase64ToString \"$FilePath\")\nfi\n\nif [ \"$Action\" == \"GetFiles\" ]; then\n    # Ensure the Path input is valid for this action.\n    PATH_PARAMETER_REGEX='\\/$'\n    if [[ $(\"${command_path}echo\" \"$FilePath\" | \"${command_path}grep\" -v \"$PATH_PARAMETER_REGEX\") ]]; then\n        FilePath=\"$FilePath/\"\n    fi\n\n    if [ ! -d \"$FilePath\" ]; then\n        ExitWithFailureMessage 'The specified path is invalid.'\n    fi\n\n    if [[ \"$NextToken\" == \"*\" ]]; then\n        ITEMS=$(/usr/bin/stat --dereference --format '{\"Name\":\"%n\",\"Length\":\"%s\",\"User\":\"%U\",\"Group\":\"%G\",\"Mode\":\"%A\",\"LastWriteTimeUTC\":\"%Y\"}' \"$FilePath\"* | \"$JQ_BINARY\" -c '.Name=(.Name | split(\"/\")[-1]) | .LastWriteTimeUTC=(.LastWriteTimeUTC + \"000\")' | \"$JQ_BINARY\" -c --slurp .)\n    else\n        PaginationFilePath=\"$FilePath$(ConvertBase64ToString \"$NextToken\")\"\n        ITEMS=$(/usr/bin/stat --dereference --format '{\"Name\":\"%n\",\"Length\":\"%s\",\"User\":\"%U\",\"Group\":\"%G\",\"Mode\":\"%A\",\"LastWriteTimeUTC\":\"%Y\"}' \"$FilePath\"* | \"$JQ_BINARY\" --arg PaginationFilePath \"$PaginationFilePath\" -c 'select(.Name>$PaginationFilePath) | .Name=(.Name | split(\"/\")[-1]) | .LastWriteTimeUTC=(.LastWriteTimeUTC + \"000\")' | \"$JQ_BINARY\" -c --slurp .)\n    fi\nfi\n\nProcessItems \"$ITEMS\" \"CONVERT_NEXT_TOKEN_TO_BASE64\"\n"
        ]
      }
    },
    {
      "precondition": {
        "StringEquals": [
          "platformType",
          "MacOS"
        ]
      },
      "action": "aws:runShellScript",
      "name": "InvokeMacOSScript",
      "inputs": {
        "runCommand": [
          "#!/bin/bash\nset -e\n\nExitWithFailureMessage() {\n    MESSAGE=\"$1\"\n    JSON=\"$2\"\n    if [[ \"$JSON\" == \"PRINT_JSON\" ]]; then\n        /bin/echo \"{\\\"error\\\":\\\"$MESSAGE\\\"}\"\n    fi\n    WriteStandardError \"$MESSAGE\"\n    exit 1\n}\n\nExitWithSuccessMessage() {\n    /bin/echo \"$1\"\n    exit 0\n}\n\nWriteStandardError() {\n    MESSAGE=\"$1\"\n    (>&2 /bin/echo \"$MESSAGE\")\n}\n\nJQ=\"jq\"\nVERSION=\"1.6\"\nPRODUCT_PATH=\"/opt/amazon/ssm/fleet_manager\"\nJQ_BINARY=\"$PRODUCT_PATH/$JQ-$VERSION\"\n\nCheckSha256FileHash() {\n    FILE_PATH=\"$1\"\n    SHA256=\"$2\"\n\n    if [ -f \"$FILE_PATH\" ]; then\n        TEST=$(/bin/echo \"$SHA256  $FILE_PATH\" | /usr/bin/shasum -c 2>&1) || return 1\n        return 0\n    fi\n\n    return 1\n}\n\nSetLockedDownPermissions() {\n    /bin/chmod u+rwx \"$1\"\n    /bin/chmod go-rwx \"$1\"\n    /usr/sbin/chown \"$(/usr/bin/whoami)\":\"$(/usr/bin/id -g -nr)\" \"$1\"\n}\n\nCreateLockedDownFolder() {\n    /bin/mkdir -p \"$1\"\n    SetLockedDownPermissions \"$1\"\n}\n\nDownloadFile() {\n    SOURCE=\"$1\"\n    DESTINATION=\"$2\"\n    /usr/bin/curl -s \"$SOURCE\" -o \"$DESTINATION\"\n}\n\nGetJQSHA256Hash() {\n    case \"$1\" in\n        'x86_64')\n            /bin/echo \"5c0a0a3ea600f302ee458b30317425dd9632d1ad8882259fcaf4e9b868b2b1ef\"\n            ;;\n        *)\n            ExitWithFailureMessage \"The CPU architecture '$1' is not supported. Failing execution.\" 'PRINT_JSON'\n            ;;\n    esac\n}\n\nRandomString() {\n    /usr/bin/openssl rand -base64 6\n}\n\nInstallJQ() {\n    CreateLockedDownFolder \"$PRODUCT_PATH\"\n\n    CPU_ARCH=$(/usr/bin/uname -m)\n    JQ_SHA256=$(GetJQSHA256Hash \"$CPU_ARCH\")\n\n    CheckSha256FileHash \"$JQ_BINARY\" \"$JQ_SHA256\" || {\n        JQ_TEMP_BINARY=\"$PRODUCT_PATH/$(RandomString)\"\n\n        OS_NAME=$(/usr/bin/uname -s)\n        REGION=\"us-east-1\"\n        S3_BUCKET=\"aws-fleet-manager-artifacts-us-east-1\"\n        S3_DNS=\"s3.us-east-1.amazonaws.com\"\n        SOURCE=\"https://$S3_BUCKET.$S3_DNS/$JQ/$VERSION/$OS_NAME/$CPU_ARCH/$JQ\"\n        DownloadFile \"$SOURCE\" \"$JQ_TEMP_BINARY\"\n\n        CheckSha256FileHash \"$JQ_TEMP_BINARY\" \"$JQ_SHA256\" || {\n            /bin/rm -f \"$JQ_TEMP_BINARY\"\n            ExitWithFailureMessage \"Downloading the $JQ binary failed. Failing execution.\"\n        }\n\n        /bin/mv \"$JQ_TEMP_BINARY\" \"$JQ_BINARY\"\n    }\n\n    SetLockedDownPermissions \"$JQ_BINARY\"\n}\n\nInstallJQ\n\nConvertBase64ToString() {\n    /bin/echo \"$1\" | /usr/bin/base64 --decode\n}\n\nConvertStringToBase64() {\n    /bin/echo \"$1\" | /usr/bin/base64\n}\n\nGetBase64EncodedGzipString() {\n    /bin/echo \"$1\" | /usr/bin/gzip -f --best | /usr/bin/base64\n}\n\nGetResultAsString() {\n    TempString=\"$1\"\n    ItemCount=\"$2\"\n    OutputTooBig=\"$3\"\n    EnableCompression=\"$4\"\n    ForceEmptyNextToken=\"$5\"\n    ConvertToBase64=\"$6\"\n\n    nextToken='\"\"'\n    if [ \"$OutputTooBig\" == \"0\" ] && [ \"$ItemCount\" -ge 1 ] && [ \"$ForceEmptyNextToken\" != \"Yes\" ]; then\n        nextToken=$(/bin/echo \"$TempString\" | \"$JQ_BINARY\" '.[-1].Name' | \"$JQ_BINARY\" -r .)\n    fi\n\n    if [ \"$ConvertToBase64\" == \"CONVERT_NEXT_TOKEN_TO_BASE64\" ] && [ \"$nextToken\" != '\"\"' ]; then\n        nextToken=\"\\\"$(/bin/echo \"$nextToken\" | /usr/bin/base64)\\\"\"\n    fi\n\n    data=$(/bin/echo [\"$nextToken\", \"$TempString\"] | \"$JQ_BINARY\" -c '{nextToken: .[0], results: .[1]}')\n\n    if [ \"$EnableCompression\" == \"Yes\" ]; then\n        compressed=$(GetBase64EncodedGzipString \"$data\")\n        \"$JQ_BINARY\" -n -c \"{data:\\\"$compressed\\\"}\"\n    else\n        /bin/echo \"$data\" | \"$JQ_BINARY\" -c '{data: .}'\n    fi\n}\n\nGetMaximumOutputBytes() {\n    AllowTruncatedOutput=\"$1\"\n    MAXIMUM_OUTPUT_SIZE=2500\n\n    if [[ \"$AllowTruncatedOutput\" == 'Yes' ]]; then\n        /bin/echo 0\n    else\n        padding=$(/bin/echo '{\"data\":{\"nextToken\":\"\",\"results\":\"\"}}' | /usr/bin/awk '{print length}')\n        /bin/echo \"$((MAXIMUM_OUTPUT_SIZE-padding))\"\n    fi\n}\n\nProcessItems() {\n    ITEMS=\"$1\"\n    CONVERT_TO_BASE64=\"$2\"\n\n    declare -a chunkedArray\n\n    counter=0\n    chunksPerLoop=5\n    outputTooBig=0\n\n    OIFS=\"$IFS\"\n    IFS=$'\\n'\n    for item in $(/bin/echo \"$ITEMS\" | \"$JQ_BINARY\" -c '.[]'); do\n        if [[ \"$outputTooBig\" == 1 ]]; then\n            break\n        fi\n\n        chunkedArray+=(\"$item\")\n\n        if [ \"$counter\" -lt \"$chunksPerLoop\" ]; then\n            counter=$((counter+1))\n            continue\n        fi\n\n        counter=0\n\n        tempString=$(/bin/echo \"${chunkedArray[@]}\" | \"$JQ_BINARY\" -c --slurp .)\n        arrayLength=$(/bin/echo \"$tempString\" | \"$JQ_BINARY\" '. | length')\n        tempContent=$(GetResultAsString \"$tempString\" \"$arrayLength\" \"$outputTooBig\" \"$CompressOutput\" 'No' \"$CONVERT_TO_BASE64\")\n\n        tempContentLength=$(/bin/echo \"$tempContent\" | /usr/bin/awk '{print length}')\n        if [ \"$MaximumOutputBytes\" -eq 0 ] || [ \"$tempContentLength\" -le \"$MaximumOutputBytes\" ]; then\n            outputContent=\"$tempContent\"\n        else\n            outputTooBig=1\n        fi\n    done\n    IFS=\"$OIFS\"\n\n    # If the output is not too large, processing any remaining items\n    if [ \"$outputTooBig\" -eq \"0\" ]; then\n        tempString=$(/bin/echo \"${chunkedArray[@]}\" | \"$JQ_BINARY\" -c --slurp .)\n        arrayLength=$(/bin/echo \"$tempString\" | \"$JQ_BINARY\" '. | length')\n        tempContent=$(GetResultAsString \"$tempString\" \"$arrayLength\" \"$outputTooBig\" \"$CompressOutput\" 'Yes' \"$CONVERT_TO_BASE64\")\n\n        tempContentLength=$(/bin/echo \"$tempContent\" | /usr/bin/awk '{print length}')\n        if [ \"$MaximumOutputBytes\" -eq 0 ] || [ \"$tempContentLength\" -le \"$MaximumOutputBytes\" ]; then\n            outputContent=\"$tempContent\"\n        fi\n    fi\n\n    /bin/echo \"$outputContent\"\n}\n\nAction='{{ Action }}'\nFilePath='{{ Path }}'\nNextToken='{{ NextToken }}'\nAllowTruncatedOutput='{{ AllowTruncatedOutput }}'\nCompressOutput='{{ CompressOutput }}'\n\nMaximumOutputBytes=$(GetMaximumOutputBytes \"$AllowTruncatedOutput\")\n\nbase64Regex='^(?!\\/)([A-Za-z0-9-_\\/+]{4})*([A-Za-z0-9-_\\/+]{4}|[A-Za-z0-9-_\\/+]{3}=|[A-Za-z0-9-_\\/+]{2}==)$'\nif [ $(/bin/echo \"$FilePath\" | /usr/bin/perl -ne \"print if /$base64Regex/\") ]; then\n    FilePath=$(ConvertBase64ToString \"$FilePath\")\nfi\n\nif [ \"$Action\" == \"GetFiles\" ]; then\n    # Ensure the Path input is valid for this action.\n    PATH_PARAMETER_REGEX='\\/$'\n    if [[ $(/bin/echo \"$FilePath\" | /usr/bin/grep -v \"$PATH_PARAMETER_REGEX\") ]]; then\n        FilePath=\"$FilePath/\"\n    fi\n\n    if [ ! -d \"$FilePath\" ]; then\n        ExitWithFailureMessage 'The specified path is invalid.'\n    fi\n\n    if [[ \"$NextToken\" == \"*\" ]]; then\n        ITEMS=$(/usr/bin/stat -L -f '{\"Name\":\"%N\",\"Length\":\"%z\",\"User\":\"%Su\",\"Group\":\"%Sg\",\"Mode\":\"%Sp\",\"LastWriteTimeUTC\":\"%a\"}' \"$FilePath\"* | \"$JQ_BINARY\" -c '.Name=(.Name | split(\"/\")[-1]) | .LastWriteTimeUTC=(.LastWriteTimeUTC + \"000\")' | \"$JQ_BINARY\" -c --slurp .)\n    else\n        PaginationFilePath=\"$FilePath$(ConvertBase64ToString \"$NextToken\")\"\n        ITEMS=$(/usr/bin/stat -L -f '{\"Name\":\"%N\",\"Length\":\"%z\",\"User\":\"%Su\",\"Group\":\"%Sg\",\"Mode\":\"%Sp\",\"LastWriteTimeUTC\":\"%a\"}' \"$FilePath\"* | \"$JQ_BINARY\" --arg PaginationFilePath \"$PaginationFilePath\" -c 'select(.Name>$PaginationFilePath) | .Name=(.Name | split(\"/\")[-1]) | .LastWriteTimeUTC=(.LastWriteTimeUTC + \"000\")' | \"$JQ_BINARY\" -c --slurp .)\n    fi\nfi\n\nProcessItems \"$ITEMS\" \"CONVERT_NEXT_TOKEN_TO_BASE64\"\n"
        ]
      }
    }
  ]
}
