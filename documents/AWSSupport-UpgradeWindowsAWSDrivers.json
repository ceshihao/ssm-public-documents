{
  "schemaVersion": "0.3",
  "description": "The AWSSupport-UpgradeWindowsAWSDrivers upgrades or repairs storage and network AWS drivers on the specified EC2 instance. The document attempts to install the latest versions of AWS drivers online by calling the SSM agent. If the SSM agent is not contactable, the document can perform an offline installation of the AWS drivers if explicitly requested. Note: Both the online and offline upgrade will create an AMI before attempting any operations, which will persist after the automation completes. It is your responsibility to secure access to the AMI, or to delete it. The online method restarts the instance as part of the upgrade process, while the offline method requires the provided EC2 instance be stopped and then started.",
  "assumeRole": "{{ AutomationAssumeRole }}",
  "parameters": {
    "InstanceId": {
      "type": "String",
      "description": "(Required) ID of your EC2 Windows instance.",
      "allowedPattern": "^i-[a-z0-9]{8,17}$"
    },
    "AllowOffline": {
      "type": "String",
      "description": "(Optional) Set it to true if you allow an offline drivers upgrade in case the online installation cannot be performed. Note: The offline method requires the provided EC2 instance be stopped and then started. Data stored in instance store volumes will be lost. The public IP address will change if you are not using an Elastic IP.",
      "default": "False",
      "allowedValues": [
        "True",
        "False"
      ]
    },
    "SubnetId": {
      "type": "String",
      "description": "(Optional) Offline only - The subnet ID for the EC2Rescue instance used to perform the offline drivers upgrade. If you specify CreateNewVPC, AWS Systems Manager Automation will create a new VPC. IMPORTANT: The subnet must be in the same Availability Zone as InstanceId, and it must allow access to the SSM endpoints.",
      "default": "SelectedInstanceSubnet",
      "allowedPattern": "^SelectedInstanceSubnet$|^CreateNewVPC$|^subnet-[a-z0-9]{8,17}$"
    },
    "ForceUpgrade": {
      "type": "String",
      "description": "(Optional) Offline only - Set it to true if you allow the offline drivers upgrade to proceed even though your instance already has the latest drivers installed.",
      "default": "False",
      "allowedValues": [
        "True",
        "False"
      ]
    },
    "AutomationAssumeRole": {
      "type": "String",
      "description": "(Optional) The ARN of the role that allows Automation to perform the actions on your behalf. If no role is specified, Systems Manager Automation uses your IAM permissions to execute this document.",
      "default": ""
    }
  },
  "mainSteps": [
    {
      "name": "assertInstanceIsWindows",
      "action": "aws:assertAwsResourceProperty",
      "onFailure": "Abort",
      "inputs": {
        "Service": "ec2",
        "Api": "DescribeInstances",
        "InstanceIds": [
          "{{ InstanceId }}"
        ],
        "PropertySelector": "$.Reservations[0].Instances[0].Platform",
        "DesiredValues": [
          "windows"
        ]
      },
      "isCritical": "true",
      "nextStep": "describeManagedInstance"
    },
    {
      "name": "describeManagedInstance",
      "action": "aws:executeAwsApi",
      "onFailure": "Abort",
      "inputs": {
        "Service": "ssm",
        "Api": "DescribeInstanceInformation",
        "InstanceInformationFilterList": [
          {
            "key": "InstanceIds",
            "valueSet": [
              "{{ InstanceId }}"
            ]
          }
        ]
      },
      "outputs": [
        {
          "Name": "PingStatus",
          "Selector": "$.InstanceInformationList[0].PingStatus"
        }
      ],
      "isCritical": "true",
      "nextStep": "branchOnManagedInstancePingStatus"
    },
    {
      "name": "branchOnManagedInstancePingStatus",
      "action": "aws:branch",
      "onFailure": "Abort",
      "inputs": {
        "Choices": [
          {
            "NextStep": "preUpgradeBackup",
            "Variable": "{{ describeManagedInstance.PingStatus }}",
            "StringEquals": "Online"
          }
        ],
        "Default": "assertAllowOffline"
      },
      "isCritical": "true"
    },
    {
      "name": "preUpgradeBackup",
      "action": "aws:executeAwsApi",
      "onFailure": "Abort",
      "inputs": {
        "Service": "ec2",
        "Api": "CreateImage",
        "InstanceId": "{{ InstanceId }}",
        "Description": "Pre-Upgrade Backup AMI Generated by Automation on {{ global:DATE_TIME }} from {{ InstanceId }}.",
        "NoReboot": false,
        "Name": "AWSSupport-Pre-Upgrade-Backup_{{ InstanceId }}_{{ global:DATE_TIME }}"
      },
      "outputs": [
        {
          "Name": "ImageId",
          "Selector": "$.ImageId",
          "Type": "String"
        }
      ],
      "isCritical": "true",
      "nextStep": "tagPreUpgradeBackup"
    },
    {
      "name": "tagPreUpgradeBackup",
      "action": "aws:createTags",
      "onFailure": "Continue",
      "inputs": {
        "ResourceIds": [
          "{{ preUpgradeBackup.ImageId }}"
        ],
        "Tags": [
          {
            "Key": "Name",
            "Value": "AWSSupport-UpgradeWindowsAWSDrivers: {{ InstanceId }}"
          },
          {
            "Key": "AWSSupport-UpgradeWindowsAWSDrivers-AutomationExecution",
            "Value": "{{ automation:EXECUTION_ID }}"
          }
        ],
        "ResourceType": "EC2"
      },
      "isCritical": "false",
      "nextStep": "assertpreUpgradeBackup"
    },
    {
      "name": "assertpreUpgradeBackup",
      "action": "aws:waitForAwsResourceProperty",
      "onFailure": "Abort",
      "inputs": {
        "Service": "ec2",
        "Api": "DescribeImages",
        "Filters": [
          {
            "Name": "image-id",
            "Values": [
              "{{preUpgradeBackup.ImageId}}"
            ]
          }
        ],
        "PropertySelector": "$.Images[0].State",
        "DesiredValues": [
          "available"
        ]
      },
      "isCritical": "true",
      "nextStep": "installAwsEnaNetworkDriverOnInstance"
    },
    {
      "name": "installAwsEnaNetworkDriverOnInstance",
      "action": "aws:runCommand",
      "onFailure": "Continue",
      "inputs": {
        "DocumentName": "AWS-RunPowerShellScript",
        "InstanceIds": [
          "{{ InstanceId }}"
        ],
        "Parameters": {
          "commands": [
            "try {",
            "    if (Test-Path -Path \"ena-state-{{ automation:EXECUTION_ID }}\") {",
            "        if (Select-String -Path \"ena-state-{{ automation:EXECUTION_ID }}\" -Pattern \"success\") {",
            "            Write-Host \"Installer has already run. Skipping installation\"",
            "            exit 0",
            "        }",
            "        else {",
            "            Write-Host \"Previous run of installer marked as failure. Skipping installation\"",
            "            exit 1",
            "        }",
            "    }",
            "    else {",
            "        # Download drivers",
            "        $url = \"https://s3.amazonaws.com/ec2-windows-drivers-downloads/ENA/Latest/AwsEnaNetworkDriver.zip\"",
            "        $tempPath = (Resolve-Path ${env:temp}).Path",
            "        Write-Host \"Downloading AWS ENA drivers\"",
            "        $tempFile = \"${tempPath}\\AwsEnaNetworkDriver.zip\"",
            "        $tempDir = \"${tempPath}\\AwsEnaNetworkDriver\"",
            "        $wc = New-Object \"System.Net.WebClient\"",
            "        $wc.Headers.Add(\"user-agent\", \"AWSSupport-UpgradeWindowsAWSDrivers\")",
            "        $wc.DownloadFile($url, $tempFile)",
            "        if (Test-Path $tempDir) {",
            "            Remove-Item -Path $tempDir -Recurse -Force",
            "        }",
            "",
            "        # Extract drivers",
            "        try {",
            "            # Unpacking the file this way is not supported in PowerShell 2",
            "            Add-Type -AssemblyName System.IO.Compression.FileSystem -ErrorAction SilentlyContinue",
            "            [System.IO.Compression.ZipFile]::ExtractToDirectory($tempFile, $tempDir)",
            "        }",
            "        catch [System.InvalidOperationException] {",
            "            # Legacy unpacking method using COM Object",
            "            # Works with PowerShell 2",
            "            New-Item -Path $tempDir -ItemType \"directory\" -Force | Out-Null",
            "            ((New-Object -com shell.application).NameSpace($tempDir)).CopyHere(((New-Object -com shell.application).NameSpace($tempFile)).Items())",
            "        }",
            "",
            "        # Run install.ps1",
            "        Write-Host \"Running install script\"",
            "        $output = & \"${tempDir}\\install.ps1\" -NoReboot",
            "        Write-Host $output",
            "",
            "        # Evaluate output",
            "        New-Item \"ena-state-{{ automation:EXECUTION_ID }}\" -ItemType file | Out-Null",
            "        if ($output -match \"successful\") {",
            "            if ($output -match \"reboot\") {",
            "                Write-Host \"Rebooting to complete installation\"",
            "                Write-Output \"success\" | Set-Content -Path \"ena-state-{{ automation:EXECUTION_ID }}\"",
            "                exit 3010",
            "            }",
            "            Write-Output \"success\" | Set-Content -Path \"ena-state-{{ automation:EXECUTION_ID }}\"",
            "            exit 0",
            "        }",
            "        else {",
            "            Write-Output \"failure\" | Set-Content -Path \"ena-state-{{ automation:EXECUTION_ID }}\"",
            "            exit 1",
            "        }",
            "    }",
            "}",
            "catch {",
            "    Write-Host $_.Exception.Message",
            "    exit 255",
            "}"
          ]
        }
      },
      "isCritical": "true",
      "nextStep": "installAWSNVMeOnInstance"
    },
    {
      "name": "installAWSNVMeOnInstance",
      "action": "aws:runCommand",
      "onFailure": "Continue",
      "inputs": {
        "DocumentName": "AWS-RunPowerShellScript",
        "InstanceIds": [
          "{{ InstanceId }}"
        ],
        "Parameters": {
          "commands": [
            "try {",
            "    if (Test-Path -Path \"nvme-state-{{ automation:EXECUTION_ID }}\") {",
            "        if (Select-String -Path \"nvme-state-{{ automation:EXECUTION_ID }}\" -Pattern \"success\") {",
            "            Write-Host \"Installer has already run. Skipping installation\"",
            "            exit 0",
            "        }",
            "        else {",
            "            Write-Host \"Previous run of installer marked as failure. Skipping installation\"",
            "            exit 1",
            "        }",
            "    }",
            "    else {",
            "        # Download drivers",
            "        $url = \"https://s3.amazonaws.com/ec2-windows-drivers-downloads/NVMe/Latest/AWSNVMe.zip\"",
            "        $tempPath = (Resolve-Path ${env:temp}).Path",
            "        Write-Host \"Downloading AWS NVMe drivers\"",
            "        $tempFile = \"${tempPath}\\AWSNVMe.zip\"",
            "        $tempDir = \"${tempPath}\\AWSNVMe\"",
            "        $wc = New-Object \"System.Net.WebClient\"",
            "        $wc.Headers.Add(\"user-agent\", \"AWSSupport-UpgradeWindowsAWSDrivers\")",
            "        $wc.DownloadFile($url, $tempFile)",
            "        if (Test-Path $tempDir) {",
            "            Remove-Item -Path $tempDir -Recurse -Force",
            "        }",
            "",
            "        # Extract drivers",
            "        try {",
            "            # Unpacking the file this way is not supported in PowerShell 2",
            "            Add-Type -AssemblyName System.IO.Compression.FileSystem -ErrorAction SilentlyContinue",
            "            [System.IO.Compression.ZipFile]::ExtractToDirectory($tempFile, $tempDir)",
            "        }",
            "        catch [System.InvalidOperationException] {",
            "            # Legacy unpacking method using COM Object",
            "            # Works with PowerShell 2",
            "            New-Item -Path $tempDir -ItemType \"directory\" -Force | Out-Null",
            "            ((New-Object -com shell.application).NameSpace($tempDir)).CopyHere(((New-Object -com shell.application).NameSpace($tempFile)).Items())",
            "        }",
            "",
            "        # Run install.ps1",
            "        Write-Host \"Running install script\"",
            "        $output = & \"${tempDir}\\install.ps1\" -NoReboot",
            "        Write-Host $output",
            "",
            "        # Handling drivers reflection: https://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/migrating-latest-types.html#upgrade-nvme",
            "        # Driver reflection is required only for Windows Server 2008 R2 and Windows Server 2012 instances",
            "        $allowedWinVer = $false",
            "        $osVer = [System.Environment]::OSVersion.Version",
            "        if ($osVer.Major -eq 6) {",
            "            $allowedMinor = @(1, 2)",
            "            if ($allowedMinor -contains $osVer.Minor) {",
            "                $allowedWinVer = $true",
            "            }",
            "        }",
            "        if ($allowedWinVer) {",
            "            # Checking instance type architecture to ensure it is not a Nitro instance type",
            "            $allowedInstanceType = $false",
            "            $ErrorActionPreference = \"stop\"",
            "            try {",
            "                $systemVersion = (Get-ItemProperty -Path HKLM:\\HARDWARE\\DESCRIPTION\\System\\BIOS -Name SystemVersion).SystemVersion",
            "                $systemManufacturer = (Get-ItemProperty -Path HKLM:\\HARDWARE\\DESCRIPTION\\System\\BIOS -Name SystemManufacturer).SystemManufacturer",
            "            }",
            "            catch [System.Management.Automation.PSArgumentException] {}",
            "            finally { $ErrorActionPreference = \"Continue\" }",
            "            if (($systemVersion -match \"amazon\") -and ($systemManufacturer -match \"Xen\")) {",
            "                $allowedInstanceType = $true",
            "            }",
            "            if ($allowedInstanceType) {",
            "                Write-Host \"Reflecting Boot Critical drivers\"",
            "                Start-Process -PassThru -Wait -FilePath \"$env:systemroot\\System32\\rundll32.exe\" -ArgumentList \"sppnp.dll,Sysprep_Generalize_Pnp\" | Out-Null",
            "            }",
            "        }",
            "",
            "        # Evaluate output",
            "        [System.Int32]$retSuccess = 0",
            "        [System.Int32]$retSuccessRebootRequired = 3010",
            "        ",
            "        New-Item \"nvme-state-{{ automation:EXECUTION_ID }}\" -ItemType file | Out-Null",
            "",
            "        if ($output -eq $retSuccess) {",
            "            Write-Output \"success\" | Set-Content -Path \"nvme-state-{{ automation:EXECUTION_ID }}\"",
            "            exit 0",
            "        }",
            "        elseif ($output -eq $retSuccessRebootRequired) {",
            "            Write-Host \"Rebooting to complete installation\"",
            "            Write-Output \"success\" | Set-Content -Path \"nvme-state-{{ automation:EXECUTION_ID }}\"",
            "            exit 3010",
            "        }",
            "        else {",
            "            Write-Output \"failure\" | Set-Content -Path \"nvme-state-{{ automation:EXECUTION_ID }}\"",
            "            exit 1",
            "        }",
            "    }",
            "}",
            "catch {",
            "    Write-Host $_.Exception.Message",
            "    exit 255",
            "}"
          ]
        }
      },
      "isCritical": "true",
      "nextStep": "installAWSPVDriverOnInstance"
    },
    {
      "name": "installAWSPVDriverOnInstance",
      "action": "aws:runCommand",
      "onFailure": "Abort",
      "inputs": {
        "DocumentName": "AWS-RunPowerShellScript",
        "InstanceIds": [
          "{{ InstanceId }}"
        ],
        "Parameters": {
          "commands": [
            "#region Functions",
            "function Uninstall-RedHatPV {",
            "    # Forcibly remove RedHat PV Drivers as the AWS PV installer does not do so",
            "    $driverFileSearchList = @(",
            "        'rhelhidden',",
            "        'rhelfltr',",
            "        'rhelnet',",
            "        'rhelscsi')",
            "    $infFiles = Get-Item (Join-Path $env:SystemRoot \"\\inf\\oem*.inf\")",
            "    foreach ($infFile in $infFiles) {",
            "        if ($infFile.Length -gt 0) {",
            "            $content = Get-Content $infFile",
            "            $removed = $false",
            "            foreach ($driverFile in $driverFileSearchList) {",
            "                if ($content -match $driverFile) {",
            "                    Write-Verbose \"Removing driver $($infFile.FullName)\"",
            "                    $dpinstProc = Start-Process -Wait -Passthru -FilePath \"${env:ProgramFiles(x86)}\\RedHat\\XenPV\\dpinst.exe\" -ArgumentList \"/u $($infFile.FullName) /d /sw\" -NoNewWindow",
            "                    if ($dpinstProc.ExitCode -ne 0) {",
            "                        throw \"Unable to remove driver $($inffile.Name): Error $($dpinstProc.ExitCode)\"",
            "                    }",
            "                    $removed = $true",
            "                }",
            "                if ($removed -eq $true) {",
            "                    break",
            "                }",
            "            }",
            "        }",
            "    }",
            "    # Forcibly remove any RedHat PV Driver registry key to ensure no leftovers",
            "    Remove-Item -Path 'HKLM:\\System\\CurrentControlSet\\Enum\\ACPI\\PNP0A03' -Recurse -Force -ErrorAction SilentlyContinue | Out-Null",
            "    Remove-Item -Path 'HKLM:\\System\\CurrentControlSet\\Enum\\PCI\\VEN_5853&DEV_0001&SUBSYS_00015853&REV_01' -Recurse -Force -ErrorAction SilentlyContinue | Out-Null",
            "    Remove-Item -Path 'HKLM:\\System\\CurrentControlSet\\Enum\\RHEL' -Recurse -Force -ErrorAction SilentlyContinue | Out-Null",
            "    Remove-Item -Path 'HKLM:\\System\\CurrentControlSet\\Services\\rhelfltr' -Recurse -Force -ErrorAction SilentlyContinue | Out-Null",
            "    Remove-Item -Path 'HKLM:\\System\\CurrentControlSet\\Services\\rhelnet' -Recurse -Force -ErrorAction SilentlyContinue | Out-Null",
            "    Remove-Item -Path 'HKLM:\\System\\CurrentControlSet\\Services\\rhelscsi' -Recurse -Force -ErrorAction SilentlyContinue | Out-Null",
            "    Remove-Item -Path 'HKLM:\\System\\CurrentControlSet\\Services\\rhelsvc' -Recurse -Force -ErrorAction SilentlyContinue | Out-Null",
            "    # Remove RedHat uninstaller entry and folder",
            "    Remove-Item -Path 'HKLM:\\SOFTWARE\\Wow6432Node\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\Red Hat Paravirtualized Xen Drivers for Windows(R)' -Recurse -Force -ErrorAction SilentlyContinue | Out-Null",
            "    Remove-Item -Path \"${env:ProgramFiles(x86)}\\RedHat\" -Recurse -Force -ErrorAction SilentlyContinue | Out-Null",
            "}",
            "",
            "function Test-NetFrameworkVersion {",
            "    [version]$requiredVersion = \"4.0.30319.17001\"",
            "    $netFrameworkList = Get-ChildItem 'HKLM:\\SOFTWARE\\Microsoft\\NET Framework Setup\\NDP' -Recurse -ErrorAction SilentlyContinue |",
            "    Get-ItemProperty -name Version, Release -ErrorAction SilentlyContinue |",
            "    Where-Object { $_.PSChildName -match '^(?!S)\\p{L}' } |",
            "    Select-Object @{ name = \"Name\"; expression = { $_.PSChildName } }, Version, Release",
            "    $netFrameworkStatus = $false",
            "    foreach ($item in $netFrameworkList) {",
            "        if (!($netFrameworkStatus)) {",
            "            if ([version]$item.version -gt [version]$requiredVersion) {",
            "                $netFrameworkStatus = $true",
            "            ",
            "            }",
            "            else {",
            "                $netFrameworkStatus = $false",
            "            ",
            "            }",
            "        }",
            "    }",
            "    if (!($netFrameworkStatus)) {",
            "        throw \"Installation failed. AWS PV drivers requires .NET Framework v4.5 or later\"",
            "    }",
            "",
            "}",
            "",
            "function Enable-DSRMwithSSM {",
            "    # This function enables Directory Services Restore Mode and hardcode the currently reachable SSM endpoint in the hosts file",
            "    # allowing communication to the SSM endpoints during DSRM, when DNS services in the DC are down",
            "    # Enable Directory Services Restore mode",
            "    $bcdcmd = \"bcdedit /set '{default}' safeboot dsrepair 2>&1\"",
            "    $bcdstderr = Invoke-Expression -Command $bcdcmd",
            "    if ($lastexitcode -ne 0) {",
            "        throw ($bcdstderr[0])",
            "    }",
            "    # Backup the Hosts file and create a new one with SSM endpoint entries for DNS resolution during DSRM",
            "    $ssmEndpoint = \"ssm.{{ global:REGION }}.amazonaws.com\"",
            "    $ec2messagesEndpoint = \"ec2messages.{{ global:REGION }}.amazonaws.com\"",
            "    $ssmEPIPAddress = [System.Net.Dns]::GetHostAddresses($ssmEndpoint)[0].IPAddressToString",
            "    $ec2messagesEPIPAddress = [System.Net.Dns]::GetHostAddresses($ec2messagesEndpoint)[0].IPAddressToString",
            "    Move-Item -Path \"${env:SYSTEMROOT}\\System32\\drivers\\etc\\hosts\" -Destination \"${env:SYSTEMROOT}\\System32\\drivers\\etc\\hosts-{{ automation:EXECUTION_ID }}\" -Force",
            "    Add-Content -Path \"${env:SYSTEMROOT}\\System32\\drivers\\etc\\hosts\" -Value \"`r`n#Lines added by AWSSupport-UpgradeWindowsAWSDrivers automation for SSM endpoint resolution`r`n$ssmEPIPAddress`t$ssmEndpoint`r`n$ec2messagesEPIPAddress`t$ec2messagesEndpoint\"",
            "    return $true",
            "}",
            "",
            "function Disable-DSRMwithSSM {",
            "    # This function disables Directory Services Restore Mode and restores the original hosts file",
            "    # Disable Directory Services Restore Mode",
            "    $bcdcmd = \"bcdedit /deletevalue '{default}' safeboot 2>&1\"",
            "    $bcdstderr = Invoke-Expression -Command $bcdcmd",
            "    if ($lastexitcode -ne 0) {",
            "        throw ($bcdstderr[0])",
            "    }",
            "    # Restore the original Hosts file",
            "    Move-Item -Path \"${env:SYSTEMROOT}\\System32\\drivers\\etc\\hosts-{{ automation:EXECUTION_ID }}\" -Destination \"${env:SYSTEMROOT}\\System32\\drivers\\etc\\hosts\" -Force",
            "}",
            "",
            "function Expand-ZipFile {",
            "    # Utility function to extract a zipped package",
            "    [CmdletBinding()]",
            "    Param(",
            "        [parameter(Mandatory = $true)]",
            "        [string]$ZipFile,",
            "        [parameter(Mandatory = $true)]",
            "        [string]$Path",
            "    )",
            "    if (Test-Path $ZipFile) {",
            "        Write-Verbose \"Found file $ZipFile\"",
            "    }",
            "    else {",
            "        throw \"$ZipFile file not found\"",
            "    }",
            "    if (Test-Path $Path) {",
            "        Write-Verbose \"$ZipFile already unpacked, skipping extraction\"",
            "    }",
            "    else {",
            "        Write-Verbose \"Extracting package $ZipFile\"",
            "        try {",
            "            # Unpacking the file this way is not supported in PowerShell 2",
            "            Add-Type -AssemblyName System.IO.Compression.FileSystem -ErrorAction SilentlyContinue",
            "            [System.IO.Compression.ZipFile]::ExtractToDirectory($ZipFile, $Path)",
            "        }",
            "        catch [System.InvalidOperationException] {",
            "            # Legacy unpacking method using COM Object",
            "            # Works with PowerShell 2",
            "            New-Item -Path $Path -ItemType \"directory\" -Force | Out-Null",
            "            ((New-Object -com shell.application).NameSpace($Path)).CopyHere(((New-Object -com shell.application).NameSpace($ZipFile)).Items())",
            "        }",
            "",
            "    }",
            "}",
            "",
            "function Set-AllDisksOnline {",
            "    # This function brings online all the offline disks, if any",
            "    $offlineDisks = \"list disk\" | diskpart.exe | Where-Object { $_ -match \"offline\" }",
            "    if ($offlineDisks) {",
            "        foreach ($disk in $offlineDisks ) {",
            "            $diskNumber = ($disk.split(\" \", [System.StringSplitOptions]::RemoveEmptyEntries))[1]",
            "            $diskpartCommands = @\" ",
            "select disk ${diskNumber} ",
            "online disk ",
            "attributes disk clear readonly ",
            "\"@",
            "            $diskpartOutput = $diskpartCommands | diskpart.exe",
            "            Start-Sleep 5",
            "        }",
            "    }",
            "}",
            "",
            "function Install-PVInstallTask {",
            "    # ",
            "    [CmdletBinding()]",
            "    Param(",
            "        [parameter(Mandatory = $true)]",
            "        [string]$PVInstallerPath",
            "        )",
            "    ",
            "    $pvInstallTaskScript = @\"",
            "    `$exitcode = &\"${PVInstallerPath}\\install.ps1\" -Quiet -NoReboot -VerboseLogging",
            "    New-Item \"pv-state-{{ automation:EXECUTION_ID }}\" -ItemType file | Out-Null",
            "    if (`$exitcode -ne 0 -and `$exitcode -ne 3010) {",
            "        Write-Output \"failure\" | Set-Content -Path \"pv-state-{{ automation:EXECUTION_ID }}\"",
            "    }",
            "    else",
            "    {",
            "        if (Select-String -Path \"pv-state-{{ automation:EXECUTION_ID }}\" -Pattern \"redhatdc\") {",
            "            Write-Output \"dsrepair\" | Set-Content -Path \"pv-state-{{ automation:EXECUTION_ID }}\"",
            "        }",
            "        else {",
            "            Write-Output \"success\" | Set-Content -Path \"pv-state-{{ automation:EXECUTION_ID }}\"",
            "        }",
            "    }",
            "    schtasks /delete /tn \"PVInstall\" /f",
            "    shutdown -r -t 10",
            "\"@",
            "        Set-Content -Path \"${tempDir}\\installTask.ps1\" -Value $pvInstallTaskScript",
            "        $taskCmd = \"powershell -ExecutionPolicy Bypass -File `\"${PVInstallerPath}\\installTask.ps1`\"\"",
            "        $taskOutput = & schtasks.exe /create /tn \"PVInstall\" /RU SYSTEM /tr $taskCmd /sc ONSTART /F",
            "        Write-Verbose $taskOutput",
            "",
            "    }",
            "#endregion",
            "",
            "#region Main Script",
            "    try {",
            "        # Check minimum .NET Framework version required for AWS PV drivers",
            "        Test-NetFrameworkVersion",
            "",
            "        if ((Get-WmiObject -Class Win32_OperatingSystem).ProductType -eq 2) {",
            "            # If ProductType is 2, the instance is a Domain Controller",
            "            # Upgrade on a domain controller requires to enable the DCCheck override, and to be performed in DSRM to avoid DS causing a BSOD",
            "            if (!(Test-Path -Path \"pv-state-{{ automation:EXECUTION_ID }}\")) {",
            "                # Enable DCCheck override for PV drivers installation",
            "                $registryPath = \"HKLM:\\SOFTWARE\\Wow6432Node\\Amazon\\AWSPVDriverSetup\"",
            "                New-Item -Path $registryPath -Force | Out-Null",
            "                New-ItemProperty -Path $registryPath -Name \"DisableDCCheck\" -Value \"true\" -PropertyType String -Force | Out-Null",
            "                # Enable Directory Services Restore Mode with SSM support",
            "                $dsRepairmode = Enable-DSRMwithSSM",
            "            }",
            "        }",
            "    ",
            "        if (Test-Path -Path \"pv-state-{{ automation:EXECUTION_ID }}\") {",
            "            if (Select-String -Path \"pv-state-{{ automation:EXECUTION_ID }}\" -Pattern \"success\") {",
            "                Write-Host \"Installer has already run. Skipping installation\"",
            "                exit 0",
            "            }",
            "            else {",
            "                if (Select-String -Path \"pv-state-{{ automation:EXECUTION_ID }}\" -Pattern \"dsrepair\") {",
            "                    # Bring all the disks online, in case any was taken offline in DS repair mode",
            "                    Set-AllDisksOnline",
            "                    # Disable Directory Services Restore Mode",
            "                    Disable-DSRMwithSSM",
            "                    # Disable DCCheck override for PV driver installation",
            "                    $registryPath = \"HKLM:\\SOFTWARE\\Wow6432Node\\Amazon\\AWSPVDriverSetup\"",
            "                    New-Item -Path $registryPath -Force | Out-Null",
            "                    Remove-ItemProperty -Path $registryPath -Name \"DisableDCCheck\" -Force -ErrorAction SilentlyContinue | Out-Null",
            "                    Write-Output \"success\" | Set-Content -Path \"pv-state-{{ automation:EXECUTION_ID }}\"",
            "                    exit 3010",
            "            ",
            "                }",
            "                else {",
            "                    Write-Host \"Previous run of installer marked as failure. Skipping installation\"",
            "                    exit 1",
            "                }",
            "            }",
            "        }",
            "        else {",
            "            # Determine OS Version",
            "            # Operating system                       Major    Minor",
            "            # Windows Server 2019                   10        0    ",
            "            # Windows Server 2016                   10        0    ",
            "            # Windows Server 2012 R2                 6        3",
            "            # Windows Server 2012                     6        2    ",
            "            # Windows Server 2008 R2                 6        1    ",
            "            # Windows Server 2008                     6        0    ",
            "            # Windows Server 2003 R2                 5        2",
            "",
            "            $OSVersion = [System.Environment]::OSVersion.Version",
            "            $version = $OSVersion.Major.ToString() + \".\" + $OSVersion.Minor.ToString()",
            "            switch -regex ($version) {",
            "                \"5.*|6.0|6.1\" {",
            "                    # 8.3.4 is the latest version that supports Windows Server 2008 R2 and below",
            "                    $url = \"https://s3.amazonaws.com/ec2-windows-drivers-downloads/AWSPV/8.3.4/AWSPVDriver.zip\"",
            "                } ",
            "                \"6.2|6.3|10.*\" {",
            "                    $url = \"https://s3.amazonaws.com/ec2-windows-drivers-downloads/AWSPV/Latest/AWSPVDriver.zip\"",
            "                }",
            "            }",
            "                    ",
            "            # Download drivers",
            "            $tempPath = (Resolve-Path ${env:temp}).Path",
            "            Write-Host \"Downloading AWS PV drivers\"",
            "            $tempFile = \"${tempPath}\\AWSPVDriver.zip\"",
            "            $tempDir = \"${tempPath}\\AWSPVDriver\"",
            "            $wc = New-Object \"System.Net.WebClient\"",
            "            $wc.Headers.Add(\"user-agent\", \"AWSSupport-UpgradeWindowsAWSDrivers\")",
            "            $wc.DownloadFile($url, $tempFile)",
            "            if (Test-Path $tempDir) {",
            "                Remove-Item -Path $tempDir -Recurse -Force",
            "            }",
            "",
            "            # Extract drivers",
            "            Expand-ZipFile -ZipFile $tempFile -Path $tempDir",
            "            # Check if Installed PV Drivers are RedHat and handle them, as they require special handling",
            "            if (Get-WmiObject win32_PnPSignedDriver | Where-Object { $_.DeviceClass -match \"SCSIAdapter\" -and $_.Manufacturer -match \"RedHat\" }) {",
            "                $isRedHat = $true",
            "                Write-Host \"RedHat PV drivers detected\"",
            "                # In case of RedhatPV, the installer will fail because upgrade is not supported",
            "                Write-Host \"Removing RedHat PV drivers\"",
            "                Uninstall-RedHatPV",
            "                # Create a scheduled task to run AWS PV installer at next boot",
            "                Write-Host \"Setting install script to run at next boot\"",
            "                Install-PVInstallTask -PVInstallerPath $tempDir",
            "                $exitCode = 3010 ",
            "            }",
            "            else {",
            "                # Run install.ps1",
            "                Write-Host \"Running install script\"",
            "                $exitCode = & \"${tempDir}\\install.ps1\" -Quiet -NoReboot -VerboseLogging",
            "            }",
            "",
            "            # Evaluate exit code",
            "            New-Item \"pv-state-{{ automation:EXECUTION_ID }}\" -ItemType file | Out-Null",
            "            if ($exitcode -ne 0 -and $exitcode -ne 3010) {",
            "                Write-Host \"Installation failed with code $exitcode.\"",
            "                Write-Output \"failure\" | Set-Content -Path \"pv-state-{{ automation:EXECUTION_ID }}\"",
            "                exit 1",
            "            }",
            "            else {",
            "                Write-Host \"Rebooting to complete installation.\"",
            "                if ($dsRepairMode) {",
            "                    if ($isRedHat) {",
            "                        Write-Output \"redhatdc\" | Set-Content -Path \"pv-state-{{ automation:EXECUTION_ID }}\"",
            "                    }",
            "                    else {",
            "                        Write-Output \"dsrepair\" | Set-Content -Path \"pv-state-{{ automation:EXECUTION_ID }}\"",
            "                    }",
            "                }",
            "                else {",
            "                    Write-Output \"success\" | Set-Content -Path \"pv-state-{{ automation:EXECUTION_ID }}\"",
            "                }",
            "                exit 3010",
            "            }",
            "        }",
            "    }",
            "    catch {",
            "        Write-Host $_.Exception.Message",
            "        exit 255",
            "    }",
            "#endregion"
          ]
        }
      },
      "isCritical": "true",
      "isEnd": "true"
    },
    {
      "name": "assertAllowOffline",
      "action": "aws:assertAwsResourceProperty",
      "onFailure": "Abort",
      "inputs": {
        "Service": "ssm",
        "Api": "GetAutomationExecution",
        "AutomationExecutionId": "{{ automation:EXECUTION_ID }}",
        "PropertySelector": "$.AutomationExecution.Parameters.AllowOffline[0]",
        "DesiredValues": [
          "True"
        ]
      },
      "isCritical": "true",
      "nextStep": "stopInstance"
    },
    {
      "name": "stopInstance",
      "action": "aws:changeInstanceState",
      "onFailure": "Continue",
      "inputs": {
        "InstanceIds": [
          "{{ InstanceId }}"
        ],
        "CheckStateOnly": false,
        "DesiredState": "stopped"
      },
      "isCritical": "false",
      "nextStep": "forceStopInstance"
    },
    {
      "name": "forceStopInstance",
      "action": "aws:changeInstanceState",
      "onFailure": "Abort",
      "inputs": {
        "InstanceIds": [
          "{{ InstanceId }}"
        ],
        "CheckStateOnly": false,
        "DesiredState": "stopped",
        "Force": true
      },
      "isCritical": "true",
      "nextStep": "preOfflineUpgradeBackup"
    },
    {
      "name": "preOfflineUpgradeBackup",
      "action": "aws:executeAwsApi",
      "onFailure": "Abort",
      "inputs": {
        "Service": "ec2",
        "Api": "CreateImage",
        "InstanceId": "{{ InstanceId }}",
        "Description": "Pre-upgrade Backup AMI Generated by Automation on {{ global:DATE_TIME }} from {{ InstanceId }}.",
        "NoReboot": false,
        "Name": "UpgradeWindowsAWSDrivers-Pre-Script-Backup_{{ InstanceId }}_{{ global:DATE_TIME }}"
      },
      "outputs": [
        {
          "Name": "ImageId",
          "Selector": "$.ImageId",
          "Type": "String"
        }
      ],
      "isCritical": "true",
      "nextStep": "tagPreOfflineUpgradeBackup"
    },
    {
      "name": "tagPreOfflineUpgradeBackup",
      "action": "aws:createTags",
      "onFailure": "Continue",
      "inputs": {
        "ResourceType": "EC2",
        "ResourceIds": [
          "{{ preOfflineUpgradeBackup.ImageId }}"
        ],
        "Tags": [
          {
            "Key": "Name",
            "Value": "AWSSupport-UpgradeWindowsAWSDrivers: {{ InstanceId }}"
          },
          {
            "Key": "AWSSupport-UpgradeWindowsAWSDrivers-AutomationExecution",
            "Value": "{{ automation:EXECUTION_ID }}"
          }
        ]
      },
      "isCritical": "false",
      "nextStep": "enableEnaSupport"
    },
    {
      "name": "enableEnaSupport",
      "onFailure": "Continue",
      "action": "aws:executeAwsApi",
      "inputs": {
        "Service": "ec2",
        "Api": "ModifyInstanceAttribute",
        "InstanceId": "{{ InstanceId }}",
        "EnaSupport": {
          "Value": true
        }
      },
      "isCritical": "true",
      "nextStep": "branchOnForceUpgrade"
    },
    {
      "name": "branchOnForceUpgrade",
      "action": "aws:branch",
      "onFailure": "step:startInstance",
      "inputs": {
        "Choices": [
          {
            "NextStep": "upgradeDriversOffline",
            "Variable": "{{ ForceUpgrade }}",
            "StringEquals": "False"
          },
          {
            "NextStep": "forceUpgradeDriversOffline",
            "Variable": "{{ ForceUpgrade }}",
            "StringEquals": "True"
          }
        ]
      },
      "isCritical": "true"
    },
    {
      "name": "upgradeDriversOffline",
      "onFailure": "Continue",
      "action": "aws:executeAutomation",
      "inputs": {
        "RuntimeParameters": {
          "InstanceId": [
            "{{ InstanceId }}"
          ],
          "EC2RescueInstanceType": [
            "t2.large"
          ],
          "OfflineScript": [
            "U2V0LUJvb3REcml2ZXJzS2V5IC1XaW5kb3dzSW5zdGFsbERhdGEgJHNjcmlwdDpFQzJSRVNDVUVfT0ZGTElORV9XSU5ET1dTX0lOU1RBTEwNCkluc3RhbGwtUFZEcml2ZXJzIC1XaW5kb3dzSW5zdGFsbERhdGEgJHNjcmlwdDpFQzJSRVNDVUVfT0ZGTElORV9XSU5ET1dTX0lOU1RBTEwNCkluc3RhbGwtTml0cm9Ecml2ZXJzIC1XaW5kb3dzSW5zdGFsbERhdGEgJHNjcmlwdDpFQzJSRVNDVUVfT0ZGTElORV9XSU5ET1dTX0lOU1RBTEw="
          ],
          "SubnetId": [
            "{{ SubnetId }}"
          ],
          "UniqueId": "{{ automation:EXECUTION_ID }}"
        },
        "DocumentName": "AWSSupport-StartEC2RescueWorkflow"
      },
      "isCritical": "true",
      "nextStep": "startInstance"
    },
    {
      "name": "forceUpgradeDriversOffline",
      "onFailure": "Continue",
      "action": "aws:executeAutomation",
      "inputs": {
        "RuntimeParameters": {
          "InstanceId": [
            "{{ InstanceId }}"
          ],
          "EC2RescueInstanceType": [
            "t2.large"
          ],
          "OfflineScript": [
            "U2V0LUJvb3REcml2ZXJzS2V5IC1XaW5kb3dzSW5zdGFsbERhdGEgJHNjcmlwdDpFQzJSRVNDVUVfT0ZGTElORV9XSU5ET1dTX0lOU1RBTEwNCkluc3RhbGwtUFZEcml2ZXJzIC1XaW5kb3dzSW5zdGFsbERhdGEgJHNjcmlwdDpFQzJSRVNDVUVfT0ZGTElORV9XSU5ET1dTX0lOU1RBTEwgLUZvcmNlDQpJbnN0YWxsLU5pdHJvRHJpdmVycyAtV2luZG93c0luc3RhbGxEYXRhICRzY3JpcHQ6RUMyUkVTQ1VFX09GRkxJTkVfV0lORE9XU19JTlNUQUxMIC1Gb3JjZQ=="
          ],
          "SubnetId": [
            "{{ SubnetId }}"
          ],
          "UniqueId": "{{ automation:EXECUTION_ID }}"
        },
        "DocumentName": "AWSSupport-StartEC2RescueWorkflow"
      },
      "isCritical": "true",
      "nextStep": "startInstance"
    },
    {
      "name": "startInstance",
      "action": "aws:changeInstanceState",
      "onFailure": "Abort",
      "inputs": {
        "InstanceIds": [
          "{{ InstanceId }}"
        ],
        "CheckStateOnly": false,
        "DesiredState": "running"
      },
      "isCritical": "true",
      "isEnd": "true"
    }
  ],
  "outputs": [
    "preUpgradeBackup.ImageId",
    "preOfflineUpgradeBackup.ImageId",
    "installAwsEnaNetworkDriverOnInstance.Output",
    "installAWSNVMeOnInstance.Output",
    "installAWSPVDriverOnInstance.Output",
    "upgradeDriversOffline.Output",
    "forceUpgradeDriversOffline.Output"
  ]
}
