{
  "schemaVersion": "0.3",
  "description": "The AWSSupport-UpgradeWindowsAWSDrivers upgrades or repairs storage and network AWS drivers on the specified EC2 instance. The document attempts to install the latest versions of AWS drivers online by calling the SSM agent. If the SSM agent is not contactable, the document can perform an offline installation of the AWS drivers if explicitly requested. Note: Both the online and offline upgrade will create an AMI before attempting any operations, which will persist after the automation completes. It is your responsibility to secure access to the AMI, or to delete it. The online method restarts the instance as part of the upgrade process, while the offline method requires the provided EC2 instance be stopped and then started.",
  "assumeRole": "{{ AutomationAssumeRole }}",
  "parameters": {
    "InstanceId": {
      "type": "AWS::EC2::Instance::Id",
      "description": "(Required) ID of your EC2 Windows instance.",
      "allowedPattern": "^i-[a-z0-9]{8,17}$"
    },
    "AllowOffline": {
      "type": "String",
      "description": "(Optional) Set it to true if you allow an offline drivers upgrade in case the online installation cannot be performed. Note: The offline method requires the provided EC2 instance be stopped and then started. Data stored in instance store volumes will be lost. The public IP address will change if you are not using an Elastic IP.",
      "default": "False",
      "allowedValues": [
        "True",
        "False"
      ]
    },
    "SubnetId": {
      "type": "String",
      "description": "(Optional) Offline only - The subnet ID for the EC2Rescue instance used to perform the offline drivers upgrade. If you specify CreateNewVPC, AWS Systems Manager Automation will create a new VPC. IMPORTANT: The subnet must be in the same Availability Zone as InstanceId, and it must allow access to the SSM endpoints.",
      "default": "SelectedInstanceSubnet",
      "allowedPattern": "^SelectedInstanceSubnet$|^CreateNewVPC$|^subnet-[a-z0-9]{8,17}$"
    },
    "ForceUpgrade": {
      "type": "String",
      "description": "(Optional) Offline only - Set it to true if you allow the offline drivers upgrade to proceed even though your instance already has the latest drivers installed.",
      "default": "False",
      "allowedValues": [
        "True",
        "False"
      ]
    },
    "AutomationAssumeRole": {
      "type": "AWS::IAM::Role::Arn",
      "description": "(Optional) The Amazon Resource Name (ARN) of the AWS Identity and Access Management (IAM) role that allows Systems Manager Automation to perform the actions on your behalf. If no role is specified, Systems Manager Automation uses the permissions of the user that starts this runbook.",
      "default": ""
    }
  },
  "mainSteps": [
    {
      "name": "assertInstanceIsWindows",
      "action": "aws:assertAwsResourceProperty",
      "description": "Verifies the input EC2 instance is Windows.",
      "onFailure": "Abort",
      "inputs": {
        "Service": "ec2",
        "Api": "DescribeInstances",
        "InstanceIds": [
          "{{ InstanceId }}"
        ],
        "PropertySelector": "$.Reservations[0].Instances[0].Platform",
        "DesiredValues": [
          "windows"
        ]
      },
      "isCritical": "true",
      "nextStep": "describeManagedInstance"
    },
    {
      "name": "describeManagedInstance",
      "action": "aws:executeAwsApi",
      "description": "Verifies the input EC2 instance is managed by Systems Manager.",
      "onFailure": "Abort",
      "inputs": {
        "Service": "ssm",
        "Api": "DescribeInstanceInformation",
        "InstanceInformationFilterList": [
          {
            "key": "InstanceIds",
            "valueSet": [
              "{{ InstanceId }}"
            ]
          }
        ]
      },
      "outputs": [
        {
          "Name": "PingStatus",
          "Selector": "$.InstanceInformationList[0].PingStatus"
        }
      ],
      "isCritical": "true",
      "nextStep": "branchOnManagedInstancePingStatus"
    },
    {
      "name": "branchOnManagedInstancePingStatus",
      "action": "aws:branch",
      "description": "Branches the workflow based on weather the EC2 instance is managed by Systems Manager or not. If so, the online upgrade starts, otherwise the offline upgrade is evaluated.",
      "onFailure": "Abort",
      "inputs": {
        "Choices": [
          {
            "NextStep": "preUpgradeBackup",
            "Variable": "{{ describeManagedInstance.PingStatus }}",
            "StringEquals": "Online"
          }
        ],
        "Default": "assertAllowOffline"
      },
      "isCritical": "true"
    },
    {
      "name": "preUpgradeBackup",
      "action": "aws:createImage",
      "description": "Creates an Amazon Machine Image (AMI) backup.",
      "onFailure": "Abort",
      "inputs": {
        "InstanceId": "{{ InstanceId }}",
        "ImageDescription": "Pre-Upgrade Backup AMI Generated by Automation on {{ global:DATE_TIME }} from {{ InstanceId }}.",
        "NoReboot": false,
        "ImageName": "AWSSupport-Pre-Upgrade-Backup_{{ InstanceId }}_{{ global:DATE_TIME }}"
      },
      "outputs": [
        {
          "Name": "BackupImageId",
          "Selector": "$.ImageId",
          "Type": "String"
        }
      ],
      "isCritical": "true",
      "nextStep": "tagPreUpgradeBackup"
    },
    {
      "name": "tagPreUpgradeBackup",
      "action": "aws:createTags",
      "description": "Tags the Amazon Machine Image (AMI) backup.",
      "onFailure": "Continue",
      "inputs": {
        "ResourceIds": [
          "{{ preUpgradeBackup.BackupImageId }}"
        ],
        "Tags": [
          {
            "Key": "Name",
            "Value": "AWSSupport-UpgradeWindowsAWSDrivers: {{ InstanceId }}"
          },
          {
            "Key": "AWSSupport-UpgradeWindowsAWSDrivers-AutomationExecution",
            "Value": "{{ automation:EXECUTION_ID }}"
          }
        ],
        "ResourceType": "EC2"
      },
      "isCritical": "false",
      "nextStep": "assertpreUpgradeBackup"
    },
    {
      "name": "assertpreUpgradeBackup",
      "action": "aws:waitForAwsResourceProperty",
      "description": "Verifies the Amazon Machine Image (AMI) backup is in 'available' state.",
      "onFailure": "Abort",
      "inputs": {
        "Service": "ec2",
        "Api": "DescribeImages",
        "Filters": [
          {
            "Name": "image-id",
            "Values": [
              "{{ preUpgradeBackup.BackupImageId }}"
            ]
          }
        ],
        "PropertySelector": "$.Images[0].State",
        "DesiredValues": [
          "available"
        ]
      },
      "isCritical": "true",
      "nextStep": "installAWSNVMeOnInstance"
    },
    {
      "name": "installAWSNVMeOnInstance",
      "action": "aws:runCommand",
      "description": "Installs the AWS NVMe driver for Windows.",
      "onFailure": "Continue",
      "inputs": {
        "DocumentName": "AWS-RunPowerShellScript",
        "InstanceIds": [
          "{{ InstanceId }}"
        ],
        "Parameters": {
          "commands": [
            "try {",
            "    if (Test-Path -Path \"nvme-state-{{ automation:EXECUTION_ID }}\") {",
            "        if (Select-String -Path \"nvme-state-{{ automation:EXECUTION_ID }}\" -Pattern \"success\") {",
            "            Write-Host \"Installer has already run. Skipping installation\"",
            "            exit 0",
            "        }",
            "        else {",
            "            Write-Host \"Previous run of installer marked as failure. Skipping installation\"",
            "            exit 1",
            "        }",
            "    }",
            "    else {",
            "        # Determine OS Version",
            "        # Operating system                       Major    Minor",
            "        # Windows Server 2019                   10        0    ",
            "        # Windows Server 2016                   10        0    ",
            "        # Windows Server 2012 R2                 6        3",
            "        # Windows Server 2012                     6        2    ",
            "        # Windows Server 2008 R2                 6        1",
            "",
            "        $OSVersion = [System.Environment]::OSVersion.Version",
            "        $version = $OSVersion.Major.ToString() + \".\" + $OSVersion.Minor.ToString()",
            "        switch -regex ($version) {",
            "            \"6.1\" {",
            "                # 1.3.2 is the latest version that supports Windows Server 2008 R2",
            "                $url = \"https://s3.amazonaws.com/ec2-windows-drivers-downloads/NVMe/1.3.2/AWSNVMe.zip\"",
            "            } ",
            "            \"6.2|6.3|10.*\" {",
            "                $url = \"https://s3.amazonaws.com/ec2-windows-drivers-downloads/NVMe/Latest/AWSNVMe.zip\"",
            "            }",
            "        }",
            "        $tempPath = (Resolve-Path ${env:temp}).Path",
            "        Write-Host \"Downloading AWS NVMe drivers\"",
            "        $tempFile = \"${tempPath}\\AWSNVMe.zip\"",
            "        $tempDir = \"${tempPath}\\AWSNVMe\"",
            "        $wc = New-Object \"System.Net.WebClient\"",
            "        $wc.Headers.Add(\"user-agent\", \"AWSSupport-UpgradeWindowsAWSDrivers\")",
            "        $wc.DownloadFile($url, $tempFile)",
            "        if (Test-Path $tempDir) {",
            "            Remove-Item -Path $tempDir -Recurse -Force",
            "        }",
            "",
            "        # Extract drivers",
            "        try {",
            "            # Unpacking the file this way is not supported in PowerShell 2",
            "            Add-Type -AssemblyName System.IO.Compression.FileSystem -ErrorAction SilentlyContinue",
            "            [System.IO.Compression.ZipFile]::ExtractToDirectory($tempFile, $tempDir)",
            "        }",
            "        catch [System.InvalidOperationException] {",
            "            # Legacy unpacking method using COM Object",
            "            # Works with PowerShell 2",
            "            New-Item -Path $tempDir -ItemType \"directory\" -Force | Out-Null",
            "            ((New-Object -com shell.application).NameSpace($tempDir)).CopyHere(((New-Object -com shell.application).NameSpace($tempFile)).Items())",
            "        }",
            "",
            "        # Run install.ps1",
            "        Write-Host \"Running install script\"",
            "        $output = & \"${tempDir}\\install.ps1\" -NoReboot",
            "        Write-Host $output",
            "",
            "        # Handling drivers reflection: https://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/migrating-latest-types.html#upgrade-nvme",
            "        # Driver reflection is required only for Windows Server 2008 R2 and Windows Server 2012 instances",
            "        $allowedWinVer = $false",
            "        $osVer = [System.Environment]::OSVersion.Version",
            "        if ($osVer.Major -eq 6) {",
            "            $allowedMinor = @(1, 2)",
            "            if ($allowedMinor -contains $osVer.Minor) {",
            "                $allowedWinVer = $true",
            "            }",
            "        }",
            "        if ($allowedWinVer) {",
            "            # Checking instance type architecture to ensure it is not a Nitro instance type",
            "            $allowedInstanceType = $false",
            "            $ErrorActionPreference = \"stop\"",
            "            try {",
            "                $systemVersion = (Get-ItemProperty -Path HKLM:\\HARDWARE\\DESCRIPTION\\System\\BIOS -Name SystemVersion).SystemVersion",
            "                $systemManufacturer = (Get-ItemProperty -Path HKLM:\\HARDWARE\\DESCRIPTION\\System\\BIOS -Name SystemManufacturer).SystemManufacturer",
            "            }",
            "            catch [System.Management.Automation.PSArgumentException] {}",
            "            finally { $ErrorActionPreference = \"Continue\" }",
            "            if (($systemVersion -match \"amazon\") -and ($systemManufacturer -match \"Xen\")) {",
            "                $allowedInstanceType = $true",
            "            }",
            "            if ($allowedInstanceType) {",
            "                Write-Host \"Reflecting Boot Critical drivers\"",
            "                Start-Process -PassThru -Wait -FilePath \"$env:systemroot\\System32\\rundll32.exe\" -ArgumentList \"sppnp.dll,Sysprep_Generalize_Pnp\" | Out-Null",
            "            }",
            "        }",
            "",
            "        # Evaluate output",
            "        [System.Int32]$retSuccess = 0",
            "        [System.Int32]$retSuccessRebootRequired = 3010",
            "        ",
            "        New-Item \"nvme-state-{{ automation:EXECUTION_ID }}\" -ItemType file | Out-Null",
            "",
            "        if ($output -eq $retSuccess) {",
            "            Write-Output \"success\" | Set-Content -Path \"nvme-state-{{ automation:EXECUTION_ID }}\"",
            "            exit 0",
            "        }",
            "        elseif ($output -eq $retSuccessRebootRequired) {",
            "            Write-Host \"Rebooting to complete installation\"",
            "            Write-Output \"success\" | Set-Content -Path \"nvme-state-{{ automation:EXECUTION_ID }}\"",
            "            exit 3010",
            "        }",
            "        else {",
            "            Write-Output \"failure\" | Set-Content -Path \"nvme-state-{{ automation:EXECUTION_ID }}\"",
            "            exit 1",
            "        }",
            "    }",
            "}",
            "catch {",
            "    Write-Host $_.Exception.Message",
            "    exit 255",
            "}"
          ]
        }
      },
      "isCritical": "true",
      "nextStep": "installAWSPVDriverOnInstance"
    },
    {
      "name": "installAWSPVDriverOnInstance",
      "action": "aws:runCommand",
      "description": "Installs the AWS PV driver for Windows.",
      "onFailure": "Abort",
      "inputs": {
        "DocumentName": "AWS-RunPowerShellScript",
        "InstanceIds": [
          "{{ InstanceId }}"
        ],
        "Parameters": {
          "commands": [
            "#region Functions",
            "function Uninstall-RedHatPV {",
            "    # Forcibly remove RedHat PV Drivers as the AWS PV installer does not do so",
            "    $driverFileSearchList = @(",
            "        'rhelhidden',",
            "        'rhelfltr',",
            "        'rhelnet',",
            "        'rhelscsi')",
            "    $infFiles = Get-Item (Join-Path $env:SystemRoot \"\\inf\\oem*.inf\")",
            "    foreach ($infFile in $infFiles) {",
            "        if ($infFile.Length -gt 0) {",
            "            $content = Get-Content $infFile",
            "            $removed = $false",
            "            foreach ($driverFile in $driverFileSearchList) {",
            "                if ($content -match $driverFile) {",
            "                    Write-Verbose \"Removing driver $($infFile.FullName)\"",
            "                    $dpinstProc = Start-Process -Wait -Passthru -FilePath \"${env:ProgramFiles(x86)}\\RedHat\\XenPV\\dpinst.exe\" -ArgumentList \"/u $($infFile.FullName) /d /sw\" -NoNewWindow",
            "                    if ($dpinstProc.ExitCode -ne 0) {",
            "                        throw \"Unable to remove driver $($inffile.Name): Error $($dpinstProc.ExitCode)\"",
            "                    }",
            "                    $removed = $true",
            "                }",
            "                if ($removed -eq $true) {",
            "                    break",
            "                }",
            "            }",
            "        }",
            "    }",
            "    # Forcibly remove any RedHat PV Driver registry key to ensure no leftovers",
            "    Remove-Item -Path 'HKLM:\\System\\CurrentControlSet\\Enum\\ACPI\\PNP0A03' -Recurse -Force -ErrorAction SilentlyContinue | Out-Null",
            "    Remove-Item -Path 'HKLM:\\System\\CurrentControlSet\\Enum\\PCI\\VEN_5853&DEV_0001&SUBSYS_00015853&REV_01' -Recurse -Force -ErrorAction SilentlyContinue | Out-Null",
            "    Remove-Item -Path 'HKLM:\\System\\CurrentControlSet\\Enum\\RHEL' -Recurse -Force -ErrorAction SilentlyContinue | Out-Null",
            "    Remove-Item -Path 'HKLM:\\System\\CurrentControlSet\\Services\\rhelfltr' -Recurse -Force -ErrorAction SilentlyContinue | Out-Null",
            "    Remove-Item -Path 'HKLM:\\System\\CurrentControlSet\\Services\\rhelnet' -Recurse -Force -ErrorAction SilentlyContinue | Out-Null",
            "    Remove-Item -Path 'HKLM:\\System\\CurrentControlSet\\Services\\rhelscsi' -Recurse -Force -ErrorAction SilentlyContinue | Out-Null",
            "    Remove-Item -Path 'HKLM:\\System\\CurrentControlSet\\Services\\rhelsvc' -Recurse -Force -ErrorAction SilentlyContinue | Out-Null",
            "    # Remove RedHat uninstaller entry and folder",
            "    Remove-Item -Path 'HKLM:\\SOFTWARE\\Wow6432Node\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\Red Hat Paravirtualized Xen Drivers for Windows(R)' -Recurse -Force -ErrorAction SilentlyContinue | Out-Null",
            "    Remove-Item -Path \"${env:ProgramFiles(x86)}\\RedHat\" -Recurse -Force -ErrorAction SilentlyContinue | Out-Null",
            "}",
            "",
            "function Test-NetFrameworkVersion {",
            "    [version]$requiredVersion = \"4.0.30319.17001\"",
            "    $netFrameworkList = Get-ChildItem 'HKLM:\\SOFTWARE\\Microsoft\\NET Framework Setup\\NDP' -Recurse -ErrorAction SilentlyContinue |",
            "    Get-ItemProperty -name Version, Release -ErrorAction SilentlyContinue |",
            "    Where-Object { $_.PSChildName -match '^(?!S)\\p{L}' } |",
            "    Select-Object @{ name = \"Name\"; expression = { $_.PSChildName } }, Version, Release",
            "    $netFrameworkStatus = $false",
            "    foreach ($item in $netFrameworkList) {",
            "        if (!($netFrameworkStatus)) {",
            "            if ([version]$item.version -gt [version]$requiredVersion) {",
            "                $netFrameworkStatus = $true",
            "            ",
            "            }",
            "            else {",
            "                $netFrameworkStatus = $false",
            "            ",
            "            }",
            "        }",
            "    }",
            "    if (!($netFrameworkStatus)) {",
            "        throw \"Installation failed. AWS PV drivers requires .NET Framework v4.5 or later\"",
            "    }",
            "",
            "}",
            "",
            "function Enable-DSRMwithSSM {",
            "    # This function enables Directory Services Restore Mode and hardcode the currently reachable SSM endpoint in the hosts file",
            "    # allowing communication to the SSM endpoints during DSRM, when DNS services in the DC are down",
            "    # Enable Directory Services Restore mode",
            "    $bcdcmd = \"bcdedit /set '{default}' safeboot dsrepair 2>&1\"",
            "    $bcdstderr = Invoke-Expression -Command $bcdcmd",
            "    if ($lastexitcode -ne 0) {",
            "        throw ($bcdstderr[0])",
            "    }",
            "    # Backup the Hosts file and create a new one with SSM endpoint entries for DNS resolution during DSRM",
            "    $ssmEndpoint = \"ssm.{{ global:REGION }}.amazonaws.com\"",
            "    $ec2messagesEndpoint = \"ec2messages.{{ global:REGION }}.amazonaws.com\"",
            "    $ssmEPIPAddress = [System.Net.Dns]::GetHostAddresses($ssmEndpoint)[0].IPAddressToString",
            "    $ec2messagesEPIPAddress = [System.Net.Dns]::GetHostAddresses($ec2messagesEndpoint)[0].IPAddressToString",
            "    Move-Item -Path \"${env:SYSTEMROOT}\\System32\\drivers\\etc\\hosts\" -Destination \"${env:SYSTEMROOT}\\System32\\drivers\\etc\\hosts-{{ automation:EXECUTION_ID }}\" -Force",
            "    Add-Content -Path \"${env:SYSTEMROOT}\\System32\\drivers\\etc\\hosts\" -Value \"`r`n#Lines added by AWSSupport-UpgradeWindowsAWSDrivers automation for SSM endpoint resolution`r`n$ssmEPIPAddress`t$ssmEndpoint`r`n$ec2messagesEPIPAddress`t$ec2messagesEndpoint\"",
            "    return $true",
            "}",
            "",
            "function Disable-DSRMwithSSM {",
            "    # This function disables Directory Services Restore Mode and restores the original hosts file",
            "    # Disable Directory Services Restore Mode",
            "    $bcdcmd = \"bcdedit /deletevalue '{default}' safeboot 2>&1\"",
            "    $bcdstderr = Invoke-Expression -Command $bcdcmd",
            "    if ($lastexitcode -ne 0) {",
            "        throw ($bcdstderr[0])",
            "    }",
            "    # Restore the original Hosts file",
            "    Move-Item -Path \"${env:SYSTEMROOT}\\System32\\drivers\\etc\\hosts-{{ automation:EXECUTION_ID }}\" -Destination \"${env:SYSTEMROOT}\\System32\\drivers\\etc\\hosts\" -Force",
            "}",
            "",
            "function Expand-ZipFile {",
            "    # Utility function to extract a zipped package",
            "    [CmdletBinding()]",
            "    Param(",
            "        [parameter(Mandatory = $true)]",
            "        [string]$ZipFile,",
            "        [parameter(Mandatory = $true)]",
            "        [string]$Path",
            "    )",
            "    if (Test-Path $ZipFile) {",
            "        Write-Verbose \"Found file $ZipFile\"",
            "    }",
            "    else {",
            "        throw \"$ZipFile file not found\"",
            "    }",
            "    if (Test-Path $Path) {",
            "        Write-Verbose \"$ZipFile already unpacked, skipping extraction\"",
            "    }",
            "    else {",
            "        Write-Verbose \"Extracting package $ZipFile\"",
            "        try {",
            "            # Unpacking the file this way is not supported in PowerShell 2",
            "            Add-Type -AssemblyName System.IO.Compression.FileSystem -ErrorAction SilentlyContinue",
            "            [System.IO.Compression.ZipFile]::ExtractToDirectory($ZipFile, $Path)",
            "        }",
            "        catch [System.InvalidOperationException] {",
            "            # Legacy unpacking method using COM Object",
            "            # Works with PowerShell 2",
            "            New-Item -Path $Path -ItemType \"directory\" -Force | Out-Null",
            "            ((New-Object -com shell.application).NameSpace($Path)).CopyHere(((New-Object -com shell.application).NameSpace($ZipFile)).Items())",
            "        }",
            "",
            "    }",
            "}",
            "",
            "function Set-AllDisksOnline {",
            "    # This function brings online all the offline disks, if any",
            "    $offlineDisks = \"list disk\" | diskpart.exe | Where-Object { $_ -match \"offline\" }",
            "    if ($offlineDisks) {",
            "        foreach ($disk in $offlineDisks ) {",
            "            $diskNumber = ($disk.split(\" \", [System.StringSplitOptions]::RemoveEmptyEntries))[1]",
            "            $diskpartCommands = @\" ",
            "select disk ${diskNumber} ",
            "online disk ",
            "attributes disk clear readonly ",
            "\"@",
            "            $diskpartOutput = $diskpartCommands | diskpart.exe",
            "            Start-Sleep 5",
            "        }",
            "    }",
            "}",
            "",
            "function Install-PVInstallTask {",
            "    # ",
            "    [CmdletBinding()]",
            "    Param(",
            "        [parameter(Mandatory = $true)]",
            "        [string]$PVInstallerPath",
            "        )",
            "    ",
            "    $pvInstallTaskScript = @\"",
            "    `$exitcode = &\"${PVInstallerPath}\\install.ps1\" -Quiet -NoReboot -VerboseLogging",
            "    New-Item \"pv-state-{{ automation:EXECUTION_ID }}\" -ItemType file | Out-Null",
            "    if (`$exitcode -ne 0 -and `$exitcode -ne 3010) {",
            "        Write-Output \"failure\" | Set-Content -Path \"pv-state-{{ automation:EXECUTION_ID }}\"",
            "    }",
            "    else",
            "    {",
            "        if (Select-String -Path \"pv-state-{{ automation:EXECUTION_ID }}\" -Pattern \"redhatdc\") {",
            "            Write-Output \"dsrepair\" | Set-Content -Path \"pv-state-{{ automation:EXECUTION_ID }}\"",
            "        }",
            "        else {",
            "            Write-Output \"success\" | Set-Content -Path \"pv-state-{{ automation:EXECUTION_ID }}\"",
            "        }",
            "    }",
            "    schtasks /delete /tn \"PVInstall\" /f",
            "    shutdown -r -t 10",
            "\"@",
            "        Set-Content -Path \"${tempDir}\\installTask.ps1\" -Value $pvInstallTaskScript",
            "        $taskCmd = \"powershell -ExecutionPolicy Bypass -File `\"${PVInstallerPath}\\installTask.ps1`\"\"",
            "        $taskOutput = & schtasks.exe /create /tn \"PVInstall\" /RU SYSTEM /tr $taskCmd /sc ONSTART /F",
            "        Write-Verbose $taskOutput",
            "",
            "    }",
            "#endregion",
            "",
            "#region Main Script",
            "    try {",
            "        # Check minimum .NET Framework version required for AWS PV drivers",
            "        Test-NetFrameworkVersion",
            "",
            "        if ((Get-WmiObject -Class Win32_OperatingSystem).ProductType -eq 2) {",
            "            # If ProductType is 2, the instance is a Domain Controller",
            "            # Upgrade on a domain controller requires to enable the DCCheck override, and to be performed in DSRM to avoid DS causing a BSOD",
            "            if (!(Test-Path -Path \"pv-state-{{ automation:EXECUTION_ID }}\")) {",
            "                # Enable DCCheck override for PV drivers installation",
            "                $registryPath = \"HKLM:\\SOFTWARE\\Wow6432Node\\Amazon\\AWSPVDriverSetup\"",
            "                New-Item -Path $registryPath -Force | Out-Null",
            "                New-ItemProperty -Path $registryPath -Name \"DisableDCCheck\" -Value \"true\" -PropertyType String -Force | Out-Null",
            "                # Enable Directory Services Restore Mode with SSM support",
            "                $dsRepairmode = Enable-DSRMwithSSM",
            "            }",
            "        }",
            "    ",
            "        if (Test-Path -Path \"pv-state-{{ automation:EXECUTION_ID }}\") {",
            "            if (Select-String -Path \"pv-state-{{ automation:EXECUTION_ID }}\" -Pattern \"success\") {",
            "                Write-Host \"Installer has already run. Skipping installation\"",
            "                exit 0",
            "            }",
            "            else {",
            "                if (Select-String -Path \"pv-state-{{ automation:EXECUTION_ID }}\" -Pattern \"dsrepair\") {",
            "                    # Bring all the disks online, in case any was taken offline in DS repair mode",
            "                    Set-AllDisksOnline",
            "                    # Disable Directory Services Restore Mode",
            "                    Disable-DSRMwithSSM",
            "                    # Disable DCCheck override for PV driver installation",
            "                    $registryPath = \"HKLM:\\SOFTWARE\\Wow6432Node\\Amazon\\AWSPVDriverSetup\"",
            "                    New-Item -Path $registryPath -Force | Out-Null",
            "                    Remove-ItemProperty -Path $registryPath -Name \"DisableDCCheck\" -Force -ErrorAction SilentlyContinue | Out-Null",
            "                    Write-Output \"success\" | Set-Content -Path \"pv-state-{{ automation:EXECUTION_ID }}\"",
            "                    exit 3010",
            "            ",
            "                }",
            "                else {",
            "                    Write-Host \"Previous run of installer marked as failure. Skipping installation\"",
            "                    exit 1",
            "                }",
            "            }",
            "        }",
            "        else {",
            "            # Determine OS Version",
            "            # Operating system                       Major    Minor",
            "            # Windows Server 2019                   10        0    ",
            "            # Windows Server 2016                   10        0    ",
            "            # Windows Server 2012 R2                 6        3",
            "            # Windows Server 2012                     6        2    ",
            "            # Windows Server 2008 R2                 6        1    ",
            "            # Windows Server 2008                     6        0    ",
            "            # Windows Server 2003 R2                 5        2",
            "",
            "            $OSVersion = [System.Environment]::OSVersion.Version",
            "            $version = $OSVersion.Major.ToString() + \".\" + $OSVersion.Minor.ToString()",
            "            # Get Version of ntoskernel.exe to check for KB3033929",
            "            $ntoskrnlver = (Get-Item $env:systemroot\\system32\\ntoskrnl.exe).VersionInfo.ProductVersion",
            "            $KB3033929 = [System.Version]\"6.1.7601.22948\"",
            "            switch -regex ($version) {",
            "                \"5.*|6.0|6.1\" {",
            "                    if ([System.Version]$ntoskrnlver -lt $KB3033929) {",
            "                        # 8.3.2 is the highest version that supports Windows Server 2008 R2 without KB3033929",
            "                        $url = \"https://s3.amazonaws.com/ec2-windows-drivers-downloads/AWSPV/8.3.2/AWSPVDriver.zip\"",
            "                    }",
            "                    else {",
            "                        # 8.3.5 is the latest version that supports Windows Server 2008 R2 and below",
            "                        $url = \"https://s3.amazonaws.com/ec2-windows-drivers-downloads/AWSPV/8.3.5/AWSPVDriver.zip\"",
            "                    }",
            "                } ",
            "                \"6.2|6.3|10.*\" {",
            "                    $url = \"https://s3.amazonaws.com/ec2-windows-drivers-downloads/AWSPV/Latest/AWSPVDriver.zip\"",
            "                }",
            "            }",
            "                    ",
            "            # Download drivers",
            "            $tempPath = (Resolve-Path ${env:temp}).Path",
            "            Write-Host \"Downloading AWS PV drivers\"",
            "            $tempFile = \"${tempPath}\\AWSPVDriver.zip\"",
            "            $tempDir = \"${tempPath}\\AWSPVDriver\"",
            "            $wc = New-Object \"System.Net.WebClient\"",
            "            $wc.Headers.Add(\"user-agent\", \"AWSSupport-UpgradeWindowsAWSDrivers\")",
            "            $wc.DownloadFile($url, $tempFile)",
            "            if (Test-Path $tempDir) {",
            "                Remove-Item -Path $tempDir -Recurse -Force",
            "            }",
            "",
            "            # Extract drivers",
            "            Expand-ZipFile -ZipFile $tempFile -Path $tempDir",
            "            # Check if Installed PV Drivers are RedHat and handle them, as they require special handling",
            "            if (Get-WmiObject win32_PnPSignedDriver | Where-Object { $_.DeviceClass -match \"SCSIAdapter\" -and $_.Manufacturer -match \"RedHat\" }) {",
            "                $isRedHat = $true",
            "                Write-Host \"RedHat PV drivers detected\"",
            "                # In case of RedhatPV, the installer will fail because upgrade is not supported",
            "                Write-Host \"Removing RedHat PV drivers\"",
            "                Uninstall-RedHatPV",
            "                # Create a scheduled task to run AWS PV installer at next boot",
            "                Write-Host \"Setting install script to run at next boot\"",
            "                Install-PVInstallTask -PVInstallerPath $tempDir",
            "                $exitCode = 3010 ",
            "            }",
            "            else {",
            "                # Run install.ps1",
            "                Write-Host \"Running install script\"",
            "                $exitCode = & \"${tempDir}\\install.ps1\" -Quiet -NoReboot -VerboseLogging",
            "            }",
            "",
            "            # Evaluate exit code",
            "            New-Item \"pv-state-{{ automation:EXECUTION_ID }}\" -ItemType file | Out-Null",
            "            if ($exitcode -ne 0 -and $exitcode -ne 3010) {",
            "                Write-Host \"Installation failed with code $exitcode.\"",
            "                Write-Output \"failure\" | Set-Content -Path \"pv-state-{{ automation:EXECUTION_ID }}\"",
            "                exit 1",
            "            }",
            "            else {",
            "                Write-Host \"Rebooting to complete installation.\"",
            "                if ($dsRepairMode) {",
            "                    if ($isRedHat) {",
            "                        Write-Output \"redhatdc\" | Set-Content -Path \"pv-state-{{ automation:EXECUTION_ID }}\"",
            "                    }",
            "                    else {",
            "                        Write-Output \"dsrepair\" | Set-Content -Path \"pv-state-{{ automation:EXECUTION_ID }}\"",
            "                    }",
            "                }",
            "                else {",
            "                    Write-Output \"success\" | Set-Content -Path \"pv-state-{{ automation:EXECUTION_ID }}\"",
            "                }",
            "                exit 3010",
            "            }",
            "        }",
            "    }",
            "    catch {",
            "        Write-Host $_.Exception.Message",
            "        exit 255",
            "    }",
            "#endregion"
          ]
        }
      },
      "isCritical": "true",
      "nextStep": "installAwsEnaNetworkDriverOnInstance"
    },
    {
      "name": "installAwsEnaNetworkDriverOnInstance",
      "action": "aws:runCommand",
      "description": "Installs the AWS Elastic Network Adapter (ENA) driver for Windows.",
      "onFailure": "Continue",
      "inputs": {
        "DocumentName": "AWS-RunPowerShellScript",
        "InstanceIds": [
          "{{ InstanceId }}"
        ],
        "Parameters": {
          "commands": [
            "try {",
            "    if (Test-Path -Path \"ena-state-{{ automation:EXECUTION_ID }}\") {",
            "        if (Select-String -Path \"ena-state-{{ automation:EXECUTION_ID }}\" -Pattern \"success\") {",
            "            Write-Host \"Installer has already run. Skipping installation\"",
            "            exit 0",
            "        }",
            "        else {",
            "            Write-Host \"Previous run of installer marked as failure. Skipping installation\"",
            "            exit 1",
            "        }",
            "    }",
            "    else {",
            "        # Determine OS Version",
            "        # Operating system                       Major    Minor",
            "        # Windows Server 2019                   10        0    ",
            "        # Windows Server 2016                   10        0    ",
            "        # Windows Server 2012 R2                 6        3",
            "        # Windows Server 2012                     6        2    ",
            "        # Windows Server 2008 R2                 6        1    ",
            "",
            "        $OSVersion = [System.Environment]::OSVersion.Version",
            "        $version = $OSVersion.Major.ToString() + \".\" + $OSVersion.Minor.ToString()",
            "        # Get Version of ntoskernel.exe to check for KB3033929",
            "        $ntoskrnlver = (Get-Item $env:systemroot\\system32\\ntoskrnl.exe).VersionInfo.ProductVersion",
            "        $KB3033929 = [System.Version]\"6.1.7601.22948\"",
            "        switch -regex ($version) {",
            "            \"6.1\" {",
            "                if ([System.Version]$ntoskrnlver -lt $KB3033929) {",
            "                    # 2.1.4 is the highest version that supports Windows Server 2008 R2 without KB3033929",
            "                    $url = \"https://s3.amazonaws.com/ec2-windows-drivers-downloads/ENA/2.1.4/AwsEnaNetworkDriver.zip\"",
            "                }",
            "                else {",
            "                    # 2.2.3 is the latest version that supports Windows Server 2008 R2",
            "                    $url = \"https://s3.amazonaws.com/ec2-windows-drivers-downloads/ENA/2.2.3/AwsEnaNetworkDriver.zip\"",
            "                }",
            "            } ",
            "            \"6.2|6.3|10.*\" {",
            "                $url = \"https://s3.amazonaws.com/ec2-windows-drivers-downloads/ENA/Latest/AwsEnaNetworkDriver.zip\"",
            "            }",
            "        }",
            "        $tempPath = (Resolve-Path ${env:temp}).Path",
            "        Write-Host \"Downloading AWS ENA drivers\"",
            "        $tempFile = \"${tempPath}\\AwsEnaNetworkDriver.zip\"",
            "        $tempDir = \"${tempPath}\\AwsEnaNetworkDriver\"",
            "        $wc = New-Object \"System.Net.WebClient\"",
            "        $wc.Headers.Add(\"user-agent\", \"AWSSupport-UpgradeWindowsAWSDrivers\")",
            "        $wc.DownloadFile($url, $tempFile)",
            "        if (Test-Path $tempDir) {",
            "            Remove-Item -Path $tempDir -Recurse -Force",
            "        }",
            "",
            "        # Extract drivers",
            "        try {",
            "            # Unpacking the file this way is not supported in PowerShell 2",
            "            Add-Type -AssemblyName System.IO.Compression.FileSystem -ErrorAction SilentlyContinue",
            "            [System.IO.Compression.ZipFile]::ExtractToDirectory($tempFile, $tempDir)",
            "        }",
            "        catch [System.InvalidOperationException] {",
            "            # Legacy unpacking method using COM Object",
            "            # Works with PowerShell 2",
            "            New-Item -Path $tempDir -ItemType \"directory\" -Force | Out-Null",
            "            ((New-Object -com shell.application).NameSpace($tempDir)).CopyHere(((New-Object -com shell.application).NameSpace($tempFile)).Items())",
            "        }",
            "",
            "        # Run install.ps1",
            "        Write-Host \"Running install script\"",
            "        $output = & \"${tempDir}\\install.ps1\" -NoReboot",
            "        Write-Host $output",
            "",
            "        # Evaluate output",
            "        New-Item \"ena-state-{{ automation:EXECUTION_ID }}\" -ItemType file | Out-Null",
            "        if ($output -match \"successful\") {",
            "            if ($output -match \"reboot\") {",
            "                Write-Host \"Rebooting to complete installation\"",
            "                Write-Output \"success\" | Set-Content -Path \"ena-state-{{ automation:EXECUTION_ID }}\"",
            "                exit 3010",
            "            }",
            "            Write-Output \"success\" | Set-Content -Path \"ena-state-{{ automation:EXECUTION_ID }}\"",
            "            exit 0",
            "        }",
            "        else {",
            "            Write-Output \"failure\" | Set-Content -Path \"ena-state-{{ automation:EXECUTION_ID }}\"",
            "            exit 1",
            "        }",
            "    }",
            "}",
            "catch {",
            "    Write-Host $_.Exception.Message",
            "    exit 255",
            "}"
          ]
        }
      },
      "isCritical": "true",
      "isEnd": "true"
    },
    {
      "name": "assertAllowOffline",
      "action": "aws:assertAwsResourceProperty",
      "description": "Verifies if the 'AllowOffline' flag is set to true. If so, the offline upgrade starts, otherwise the automation ends.",
      "onFailure": "Abort",
      "inputs": {
        "Service": "ssm",
        "Api": "GetAutomationExecution",
        "AutomationExecutionId": "{{ automation:EXECUTION_ID }}",
        "PropertySelector": "$.AutomationExecution.Parameters.AllowOffline[0]",
        "DesiredValues": [
          "True"
        ]
      },
      "isCritical": "true",
      "nextStep": "stopInstance"
    },
    {
      "name": "stopInstance",
      "action": "aws:changeInstanceState",
      "description": "Stops the source EC2 instance.",
      "onFailure": "Continue",
      "inputs": {
        "InstanceIds": [
          "{{ InstanceId }}"
        ],
        "CheckStateOnly": false,
        "DesiredState": "stopped"
      },
      "isCritical": "false",
      "nextStep": "forceStopInstance"
    },
    {
      "name": "forceStopInstance",
      "action": "aws:changeInstanceState",
      "description": "Forces-stop the source EC2 instance.",
      "onFailure": "Abort",
      "inputs": {
        "InstanceIds": [
          "{{ InstanceId }}"
        ],
        "CheckStateOnly": false,
        "DesiredState": "stopped",
        "Force": true
      },
      "isCritical": "true",
      "nextStep": "preOfflineUpgradeBackup"
    },
    {
      "name": "preOfflineUpgradeBackup",
      "action": "aws:createImage",
      "description": "Creates an Amazon Machine Image (AMI) backup of the source EC2 instance.",
      "onFailure": "Abort",
      "inputs": {
        "InstanceId": "{{ InstanceId }}",
        "ImageDescription": "Pre-upgrade Backup AMI Generated by Automation on {{ global:DATE_TIME }} from {{ InstanceId }}.",
        "NoReboot": false,
        "ImageName": "UpgradeWindowsAWSDrivers-Pre-Script-Backup_{{ InstanceId }}_{{ global:DATE_TIME }}"
      },
      "outputs": [
        {
          "Name": "BackupImageId",
          "Selector": "$.ImageId",
          "Type": "String"
        }
      ],
      "isCritical": "true",
      "nextStep": "tagPreOfflineUpgradeBackup"
    },
    {
      "name": "tagPreOfflineUpgradeBackup",
      "action": "aws:createTags",
      "description": "Tags the Amazon Machine Image (AMI) backup of the source EC2 instance.",
      "onFailure": "Continue",
      "inputs": {
        "ResourceType": "EC2",
        "ResourceIds": [
          "{{ preOfflineUpgradeBackup.BackupImageId }}"
        ],
        "Tags": [
          {
            "Key": "Name",
            "Value": "AWSSupport-UpgradeWindowsAWSDrivers: {{ InstanceId }}"
          },
          {
            "Key": "AWSSupport-UpgradeWindowsAWSDrivers-AutomationExecution",
            "Value": "{{ automation:EXECUTION_ID }}"
          }
        ]
      },
      "isCritical": "false",
      "nextStep": "assertPreOfflineUpgradeBackup"
    },
    {
      "name": "assertPreOfflineUpgradeBackup",
      "action": "aws:waitForAwsResourceProperty",
      "description": "Verifies the Amazon Machine Image (AMI) backup of the source EC2 instance is in 'available' state.",
      "onFailure": "Abort",
      "inputs": {
        "Service": "ec2",
        "Api": "DescribeImages",
        "Filters": [
          {
            "Name": "image-id",
            "Values": [
              "{{ preOfflineUpgradeBackup.BackupImageId }}"
            ]
          }
        ],
        "PropertySelector": "$.Images[0].State",
        "DesiredValues": [
          "available"
        ]
      },
      "isCritical": "true",
      "nextStep": "enableEnaSupport"
    },
    {
      "name": "enableEnaSupport",
      "onFailure": "Continue",
      "action": "aws:executeAwsApi",
      "description": "Enables enhanced networking with the Elastic Network Adapter (ENA) for the instance.",
      "inputs": {
        "Service": "ec2",
        "Api": "ModifyInstanceAttribute",
        "InstanceId": "{{ InstanceId }}",
        "EnaSupport": {
          "Value": true
        }
      },
      "isCritical": "true",
      "nextStep": "branchOnForceUpgrade"
    },
    {
      "name": "branchOnForceUpgrade",
      "action": "aws:branch",
      "description": "Asserts the 'ForceUpgrade' flag.",
      "onFailure": "step:startInstance",
      "inputs": {
        "Choices": [
          {
            "NextStep": "upgradeDriversOffline",
            "Variable": "{{ ForceUpgrade }}",
            "StringEquals": "False"
          },
          {
            "NextStep": "forceUpgradeDriversOffline",
            "Variable": "{{ ForceUpgrade }}",
            "StringEquals": "True"
          }
        ]
      },
      "isCritical": "true"
    },
    {
      "name": "upgradeDriversOffline",
      "onFailure": "Continue",
      "action": "aws:executeAutomation",
      "description": "If 'ForceUpgrade' = 'true' then run aws:executeAutomation to invoke AWSSupport-StartEC2RescueWorkflow with the drivers force upgrade script. This installs the drivers regardless of the current version that is installed.",
      "inputs": {
        "RuntimeParameters": {
          "InstanceId": [
            "{{ InstanceId }}"
          ],
          "EC2RescueInstanceType": [
            "t2.large"
          ],
          "OfflineScript": [
            "IyBPcGVyYXRpbmcgc3lzdGVtCSAgICAgICAgICAgICAgICAgICBNYWpvcglNaW5vcg0KIyBXaW5kb3dzIFNlcnZlciAyMDA4IFIyCSAgICAgICAgICAgICA2CSAgICAxCQ0KIyBXaW5kb3dzIFNlcnZlciAyMDA4CSAgICAgICAgICAgICAgICAgNgkgICAgMAkNCiMgV2luZG93cyBTZXJ2ZXIgMjAwMyBSMgkgICAgICAgICAgICAgNQkgICAgMg0KDQokQVdTUFZWZXJzaW9uPSJMYXRlc3QiDQokRU5BVmVyc2lvbj0iTGF0ZXN0Ig0KJE5WTUVWZXJzaW9uPSJMYXRlc3QiDQokS0IzMDMzOTI5ID0gW1N5c3RlbS5WZXJzaW9uXSI2LjEuNzYwMS4yMjk0OCINCiRUYXJnZXRWZXJzaW9uID0gW1N5c3RlbS5WZXJzaW9uXSRlbnY6RUMyUkVTQ1VFX09GRkxJTkVfS0VSTkVMX1ZFUg0KaWYgKFtTeXN0ZW0uVmVyc2lvbl06Om5ldygkVGFyZ2V0VmVyc2lvbi5NYWpvciwkVGFyZ2V0VmVyc2lvbi5NaW5vcikgLWxlIFtTeXN0ZW0uVmVyc2lvbl06Om5ldyg2LDEpKSB7DQogICAgV3JpdGUtSG9zdCAiUmV2ZXJ0aW5nIGJhY2sgdG8gdGhlIGxhdGVzdCBjb21wYXRpYmxlIGRyaXZlciB2ZXJzaW9ucyINCiAgICBXcml0ZS1Ib3N0ICJSZXZlcnRpbmcgdG8gTlZNRSBkcml2ZXJzIHZlcnNpb24gMS4zLjIiDQogICAgJE5WTUVWZXJzaW9uPSIxLjMuMiINCiAgICBpZiAoJFRhcmdldFZlcnNpb24gLWx0ICRLQjMwMzM5Mjkpew0KICAgICAgICBXcml0ZS1Ib3N0ICJPcGVyYXRpbmcgU3lzdGVtIGlzIG1pc3NpbmcgS0IzMDMzOTI5LiINCiAgICAgICAgIyA4LjMuMiBpcyB0aGUgaGlnaGVzdCBBV1MgUFYgdmVyc2lvbiB0aGF0IHN1cHBvcnRzIFdpbmRvd3MgU2VydmVyIDIwMDggUjIgd2l0aG91dCBLQjMwMzM5MjkNCiAgICAgICAgV3JpdGUtSG9zdCAiUmV2ZXJ0aW5nIHRvIEFXUyBQViBkcml2ZXJzIHZlcnNpb24gOC4zLjIiDQogICAgICAgICRBV1NQVlZlcnNpb249IjguMy4yIg0KICAgICAgICAjIDIuMS40IGlzIHRoZSBoaWdoZXN0IEVOQSB2ZXJzaW9uIHRoYXQgc3VwcG9ydHMgV2luZG93cyBTZXJ2ZXIgMjAwOCBSMiB3aXRob3V0IEtCMzAzMzkyOQ0KICAgICAgICBXcml0ZS1Ib3N0ICJSZXZlcnRpbmcgdG8gRU5BIGRyaXZlcnMgdmVyc2lvbiAyLjEuNCINCiAgICAgICAgJEVOQVZlcnNpb249IjIuMS40Ig0KICAgIH0NCiAgICBlbHNlIHsNCiAgICAgICAgIyA4LjMuNSBpcyB0aGUgbGF0ZXN0IEFXUyBQViB2ZXJzaW9uIHRoYXQgc3VwcG9ydHMgV2luZG93cyBTZXJ2ZXIgMjAwOCBSMg0KICAgICAgICBXcml0ZS1Ib3N0ICJSZXZlcnRpbmcgdG8gQVdTIFBWIGRyaXZlcnMgdmVyc2lvbiA4LjMuNSINCiAgICAgICAgJEFXU1BWVmVyc2lvbj0iOC4zLjUiDQogICAgICAgICMgMi4yLjMgaXMgdGhlIGxhdGVzdCBFTkEgdmVyc2lvbiB0aGF0IHN1cHBvcnRzIFdpbmRvd3MgU2VydmVyIDIwMDggUjINCiAgICAgICAgV3JpdGUtSG9zdCAiUmV2ZXJ0aW5nIHRvIEVOQSBkcml2ZXJzIHZlcnNpb24gMi4yLjMiDQogICAgICAgICRFTkFWZXJzaW9uPSIyLjIuMyINCiAgICB9DQp9DQoNClNldC1Cb290RHJpdmVyc0tleSAtV2luZG93c0luc3RhbGxEYXRhICRzY3JpcHQ6RUMyUkVTQ1VFX09GRkxJTkVfV0lORE9XU19JTlNUQUxMDQpJbnN0YWxsLVBWRHJpdmVycyAtV2luZG93c0luc3RhbGxEYXRhICRzY3JpcHQ6RUMyUkVTQ1VFX09GRkxJTkVfV0lORE9XU19JTlNUQUxMIC1BV1NQVlZlcnNpb24gJEFXU1BWVmVyc2lvbg0KSW5zdGFsbC1OaXRyb0RyaXZlcnMgLVdpbmRvd3NJbnN0YWxsRGF0YSAkc2NyaXB0OkVDMlJFU0NVRV9PRkZMSU5FX1dJTkRPV1NfSU5TVEFMTCAtRU5BVmVyc2lvbiAkRU5BVmVyc2lvbiAgLU5WTUVWZXJzaW9uICROVk1FVmVyc2lvbg=="
          ],
          "SubnetId": [
            "{{ SubnetId }}"
          ],
          "UniqueId": "{{ automation:EXECUTION_ID }}"
        },
        "DocumentName": "AWSSupport-StartEC2RescueWorkflow"
      },
      "isCritical": "true",
      "nextStep": "startInstance"
    },
    {
      "name": "forceUpgradeDriversOffline",
      "onFailure": "Continue",
      "action": "aws:executeAutomation",
      "description": "If 'ForceUpgrade' = 'false' then run aws:executeAutomation to invoke AWSSupport-StartEC2RescueWorkflow with the drivers upgrade script.",
      "inputs": {
        "RuntimeParameters": {
          "InstanceId": [
            "{{ InstanceId }}"
          ],
          "EC2RescueInstanceType": [
            "t2.large"
          ],
          "OfflineScript": [
            "JEFXU1BWVmVyc2lvbj0iTGF0ZXN0Ig0KJEVOQVZlcnNpb249IkxhdGVzdCINCiROVk1FVmVyc2lvbj0iTGF0ZXN0Ig0KJEtCMzAzMzkyOSA9IFtTeXN0ZW0uVmVyc2lvbl0iNi4xLjc2MDEuMjI5NDgiDQppZiAoW1N5c3RlbS5WZXJzaW9uXSRlbnY6RUMyUkVTQ1VFX09GRkxJTkVfS0VSTkVMX1ZFUiAtbGUgW1N5c3RlbS5WZXJzaW9uXTo6bmV3KDYsMSkpIHsNCiAgICBXcml0ZS1Ib3N0ICJSZXZlcnRpbmcgYmFjayB0byB0aGUgbGF0ZXN0IGNvbXBhdGlibGUgZHJpdmVyIHZlcnNpb25zIg0KICAgIFdyaXRlLUhvc3QgIlJldmVydGluZyB0byBOVk1FIGRyaXZlcnMgdmVyc2lvbiAxLjMuMiINCiAgICAkTlZNRVZlcnNpb249IjEuMy4yIg0KICAgIGlmIChbU3lzdGVtLlZlcnNpb25dJGVudjpFQzJSRVNDVUVfT0ZGTElORV9LRVJORUxfVkVSIC1sdCAkS0IzMDMzOTI5KXsNCiAgICAgICAgV3JpdGUtSG9zdCAiT3BlcmF0aW5nIFN5c3RlbSBpcyBtaXNzaW5nIEtCMzAzMzkyOS4iDQogICAgICAgICMgOC4zLjIgaXMgdGhlIGhpZ2hlc3QgQVdTIFBWIHZlcnNpb24gdGhhdCBzdXBwb3J0cyBXaW5kb3dzIFNlcnZlciAyMDA4IFIyIHdpdGhvdXQgS0IzMDMzOTI5DQogICAgICAgIFdyaXRlLUhvc3QgIlJldmVydGluZyB0byBBV1MgUFYgZHJpdmVycyB2ZXJzaW9uIDguMy4yIg0KICAgICAgICAkQVdTUFZWZXJzaW9uPSI4LjMuMiINCiAgICAgICAgIyAyLjEuNCBpcyB0aGUgaGlnaGVzdCBFTkEgdmVyc2lvbiB0aGF0IHN1cHBvcnRzIFdpbmRvd3MgU2VydmVyIDIwMDggUjIgd2l0aG91dCBLQjMwMzM5MjkNCiAgICAgICAgV3JpdGUtSG9zdCAiUmV2ZXJ0aW5nIHRvIEVOQSBkcml2ZXJzIHZlcnNpb24gMi4xLjQiDQogICAgICAgICRFTkFWZXJzaW9uPSIyLjEuNCINCiAgICB9DQogICAgZWxzZSB7DQogICAgICAgICMgOC4zLjUgaXMgdGhlIGxhdGVzdCBBV1MgUFYgdmVyc2lvbiB0aGF0IHN1cHBvcnRzIFdpbmRvd3MgU2VydmVyIDIwMDggUjINCiAgICAgICAgV3JpdGUtSG9zdCAiUmV2ZXJ0aW5nIHRvIEFXUyBQViBkcml2ZXJzIHZlcnNpb24gOC4zLjUiDQogICAgICAgICRBV1NQVlZlcnNpb249IjguMy41Ig0KICAgICAgICAjIDIuMi4zIGlzIHRoZSBsYXRlc3QgRU5BIHZlcnNpb24gdGhhdCBzdXBwb3J0cyBXaW5kb3dzIFNlcnZlciAyMDA4IFIyDQogICAgICAgIFdyaXRlLUhvc3QgIlJldmVydGluZyB0byBFTkEgZHJpdmVycyB2ZXJzaW9uIDIuMi4zIg0KICAgICAgICAkRU5BVmVyc2lvbj0iMi4yLjMiDQogICAgfQ0KfQ0KDQpTZXQtQm9vdERyaXZlcnNLZXkgLVdpbmRvd3NJbnN0YWxsRGF0YSAkc2NyaXB0OkVDMlJFU0NVRV9PRkZMSU5FX1dJTkRPV1NfSU5TVEFMTA0KSW5zdGFsbC1QVkRyaXZlcnMgLVdpbmRvd3NJbnN0YWxsRGF0YSAkc2NyaXB0OkVDMlJFU0NVRV9PRkZMSU5FX1dJTkRPV1NfSU5TVEFMTCAtQVdTUFZWZXJzaW9uICRBV1NQVlZlcnNpb24gLUZvcmNlDQpJbnN0YWxsLU5pdHJvRHJpdmVycyAtV2luZG93c0luc3RhbGxEYXRhICRzY3JpcHQ6RUMyUkVTQ1VFX09GRkxJTkVfV0lORE9XU19JTlNUQUxMIC1FTkFWZXJzaW9uICRFTkFWZXJzaW9uICAtTlZNRVZlcnNpb24gJE5WTUVWZXJzaW9uIC1Gb3JjZQ=="
          ],
          "SubnetId": [
            "{{ SubnetId }}"
          ],
          "UniqueId": "{{ automation:EXECUTION_ID }}"
        },
        "DocumentName": "AWSSupport-StartEC2RescueWorkflow"
      },
      "isCritical": "true",
      "nextStep": "startInstance"
    },
    {
      "name": "startInstance",
      "action": "aws:changeInstanceState",
      "description": "Starts the EC2 instance.",
      "onFailure": "Abort",
      "inputs": {
        "InstanceIds": [
          "{{ InstanceId }}"
        ],
        "CheckStateOnly": false,
        "DesiredState": "running"
      },
      "isCritical": "true",
      "isEnd": "true"
    }
  ],
  "outputs": [
    "preUpgradeBackup.BackupImageId",
    "preOfflineUpgradeBackup.BackupImageId",
    "installAwsEnaNetworkDriverOnInstance.Output",
    "installAWSNVMeOnInstance.Output",
    "installAWSPVDriverOnInstance.Output",
    "upgradeDriversOffline.Output",
    "forceUpgradeDriversOffline.Output"
  ]
}
