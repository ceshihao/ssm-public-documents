{
  "schemaVersion": "0.3",
  "description": "The **AWSSupport-UpgradeWindowsAWSDrivers** automation runbook upgrades or repairs storage and network AWS drivers on the specified Windows Amazon Elastic Compute Cloud (Amazon EC2) instance. The document attempts to install the latest supported versions of AWS drivers online by using the SSM agent. If the SSM agent is not contactable, the document can perform an offline installation of the AWS drivers if explicitly requested. **Note:** Both the online and offline upgrade will create an Amazon Machine Image (AMI) backup before attempting any operations, which will persist after the automation completes. It is your responsibility to secure access to the AMI, or to delete it. The online method restarts the instance as part of the upgrade process, while the offline method requires the provided EC2 instance be stopped and then started.",
  "assumeRole": "{{ AutomationAssumeRole }}",
  "parameters": {
    "AutomationAssumeRole": {
      "type": "AWS::IAM::Role::Arn",
      "description": "(Optional) The Amazon Resource Name (ARN) of the AWS Identity and Access Management (IAM) role that allows Systems Manager Automation to perform the actions on your behalf. If no role is specified, Systems Manager Automation uses the permissions of the user that starts this runbook.",
      "default": ""
    },
    "InstanceId": {
      "type": "AWS::EC2::Instance::Id",
      "description": "(Required) The ID of your EC2 Windows instance.",
      "allowedPattern": "^i-[a-z0-9]{8,17}$"
    },
    "ForceOffline": {
      "type": "String",
      "description": "(Optional) Set it to `True` to force the offline drivers upgrade regardless of the instance's online status. When set to `True`, the automation will skip the online installation attempt and proceed directly to the offline method.",
      "default": "False",
      "allowedValues": [
        "True",
        "False"
      ]
    },
    "AllowOffline": {
      "type": "String",
      "description": "(Optional) Set it to `True` if you allow an offline drivers upgrade in case the online installation cannot be performed. **Note:** The offline method requires the provided EC2 instance be stopped and then started. Data stored in instance store volumes will be lost. The public IP address will change if you are not using an Elastic IP.",
      "default": "False",
      "allowedValues": [
        "True",
        "False"
      ]
    },
    "SubnetId": {
      "type": "String",
      "description": "(Optional) Offline only - The subnet ID for the EC2Rescue instance used to perform the offline drivers upgrade. If you specify `CreateNewVPC`, AWS Systems Manager Automation will create a new Amazon Virtual Private Cloud (Amazon VPC). IMPORTANT: The subnet must be in the same availability zone as the `InstanceId`, and it must allow access to the AWS Systems Manager endpoints.",
      "default": "SelectedInstanceSubnet",
      "allowedPattern": "^SelectedInstanceSubnet$|^CreateNewVPC$|^subnet-[a-z0-9]{8,17}$"
    },
    "ForceUpgrade": {
      "type": "String",
      "description": "(Optional) Offline only - Set it to `True` if you allow the offline drivers upgrade to proceed even though your instance already has the latest drivers installed.",
      "default": "False",
      "allowedValues": [
        "True",
        "False"
      ]
    },
    "EC2RescueInstanceType": {
      "type": "String",
      "description": "(Optional) The EC2 instance type for the EC2Rescue instance (for `offline` installation).",
      "default": "t3.large",
      "allowedValues": [
        "t2.small",
        "t2.medium",
        "t2.large",
        "t3.small",
        "t3.medium",
        "t3.large",
        "i3.large"
      ]
    },
    "EC2RescueInstanceProfileName": {
      "type": "String",
      "description": "(Conditional) The name of an existing IAM instance profile for the EC2Rescue instance. If an IAM instance profile is not specified, the automation creates one on your behalf.",
      "default": "",
      "allowedPattern": "^$|^[\\w+=,.@-]{1,128}$"
    }
  },
  "mainSteps": [
    {
      "name": "assertInstanceIsWindows",
      "action": "aws:assertAwsResourceProperty",
      "description": "Verifies the input EC2 instance is Windows.",
      "onFailure": "Abort",
      "inputs": {
        "Service": "ec2",
        "Api": "DescribeInstances",
        "InstanceIds": [
          "{{ InstanceId }}"
        ],
        "PropertySelector": "$.Reservations[0].Instances[0].Platform",
        "DesiredValues": [
          "windows"
        ]
      },
      "isCritical": true,
      "nextStep": "describeManagedInstance"
    },
    {
      "name": "describeManagedInstance",
      "action": "aws:executeAwsApi",
      "description": "Verifies the input EC2 instance is managed by AWS Systems Manager.",
      "onFailure": "Abort",
      "inputs": {
        "Service": "ssm",
        "Api": "DescribeInstanceInformation",
        "InstanceInformationFilterList": [
          {
            "key": "InstanceIds",
            "valueSet": [
              "{{ InstanceId }}"
            ]
          }
        ]
      },
      "outputs": [
        {
          "Name": "PingStatus",
          "Selector": "$.InstanceInformationList[0].PingStatus"
        }
      ],
      "isCritical": true,
      "nextStep": "branchOnManagedInstancePingStatus"
    },
    {
      "name": "branchOnManagedInstancePingStatus",
      "action": "aws:branch",
      "description": "Branches the workflow based on whether the EC2 instance is managed by AWS Systems Manager or not, and if ForceOffline is set to True. If ForceOffline is True, it will go directly to BranchOnAllowOffline. If the instance is online and ForceOffline is False, the online upgrade starts, otherwise the offline upgrade is evaluated.",
      "onFailure": "Abort",
      "inputs": {
        "Choices": [
          {
            "NextStep": "BranchOnAllowOffline",
            "Variable": "{{ ForceOffline }}",
            "StringEquals": "True"
          },
          {
            "NextStep": "preUpgradeBackup",
            "Variable": "{{ describeManagedInstance.PingStatus }}",
            "StringEquals": "Online"
          }
        ],
        "Default": "BranchOnAllowOffline"
      },
      "isCritical": true,
      "nextStep": "BranchOnAllowOffline"
    },
    {
      "name": "preUpgradeBackup",
      "action": "aws:createImage",
      "description": "Creates an Amazon Machine Image (AMI) backup. This step reboots the instance so that it can take snapshots of the attached volumes while data is at rest, in order to ensure a consistent state.",
      "onFailure": "Abort",
      "inputs": {
        "InstanceId": "{{ InstanceId }}",
        "ImageDescription": "Pre-Upgrade Backup AMI Generated by Automation on {{ global:DATE_TIME }} from {{ InstanceId }}.",
        "NoReboot": false,
        "ImageName": "AWSSupport-Pre-Upgrade-Backup_{{ InstanceId }}_{{ global:DATE_TIME }}"
      },
      "outputs": [
        {
          "Name": "BackupImageId",
          "Selector": "$.ImageId",
          "Type": "String"
        }
      ],
      "isCritical": true,
      "nextStep": "tagPreUpgradeBackup"
    },
    {
      "name": "tagPreUpgradeBackup",
      "action": "aws:createTags",
      "description": "Tags the Amazon Machine Image (AMI) backup.",
      "onFailure": "Continue",
      "inputs": {
        "ResourceIds": [
          "{{ preUpgradeBackup.BackupImageId }}"
        ],
        "Tags": [
          {
            "Key": "Name",
            "Value": "AWSSupport-UpgradeWindowsAWSDrivers: {{ InstanceId }}"
          },
          {
            "Key": "AWSSupport-UpgradeWindowsAWSDrivers-AutomationExecution",
            "Value": "{{ automation:EXECUTION_ID }}"
          }
        ],
        "ResourceType": "EC2"
      },
      "isCritical": false,
      "nextStep": "assertpreUpgradeBackup"
    },
    {
      "name": "assertpreUpgradeBackup",
      "action": "aws:waitForAwsResourceProperty",
      "description": "Verifies the Amazon Machine Image (AMI) backup is in `available` state.",
      "onFailure": "Abort",
      "inputs": {
        "Service": "ec2",
        "Api": "DescribeImages",
        "Filters": [
          {
            "Name": "image-id",
            "Values": [
              "{{ preUpgradeBackup.BackupImageId }}"
            ]
          }
        ],
        "PropertySelector": "$.Images[0].State",
        "DesiredValues": [
          "available"
        ]
      },
      "isCritical": true,
      "nextStep": "installAWSNVMeOnInstance"
    },
    {
      "name": "installAWSNVMeOnInstance",
      "action": "aws:runCommand",
      "description": "Installs the AWS NVMe driver for Windows.",
      "onFailure": "Continue",
      "inputs": {
        "DocumentName": "AWS-RunPowerShellScript",
        "InstanceIds": [
          "{{ InstanceId }}"
        ],
        "Parameters": {
          "commands": [
            "try {",
            "    if (Test-Path -Path \"nvme-state-{{ automation:EXECUTION_ID }}\") {",
            "        if (Select-String -Path \"nvme-state-{{ automation:EXECUTION_ID }}\" -Pattern \"success\") {",
            "            Write-Host \"Installer has already run. Skipping installation\"",
            "            exit 0",
            "        }",
            "        else {",
            "            Write-Host \"Previous run of installer marked as failure. Skipping installation\"",
            "            exit 1",
            "        }",
            "    }",
            "    else {",
            "        $region = \"{{ global:REGION }}\"",
            "        $s3Endpoint = switch -Regex ($region){",
            "            \"^us-iso-\" {\"https://s3.$region.c2s.ic.gov\"}",
            "            \"^us-isob-\" {\"https://s3.$region.sc2s.sgov.gov\"}",
            "            \"^us-isof-\" {\"https://s3.$region.csp.hci.ic.gov\"}",
            "            \"^eu-isoe-\" {\"https://s3.$region.cloud.adc-e.uk\"}",
            "            default {\"https://s3.amazonaws.com\"}",
            "        }",
            "        $OSVersion = [System.Environment]::OSVersion.Version",
            "        $version = $OSVersion.Major.ToString() + \".\" + $OSVersion.Minor.ToString()",
            "        switch -regex ($version) {",
            "            \"6.1\" {",
            "                # 1.3.2 is the latest version that supports Windows Server 2008 R2",
            "                $url = \"$s3Endpoint/ec2-windows-drivers-downloads/NVMe/1.3.2/AWSNVMe.zip\"",
            "            }",
            "            # Windows Server 2012 and 2012 R2",
            "            \"6.2|6.3\" {",
            "                $url = \"$s3Endpoint/ec2-windows-drivers-downloads/NVMe/1.5.1/AWSNVMe.zip\"",
            "            }",
            "            # Windows Server 2016, 2019, 2022, 2025",
            "            \"10.*\" {",
            "                $url = \"$s3Endpoint/ec2-windows-drivers-downloads/NVMe/Latest/AWSNVMe.zip\"",
            "            }",
            "        }",
            "",
            "        [System.Net.ServicePointManager]::SecurityProtocol = ([int][system.net.SecurityProtocolType]::Tls13 -bor [int][system.net.SecurityProtocolType]::Tls12)",
            "        $attemptCount = 1",
            "        $maxAttempts = 5",
            "",
            "        $tempPath = (Resolve-Path ${env:temp}).Path",
            "        Write-Host \"Downloading AWS NVMe drivers\"",
            "        $tempFile = \"${tempPath}\\AWSNVMe.zip\"",
            "        $tempDir = \"${tempPath}\\AWSNVMe\"",
            "        $wc = New-Object \"System.Net.WebClient\"",
            "        $wc.Headers.Add(\"user-agent\", \"AWSSupport-UpgradeWindowsAWSDrivers\")",
            "",
            "        Do {",
            "            Write-Host \"Downloading AWSNVMe.zip, attempt: $attemptCount/$maxAttempts...\"",
            "            try {",
            "                $wc.DownloadFile($url, $tempFile)",
            "                if (Test-Path $tempFile) {",
            "                    Write-Host \"Download successful.\"",
            "                    break",
            "                }",
            "            }",
            "            catch {",
            "                Write-Host \"Download failed: $_. Retrying...\"",
            "            }",
            "",
            "            $attemptCount++",
            "            Start-Sleep -Seconds ($attemptCount * 1)",
            "        } While (($attemptCount -le $maxAttempts) -and (-not (Test-Path $tempFile)))",
            "",
            "        if (-not (Test-Path $tempFile)) {",
            "            throw \"Failed to download AWSNVMe.zip after $maxAttempts attempts.\"",
            "        }",
            "",
            "        if (Test-Path $tempDir) {",
            "            Remove-Item -Path $tempDir -Recurse -Force",
            "        }",
            "",
            "        # Extract drivers",
            "        try {",
            "            # Unpacking the file this way is not supported in PowerShell 2",
            "            Add-Type -AssemblyName System.IO.Compression.FileSystem -ErrorAction SilentlyContinue",
            "            [System.IO.Compression.ZipFile]::ExtractToDirectory($tempFile, $tempDir)",
            "        }",
            "        catch [System.InvalidOperationException] {",
            "            # Legacy unpacking method using COM Object",
            "            # Works with PowerShell 2",
            "            New-Item -Path $tempDir -ItemType \"directory\" -Force | Out-Null",
            "            ((New-Object -com shell.application).NameSpace($tempDir)).CopyHere(((New-Object -com shell.application).NameSpace($tempFile)).Items())",
            "        }",
            "",
            "        # Create the folder ProgramData\\Amazon\\Tools if it does not exist",
            "        # If this directory is missing there might be issues with the driver installation script",
            "        $nvmetoolPath=\"${env:ProgramData}\\Amazon\\Tools\"",
            "        if (-Not (Test-Path -Path $nvmetoolPath)) {",
            "            New-Item -Path $nvmetoolPath -ItemType \"directory\" -Force | Out-Null",
            "        }",
            "",
            "        # Run install.ps1",
            "        Write-Host \"Running install script\"",
            "        $output = & \"${tempDir}\\install.ps1\" -NoReboot",
            "        Write-Host $output",
            "",
            "        # First check the explicit return value (1.5.1 version)",
            "        # Then fall back to LASTEXITCODE (latest version)",
            "        $result = 1  # Default to failure",
            "        if ($output -eq 0 -or $output -eq 3010) {",
            "            # 1.5.1 version - using return value",
            "            # https://tiny.amazon.com/1eh69pqth/EC2-Windows-AWSNVMe-Package-115",
            "            $result = $output",
            "        } elseif ($global:LASTEXITCODE -eq 0 -or $global:LASTEXITCODE -eq 3010) {",
            "            # latest version - using LASTEXITCODE",
            "            # https://tiny.amazon.com/2wxhi6en/EC2-Windows-AWSNVMe-Package-Latest",
            "            $result = $global:LASTEXITCODE",
            "        }",
            "",
            "        if ($result -eq 0) {",
            "            $result = 0",
            "        } elseif ($result -eq 3010) {",
            "            # Reboot required to complete installation",
            "            $result = 3010",
            "        }",
            "",
            "        # Handling drivers reflection: https://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/migrating-latest-types.html#upgrade-nvme",
            "        # Driver reflection is required only for Windows Server 2008 R2 and Windows Server 2012 instances",
            "        $allowedWinVer = $false",
            "        $osVer = [System.Environment]::OSVersion.Version",
            "        if ($osVer.Major -eq 6) {",
            "            $allowedMinor = @(1, 2)",
            "            if ($allowedMinor -contains $osVer.Minor) {",
            "                $allowedWinVer = $true",
            "            }",
            "        }",
            "        if ($allowedWinVer) {",
            "            # Checking instance type architecture to ensure it is not a Nitro instance type",
            "            $allowedInstanceType = $false",
            "            $ErrorActionPreference = \"stop\"",
            "            try {",
            "                $systemVersion = (Get-ItemProperty -Path HKLM:\\HARDWARE\\DESCRIPTION\\System\\BIOS -Name SystemVersion).SystemVersion",
            "                $systemManufacturer = (Get-ItemProperty -Path HKLM:\\HARDWARE\\DESCRIPTION\\System\\BIOS -Name SystemManufacturer).SystemManufacturer",
            "            }",
            "            catch [System.Management.Automation.PSArgumentException] {}",
            "            finally { $ErrorActionPreference = \"Continue\" }",
            "            if (($systemVersion -match \"amazon\") -and ($systemManufacturer -match \"Xen\")) {",
            "                $allowedInstanceType = $true",
            "            }",
            "            if ($allowedInstanceType) {",
            "                Write-Host \"Reflecting Boot Critical drivers\"",
            "                Start-Process -PassThru -Wait -FilePath \"$env:systemroot\\System32\\rundll32.exe\" -ArgumentList \"sppnp.dll,Sysprep_Generalize_Pnp\" | Out-Null",
            "            }",
            "        }",
            "",
            "        New-Item \"nvme-state-{{ automation:EXECUTION_ID }}\" -ItemType file | Out-Null",
            "",
            "        if ($result -eq 0) {",
            "            Write-Output \"success\" | Set-Content -Path \"nvme-state-{{ automation:EXECUTION_ID }}\"",
            "            exit 0",
            "        }",
            "        elseif ($result -eq 3010) {",
            "            Write-Host \"Rebooting to complete installation\"",
            "            Write-Output \"success\" | Set-Content -Path \"nvme-state-{{ automation:EXECUTION_ID }}\"",
            "            exit 3010",
            "        }",
            "        else {",
            "            Write-Output \"failure\" | Set-Content -Path \"nvme-state-{{ automation:EXECUTION_ID }}\"",
            "            exit 1",
            "        }",
            "    }",
            "}",
            "catch {",
            "    Write-Host $_.Exception.Message",
            "    exit 255",
            "}"
          ]
        }
      },
      "isCritical": true,
      "nextStep": "installAWSPVDriverOnInstance"
    },
    {
      "name": "installAWSPVDriverOnInstance",
      "action": "aws:runCommand",
      "description": "Installs the AWS PV driver for Windows.",
      "onFailure": "Abort",
      "inputs": {
        "DocumentName": "AWS-RunPowerShellScript",
        "InstanceIds": [
          "{{ InstanceId }}"
        ],
        "Parameters": {
          "commands": [
            "#region Functions",
            "function Uninstall-RedHatPV {",
            "    # Forcibly remove RedHat PV Drivers as the AWS PV installer does not do so",
            "    $driverFileSearchList = @(",
            "        'rhelhidden',",
            "        'rhelfltr',",
            "        'rhelnet',",
            "        'rhelscsi')",
            "    $infFiles = Get-Item (Join-Path $env:SystemRoot \"\\inf\\oem*.inf\")",
            "    foreach ($infFile in $infFiles) {",
            "        if ($infFile.Length -gt 0) {",
            "            $content = Get-Content $infFile",
            "            $removed = $false",
            "            foreach ($driverFile in $driverFileSearchList) {",
            "                if ($content -match $driverFile) {",
            "                    Write-Verbose \"Removing driver $($infFile.FullName)\"",
            "                    $dpinstProc = Start-Process -Wait -Passthru -FilePath \"${env:ProgramFiles(x86)}\\RedHat\\XenPV\\dpinst.exe\" -ArgumentList \"/u $($infFile.FullName) /d /sw\" -NoNewWindow",
            "                    if ($dpinstProc.ExitCode -ne 0) {",
            "                        throw \"Unable to remove driver $($inffile.Name): Error $($dpinstProc.ExitCode)\"",
            "                    }",
            "                    $removed = $true",
            "                }",
            "                if ($removed -eq $true) {",
            "                    break",
            "                }",
            "            }",
            "        }",
            "    }",
            "    # Forcibly remove any RedHat PV Driver registry key to ensure no leftovers",
            "    $currentControlSet = \"HKLM:\\System\\CurrentControlSet\"",
            "    Remove-Item -Path \"$currentControlSet\\Enum\\ACPI\\PNP0A03\" -Recurse -Force -ErrorAction SilentlyContinue | Out-Null",
            "    Remove-Item -Path \"$currentControlSet\\Enum\\PCI\\VEN_5853&DEV_0001&SUBSYS_00015853&REV_01\" -Recurse -Force -ErrorAction SilentlyContinue | Out-Null",
            "    Remove-Item -Path \"$currentControlSet\\Enum\\RHEL\" -Recurse -Force -ErrorAction SilentlyContinue | Out-Null",
            "    Remove-Item -Path \"$currentControlSet\\Services\\rhelfltr\" -Recurse -Force -ErrorAction SilentlyContinue | Out-Null",
            "    Remove-Item -Path \"$currentControlSet\\Services\\rhelnet\" -Recurse -Force -ErrorAction SilentlyContinue | Out-Null",
            "    Remove-Item -Path \"$currentControlSet\\Services\\rhelscsi\" -Recurse -Force -ErrorAction SilentlyContinue | Out-Null",
            "    Remove-Item -Path \"$currentControlSet\\Services\\rhelsvc\" -Recurse -Force -ErrorAction SilentlyContinue | Out-Null",
            "    # Remove RedHat uninstaller entry and folder",
            "    Remove-Item -Path \"HKLM:\\SOFTWARE\\Wow6432Node\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\Red Hat Paravirtualized Xen Drivers for Windows(R)\" -Recurse -Force -ErrorAction SilentlyContinue | Out-Null",
            "    Remove-Item -Path \"${env:ProgramFiles(x86)}\\RedHat\" -Recurse -Force -ErrorAction SilentlyContinue | Out-Null",
            "}",
            "",
            "function Test-NetFrameworkVersion {",
            "    [version]$requiredVersion = \"4.0.30319.17001\"",
            "    $netFrameworkList = Get-ChildItem 'HKLM:\\SOFTWARE\\Microsoft\\NET Framework Setup\\NDP' -Recurse -ErrorAction SilentlyContinue |",
            "    Get-ItemProperty -name Version, Release -ErrorAction SilentlyContinue |",
            "    Where-Object { $_.PSChildName -match '^(?!S)\\p{L}' } |",
            "    Select-Object @{ name = \"Name\"; expression = { $_.PSChildName } }, Version, Release",
            "    $netFrameworkStatus = $false",
            "    foreach ($item in $netFrameworkList) {",
            "        if (!($netFrameworkStatus)) {",
            "            if ([version]$item.version -gt [version]$requiredVersion) {",
            "                $netFrameworkStatus = $true",
            "",
            "            }",
            "            else {",
            "                $netFrameworkStatus = $false",
            "",
            "            }",
            "        }",
            "    }",
            "    if (!($netFrameworkStatus)) {",
            "        throw \"Installation failed. AWS PV drivers requires .NET Framework v4.5 or later\"",
            "    }",
            "",
            "}",
            "",
            "function Enable-DSRMwithSSM {",
            "    # This function enables Directory Services Restore Mode and hardcode the currently reachable SSM endpoint in the hosts file",
            "    # allowing communication to the SSM endpoints during DSRM, when DNS services in the DC are down",
            "    # Enable Directory Services Restore mode",
            "    $bcdcmd = \"bcdedit /set '{default}' safeboot dsrepair 2>&1\"",
            "    $bcdstderr = Invoke-Expression -Command $bcdcmd",
            "    if ($lastexitcode -ne 0) {",
            "        throw ($bcdstderr[0])",
            "    }",
            "    # Backup the Hosts file and create a new one with SSM endpoint entries for DNS resolution during DSRM",
            "    $awsDomain = \"amazonaws.com\"",
            "    $awsPartition = \"{{ global:AWS_PARTITION }}\"",
            "    if ($awsPartition -eq \"aws-cn\") {",
            "        $awsDomain = \"amazonaws.com.cn\"",
            "    }",
            "    $ssmEndpoint = \"ssm.{{ global:REGION }}.$awsDomain\"",
            "    $ec2messagesEndpoint = \"ec2messages.{{ global:REGION }}.$awsDomain\"",
            "    $ssmEPIPAddress = [System.Net.Dns]::GetHostAddresses($ssmEndpoint)[0].IPAddressToString",
            "    $ec2messagesEPIPAddress = [System.Net.Dns]::GetHostAddresses($ec2messagesEndpoint)[0].IPAddressToString",
            "    Move-Item -Path \"${env:SYSTEMROOT}\\System32\\drivers\\etc\\hosts\" -Destination \"${env:SYSTEMROOT}\\System32\\drivers\\etc\\hosts-{{ automation:EXECUTION_ID }}\" -Force",
            "    Add-Content -Path \"${env:SYSTEMROOT}\\System32\\drivers\\etc\\hosts\" -Value \"`r`n#Lines added by AWSSupport-UpgradeWindowsAWSDrivers automation for SSM endpoint resolution`r`n$ssmEPIPAddress`t$ssmEndpoint`r`n$ec2messagesEPIPAddress`t$ec2messagesEndpoint\"",
            "    return $true",
            "}",
            "",
            "function Disable-DSRMwithSSM {",
            "    # This function disables Directory Services Restore Mode and restores the original hosts file",
            "    # Disable Directory Services Restore Mode",
            "    $bcdcmd = \"bcdedit /deletevalue '{default}' safeboot 2>&1\"",
            "    $bcdstderr = Invoke-Expression -Command $bcdcmd",
            "    if ($lastexitcode -ne 0) {",
            "        throw ($bcdstderr[0])",
            "    }",
            "    # Restore the original Hosts file",
            "    Move-Item -Path \"${env:SYSTEMROOT}\\System32\\drivers\\etc\\hosts-{{ automation:EXECUTION_ID }}\" -Destination \"${env:SYSTEMROOT}\\System32\\drivers\\etc\\hosts\" -Force",
            "}",
            "",
            "function Expand-ZipFile {",
            "    # Utility function to extract a zipped package",
            "    [CmdletBinding()]",
            "    Param(",
            "        [parameter(Mandatory = $true)]",
            "        [string]$ZipFile,",
            "        [parameter(Mandatory = $true)]",
            "        [string]$Path",
            "    )",
            "    if (Test-Path $ZipFile) {",
            "        Write-Verbose \"Found file $ZipFile\"",
            "    }",
            "    else {",
            "        throw \"$ZipFile file not found\"",
            "    }",
            "    if (Test-Path $Path) {",
            "        Write-Verbose \"$ZipFile already unpacked, skipping extraction\"",
            "    }",
            "    else {",
            "        Write-Verbose \"Extracting package $ZipFile\"",
            "        try {",
            "            # Unpacking the file this way is not supported in PowerShell 2",
            "            Add-Type -AssemblyName System.IO.Compression.FileSystem -ErrorAction SilentlyContinue",
            "            [System.IO.Compression.ZipFile]::ExtractToDirectory($ZipFile, $Path)",
            "        }",
            "        catch [System.InvalidOperationException] {",
            "            # Legacy unpacking method using COM Object",
            "            # Works with PowerShell 2",
            "            New-Item -Path $Path -ItemType \"directory\" -Force | Out-Null",
            "            ((New-Object -com shell.application).NameSpace($Path)).CopyHere(((New-Object -com shell.application).NameSpace($ZipFile)).Items())",
            "        }",
            "",
            "    }",
            "}",
            "",
            "function Set-AllDisksOnline {",
            "    # This function brings online all the offline disks, if any",
            "    $offlineDisks = \"list disk\" | diskpart.exe | Where-Object { $_ -match \"offline\" }",
            "    if ($offlineDisks) {",
            "        foreach ($disk in $offlineDisks ) {",
            "            $diskNumber = ($disk.split(\" \", [System.StringSplitOptions]::RemoveEmptyEntries))[1]",
            "            $diskpartCommands = @\"",
            "select disk ${diskNumber}",
            "online disk",
            "attributes disk clear readonly",
            "\"@",
            "            $diskpartOutput = $diskpartCommands | diskpart.exe",
            "            Start-Sleep 5",
            "        }",
            "    }",
            "}",
            "",
            "function Install-PVInstallTask {",
            "    #",
            "    [CmdletBinding()]",
            "    Param(",
            "        [parameter(Mandatory = $true)]",
            "        [string]$PVInstallerPath",
            "        )",
            "",
            "    $pvInstallTaskScript = @\"",
            "    `$exitcode = &\"${PVInstallerPath}\\install.ps1\" -Quiet -NoReboot -VerboseLogging",
            "    New-Item \"pv-state-{{ automation:EXECUTION_ID }}\" -ItemType file | Out-Null",
            "    if (`$exitcode -ne 0 -and `$exitcode -ne 3010) {",
            "        Write-Output \"failure\" | Set-Content -Path \"pv-state-{{ automation:EXECUTION_ID }}\"",
            "    }",
            "    else",
            "    {",
            "        if (Select-String -Path \"pv-state-{{ automation:EXECUTION_ID }}\" -Pattern \"redhatdc\") {",
            "            Write-Output \"dsrepair\" | Set-Content -Path \"pv-state-{{ automation:EXECUTION_ID }}\"",
            "        }",
            "        else {",
            "            Write-Output \"success\" | Set-Content -Path \"pv-state-{{ automation:EXECUTION_ID }}\"",
            "        }",
            "    }",
            "    schtasks /delete /tn \"PVInstall\" /f",
            "    shutdown -r -t 10",
            "\"@",
            "        Set-Content -Path \"${tempDir}\\installTask.ps1\" -Value $pvInstallTaskScript",
            "        $taskCmd = \"powershell -ExecutionPolicy Bypass -File `\"${PVInstallerPath}\\installTask.ps1`\"\"",
            "        $taskOutput = & schtasks.exe /create /tn \"PVInstall\" /RU SYSTEM /tr $taskCmd /sc ONSTART /F",
            "        Write-Verbose $taskOutput",
            "",
            "    }",
            "#endregion",
            "",
            "#region Main Script",
            "    try {",
            "        # Check minimum .NET Framework version required for AWS PV drivers",
            "        Test-NetFrameworkVersion",
            "",
            "        if ((Get-WmiObject -Class Win32_OperatingSystem).ProductType -eq 2) {",
            "            # If ProductType is 2, the instance is a Domain Controller",
            "            # Upgrade on a domain controller requires to enable the DCCheck override, and to be performed in DSRM to avoid DS causing a BSOD",
            "            if (!(Test-Path -Path \"pv-state-{{ automation:EXECUTION_ID }}\")) {",
            "                # Enable DCCheck override for PV drivers installation",
            "                $registryPath = \"HKLM:\\SOFTWARE\\Wow6432Node\\Amazon\\AWSPVDriverSetup\"",
            "                New-Item -Path $registryPath -Force | Out-Null",
            "                New-ItemProperty -Path $registryPath -Name \"DisableDCCheck\" -Value \"true\" -PropertyType String -Force | Out-Null",
            "                # Enable Directory Services Restore Mode with SSM support",
            "                $dsRepairmode = Enable-DSRMwithSSM",
            "            }",
            "        }",
            "",
            "        if (Test-Path -Path \"pv-state-{{ automation:EXECUTION_ID }}\") {",
            "            if (Select-String -Path \"pv-state-{{ automation:EXECUTION_ID }}\" -Pattern \"success\") {",
            "                Write-Host \"Installer has already run. Skipping installation\"",
            "                exit 0",
            "            }",
            "            else {",
            "                if (Select-String -Path \"pv-state-{{ automation:EXECUTION_ID }}\" -Pattern \"dsrepair\") {",
            "                    # Bring all the disks online, in case any was taken offline in DS repair mode",
            "                    Set-AllDisksOnline",
            "                    # Disable Directory Services Restore Mode",
            "                    Disable-DSRMwithSSM",
            "                    # Disable DCCheck override for PV driver installation",
            "                    $registryPath = \"HKLM:\\SOFTWARE\\Wow6432Node\\Amazon\\AWSPVDriverSetup\"",
            "                    New-Item -Path $registryPath -Force | Out-Null",
            "                    Remove-ItemProperty -Path $registryPath -Name \"DisableDCCheck\" -Force -ErrorAction SilentlyContinue | Out-Null",
            "                    Write-Output \"success\" | Set-Content -Path \"pv-state-{{ automation:EXECUTION_ID }}\"",
            "                    exit 3010",
            "",
            "                }",
            "                else {",
            "                    Write-Host \"Previous run of installer marked as failure. Skipping installation\"",
            "                    exit 1",
            "                }",
            "            }",
            "        }",
            "        else {",
            "            $region = \"{{ global:REGION }}\"",
            "            $s3Endpoint = switch -Regex ($region){",
            "                \"^us-iso-\" {\"https://s3.$region.c2s.ic.gov\"}",
            "                \"^us-isob-\" {\"https://s3.$region.sc2s.sgov.gov\"}",
            "                \"^us-isof-\" {\"https://s3.$region.csp.hci.ic.gov\"}",
            "                \"^eu-isoe-\" {\"https://s3.$region.cloud.adc-e.uk\"}",
            "                default {\"https://s3.amazonaws.com\"}",
            "            }",
            "            $OSVersion = [System.Environment]::OSVersion.Version",
            "            $version = $OSVersion.Major.ToString() + \".\" + $OSVersion.Minor.ToString()",
            "            # Get Version of ntoskernel.exe to check for KB3033929",
            "            $ntoskrnlver = (Get-Item $env:systemroot\\system32\\ntoskrnl.exe).VersionInfo.ProductVersion",
            "            $KB3033929 = [System.Version]\"6.1.7601.22948\"",
            "            switch -regex ($version) {",
            "                \"5.*|6.0|6.1\" {",
            "                    if ([System.Version]$ntoskrnlver -lt $KB3033929) {",
            "                        # 8.3.2 is the highest version that supports Windows Server 2008 R2 without KB3033929",
            "                        $url = \"$s3Endpoint/ec2-windows-drivers-downloads/AWSPV/8.3.2/AWSPVDriver.zip\"",
            "                    }",
            "                    else {",
            "                        # 8.3.5 is the latest version that supports Windows Server 2008 R2 and below",
            "                        $url = \"$s3Endpoint/ec2-windows-drivers-downloads/AWSPV/8.3.5/AWSPVDriver.zip\"",
            "                    }",
            "                }",
            "                # Windows Server 2012 and 2012 R2",
            "                \"6.2|6.3\" {",
            "                    $url = \"$s3Endpoint/ec2-windows-drivers-downloads/AWSPV/8.4.3/AWSPVDriver.zip\"",
            "                }",
            "                # Windows Server 2016, 2019, 2022, 2025",
            "                \"10.*\" {",
            "                    $url = \"$s3Endpoint/ec2-windows-drivers-downloads/AWSPV/Latest/AWSPVDriver.zip\"",
            "                }",
            "            }",
            "",
            "            [System.Net.ServicePointManager]::SecurityProtocol = ([int][system.net.SecurityProtocolType]::Tls13 -bor [int][system.net.SecurityProtocolType]::Tls12)",
            "            $attemptCount = 1",
            "            $maxAttempts = 5",
            "",
            "            $tempPath = (Resolve-Path ${env:temp}).Path",
            "            Write-Host \"Downloading AWS PV drivers\"",
            "            $tempFile = \"${tempPath}\\AWSPVDriver.zip\"",
            "            $tempDir = \"${tempPath}\\AWSPVDriver\"",
            "            $wc = New-Object \"System.Net.WebClient\"",
            "            $wc.Headers.Add(\"user-agent\", \"AWSSupport-UpgradeWindowsAWSDrivers\")",
            "",
            "            Do {",
            "                Write-Host \"Downloading AWSPVDriver.zip, attempt: $attemptCount/$maxAttempts...\"",
            "                try {",
            "                    $wc.DownloadFile($url, $tempFile)",
            "                    if (Test-Path $tempFile) {",
            "                        Write-Host \"Download successful.\"",
            "                        break",
            "                    }",
            "                }",
            "                catch {",
            "                    Write-Host \"Download failed: $_. Retrying...\"",
            "                }",
            "",
            "                $attemptCount++",
            "                Start-Sleep -Seconds ($attemptCount * 2)",
            "",
            "            } While (($attemptCount -le $maxAttempts) -and (-not (Test-Path $tempFile)))",
            "",
            "            if (-not (Test-Path $tempFile)) {",
            "                throw \"Failed to download AWSPVDriver.zip after $maxAttempts attempts.\"",
            "            }",
            "",
            "            if (Test-Path $tempDir) {",
            "                Remove-Item -Path $tempDir -Recurse -Force",
            "            }",
            "",
            "            # Extract drivers",
            "            Expand-ZipFile -ZipFile $tempFile -Path $tempDir",
            "            # Check if Installed PV Drivers are RedHat and handle them, as they require special handling",
            "            if (Get-WmiObject win32_PnPSignedDriver | Where-Object { $_.DeviceClass -match \"SCSIAdapter\" -and $_.Manufacturer -match \"RedHat\" }) {",
            "                $isRedHat = $true",
            "                Write-Host \"RedHat PV drivers detected\"",
            "                # In case of RedhatPV, the installer will fail because upgrade is not supported",
            "                Write-Host \"Removing RedHat PV drivers\"",
            "                Uninstall-RedHatPV",
            "                # Create a scheduled task to run AWS PV installer at next boot",
            "                Write-Host \"Setting install script to run at next boot\"",
            "                Install-PVInstallTask -PVInstallerPath $tempDir",
            "                $exitCode = 3010",
            "            }",
            "            else {",
            "                # Run install.ps1",
            "                Write-Host \"Running install script\"",
            "                $exitCode = & \"${tempDir}\\install.ps1\" -Quiet -NoReboot -VerboseLogging",
            "            }",
            "",
            "            # Evaluate exit code",
            "            New-Item \"pv-state-{{ automation:EXECUTION_ID }}\" -ItemType file | Out-Null",
            "            if ($exitcode -ne 0 -and $exitcode -ne 3010) {",
            "                Write-Host \"Installation failed with code $exitcode.\"",
            "                Write-Output \"failure\" | Set-Content -Path \"pv-state-{{ automation:EXECUTION_ID }}\"",
            "                exit 1",
            "            }",
            "            else {",
            "                Write-Host \"Rebooting to complete installation.\"",
            "                if ($dsRepairMode) {",
            "                    if ($isRedHat) {",
            "                        Write-Output \"redhatdc\" | Set-Content -Path \"pv-state-{{ automation:EXECUTION_ID }}\"",
            "                    }",
            "                    else {",
            "                        Write-Output \"dsrepair\" | Set-Content -Path \"pv-state-{{ automation:EXECUTION_ID }}\"",
            "                    }",
            "                }",
            "                else {",
            "                    Write-Output \"success\" | Set-Content -Path \"pv-state-{{ automation:EXECUTION_ID }}\"",
            "                }",
            "                exit 3010",
            "            }",
            "        }",
            "    }",
            "    catch {",
            "        Write-Host $_.Exception.Message",
            "        exit 255",
            "    }",
            "#endregion"
          ]
        }
      },
      "isCritical": true,
      "nextStep": "installAwsEnaNetworkDriverOnInstance"
    },
    {
      "name": "installAwsEnaNetworkDriverOnInstance",
      "action": "aws:runCommand",
      "description": "Installs the AWS Elastic Network Adapter (ENA) driver for Windows.",
      "onFailure": "Continue",
      "inputs": {
        "DocumentName": "AWS-RunPowerShellScript",
        "InstanceIds": [
          "{{ InstanceId }}"
        ],
        "Parameters": {
          "commands": [
            "try {",
            "    if (Test-Path -Path \"ena-state-{{ automation:EXECUTION_ID }}\") {",
            "        if (Select-String -Path \"ena-state-{{ automation:EXECUTION_ID }}\" -Pattern \"success\") {",
            "            Write-Host \"Installer has already run. Skipping installation\"",
            "            exit 0",
            "        }",
            "        else {",
            "            Write-Host \"Previous run of installer marked as failure. Skipping installation\"",
            "            exit 1",
            "        }",
            "    }",
            "    else {",
            "        $region = \"{{ global:REGION }}\"",
            "        $s3Endpoint = switch -Regex ($region){",
            "            \"^us-iso-\" {\"https://s3.$region.c2s.ic.gov\"}",
            "            \"^us-isob-\" {\"https://s3.$region.sc2s.sgov.gov\"}",
            "            \"^us-isof-\" {\"https://s3.$region.csp.hci.ic.gov\"}",
            "            \"^eu-isoe-\" {\"https://s3.$region.cloud.adc-e.uk\"}",
            "            default {\"https://s3.amazonaws.com\"}",
            "        }",
            "        $OSVersion = [System.Environment]::OSVersion.Version",
            "        $version = $OSVersion.Major.ToString() + \".\" + $OSVersion.Minor.ToString()",
            "        # Get Version of ntoskernel.exe to check for KB3033929",
            "        $ntoskrnlver = (Get-Item $env:systemroot\\system32\\ntoskrnl.exe).VersionInfo.ProductVersion",
            "        $KB3033929 = [System.Version]\"6.1.7601.22948\"",
            "        switch -regex ($version) {",
            "            # Windows Server 2008 R2",
            "            \"6.1\" {",
            "                if ([System.Version]$ntoskrnlver -lt $KB3033929) {",
            "                    # 2.1.4 is the highest version that supports Windows Server 2008 R2 without KB3033929",
            "                    $url = \"$s3Endpoint/ec2-windows-drivers-downloads/ENA/2.1.4/AwsEnaNetworkDriver.zip\"",
            "                }",
            "                else {",
            "                    # 2.2.3 is the latest version that supports Windows Server 2008 R2",
            "                    $url = \"$s3Endpoint/ec2-windows-drivers-downloads/ENA/2.2.3/AwsEnaNetworkDriver.zip\"",
            "                }",
            "            }",
            "            # Windows Server 2012 and 2012 R2",
            "            \"6.2|6.3\" {",
            "                $url = \"$s3Endpoint/ec2-windows-drivers-downloads/ENA/x64/2.6.0/AwsEnaNetworkDriver.zip\"",
            "            }",
            "            # Windows Server 2016, 2019, 2022",
            "            \"10.*\" {",
            "                $url = \"$s3Endpoint/ec2-windows-drivers-downloads/ENA/Latest/AwsEnaNetworkDriver.zip\"",
            "            }",
            "        }",
            "",
            "        [System.Net.ServicePointManager]::SecurityProtocol = ([int][system.net.SecurityProtocolType]::Tls13 -bor [int][system.net.SecurityProtocolType]::Tls12)",
            "        $attemptCount = 1",
            "        $maxAttempts = 5",
            "",
            "        $tempPath = (Resolve-Path ${env:temp}).Path",
            "        Write-Host \"Downloading AWS ENA drivers\"",
            "        $tempFile = \"${tempPath}\\AwsEnaNetworkDriver.zip\"",
            "        $tempDir = \"${tempPath}\\AwsEnaNetworkDriver\"",
            "        $wc = New-Object \"System.Net.WebClient\"",
            "        $wc.Headers.Add(\"user-agent\", \"AWSSupport-UpgradeWindowsAWSDrivers\")",
            "",
            "        Do {",
            "            Write-Host \"Downloading AwsEnaNetworkDriver.zip, attempt: $attemptCount/$maxAttempts...\"",
            "            try {",
            "                $wc.DownloadFile($url, $tempFile)",
            "                if (Test-Path $tempFile) {",
            "                    Write-Host \"Download successful.\"",
            "                    break",
            "                }",
            "            }",
            "            catch {",
            "                Write-Host \"Download failed: $_. Retrying...\"",
            "            }",
            "",
            "            $attemptCount++",
            "            Start-Sleep -Seconds ($attemptCount * 2)",
            "",
            "        } While (($attemptCount -le $maxAttempts) -and (-not (Test-Path $tempFile)))",
            "",
            "        if (-not (Test-Path $tempFile)) {",
            "            throw \"Failed to download AwsEnaNetworkDriver.zip after $maxAttempts attempts.\"",
            "        }",
            "",
            "        if (Test-Path $tempDir) {",
            "            Remove-Item -Path $tempDir -Recurse -Force",
            "        }",
            "",
            "        # Extract drivers",
            "        try {",
            "            # Unpacking the file this way is not supported in PowerShell 2",
            "            Add-Type -AssemblyName System.IO.Compression.FileSystem -ErrorAction SilentlyContinue",
            "            [System.IO.Compression.ZipFile]::ExtractToDirectory($tempFile, $tempDir)",
            "        }",
            "        catch [System.InvalidOperationException] {",
            "            # Legacy unpacking method using COM Object",
            "            # Works with PowerShell 2",
            "            New-Item -Path $tempDir -ItemType \"directory\" -Force | Out-Null",
            "            ((New-Object -com shell.application).NameSpace($tempDir)).CopyHere(((New-Object -com shell.application).NameSpace($tempFile)).Items())",
            "        }",
            "",
            "        # Run install.ps1",
            "        Write-Host \"Running install script\"",
            "        $output = & \"${tempDir}\\install.ps1\" -NoReboot",
            "        Write-Host $output",
            "",
            "        # Evaluate output",
            "        New-Item \"ena-state-{{ automation:EXECUTION_ID }}\" -ItemType file | Out-Null",
            "        if ($output -match \"successful\") {",
            "            if ($output -match \"reboot\") {",
            "                Write-Host \"Rebooting to complete installation\"",
            "                Write-Output \"success\" | Set-Content -Path \"ena-state-{{ automation:EXECUTION_ID }}\"",
            "                exit 3010",
            "            }",
            "            Write-Output \"success\" | Set-Content -Path \"ena-state-{{ automation:EXECUTION_ID }}\"",
            "            exit 0",
            "        }",
            "        else {",
            "            Write-Output \"failure\" | Set-Content -Path \"ena-state-{{ automation:EXECUTION_ID }}\"",
            "            exit 1",
            "        }",
            "    }",
            "}",
            "catch {",
            "    Write-Host $_.Exception.Message",
            "    exit 255",
            "}"
          ]
        }
      },
      "isCritical": true,
      "isEnd": true
    },
    {
      "name": "BranchOnAllowOffline",
      "action": "aws:branch",
      "description": "Branches the workflow based on whether the `AllowOffline` input parameter is set to `True`. If so, the offline upgrade starts, otherwise the automation ends.",
      "onFailure": "Abort",
      "inputs": {
        "Choices": [
          {
            "NextStep": "stopInstance",
            "Variable": "{{ AllowOffline }}",
            "StringEquals": "True"
          }
        ]
      },
      "isEnd": true,
      "isCritical": true
    },
    {
      "name": "stopInstance",
      "action": "aws:changeInstanceState",
      "description": "Stops the target EC2 instance.",
      "onFailure": "Continue",
      "inputs": {
        "InstanceIds": [
          "{{ InstanceId }}"
        ],
        "CheckStateOnly": false,
        "DesiredState": "stopped"
      },
      "isCritical": false,
      "nextStep": "forceStopInstance"
    },
    {
      "name": "forceStopInstance",
      "action": "aws:changeInstanceState",
      "description": "Forces-stop the source EC2 instance.",
      "onFailure": "Abort",
      "inputs": {
        "InstanceIds": [
          "{{ InstanceId }}"
        ],
        "CheckStateOnly": false,
        "DesiredState": "stopped",
        "Force": true
      },
      "isCritical": true,
      "nextStep": "preOfflineUpgradeBackup"
    },
    {
      "name": "preOfflineUpgradeBackup",
      "action": "aws:createImage",
      "description": "Creates an Amazon Machine Image (AMI) backup of the source EC2 instance.",
      "onFailure": "Abort",
      "inputs": {
        "InstanceId": "{{ InstanceId }}",
        "ImageDescription": "Pre-upgrade Backup AMI Generated by Automation on {{ global:DATE_TIME }} from {{ InstanceId }}.",
        "NoReboot": false,
        "ImageName": "UpgradeWindowsAWSDrivers-Pre-Script-Backup_{{ InstanceId }}_{{ global:DATE_TIME }}"
      },
      "outputs": [
        {
          "Name": "BackupImageId",
          "Selector": "$.ImageId",
          "Type": "String"
        }
      ],
      "isCritical": true,
      "nextStep": "tagPreOfflineUpgradeBackup"
    },
    {
      "name": "tagPreOfflineUpgradeBackup",
      "action": "aws:createTags",
      "description": "Tags the Amazon Machine Image (AMI) backup of the source EC2 instance.",
      "onFailure": "Continue",
      "inputs": {
        "ResourceType": "EC2",
        "ResourceIds": [
          "{{ preOfflineUpgradeBackup.BackupImageId }}"
        ],
        "Tags": [
          {
            "Key": "Name",
            "Value": "AWSSupport-UpgradeWindowsAWSDrivers: {{ InstanceId }}"
          },
          {
            "Key": "AWSSupport-UpgradeWindowsAWSDrivers-AutomationExecution",
            "Value": "{{ automation:EXECUTION_ID }}"
          }
        ]
      },
      "isCritical": false,
      "nextStep": "assertPreOfflineUpgradeBackup"
    },
    {
      "name": "assertPreOfflineUpgradeBackup",
      "action": "aws:waitForAwsResourceProperty",
      "description": "Verifies the Amazon Machine Image (AMI) backup of the source EC2 instance is in `available` state.",
      "onFailure": "Abort",
      "inputs": {
        "Service": "ec2",
        "Api": "DescribeImages",
        "Filters": [
          {
            "Name": "image-id",
            "Values": [
              "{{ preOfflineUpgradeBackup.BackupImageId }}"
            ]
          }
        ],
        "PropertySelector": "$.Images[0].State",
        "DesiredValues": [
          "available"
        ]
      },
      "isCritical": true,
      "nextStep": "enableEnaSupport"
    },
    {
      "name": "enableEnaSupport",
      "onFailure": "Continue",
      "action": "aws:executeAwsApi",
      "description": "Enables enhanced networking with the Elastic Network Adapter (ENA) for the instance.",
      "inputs": {
        "Service": "ec2",
        "Api": "ModifyInstanceAttribute",
        "InstanceId": "{{ InstanceId }}",
        "EnaSupport": {
          "Value": true
        }
      },
      "isCritical": true,
      "nextStep": "branchOnForceUpgrade"
    },
    {
      "name": "branchOnForceUpgrade",
      "action": "aws:branch",
      "description": "Asserts the `ForceUpgrade` input parameter. If `True` then proceed to install the drivers even though your instance already has the latest drivers installed.",
      "onFailure": "step:startInstance",
      "inputs": {
        "Choices": [
          {
            "NextStep": "upgradeDriversOffline",
            "Variable": "{{ ForceUpgrade }}",
            "StringEquals": "False"
          },
          {
            "NextStep": "forceUpgradeDriversOffline",
            "Variable": "{{ ForceUpgrade }}",
            "StringEquals": "True"
          }
        ],
        "Default": "startInstance"
      },
      "nextStep": "startInstance",
      "isCritical": true
    },
    {
      "name": "upgradeDriversOffline",
      "onFailure": "Continue",
      "action": "aws:executeAutomation",
      "description": "If `ForceUpgrade` is set to `True` then run `aws:executeAutomation` to invoke `AWSSupport-StartEC2RescueWorkflow` with the drivers force upgrade script. This installs the drivers regardless of the current versions that are installed.",
      "inputs": {
        "RuntimeParameters": {
          "InstanceId": [
            "{{ InstanceId }}"
          ],
          "EC2RescueInstanceType": [
            "{{ EC2RescueInstanceType }}"
          ],
          "OfflineScript": [
            "JEFXU1BWVmVyc2lvbj0iTGF0ZXN0IgokRU5BVmVyc2lvbj0iTGF0ZXN0IgokTlZNRVZlcnNpb249IkxhdGVzdCIKJEtCMzAzMzkyOSA9IFtTeXN0ZW0uVmVyc2lvbl0iNi4xLjc2MDEuMjI5NDgiCldyaXRlLUhvc3QgIlRhcmdldCBXaW5kb3dzIFZlcnNpb24gJCgkZW52OkVDMlJFU0NVRV9PRkZMSU5FX0tFUk5FTF9WRVIpIgokVGFyZ2V0VmVyc2lvbiA9IFtTeXN0ZW0uVmVyc2lvbl0kZW52OkVDMlJFU0NVRV9PRkZMSU5FX0tFUk5FTF9WRVIKaWYgKFtTeXN0ZW0uVmVyc2lvbl0iJCgkVGFyZ2V0VmVyc2lvbi5NYWpvcikuJCgkVGFyZ2V0VmVyc2lvbi5NaW5vcikiIC1sZSBbU3lzdGVtLlZlcnNpb25dIjYuMSIpIHsKICAgIFdyaXRlLUhvc3QgIlJldmVydGluZyBiYWNrIHRvIHRoZSBsYXRlc3QgY29tcGF0aWJsZSBkcml2ZXIgdmVyc2lvbnMgd2l0aCBXaW5kb3dzIFNlcnZlciAyMDA4IFIyIgogICAgV3JpdGUtSG9zdCAiUmV2ZXJ0aW5nIHRvIE5WTUUgZHJpdmVycyB2ZXJzaW9uIDEuMy4yIgogICAgJE5WTUVWZXJzaW9uPSIxLjMuMiIKICAgIGlmICgkVGFyZ2V0VmVyc2lvbiAtbHQgJEtCMzAzMzkyOSl7CiAgICAgICAgV3JpdGUtSG9zdCAiT3BlcmF0aW5nIFN5c3RlbSBpcyBtaXNzaW5nIEtCMzAzMzkyOS4iCiAgICAgICAgIyA4LjMuMiBpcyB0aGUgaGlnaGVzdCBBV1MgUFYgdmVyc2lvbiB0aGF0IHN1cHBvcnRzIFdpbmRvd3MgU2VydmVyIDIwMDggUjIgd2l0aG91dCBLQjMwMzM5MjkKICAgICAgICBXcml0ZS1Ib3N0ICJSZXZlcnRpbmcgdG8gQVdTIFBWIGRyaXZlcnMgdmVyc2lvbiA4LjMuMiIKICAgICAgICAkQVdTUFZWZXJzaW9uPSI4LjMuMiIKICAgICAgICAjIDIuMS40IGlzIHRoZSBoaWdoZXN0IEVOQSB2ZXJzaW9uIHRoYXQgc3VwcG9ydHMgV2luZG93cyBTZXJ2ZXIgMjAwOCBSMiB3aXRob3V0IEtCMzAzMzkyOQogICAgICAgIFdyaXRlLUhvc3QgIlJldmVydGluZyB0byBFTkEgZHJpdmVycyB2ZXJzaW9uIDIuMS40IgogICAgICAgICRFTkFWZXJzaW9uPSIyLjEuNCIKICAgIH0KICAgIGVsc2UgewogICAgICAgICMgOC4zLjUgaXMgdGhlIGxhdGVzdCBBV1MgUFYgdmVyc2lvbiB0aGF0IHN1cHBvcnRzIFdpbmRvd3MgU2VydmVyIDIwMDggUjIKICAgICAgICBXcml0ZS1Ib3N0ICJSZXZlcnRpbmcgdG8gQVdTIFBWIGRyaXZlcnMgdmVyc2lvbiA4LjMuNSIKICAgICAgICAkQVdTUFZWZXJzaW9uPSI4LjMuNSIKICAgICAgICAjIDIuMi4zIGlzIHRoZSBsYXRlc3QgRU5BIHZlcnNpb24gdGhhdCBzdXBwb3J0cyBXaW5kb3dzIFNlcnZlciAyMDA4IFIyCiAgICAgICAgV3JpdGUtSG9zdCAiUmV2ZXJ0aW5nIHRvIEVOQSBkcml2ZXJzIHZlcnNpb24gMi4yLjMiCiAgICAgICAgJEVOQVZlcnNpb249IjIuMi4zIgogICAgfQp9CmVsc2VpZiAoW1N5c3RlbS5WZXJzaW9uXSIkKCRUYXJnZXRWZXJzaW9uLk1ham9yKS4kKCRUYXJnZXRWZXJzaW9uLk1pbm9yKSIgLWVxIFtTeXN0ZW0uVmVyc2lvbl0iNi4yIiAtb3IgW1N5c3RlbS5WZXJzaW9uXSIkKCRUYXJnZXRWZXJzaW9uLk1ham9yKS4kKCRUYXJnZXRWZXJzaW9uLk1pbm9yKSIgLWVxIFtTeXN0ZW0uVmVyc2lvbl0iNi4zIikgewogICAgV3JpdGUtSG9zdCAiUmV2ZXJ0aW5nIGJhY2sgdG8gdGhlIGxhdGVzdCBjb21wYXRpYmxlIGRyaXZlciB2ZXJzaW9ucyB3aXRoIFdpbmRvd3MgU2VydmVyIDIwMTIgYW5kIDIwMTIgUjIiCiAgICBXcml0ZS1Ib3N0ICJSZXZlcnRpbmcgdG8gRU5BIGRyaXZlcnMgdmVyc2lvbiAyLjYuMCIKICAgICMgMi42LjAgaXMgdGhlIGxhdGVzdCBFTkEgdmVyc2lvbiB0aGF0IHN1cHBvcnRzIFdpbmRvd3MgU2VydmVyIDIwMTIgYW5kIDIwMTIgUjIKICAgICRFTkFWZXJzaW9uPSIyLjYuMCIKfQoKU2V0LUJvb3REcml2ZXJzS2V5IC1XaW5kb3dzSW5zdGFsbERhdGEgJHNjcmlwdDpFQzJSRVNDVUVfT0ZGTElORV9XSU5ET1dTX0lOU1RBTEwKSW5zdGFsbC1QVkRyaXZlcnMgLVdpbmRvd3NJbnN0YWxsRGF0YSAkc2NyaXB0OkVDMlJFU0NVRV9PRkZMSU5FX1dJTkRPV1NfSU5TVEFMTCAtQVdTUFZWZXJzaW9uICRBV1NQVlZlcnNpb24KSW5zdGFsbC1OaXRyb0RyaXZlcnMgLVdpbmRvd3NJbnN0YWxsRGF0YSAkc2NyaXB0OkVDMlJFU0NVRV9PRkZMSU5FX1dJTkRPV1NfSU5TVEFMTCAtRU5BVmVyc2lvbiAkRU5BVmVyc2lvbiAgLU5WTUVWZXJzaW9uICROVk1FVmVyc2lvbg=="
          ],
          "SubnetId": [
            "{{ SubnetId }}"
          ],
          "HelperInstanceProfileName": [
            "{{ EC2RescueInstanceProfileName }}"
          ],
          "AutomationAssumeRole": [
            "{{ AutomationAssumeRole }}"
          ],
          "UniqueId": "{{ automation:EXECUTION_ID }}"
        },
        "DocumentName": "AWSSupport-StartEC2RescueWorkflow"
      },
      "isCritical": true,
      "nextStep": "startInstance"
    },
    {
      "name": "forceUpgradeDriversOffline",
      "onFailure": "Continue",
      "action": "aws:executeAutomation",
      "description": "If `ForceUpgrade` is set to `False` then run `aws:executeAutomation` to invoke `AWSSupport-StartEC2RescueWorkflow` with the drivers upgrade script. This installs the drivers only if the current versions are outdated.",
      "inputs": {
        "RuntimeParameters": {
          "InstanceId": [
            "{{ InstanceId }}"
          ],
          "EC2RescueInstanceType": [
            "{{ EC2RescueInstanceType }}"
          ],
          "OfflineScript": [
            "JEFXU1BWVmVyc2lvbj0iTGF0ZXN0IgokRU5BVmVyc2lvbj0iTGF0ZXN0IgokTlZNRVZlcnNpb249IkxhdGVzdCIKJEtCMzAzMzkyOSA9IFtTeXN0ZW0uVmVyc2lvbl0iNi4xLjc2MDEuMjI5NDgiCldyaXRlLUhvc3QgIlRhcmdldCBXaW5kb3dzIFZlcnNpb24gJCgkZW52OkVDMlJFU0NVRV9PRkZMSU5FX0tFUk5FTF9WRVIpIgokVGFyZ2V0VmVyc2lvbiA9IFtTeXN0ZW0uVmVyc2lvbl0kZW52OkVDMlJFU0NVRV9PRkZMSU5FX0tFUk5FTF9WRVIKaWYgKFtTeXN0ZW0uVmVyc2lvbl0iJCgkVGFyZ2V0VmVyc2lvbi5NYWpvcikuJCgkVGFyZ2V0VmVyc2lvbi5NaW5vcikiIC1sZSBbU3lzdGVtLlZlcnNpb25dIjYuMSIpIHsKICAgIFdyaXRlLUhvc3QgIlJldmVydGluZyBiYWNrIHRvIHRoZSBsYXRlc3QgY29tcGF0aWJsZSBkcml2ZXIgdmVyc2lvbnMiCiAgICBXcml0ZS1Ib3N0ICJSZXZlcnRpbmcgdG8gTlZNRSBkcml2ZXJzIHZlcnNpb24gMS4zLjIiCiAgICAkTlZNRVZlcnNpb249IjEuMy4yIgogICAgaWYgKCRUYXJnZXRWZXJzaW9uIC1sdCAkS0IzMDMzOTI5KXsKICAgICAgICBXcml0ZS1Ib3N0ICJPcGVyYXRpbmcgU3lzdGVtIGlzIG1pc3NpbmcgS0IzMDMzOTI5LiIKICAgICAgICAjIDguMy4yIGlzIHRoZSBoaWdoZXN0IEFXUyBQViB2ZXJzaW9uIHRoYXQgc3VwcG9ydHMgV2luZG93cyBTZXJ2ZXIgMjAwOCBSMiB3aXRob3V0IEtCMzAzMzkyOQogICAgICAgIFdyaXRlLUhvc3QgIlJldmVydGluZyB0byBBV1MgUFYgZHJpdmVycyB2ZXJzaW9uIDguMy4yIgogICAgICAgICRBV1NQVlZlcnNpb249IjguMy4yIgogICAgICAgICMgMi4xLjQgaXMgdGhlIGhpZ2hlc3QgRU5BIHZlcnNpb24gdGhhdCBzdXBwb3J0cyBXaW5kb3dzIFNlcnZlciAyMDA4IFIyIHdpdGhvdXQgS0IzMDMzOTI5CiAgICAgICAgV3JpdGUtSG9zdCAiUmV2ZXJ0aW5nIHRvIEVOQSBkcml2ZXJzIHZlcnNpb24gMi4xLjQiCiAgICAgICAgJEVOQVZlcnNpb249IjIuMS40IgogICAgfQogICAgZWxzZSB7CiAgICAgICAgIyA4LjMuNSBpcyB0aGUgbGF0ZXN0IEFXUyBQViB2ZXJzaW9uIHRoYXQgc3VwcG9ydHMgV2luZG93cyBTZXJ2ZXIgMjAwOCBSMgogICAgICAgIFdyaXRlLUhvc3QgIlJldmVydGluZyB0byBBV1MgUFYgZHJpdmVycyB2ZXJzaW9uIDguMy41IgogICAgICAgICRBV1NQVlZlcnNpb249IjguMy41IgogICAgICAgICMgMi4yLjMgaXMgdGhlIGxhdGVzdCBFTkEgdmVyc2lvbiB0aGF0IHN1cHBvcnRzIFdpbmRvd3MgU2VydmVyIDIwMDggUjIKICAgICAgICBXcml0ZS1Ib3N0ICJSZXZlcnRpbmcgdG8gRU5BIGRyaXZlcnMgdmVyc2lvbiAyLjIuMyIKICAgICAgICAkRU5BVmVyc2lvbj0iMi4yLjMiCiAgICB9Cn0KClNldC1Cb290RHJpdmVyc0tleSAtV2luZG93c0luc3RhbGxEYXRhICRzY3JpcHQ6RUMyUkVTQ1VFX09GRkxJTkVfV0lORE9XU19JTlNUQUxMCkluc3RhbGwtUFZEcml2ZXJzIC1XaW5kb3dzSW5zdGFsbERhdGEgJHNjcmlwdDpFQzJSRVNDVUVfT0ZGTElORV9XSU5ET1dTX0lOU1RBTEwgLUFXU1BWVmVyc2lvbiAkQVdTUFZWZXJzaW9uIC1Gb3JjZQpJbnN0YWxsLU5pdHJvRHJpdmVycyAtV2luZG93c0luc3RhbGxEYXRhICRzY3JpcHQ6RUMyUkVTQ1VFX09GRkxJTkVfV0lORE9XU19JTlNUQUxMIC1FTkFWZXJzaW9uICRFTkFWZXJzaW9uICAtTlZNRVZlcnNpb24gJE5WTUVWZXJzaW9uIC1Gb3JjZQ=="
          ],
          "SubnetId": [
            "{{ SubnetId }}"
          ],
          "HelperInstanceProfileName": [
            "{{ EC2RescueInstanceProfileName }}"
          ],
          "AutomationAssumeRole": [
            "{{ AutomationAssumeRole }}"
          ],
          "UniqueId": "{{ automation:EXECUTION_ID }}"
        },
        "DocumentName": "AWSSupport-StartEC2RescueWorkflow"
      },
      "isCritical": true,
      "nextStep": "startInstance"
    },
    {
      "name": "startInstance",
      "action": "aws:changeInstanceState",
      "description": "Starts the EC2 instance.",
      "onFailure": "Abort",
      "inputs": {
        "InstanceIds": [
          "{{ InstanceId }}"
        ],
        "CheckStateOnly": false,
        "DesiredState": "running"
      },
      "isCritical": true,
      "isEnd": true
    }
  ],
  "outputs": [
    "preUpgradeBackup.BackupImageId",
    "preOfflineUpgradeBackup.BackupImageId",
    "installAwsEnaNetworkDriverOnInstance.Output",
    "installAWSNVMeOnInstance.Output",
    "installAWSPVDriverOnInstance.Output",
    "upgradeDriversOffline.Output",
    "forceUpgradeDriversOffline.Output"
  ]
}
