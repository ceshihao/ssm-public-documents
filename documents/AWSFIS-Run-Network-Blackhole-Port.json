{
  "description": "### Document name - AWSFIS-Run-Network-Blackhole-Port\n\n## What does this document do?\nIt drops incoming or outgoing traffic for a configurable protocol (tcp or udp) and port using iptables. If iptables is not already installed on the instance, this SSM document will install it together with other dependencies listed below.\nThis SSM document supports Amazon Linux and Ubuntu operating systems only.\n\n## Dependencies installed by this SSM Document\n* atd\n* dig\n* iptables\nNote: This SSM document does not uninstall dependencies once installed. If you don't want this SSM document to install any dependencies, set InstallDependencies to False and bake the dependencies into your EC2 instance. For example, by using image-builder (https://aws.amazon.com/image-builder/).\n\n## Input Parameters\n* Protocol: (Required) Specify the protocol to blackhole (tcp|udp).\n* Port: (Required) Specify the port to blackhole.\n* TrafficType: Specify the type of traffic to delay (egress|ingress) (default: ingress).\n* DurationSeconds: (Required) The duration - in seconds - of the fault injection.\n* InstallDependencies: If set to True, Systems Manager installs the required dependencies on the target instances (default: True).\n\n## Output Parameters\nNone.",
  "schemaVersion": "2.2",
  "parameters": {
    "Protocol": {
      "type": "String",
      "description": "(Required) Specify the protocol to blackhole (tcp|udp).",
      "allowedValues": [
        "tcp",
        "udp"
      ]
    },
    "Port": {
      "type": "String",
      "description": "(Required) Specify the port to blackhole.",
      "allowedPattern": "^([1-9][0-9]{0,3}|[1-5][0-9]{4}|6[0-4][0-9]{3}|65[0-4][0-9]{2}|655[0-2][0-9]|6553[0-5])$"
    },
    "TrafficType": {
      "type": "String",
      "description": "Specify the type of traffic to delay (egress|ingress) (default: ingress).",
      "default": "ingress",
      "allowedValues": [
        "egress",
        "ingress"
      ]
    },
    "DurationSeconds": {
      "type": "String",
      "description": "(Required) The duration - in seconds - of the fault injection.",
      "allowedPattern": "^[0-9]+$"
    },
    "InstallDependencies": {
      "type": "String",
      "description": "If set to True, Systems Manager installs the required dependencies on the target instances (default: True).",
      "default": "True",
      "allowedValues": [
        "True",
        "False"
      ]
    }
  },
  "mainSteps": [
    {
      "action": "aws:runShellScript",
      "name": "InstallDependencies",
      "precondition": {
        "StringEquals": [
          "platformType",
          "Linux"
        ]
      },
      "description": "## Parameter: InstallDependencies\nIf set to True, this step installs the required dependency via operating system's repository. It supports both\nDebian (apt) and CentOS (yum) based package managers.",
      "inputs": {
        "onFailure": "exit",
        "runCommand": [
          "#!/bin/bash\n\nset -o errexit\n\n# Configure ATD service if required\nconfigure_atd() {\n  if ! systemctl is-enabled atd || ! systemctl is-active atd; then\n    echo \"Enabling and starting atd\"\n    systemctl enable atd\n    systemctl start atd\n  fi\n}\n\n# Check if dependencies are already installed\ncheck_existing_dependencies() {\n  if [[ \"$( command -v atd 2>/dev/null )\" && \"$( command -v dig 2>/dev/null )\" && \"$( command -v iptables 2>/dev/null )\" ]]; then\n  \n    echo \"Dependencies are already installed.\"\n    exit\n  \n  fi\n}\n\nvalidate_installation_settings() {\n  if [[ \"{{ InstallDependencies }}\" == False ]]; then\n    echo \"Missing dependencies detected with InstallDependencies set to false. Please install dependencies [\"atd\", \"dig\", \"iptables\"] or set InstallDependencies to true for supported operating systems.\" >&2\n    exit 1\n  fi\n}\n\n# Handle Amazon Linux installations\ninstall_amazon_linux() {\n  if ! grep -Fiq 'VERSION_ID=\"2023\"' /etc/os-release; then\n  \n    yum -y install at bind-utils iptables\n  elif grep -Fiq 'ID=\"amzn\"' /etc/os-release && grep -Fiq 'VERSION_ID=\"2023\"' /etc/os-release; then\n  \n    yum -y install at bind-utils iptables\n  else\n    echo \"Exiting - This SSM document supports: Amazon Linux 2023, Amazon Linux 2, Ubuntu, CentOS 9 and RHEL (8, 9) operating systems\"\n    exit 1\n  fi\n}\n\n# Handle RHEL/CentOS installations\ninstall_rhel_centos() {\n  # Fetch OS Version\n  os_version_number=$(grep -oP '(?<=^VERSION_ID=).+' /etc/os-release | tr -d '\"')\n  # if the version has a decimal, this line will remove it\n  os_major_version_number=${os_version_number%.*}\n  # Replace with version number in the url if required\n  if ! rpm --quiet -q epel-release; then\n    epel_dl_url=\"https://dl.fedoraproject.org/pub/epel/epel-release-latest-VERSION.noarch.rpm\"\n    epel_with_version=\"${epel_dl_url/VERSION/$os_major_version_number}\"\n    yum -y install $epel_with_version\n  fi\n  rhel_package=\"at bind-utils iptables\"\n  \n  yum -y install $rhel_package\n}\n\n# Handle Ubuntu installations\ninstall_ubuntu() {\n  apt-get update -y\n  # when installing, sometimes ubuntu has stderr that are not breaking errors.\n  install_error=$(apt-get install -y at dnsutils iptables 2>&1)\n  if [[ -n \"$install_error\" ]]; then\n    echo \"$install_error\"\n  fi\n\n  ubuntu_commands=( atd dig iptables )\n  for dependency_command in \"${ubuntu_commands[@]}\"; do\n    if ! command -v $dependency_command >/dev/null 2>&1; then\n      echo \"Exiting - $dependency_command not installed\"\n      exit 1\n    fi\n  done\n}\n\n# Main function to orchestrate the installation process\nmain() {\n  check_existing_dependencies\n  validate_installation_settings\n\n  echo \"Installing required dependencies\"\n  trap 'status=$?; if [ $status -eq 1 ]; then echo \"Failed to install dependencies. Please retry or manually install dependencies [\"atd\", \"dig\", \"iptables\"] and set InstallDependencies to false.\" >&2; fi' EXIT\n\n  if [ -f \"/etc/system-release\" ] && grep -i 'Amazon Linux' /etc/system-release; then\n    install_amazon_linux\n  elif grep -Fiq 'ID=\"centos\"' /etc/os-release || grep -Fiq 'ID=\"rhel\"' /etc/os-release; then\n    install_rhel_centos\n  elif grep -i \"Ubuntu\" /etc/issue; then\n    install_ubuntu\n  else\n    echo \"Exiting - This SSM document supports: Amazon Linux 2023, Amazon Linux 2, Ubuntu, CentOS 9 and RHEL (8, 9) operating systems\"\n    exit 1\n  fi\n  configure_atd\n}\n\n# Execute main function\nmain\n"
        ]
      }
    },
    {
      "action": "aws:runShellScript",
      "name": "FaultInjection",
      "precondition": {
        "StringEquals": [
          "platformType",
          "Linux"
        ]
      },
      "description": "## Parameters: Protocol, Port, TrafficType, and DurationSeconds\nThis step blocks  `Protocol` 'TrafficType' traffic to `Port` for the given `DurationSeconds`, using the `iptables` command.\nThe script will block the traffic, and wait for the given duration to remove that. It has two rollback mechanisms in place:\n* It will listen for exit signals (SIGINT and SIGTERM), and will stop the fault injection if any of them is received.\n* It will periodically enqueue rollback checks into a queue (using `at` command). This way, if the command is stopped and the rollback\nwas not executed, the enqueued commands will to stop it. (for example, if the command is stopped using kill -9). This is just\nand extra safety check to avoid the fault to remain injected after the script is no longer running.",
      "inputs": {
        "maxAttempts": 1,
        "timeoutSeconds": 43200,
        "runCommand": [
          "#!/bin/bash\nset -o errexit -o errtrace -o nounset -o pipefail\n\n########################\n# Fault-specific logic #\n########################\n\nPORT={{ Port }}\nPROTOCOL={{ Protocol }}\nDURATION={{ DurationSeconds }}\nTRAFFIC_TYPE={{ TrafficType }}\n\nvalidate_parameter_within_range() {\n  local parameter=$1\n  local value=$2\n  local min=$3\n  local max=$4\n\n  if (( value >= min && value <= max )); then\n    return 0\n  fi\n\n  echo \"Parameter $parameter must be between $min and $max, was: '$value'\" >&2\n  exit 1\n}\n\nvalidate_running_in_ssm_document() {\n  # Check if the script is running in an SSM document by verifying that AWS_SSM_REGION_NAME environment variable is set\n  if [[ -n \"${AWS_SSM_REGION_NAME-}\" ]]; then\n    return 0\n  fi\n\n  echo \"Environment variable AWS_SSM_REGION_NAME is not set. Run this script as part of an SSM document.\" >&2\n  exit 1\n}\n\nforce_dns() {\n  local -r hostname=\"$1\"    # Hostname is expected as first argument\n  local -ar ips=(\"${@:2}\")  # The rest will be the IPs\n\n  # Force any new DNS resolution for that host to the latest known IPs\n  for ip in \"${ips[@]}\"; do\n    echo \"$ip $hostname ${DELETE_MSG:-\"#delete-after-fault-injection\"}\" >> \"${HOSTS_FILE:-/etc/hosts}\"\n  done\n\n  return 0\n}\n\nadd_imds_ip_to_protected_endpoints() {\n  local -r instance_id=\"$1\"\n\n  # Only on EC2 instances add EC2 metadata. On-premise instances will be prefixed with \"mi-\"\n  if [[ \"$instance_id\" =~ ^i-.* ]]; then\n    echo \"Running on EC2 instance. Adding EC2 metadata IP to PROTECTED_ENDPOINTS\"\n    PROTECTED_ENDPOINTS+=(\"${IMDS_IP:-\"169.254.169.254\"}\") \n  fi\n\n  return 0\n}\n\nget_ips_from_input() {\n  local -r input=\"$1\"\n  local -r regex=\"$2\"\n\n  # Echoes the input and returns 0 if the input is valid, otherwise returns 1\n  local -r validated_input=$(grep -E \"$regex\" <<< \"$input\")\n  [ -z \"$validated_input\" ] || { echo \"$validated_input\" ; return 0 ;}\n\n  return 1\n}\n\nget_ips_from_dns() {\n  local -r domain=\"$1\"\n  local -a resolved_ips=()\n\n  # Echoes IPs of the domain and forces DNS resolution to the IPs then returns 0, otherwise returns 1\n  # Since `dig` can return different IPs, we call it 10 times to maximize the chances of covering as many IPs as possible for the provided domain\n  for _ in {1..10}\n    do\n      local -a dig_output=( $(dig +short \"$domain\" | grep -v '[[:alpha:]]') )\n      [ ${#dig_output[@]} -eq 0 ] || resolved_ips+=(\"${dig_output[@]}\")\n    done\n\n  if [ ${#resolved_ips[@]} -gt 0 ]; then\n    local -ar unique_resolved_ips=( $(printf '%s\\n' \"${resolved_ips[@]}\" | sort -u) )\n    [ ${#unique_resolved_ips[@]} -eq 0 ] || { echo \"${unique_resolved_ips[@]}\" ; force_dns \"$domain\" \"${unique_resolved_ips[@]}\" ; return 0 ;}\n  fi\n\n  return 1\n}\n\nrestore_hosts_file() {\n  local mutated_hosts_file\n  mutated_hosts_file=$(mktemp)\n\n  if ! cp \"${HOSTS_FILE:-/etc/hosts}\" \"$mutated_hosts_file\"; then\n    echo \"Failed to copy current hosts file - exiting without restoring hosts file\" >&2\n    rm -f \"$mutated_hosts_file\"\n    exit 1\n  fi\n\n  local restored_hosts_file\n  restored_hosts_file=$(mktemp)\n\n  sed \"/${DELETE_MSG:-\"#delete-after-fault-injection\"}/d\" \"${HOSTS_FILE:-/etc/hosts}\" > \"$restored_hosts_file\"\n\n  local actual_deleted_lines\n  actual_deleted_lines=$(grep --invert-match --line-regexp --file=\"$restored_hosts_file\" \"$mutated_hosts_file\" || true)\n\n  local expected_deleted_lines\n  expected_deleted_lines=$(grep \"${DELETE_MSG:-\"#delete-after-fault-injection\"}\" \"$mutated_hosts_file\" || true)\n\n  if [ \"$actual_deleted_lines\" != \"$expected_deleted_lines\" ]; then\n    echo \"sed operation produced unexpected results - exiting without restoring hosts file\" >&2\n    echo \"Before sed operation:\" >&2\n    cat \"${mutated_hosts_file}\" >&2\n    echo \"After sed operation:\" >&2\n    cat \"${restored_hosts_file}\" >&2\n    rm -f \"$restored_hosts_file\" \"$mutated_hosts_file\"\n    exit 1\n  fi\n\n  if ! cat \"$restored_hosts_file\" > \"${HOSTS_FILE:-/etc/hosts}\"; then\n    echo \"Failed to write back to hosts file\" >&2\n    rm -f \"$restored_hosts_file\" \"$mutated_hosts_file\"\n    exit 1\n  fi\n\n  local final_deleted_lines\n  final_deleted_lines=$(grep --invert-match --line-regexp --file=\"${HOSTS_FILE:-/etc/hosts}\" \"$mutated_hosts_file\" || true)\n\n  if [ \"$final_deleted_lines\" != \"$expected_deleted_lines\" ]; then\n    echo \"Hosts file restore verification failed after write-back to hosts file\" >&2\n    echo \"Before write-back operation:\" >&2\n    cat \"${restored_hosts_file}\" >&2\n    echo \"After write-back operation:\" >&2\n    cat \"${HOSTS_FILE:-/etc/hosts}\" >&2\n    rm -f \"$restored_hosts_file\" \"$mutated_hosts_file\"\n    exit 1\n  fi\n\n  rm -f \"$restored_hosts_file\" \"$mutated_hosts_file\"\n  echo \"Hosts file restore completed successfully\"\n}\n\n# Trap to ensure hosts file is restored on exit\ntrap 'restore_hosts_file' EXIT\n\nget_ips()\n{\n  local -r input=\"$1\"\n\n  get_ips_from_input \"$input\" \"$IP_REGEX\" ||\n  get_ips_from_dns \"$input\"\n}\n\nvalidate_parameter_within_range \"DurationSeconds\" $DURATION 1 43200\nvalidate_running_in_ssm_document\n\nFAULT_NAME=\"Run-Network-Blackhole-Port\"\n\nIP_REGEX=\"^(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])$\"\n\nIMDS_IP=169.254.169.254\n\nDELETE_MSG=\"#delete-after-fault-injection\"\n\n# Get the REGION of the instance\nEC2_REGION=$AWS_SSM_REGION_NAME\n\n# Endpoints we want to preserve (SSM API)\nSSMMESSAGES_ENDPOINT=ssmmessages.$AWS_SSM_REGION_NAME.amazonaws.com\nSSM_ENDPOINT=ssm.$AWS_SSM_REGION_NAME.amazonaws.com\nEC2MESSAGES_ENDPOINT=ec2messages.$AWS_SSM_REGION_NAME.amazonaws.com\n\nPROTECTED_ENDPOINTS=(\n  \"${SSMMESSAGES_ENDPOINT}\"\n  \"${SSM_ENDPOINT}\"\n  \"${EC2MESSAGES_ENDPOINT}\"\n)\n\nadd_imds_ip_to_protected_endpoints \"$AWS_SSM_INSTANCE_ID\"\n\n# Function to enable fault\nenable_fault() {\n  # Exit if FIS network fault is already running\n  test_file_exit() {\n    if [ \"$(ls $1 2>/dev/null | wc -l)\" -ge \"2\" ]; then { echo \"Fault might be already running (Found flag file matching \"$1\"). Exiting...\" 1>&2 ; exit 1; } ; fi;\n  }\n  test_file_exit \"/var/lib/amazon/ssm/Run-Network-*.flag\"\n\n  if [[ \"${PORT}\" =~ ^(443|80)$ ]] && [ \"$TRAFFIC_TYPE\" = \"egress\" ]; then\n    # Create new iptables chain\n    iptables -N fault-in || { echo iptables chain already exist, fault might be already running. Exiting... 1>&2 ; exit 1; }\n    iptables -N fault-out || { echo iptables chain already exist, fault might be already running. Exiting... 1>&2 ; exit 1; }\n\n    # Allowlist the SSM endpoints\n    for e in ${PROTECTED_ENDPOINTS[*]};\n      do\n        get_ips $e >/dev/null 2>&1 # Get the IP and modify the /etc/hosts for domain names\n        iptables -A fault-out -p tcp --dport ${PORT} -d $e -j ACCEPT\n        iptables -A fault-in -m conntrack --ctstate ESTABLISHED,RELATED -d $e -j ACCEPT\n    done\n    iptables -I INPUT -j fault-in\n\n    # Block the requested port/protocol\n    iptables -A fault-out -p ${PROTOCOL} --dport ${PORT} -j DROP\n    iptables -I OUTPUT -j fault-out\n\n  elif ! [[ \"${PORT}\" =~ ^(443|80)$ ]] && [ \"${TRAFFIC_TYPE}\" = \"egress\" ] ; then\n    # Create new iptables chain\n    iptables -N fault-out || { echo iptables chain already exist, fault might be already running. Exiting... 1>&2 ; exit 1; }\n    # Block the requested port/protocol\n    iptables -A fault-out -p ${PROTOCOL} --dport ${PORT} -j DROP\n    iptables -I OUTPUT -j fault-out\n\n  elif [ \"${TRAFFIC_TYPE}\" = \"ingress\" ] ; then\n    # Create new iptables chain\n    iptables -N fault-in || { echo iptables chain already exist, fault might be already running. Exiting... 1>&2 ; exit 1; }\n    # Block the requested port/protocol\n    iptables -A fault-in -p ${PROTOCOL} --dport ${PORT} -j DROP\n    iptables -I INPUT -j fault-in\n  fi\n}\n\n# Function to disable fault\ndisable_fault() {\n  echo \"Rolling back...\"\n  check_chain_exists()\n  {\n    iptables --list \"$1\" >/dev/null 2>&1\n  }\n  if check_chain_exists fault-out; then\n    iptables -F fault-out\n    iptables -D OUTPUT -j fault-out\n    iptables -X fault-out\n  fi\n  if check_chain_exists fault-in; then\n    iptables -F fault-in\n    iptables -D INPUT -j fault-in\n    iptables -X fault-in\n  fi\n  restore_hosts_file\n}\n\n#################################\n# General fault-execution logic #\n#################################\n\n# Function to generate the flag path\nget_flag_path() {\n  local fault_name=\"$1\"\n  local random_string=\"$2\"\n  echo \"/var/lib/amazon/ssm/$fault_name-$random_string.flag\"\n}\n\n# Function to generate the rollback path\nget_rollback_path() {\n  local fault_name=\"$1\"\n  local random_string=\"$2\"\n  echo \"/var/lib/amazon/ssm/$fault_name-$random_string-Rollback.sh\"\n}\n\nget_user_vars() {\n    # Define system variable patterns to exclude\n    local patterns=(\n        '^BASH_'\n        '^COMP_'\n        '^EUID$'\n        '^PPID$'\n        '^SHELLOPTS$'\n        '^UID$'\n        '^PWD$'\n        '^OLDPWD$'\n        '^SHLVL$'\n        '^_$'\n    )\n    \n    # Join patterns with |\n    local exclude_pattern=$(IFS='|'; echo \"${patterns[*]}\")\n    \n    # Get variables using set\n    set | grep \"^[A-Za-z][A-Za-z0-9_]*=\" | \n    grep -Ev \"$exclude_pattern\" | \n    grep -Ev \"^(patterns|exclude_pattern)=\"\n}\n\n# Function to create rollback script\ncreate_rollback_script() {\n  local FLAG_PATH=\"$1\"\n  local ROLLBACK_PATH=\"$2\"\n  local MAX_FLAG_AGE_SECONDS=\"$3\"\n  local ATTEMPT_ROLLBACK_AT_SECONDS=\"$4\"\n  local DISABLE_FAULT_COMMAND=\"$5\"\n  local ROLLBACK_LOG_FILE=\"/tmp/aws-fis-rollback-$(date -u +%Y-%m-%dT%H:%M:%SZ)-$$.log\"\n\n  # Validate that required functions exist before creating the script\n  if ! declare -f restore_hosts_file >/dev/null 2>&1; then\n    echo \"ERROR: restore_hosts_file function required but not found\" >&2\n    return 1\n  fi\n\n  # Creating a file with rollback check command to be executed by atd\n  cat << EOF > \"$ROLLBACK_PATH\"\n#!/bin/bash\n# Environment variables needed to run the rollback command\n$(get_user_vars)\n\n# Setup dual logging - redirect all output to both temp file and syslog\nexec 1> >(tee -a \"$ROLLBACK_LOG_FILE\" | while read line; do logger -t \"aws-fis-rollback\" -p \"local0.info\" \"[\\$(date -u '+%Y-%m-%dT%H:%M:%SZ')] \\$line\" 2>/dev/null || true; done)\nexec 2>&1\n\n# Dont sleep if run in terminal\nif ! [ -t 0 ] ; then\n  sleep $ATTEMPT_ROLLBACK_AT_SECONDS\nfi\n\n# Include the function definition and its dependencies\n$(declare -f restore_hosts_file)\n$(declare -f \"$DISABLE_FAULT_COMMAND\")\n\nif ! [ -f \"$FLAG_PATH\" ] || [ \"\\$(( \\$(date +%s) - \\$(stat -c \"%Y\" \"$FLAG_PATH\") ))\" -gt $MAX_FLAG_AGE_SECONDS ] || [ -t 0 ]; then\n  echo \"Starting rollback: $DISABLE_FAULT_COMMAND\"\n\n  $DISABLE_FAULT_COMMAND\n  rm -f \"$FLAG_PATH\"\n\n  # Dont delete rollback script if run in terminal\n  if ! [ -t 0 ] ; then\n    rm -f \"$ROLLBACK_PATH\"\n  fi\nfi\nEOF\n\n  echo \"Temporary rollback file created: $ROLLBACK_PATH (logs: $ROLLBACK_LOG_FILE)\"\n}\n\n# Function to schedule rollback attempt\nschedule_rollback_attempt() {\n  local ROLLBACK_PATH=\"$1\"\n  echo \"bash $ROLLBACK_PATH\" | at now 2>&1 | grep -v \"warning: commands will be executed using /bin/sh\"\n}\n\n# Function to perform rollback\nrollback() {\n  local DISABLE_FAULT_COMMAND=\"$1\"\n  local FLAG_PATH=\"$2\"\n  local ROLLBACK_PATH=\"$3\"\n\n  eval \"$DISABLE_FAULT_COMMAND\" ; local STATUS=$?\n  rm -f \"$FLAG_PATH\"\n  rm -f \"$ROLLBACK_PATH\"\n  echo \"Rollback done.\"\n  exit $STATUS\n}\n\n# Function to run fault injection loop\nrun_fault_injection_loop() {\n  local STOP_TIME=\"$1\"\n  local FLAG_PATH=\"$2\"\n  local ROLLBACK_PATH=\"$3\"\n  local INJECTION_LOOP_SLEEP_SECONDS=\"$4\"\n  local DISABLE_FAULT_COMMAND=\"$5\"\n\n  # For the duration of the injection, the flag file is updated, and a rollback check is enqueued\n  while [[ $(date +%s) -lt $STOP_TIME ]] ; do\n    # If the background rollback process fires, it will delete the script\n    # from disk containing the rollback logic. That should not happen while\n    # this script is running, but if it does, we immediately fail the script\n    # to prevent the script from continuing to run as if the fault were active.\n    if ! [ -f \"$ROLLBACK_PATH\" ]; then\n      echo \"Fault rollback script was deleted from disk prematurely, exiting...\" 1>&2\n      # though the rollback likely already happened, we attempt rollback again since\n      # the rollback script might have been deleted by some unanticipated mechanism\n      eval \"$DISABLE_FAULT_COMMAND\"\n      exit 1\n    fi\n    \n    touch \"$FLAG_PATH\"\n    schedule_rollback_attempt \"$ROLLBACK_PATH\"\n    sleep \"$INJECTION_LOOP_SLEEP_SECONDS\"\n  done\n}\n\n# Main execution starts here\nrun_post_fault_injection() {\n  local FAULT_NAME=\"$1\"\n  local DURATION=\"$2\"\n  local ENABLE_FAULT_COMMAND=\"$3\"\n  local DISABLE_FAULT_COMMAND=\"$4\"\n\n  # Constants\n  local -r MAX_FLAG_AGE_SECONDS=10\n  local -r INJECTION_LOOP_SLEEP_SECONDS=5\n  local -r ATTEMPT_ROLLBACK_AT_SECONDS=20\n  local -r STOP_TIME=$(( $(date +%s) + DURATION ))\n  local -r RANDOM_STRING=$(LC_ALL=C cat /dev/urandom | LC_ALL=C tr -dc 'a-zA-Z0-9' | head -c 32)\n  \n  # Define paths\n  local -r FLAG_PATH=$(get_flag_path \"$FAULT_NAME\" \"$RANDOM_STRING\")\n  local -r ROLLBACK_PATH=$(get_rollback_path \"$FAULT_NAME\" \"$RANDOM_STRING\")\n\n  # Create rollback script\n  create_rollback_script \"$FLAG_PATH\" \"$ROLLBACK_PATH\" \"$MAX_FLAG_AGE_SECONDS\" \"$ATTEMPT_ROLLBACK_AT_SECONDS\" \"$DISABLE_FAULT_COMMAND\"\n\n  # Binding the rollback function to these exit signals\n  trap 'rollback \"$DISABLE_FAULT_COMMAND\" \"$FLAG_PATH\" \"$ROLLBACK_PATH\"' INT TERM\n\n  echo \"Making sure atd daemon is running\"\n  # atd must be running in order to use \"at\" later\n  atd || { echo \"Failed to run atd daemon, exiting...\" 1>&2 ; exit 1; }\n\n  echo \"Scheduling rollback\"\n  schedule_rollback_attempt \"$ROLLBACK_PATH\"\n\n  # Injecting fault\n  echo \"Enabling fault injection\"\n  touch \"$FLAG_PATH\"\n  eval \"$ENABLE_FAULT_COMMAND\"\n\n  # Run fault injection loop\n  run_fault_injection_loop \"$STOP_TIME\" \"$FLAG_PATH\" \"$ROLLBACK_PATH\" \"$INJECTION_LOOP_SLEEP_SECONDS\" \"$DISABLE_FAULT_COMMAND\"\n\n  # After the desired duration, the fault injection is removed\n  rollback \"$DISABLE_FAULT_COMMAND\" \"$FLAG_PATH\" \"$ROLLBACK_PATH\"\n}\nrun_post_fault_injection \"$FAULT_NAME\" \"$DURATION\" enable_fault disable_fault"
        ]
      }
    }
  ]
}
