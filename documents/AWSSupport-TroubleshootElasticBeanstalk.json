{
  "schemaVersion": "0.3",
  "description": "The **AWSSupport-TroubleshootElasticBeanstalk** runbook helps you troubleshoot the potential reasons why your AWS Elastic Beanstalk environment is in a ```Degraded``` or ```Severe``` state. This automation checks the following AWS resources associated with your Elastic Beanstalk environment:\n\n- Configuration details for a load balancer, AWS CloudFormation stack, Amazon EC2 Auto Scaling group, Amazon Elastic Compute Cloud (Amazon EC2) instances, and virtual private cloud (VPC).\n- Network configuration issues with the associated security group rules, route tables, and network access control lists (ACLs) associated with your subnets.\n- Verifies connectivity to the Elastic Beanstalk endpoints and public internet access.\n- Verifies the status of the load balancer.\n- Verifies the status of the Amazon EC2 instances.\n- Retrieves a log bundle from your Elastic Beanstalk environment, and optionally uploads the files to AWS Support.",
  "assumeRole": "{{ AutomationAssumeRole }}",
  "parameters": {
    "AutomationAssumeRole": {
      "type": "AWS::IAM::Role::Arn",
      "description": "(Optional) The Amazon Resource Name (ARN) of the AWS Identity and Access Management (IAM) role that allows Systems Manager Automation to perform the actions on your behalf. If no role is specified, Systems Manager Automation uses the permissions of the user that starts this runbook.",
      "default": ""
    },
    "ApplicationName": {
      "type": "String",
      "description": "(Required) The name of your Elastic Beanstalk application.",
      "allowedPattern": "^[A-Za-z0-9\\_\\'\\.\\,\\+\\-\\[\\]\\(\\)]{1,100}$"
    },
    "EnvironmentName": {
      "type": "String",
      "description": "(Required) The name of your Elastic Beanstalk environment.",
      "allowedPattern": "^[a-zA-Z0-9]{1}[a-zA-Z0-9\\-]{2,38}[a-zA-Z0-9]{1}$"
    },
    "AWSS3UploaderLink": {
      "default": "",
      "type": "String",
      "description": "(Optional) A URL provided to you by AWS Support to upload the log bundle from your Elastic Beanstalk environment to the AWS Support S3 Uploader. This option is only available to customers who have purchased an AWS Support plan, and have opened a Support case. Please make sure you are not sending any sensitive data, including access credentials and data bound by special requirements or regulations.",
      "allowedPattern": "^$|https://d1mg6achc83nsz.cloudfront.net/[a-z0-9]{1,64}/us-east-1"
    }
  },
  "mainSteps": [
    {
      "name": "IAMPermissionsCheck",
      "onFailure": "Abort",
      "onCancel": "Abort",
      "action": "aws:executeScript",
      "isCritical": true,
      "description": "Verifies the AWS Identity and Access Management (IAM) principal who started the automation has the requisite permissions to perform all of the actions defined in the runbook.",
      "timeoutSeconds": 60,
      "inputs": {
        "Runtime": "python3.8",
        "Handler": "iam_permission_handler.iam_permission_handler",
        "Attachment": "attachment.zip",
        "Script": "import boto3\nfrom modules.common.iam import simulation\nfrom modules.common.iam.iam_const import REQUIRED_PERMISSIONS\nfrom modules.common.printlogs import report,final_report\nfrom modules.common.errors import error_and_exit\ndef iam_permission_handler(events,context):\n\t'\\n    The iam_permission_handler() verifies if the\\n    user who initiated this RunBook or optionally passed SSM role has enough permission\\n    to perform all required intended actions or not\\n    ';H='Message: [{}].';G='Info code: {}';F='ERROR';E='INFO';A='SUBSECTION';I=boto3.client('sts');B='FAILED';C=[];D=[]\n\ttry:\n\t\tJ=I.get_caller_identity();K=J.get('UserId').split(':')[0];C,D,B=simulation.simulate_caller_policy(K,REQUIRED_PERMISSIONS);report('HEADING','NODASH','IAM Permissions check');report('SUBHEADING',E,'Results: [{}].',B)\n\t\tif B!='SUCCESS':report(A,F,G,C);report(A,F,H,''.join(D))\n\t\telse:report(A,E,G,C);report(A,E,H,''.join(D))\n\t\treturn{'FinalResult':final_report()}\n\texcept Exception as L:error_and_exit(L)\n"
      },
      "outputs": [
        {
          "Name": "out",
          "Selector": "$.Payload.FinalResult",
          "Type": "String"
        }
      ],
      "nextStep": "ProceedOnlyIfUserHasPermission"
    },
    {
      "name": "ProceedOnlyIfUserHasPermission",
      "action": "aws:branch",
      "onFailure": "Abort",
      "description": "Branches the workflow based on the results of the previous step.",
      "inputs": {
        "Choices": [
          {
            "Variable": "{{ IAMPermissionsCheck.out }}",
            "StringEquals": "OK",
            "NextStep": "GetEnvironmentDetails"
          }
        ],
        "Default": "Finish"
      }
    },
    {
      "name": "GetEnvironmentDetails",
      "description": "Collects information about the Elastic Beanstalk environment including the load balancer, AWS CloudFormation stack, Auto Scaling group, Amazon EC2 instances, and VPC configuration.",
      "action": "aws:executeScript",
      "onFailure": "Abort",
      "onCancel": "Abort",
      "isCritical": true,
      "timeoutSeconds": 180,
      "maxAttempts": 1,
      "inputs": {
        "Runtime": "python3.8",
        "Handler": "script_handler",
        "Attachment": "attachment.zip",
        "InputPayload": {
          "EnvironmentName": "{{ EnvironmentName }}",
          "ApplicationName": "{{ ApplicationName }}"
        },
        "Script": "_N='Message'\n_M='ApplicationName'\n_L='EnvironmentName'\n_K='LoadBalancerType'\n_J='EnvironmentType'\n_I='Subnets'\n_H='AutoScalingGroups'\n_G='SecurityGroups'\n_F='Error'\n_E=True\n_D='Values'\n_C='Null'\n_B=None\n_A='Name'\nimport botocore,boto3\nclass EnvironmentProperties:\n\t'Represents a Beanstalk environment, with all the inherited properites.\\n\\n    Parameters\\n    ----------\\n    environment_name : String\\n        Beanstalk Environment name.\\n    application_name : String\\n        Beanstalk Application name.\\n    '\n\tdef __init__(A,environment_name=_B,application_name=_B,acc_id=_B,aws_region=_B):\n\t\t'Fetch and populate all the properties.\\n\\n        Parameters\\n        ----------\\n        environment_name : String\\n            Beanstalk Environment name.\\n        application_name : String\\n            Beanstalk Application name.\\n\\n        Returns\\n        -------\\n        JSON document\\n            Returns a JSON structure with all the environment properites.\\n\\n        ';E='aws:elasticbeanstalk:environment';D=application_name;C=environment_name;B='aws:ec2:vpc'\n\t\ttry:\n\t\t\tif C is _B or D is _B:print('Both Environment and Application must be supplied.');exit(1)\n\t\t\tA.eb_client=boto3.client('elasticbeanstalk');A.ec2_client=boto3.client('ec2');A.asg_client=boto3.client('autoscaling');A.account_id=acc_id;A.region=aws_region;A.environment_name=C;A.application_name=D;A.env_option_settings=A.load_option_settings();A.env_resources=A.load_env_resources();A.lb_subnets=A.get_option_setting('ELBSubnets',B,want_list=_E);A.ec2_subnets=A.get_option_setting(_I,B,want_list=_E);A.vpc=A.get_option_setting('VPCId',B);A.env_type=A.get_option_setting(_J,E);A.elb_type=A.get_option_setting(_K,E);A.elb_security_groups=A.get_balancer_security_groups();A.ec2_security_groups=A.get_instance_security_groups();A.environment_ec2=A.get_environment_instances();A.cfn_arn=A.get_cloudformation_arn();A.loadbalancer_arn=A.get_loadbalancer_arn()\n\t\t\tif A.vpc==_C:A.vpc=A.get_default_vpc();A.ec2_subnets=A.get_ec2_default_subnets();A.lb_subnets=A.ec2_subnets\n\t\texcept:raise Exception('[ERROR] - There was a failure while retrieving the environment details.')\n\tdef get_properties(A):'Return the environment properties.';return{_J:A.env_type,'EC2Subnet':A.ec2_subnets,'LBSubnets':A.lb_subnets,'EC2Security':A.ec2_security_groups,'ELBSecurity':A.elb_security_groups,'VPC':A.vpc,'LoadBalancer':A.loadbalancer_arn,_K:A.elb_type,'CloudFormation':A.cfn_arn,'EC2Instances':A.environment_ec2,_L:A.environment_name,_M:A.application_name}\n\tdef load_option_settings(A):\n\t\t'Load all the option settings.'\n\t\ttry:C=A.eb_client.describe_configuration_settings(ApplicationName=A.application_name,EnvironmentName=A.environment_name)\n\t\texcept botocore.exceptions.ClientError as B:D=B.response[_F]['Code'];E=B.response[_F][_N];raise Exception(f\"An error occurred: {D}:{E}.\")\n\t\treturn C['ConfigurationSettings'][0]['OptionSettings']\n\tdef load_env_resources(A):\n\t\t'Load all the environment resources.'\n\t\ttry:return A.eb_client.describe_environment_resources(EnvironmentName=A.environment_name)['EnvironmentResources']\n\t\texcept botocore.exceptions.ClientError as B:C=B.response[_F]['Code'];D=B.response[_F][_N];raise Exception(f\"An error occurred: {C}:{D}.\")\n\tdef get_option_setting(C,option,namespace,want_list=False):\n\t\t'Retrieve EB environment specific option setting.';B=[A for A in C.env_option_settings if A['OptionName']==option and A['Namespace']==namespace];A=B[0].get('Value',_C)if B else _C\n\t\tif len(A.split(',',-1))>1:return A.split(',',-1)\n\t\treturn[A]if want_list and A!=_C else A\n\tdef get_environment_instances(A):'Retrieve EB environment EC2 Instances.';return[A['Id']for A in A.env_resources['Instances']if'Id'in A]\n\tdef get_instance_security_groups(A):'Retrieve EC2 Instances attached security groups.';B=A.get_option_setting(_G,'aws:autoscaling:launchconfiguration',want_list=_E);C=A.ec2_client.describe_security_groups(Filters=[{_A:'group-name',_D:B}])[_G];C+=A.ec2_client.describe_security_groups(Filters=[{_A:'group-id',_D:B}])[_G];return[A['GroupId']for A in C]\n\tdef get_balancer_security_groups(A):\n\t\t'Retrieve Balancer attached security groups.'\n\t\tif A.env_type!='LoadBalanced':return[]\n\t\tif A.elb_type!='classic':B='aws:elbv2:loadbalancer'\n\t\telse:B='aws:elb:loadbalancer'\n\t\tC=A.get_option_setting(_G,B,want_list=_E)\n\t\tif not isinstance(C,list):return[]\n\t\treturn C\n\tdef get_loadbalancer_arn(A):\n\t\t'Obtain Load Balancer ARN. This will differ depending on the type.';B='LoadBalancers'\n\t\tif len(A.env_resources[B])==0:return _C\n\t\treturn A.env_resources[B][0][_A]\n\tdef get_cloudformation_arn(A):'Retrieve the CloudFormation ARN for the underlying Stack.';B=A.env_resources[_H][0][_A];C=A.asg_client.describe_auto_scaling_groups(AutoScalingGroupNames=[B])[_H][0]['Tags'];return[A['Value']for A in C if A['Key']=='aws:cloudformation:stack-id'][0]\n\tdef get_default_vpc(B):'Retrieve the default VPC.';A=B.ec2_client.describe_vpcs(Filters=[{_A:'isDefault',_D:['true']}])['Vpcs'];return A[0]['VpcId']if A else _C\n\tdef get_ec2_default_subnets(A):'Retrieve the default subnets.';B=A.env_resources[_H][0][_A];C=A.asg_client.describe_auto_scaling_groups(AutoScalingGroupNames=[B])[_H][0]['AvailabilityZones'];D=A.ec2_client.describe_subnets(Filters=[{_A:'default-for-az',_D:['true'],_A:'vpc-id',_D:[A.vpc]}])[_I];return[A['SubnetId']for A in D if A['AvailabilityZone']in C]\ndef script_handler(events,context):'Will be invoked by external modules.\\n\\n    Returns\\n    -------\\n    type\\n        Environment properties.\\n    ';C='None';B=context;A=events;D=A.get(_L,C).strip();E=A.get(_M,C).strip();F=B['global:ACCOUNT_ID'];G=B['global:REGION'];H=EnvironmentProperties(D,E,F,G);return H.get_properties()\n"
      },
      "outputs": [
        {
          "Name": "EnvironmentType",
          "Selector": "$.Payload.EnvironmentType",
          "Type": "String"
        },
        {
          "Name": "EC2Subnet",
          "Selector": "$.Payload.EC2Subnet",
          "Type": "StringList"
        },
        {
          "Name": "LBSubnets",
          "Selector": "$.Payload.LBSubnets",
          "Type": "StringList"
        },
        {
          "Name": "EC2Security",
          "Selector": "$.Payload.EC2Security",
          "Type": "StringList"
        },
        {
          "Name": "ELBSecurity",
          "Selector": "$.Payload.ELBSecurity",
          "Type": "StringList"
        },
        {
          "Name": "VPC",
          "Selector": "$.Payload.VPC",
          "Type": "String"
        },
        {
          "Name": "LoadBalancer",
          "Selector": "$.Payload.LoadBalancer",
          "Type": "String"
        },
        {
          "Name": "LoadBalancerType",
          "Selector": "$.Payload.LoadBalancerType",
          "Type": "String"
        },
        {
          "Name": "CloudFormation",
          "Selector": "$.Payload.CloudFormation",
          "Type": "String"
        },
        {
          "Name": "EC2Instances",
          "Selector": "$.Payload.EC2Instances",
          "Type": "StringList"
        },
        {
          "Name": "EnvironmentName",
          "Selector": "$.Payload.EnvironmentName",
          "Type": "String"
        },
        {
          "Name": "ApplicationName",
          "Selector": "$.Payload.ApplicationName",
          "Type": "String"
        }
      ]
    },
    {
      "name": "CheckVPCSubnets",
      "description": "Checks for network connectivity issues with the route tables and ACLs associated with the subnets in your VPC.",
      "action": "aws:executeScript",
      "onFailure": "Continue",
      "onCancel": "Abort",
      "timeoutSeconds": 180,
      "maxAttempts": 1,
      "inputs": {
        "Runtime": "python3.8",
        "Handler": "script_handler",
        "Attachment": "attachment.zip",
        "InputPayload": {
          "EnvironmentType": "{{ GetEnvironmentDetails.EnvironmentType }}",
          "VPC": "{{ GetEnvironmentDetails.VPC }}",
          "LBSubnets": "{{ GetEnvironmentDetails.LBSubnets }}",
          "EC2Subnet": "{{ GetEnvironmentDetails.EC2Subnet }}"
        },
        "Script": "_E='CidrBlock'\n_D='Egress'\n_C='Entries'\n_B=None\n_A=True\nimport boto3\nfrom modules.common.netlib import nacl_allowed\nfrom modules.common.errors import error_and_exit\nfrom modules.common.errors import ERROR_MESSAGES,INFO_MESSAGES\nfrom modules.common.printlogs import report,final_report\ndef is_nacl_ingress_allowed(nacl_to_check,cidr,port_from,port_to,protocol):'Evaluate NACL Ingress Entries against provided CIDR and port range.';A=[A for A in nacl_to_check.get(_C,[])if A.get(_D)is False and len(A.get(_E,''))>0];return nacl_allowed(nacl_rules=A,cidr=cidr,port_from=port_from,port_to=port_to,protocol=protocol)\ndef is_nacl_egress_allowed(nacl_to_check,cidr,port_from,port_to,protocol):'\\n    Evaluate NACL Egress Entries against provided CIDR and port range.\\n    IPv6 entries are ignored.\\n    ';print('Checking egress NACL rules');A=[A for A in nacl_to_check.get(_C,[])if A.get(_D)is _A and len(A.get(_E,''))>0];return nacl_allowed(nacl_rules=A,cidr=cidr,port_from=port_from,port_to=port_to,protocol=protocol)\ndef check_networking(vpc=_B,subnets=_B):\n\t'Check VPC and subnets.';Y='RouteTables';X='association.subnet-id';W='SubnetId';U='ERROR';T='WARNING';S='RouteTableId';R='ITEM';Q='SUBSECTION';O=vpc;N='Values';M='Name';L='INFO';K='NODASH';H='TCP';E='0.0.0.0/0';D='PASSED';C=subnets;A='SUBITEM'\n\ttry:\n\t\tif O is _B or C is _B:error_and_exit('You need to provide both Subnets and a VPC.')\n\t\tI=boto3.client('ec2');report('HEADING',K,'Networking checks');report('SUBHEADING',L,'Processing subnets [{}], within VPC [{}].',C,O);report(Q,K,'Do all subnets belong to the same VPC?');Z=I.describe_subnets(Filters=[{M:'vpc-id',N:[O]}]);a=list(map(lambda subnet:subnet[W],Z['Subnets']))\n\t\tif not all(A in a for A in C):error_and_exit('All the subnets must belong to the same VPC.')\n\t\treport(A,D,'Yes.');report(Q,K,'Checking subnet internet access...');P=I.describe_route_tables(Filters=[{M:X,N:C}])[Y]\n\t\tif not P:P=I.describe_route_tables(Filters=[{M:'association.main',N:['true']}])[Y]\n\t\tfor J in P:\n\t\t\treport(R,L,'Checking route [{}].',J[S]);V=False\n\t\t\tfor F in J['Routes']:\n\t\t\t\tif F.get('DestinationCidrBlock')==E or F.get('DestinationIpv6CidrBlock')=='::/0':\n\t\t\t\t\tV=_A;G=F.get('GatewayId')or F.get('NatGatewayId')or _B\n\t\t\t\t\tif G is _B:report(A,T,ERROR_MESSAGES['NoInet'],buffered=_A)\n\t\t\t\t\telif F['State']!='active':report(A,T,ERROR_MESSAGES['Blackhole'],buffered=_A)\n\t\t\t\t\telif G.startswith('igw-'):report(A,D,INFO_MESSAGES['IGW'],J[S],G)\n\t\t\t\t\telif G.startswith('nat-'):report(A,D,INFO_MESSAGES['NGW'],J[S],G)\n\t\t\t\telse:continue\n\t\t\tif not V:report(A,T,ERROR_MESSAGES['NoDefRoute'],buffered=_A)\n\t\treport(Q,K,'Checking Network ACLs...');b=I.describe_network_acls(Filters=[{M:X,N:C}])['NetworkAcls']\n\t\tfor B in b:\n\t\t\tc=list(map(lambda sub:sub[W],B['Associations']));report(R,L,INFO_MESSAGES['CheckingACLS'],B['NetworkAclId'],set(C).intersection(c));d=is_nacl_ingress_allowed(B,E,1024,65535,H);e=is_nacl_ingress_allowed(B,E,443,443,H);f=is_nacl_ingress_allowed(B,E,80,80,H);g=is_nacl_egress_allowed(B,E,443,443,H);h=is_nacl_egress_allowed(B,E,80,80,H);report(R,L,'Final traffic analysis...')\n\t\t\tif d:report(A,D,'Return traffic.')\n\t\t\telse:report(A,U,ERROR_MESSAGES['NoReturnTraffic'],buffered=_A)\n\t\t\tif e and f:report(A,D,'Inbound application traffic (443 and 80).')\n\t\t\telse:report(A,U,ERROR_MESSAGES['NoApplicationTraffic'],buffered=_A)\n\t\t\tif g and h:report(A,D,'Outgoing Internet traffic (443 and 80).')\n\t\t\telse:report(A,U,ERROR_MESSAGES['NoInternetTraffic'],buffered=_A)\n\texcept Exception as i:error_and_exit(i)\n\treturn final_report()\ndef script_handler(events,context):'Will be invoked by external modules.';A=events;B=A['VPC'];C=list(set(A.get('EC2Subnet',[])+A.get('LBSubnets',[])));return{'FinalResult':check_networking(B,C)}\n"
      },
      "outputs": [
        {
          "Name": "out",
          "Selector": "$.Payload.FinalResult",
          "Type": "String"
        }
      ]
    },
    {
      "name": "CheckSecurityGroups",
      "description": "Checks for network connectivity issues with the security group rules associated with your Amazon EC2 instances.",
      "action": "aws:executeScript",
      "onFailure": "Continue",
      "onCancel": "Abort",
      "timeoutSeconds": 180,
      "maxAttempts": 1,
      "inputs": {
        "Runtime": "python3.8",
        "Handler": "script_handler",
        "Script": "_N='HEADING'\n_M='SGNotFound'\n_L='No Ingress Rules have been detected on this Security Group.'\n_K='NODASH'\n_J='SUBHEADING'\n_I='PASSED'\n_H='null_reference_group'\n_G='All'\n_F='SUBITEM'\n_E='WARNING'\n_D=False\n_C='INFO'\n_B=True\n_A='ITEM'\nimport boto3\nfrom modules.common.errors import ERROR_MESSAGES,INFO_MESSAGES\nfrom modules.common.printlogs import report,final_report\nclient=boto3.client('ec2')\nclass SecurityGroupRule:\n\t'Represents Security Group rules.\\n\\n    Parameters\\n    ----------\\n    Receives all the security group properties.\\n    '\n\tdef __init__(A,sg_id,sg_rule_id,sg_rule_is_egress,sg_rule_ip_protocol,sg_rule_from_port,sg_rule_to_port,sg_rule_reference_group,sg_rule_cidr_ipv4):'Fetch and populate all the properties.';A.sg_id=sg_id;A.sg_rule_id=sg_rule_id;A.sg_rule_is_egress=sg_rule_is_egress;A.sg_rule_ip_protocol=sg_rule_ip_protocol;A.sg_rule_from_port=sg_rule_from_port;A.sg_rule_to_port=sg_rule_to_port;A.sg_rule_reference_group=sg_rule_reference_group;A.sg_rule_cidr_ipv4=sg_rule_cidr_ipv4\n\tdef print_security_group_object(A):'Print Security Group details.';print(f\"Sg-Id {A.sg_id} : Rule-Id {A.sg_rule_id} : IsEgress {A.sg_rule_is_egress} : IpProtocol {A.sg_rule_ip_protocol} : FromPort {A.sg_rule_from_port} : ToPort {A.sg_rule_to_port} : ReferenceGroup Id {A.sg_rule_reference_group} : CidrIpv4 {A.sg_rule_cidr_ipv4}\")\n\tdef print_security_group_rule_single_instance(A):'Print Security Group details.';print(f\"Sg-Id {A.sg_id} : Rule-Id {A.sg_rule_id} : IsEgress {A.sg_rule_is_egress} : IpProtocol {A.sg_rule_ip_protocol} : FromPort {A.sg_rule_from_port} : ToPort {A.sg_rule_to_port} : CidrIpv4 {A.sg_rule_cidr_ipv4}\")\ndef check_security_groups_exist(security_group_list):\n\t'Check if the Security Group exists.';B=[]\n\tfor A in security_group_list:\n\t\ttry:client.describe_security_groups(GroupIds=[A]);report(_A,_C,'Security Group: {} present in VPC.',A);B.append(A)\n\t\texcept:report(_A,_E,'Security Group: {} not present in VPC, removing.',A,buffered=_B)\n\treturn B\ndef fetch_security_group_rules(security_group_id):\n\t'Fetch rules.';A=security_group_id\n\ttry:B=client.describe_security_group_rules(Filters=[{'Name':'group-id','Values':[''+A+'']}]);report(_J,_C,'Security Group {} present, fetched rules.',A);return B\n\texcept:report(_J,_E,'Security Group: {} may have no rules.',A,buffered=_B);return 0\ndef create_security_group_rule_object(rules_list):\n\t'Populate the Security Group object.';N='GroupId';G='-1';B='SecurityGroupRules';A=rules_list;O=len(A[B]);H=[]\n\tfor C in range(0,O):\n\t\ttry:I=A[B][C][N]\n\t\texcept:I='null_sg_id'\n\t\ttry:J=A[B][C]['SecurityGroupRuleId']\n\t\texcept:J='null_sg_r_id'\n\t\ttry:K=A[B][C]['IsEgress']\n\t\texcept:K='null_ingress_egress'\n\t\ttry:D=A[B][C]['IpProtocol']\n\t\texcept:D='null_ip_protocol'\n\t\ttry:E=A[B][C]['FromPort']\n\t\texcept:E='null_from_port'\n\t\ttry:F=A[B][C]['ToPort']\n\t\texcept:F='null_to_port'\n\t\ttry:L=A[B][C]['ReferencedGroupInfo'][N]\n\t\texcept:L=_H\n\t\ttry:M=A[B][C]['CidrIpv4']\n\t\texcept:M='null_cidr_ipv4'\n\t\tif D==G:D=_G\n\t\tif E==int(G):E=_G\n\t\tif F==int(G):F=_G\n\t\tH.append(SecurityGroupRule(I,J,K,D,E,F,L,M))\n\treturn H\ndef check_single_instance_security_group(rules_list):\n\t'Check the Security Group object.';D=rules_list;C='0.0.0.0/0';B=[]\n\tif D:\n\t\tfor A in D:\n\t\t\treport(_A,_C,'FromPort: {} ToPort: {} IpProtocol: {} CidrIpv4: {}',A.sg_rule_from_port,A.sg_rule_to_port,A.sg_rule_ip_protocol,A.sg_rule_cidr_ipv4)\n\t\t\tif check_wildcard_rule(A)and A.sg_rule_is_egress==_B:report(_F,_I,'This egress rule allows all traffic on all ports TO any CIDR.');B.append(A)\n\t\t\tif check_wildcard_rule(A)and A.sg_rule_is_egress==_D:report(_F,_I,'This ingress rule allows all traffic on all ports FROM any CIDR.');B.append(A)\n\t\t\tif check_http_rule(A)and A.sg_rule_is_egress==_D and A.sg_rule_cidr_ipv4!=C:report(_F,_E,ERROR_MESSAGES['SGLimitingAccess80'],A.sg_rule_cidr_ipv4,buffered=_B)\n\t\t\tif check_http_rule(A)and A.sg_rule_is_egress==_D and A.sg_rule_cidr_ipv4==C:report(_F,_I,'This ingress HTTP rule allows all incoming traffic on port 80.');B.append(A)\n\t\t\tif check_https_rule(A)and A.sg_rule_is_egress==_D and A.sg_rule_cidr_ipv4!=C:report(_F,_E,ERROR_MESSAGES['SGLimitingAccess443'],A.sg_rule_cidr_ipv4,buffered=_B)\n\t\t\tif check_https_rule(A)and A.sg_rule_is_egress==_D and A.sg_rule_cidr_ipv4==C:report(_F,_I,'This ingress HTTPS rule allows all incoming traffic on port 443.');B.append(A)\n\t\treturn B\n\treport(_F,_E,ERROR_MESSAGES[_M],buffered=_B)\ndef check_load_balanced_env_instance_security_group(rules_list,valid_loadbalancer_groups):\n\t'Check the Load Balancer Security Group.';C=rules_list;B=valid_loadbalancer_groups\n\tif C:\n\t\tfor A in C:\n\t\t\treport(_A,_C,'FromPort: {} ToPort: {} IpProtocol: {} SourceGroup: {}  RuleIsEgress: {}',A.sg_rule_from_port,A.sg_rule_to_port,A.sg_rule_ip_protocol,A.sg_rule_reference_group,A.sg_rule_is_egress)\n\t\t\tif check_wildcard_rule(A)and A.sg_rule_is_egress==_D and A.sg_rule_reference_group!=_H:report(_A,_C,'This ingress rule allows all traffic on all ports from another Security Group {}.',A.sg_rule_reference_group);check_source_rule_match_elb(A,B)\n\t\t\tif check_http_rule(A)and A.sg_rule_is_egress==_D and A.sg_rule_reference_group!=_H:report(_A,_C,'This ingress HTTP rule allows incoming traffic on port 80 from another Security Group {}.',A.sg_rule_reference_group);check_source_rule_match_elb(A,B)\n\t\t\tif check_https_rule(A)and A.sg_rule_is_egress==_D and A.sg_rule_reference_group!=_H:report(_A,_C,'This ingress HTTPS rule allows incoming traffic on port 443 from another Security Group {}.',A.sg_rule_reference_group);check_source_rule_match_elb(A,B)\n\telse:report(_F,_E,ERROR_MESSAGES[_M],buffered=_B)\ndef check_source_rule_match_elb(rule,valid_loadbalancer_groups):\n\t'Check the Security Group source from ELB.';A=valid_loadbalancer_groups\n\tif A:\n\t\tfor B in A:\n\t\t\tif rule.sg_rule_reference_group==B.sg_id:report(_F,_I,INFO_MESSAGES['SGMatches'],rule.sg_rule_id,B.sg_id);return _B\n\t\t\telse:return _D\n\telse:report(_A,_E,'No Load Balancer Groups to compare against.',buffered=_B);return _D\ndef check_wildcard_rule(ruleObject):\n\t'Check wildcard rules.';A=ruleObject\n\tif A.sg_rule_from_port==_G and A.sg_rule_to_port==_G and A.sg_rule_ip_protocol==_G:return _B\n\telse:return _D\ndef check_http_rule(ruleObject):\n\t'Check HTTP rules.';A=ruleObject\n\tif A.sg_rule_from_port==80 and A.sg_rule_to_port==80:return _B\n\telse:return _D\ndef check_https_rule(ruleObject):\n\t'Check HTTPs rules.';A=ruleObject\n\tif A.sg_rule_from_port==443 and A.sg_rule_to_port==443:return _B\n\telse:return _D\ndef filter_ingress_rule(rules_list):\n\t'Filter rules.';B=rules_list;C=[]\n\tif B:\n\t\tfor A in B:\n\t\t\tif A.sg_rule_is_egress is _D:report(_A,_C,'Identified rule [{}] as ingress.',A.sg_rule_id);C.append(A)\n\t\treturn C\n\treport(_A,_C,'Identified no ingress rules in this Security Group.')\ndef filter_single_instance_egress(rules_list):\n\t'Filter Single Instance rules.';B=rules_list;C=[]\n\tif B:\n\t\tfor A in B:\n\t\t\tif A.sg_rule_is_egress is _B:report(_A,_C,'Identified rule [{}] as egress.',A.sg_rule_id);C.append(A)\n\t\treturn C\n\treport(_A,_C,'Identified no egress rules in this Security Group.')\ndef filter_elb_env_instance_group_source(rules_list):\n\tB=rules_list;C=[]\n\tif B:\n\t\tfor A in B:\n\t\t\tif A.sg_rule_reference_group!=_H:report(_A,_C,'Identified rule [{}] has source to another Security Group.',A.sg_rule_id);C.append(A)\n\t\treturn C\n\telse:report(_A,_C,'No rules in this Security Group with source to another Security Group.')\ndef filter_rules_to_check(rules_list):\n\tC=rules_list;B=[]\n\tif C:\n\t\tfor A in C:\n\t\t\tif check_wildcard_rule(A)is _B:report(_A,_C,'Rule [{}] is wildcard.',A.sg_rule_id);B.append(A)\n\t\t\telif check_http_rule(A)is _B:report(_A,_C,'Rule [{}] is HTTP.',A.sg_rule_id);B.append(A)\n\t\t\telif check_https_rule(A)is _B:report(_A,_C,'Rule [{}] is HTTPS.',A.sg_rule_id);B.append(A)\n\t\t\telse:report(_A,_C,'Rule: [{}] is non wildcard, http or https - skipping.',A.sg_rule_id)\n\t\treturn B\n\telse:report(_A,_C,'No rules to check for this Security Group.')\ndef process_single_instance_env(valid_instance_groups):\n\tfor A in valid_instance_groups:\n\t\tG=fetch_security_group_rules(A);B=create_security_group_rule_object(G);C=filter_ingress_rule(B);D=filter_single_instance_egress(B);report(_A,_C,'Checking - {}.',A);E=[];F=[]\n\t\tif not C:report(_A,_E,_L,buffered=_B)\n\t\telse:E=filter_rules_to_check(C);check_single_instance_security_group(E)\n\t\tif not D:report(_A,_E,'No Egress Rules have been detected on this Security Group.',buffered=_B)\n\t\telse:F=filter_rules_to_check(D);check_single_instance_security_group(F)\n\treturn final_report()\ndef process_load_balanced_env(valid_instance_groups,valid_loadbalancer_groups):\n\treport(_N,_K,'Load Balanced Environment Identified');report(_J,_K,'Load Balancer Security Groups')\n\tfor D in valid_loadbalancer_groups:\n\t\tE=fetch_security_group_rules(D);F=create_security_group_rule_object(E);A=filter_ingress_rule(F);B=filter_rules_to_check(A)\n\t\tif not A:report(_A,_E,_L);report(_A,_E,'Load Balancer Security Group must have a rule to allow incoming traffic.',buffered=_B)\n\t\telse:check_single_instance_security_group(B)\n\treport(_J,_K,'Instance Security Groups')\n\tfor G in valid_instance_groups:\n\t\tH=fetch_security_group_rules(G);I=create_security_group_rule_object(H);C=filter_ingress_rule(I)\n\t\tif not C:report(_A,_E,_L);report(_A,_E,'Instance Security Group must have a rule to allow traffic from Load Balancer.',buffered=_B)\n\t\telse:J=filter_rules_to_check(C);K=filter_elb_env_instance_group_source(J);check_load_balanced_env_instance_security_group(K,B)\n\treturn final_report()\ndef script_handler(events,context):\n\t'Will be invoked by external modules.';F='SingleInstance';D=events;B='FinalResult';G=D.get('EC2Security',[]);H=D.get('ELBSecurity',[]);E=D.get('EnvironmentType',F);A=check_security_groups_exist(G);C=check_security_groups_exist(H)\n\tif E==F:\n\t\tif not A:return{B:'Single Instance environment detected but no Security Groups identified, skipping Security Group check.'}\n\t\telse:report(_N,_K,'Single Instance Environment Identified.');return{B:process_single_instance_env(A)}\n\telif E=='LoadBalanced':\n\t\tif not(C or A):return{B:'Load Balanced environment detected but no Security Groups identified at ELB or Instance Level, skipping Security Group check.'}\n\t\telif C and A:return{B:process_load_balanced_env(A,C)}\n\t\telif not C:print('No ELB Security Groups detected, possible Network Load Balancer, continuing check for Instance Security Groups.');return{B:process_single_instance_env(A)}\n\telse:return{B:'Security script check did not receive required information, skipping Security Group check.'}\n",
        "Attachment": "attachment.zip",
        "InputPayload": {
          "EnvironmentType": "{{ GetEnvironmentDetails.EnvironmentType }}",
          "EC2Security": "{{ GetEnvironmentDetails.EC2Security }}",
          "ELBSecurity": "{{ GetEnvironmentDetails.ELBSecurity }}"
        }
      },
      "outputs": [
        {
          "Name": "out",
          "Selector": "$.Payload.FinalResult",
          "Type": "String"
        }
      ]
    },
    {
      "name": "CheckEc2Health",
      "description": "Verifies the status checks for the Amazon EC2 instances.",
      "action": "aws:executeScript",
      "onFailure": "Continue",
      "onCancel": "Abort",
      "timeoutSeconds": 180,
      "maxAttempts": 1,
      "inputs": {
        "Runtime": "python3.8",
        "Handler": "script_handler",
        "Attachment": "attachment.zip",
        "InputPayload": {
          "EnvironmentName": "{{ GetEnvironmentDetails.EnvironmentName }}",
          "ApplicationName": "{{ GetEnvironmentDetails.ApplicationName }}",
          "EnvironmentType": "{{ GetEnvironmentDetails.EnvironmentType }}",
          "LoadBalancer": "{{ GetEnvironmentDetails.LoadBalancer }}",
          "LoadBalancerType": "{{ GetEnvironmentDetails.LoadBalancerType }}"
        },
        "Script": "_A=None\nimport boto3\nfrom modules.common.errors import error_and_exit,ERROR_MESSAGES,INFO_MESSAGES\nfrom modules.common.printlogs import report,final_report\ndef get_health_info(environment_name=_A,env_type=_A,lb_arn=_A,lb_type=_A):\n\t'Retrieve health details.';f='Description';e='Details: {}';d='Reason: {}';c='Target unhealthy.';b='State: {}';a='Target';Z='Target status report:';Y='Port';X='Possible causes: {}';W='HealthStatus';V='INFO';U='All';S=lb_arn;R=environment_name;Q='ITEM';P='InstanceId';O='Causes';M='SUBSUBITEM';L='State';K='TargetHealth';J=True;I='SUBHEADING';E='SUBITEM';D='SUBSECTION';C='WARNING';A='NODASH'\n\ttry:\n\t\tT=boto3.client('elasticbeanstalk');F=T.describe_environment_health(EnvironmentName=R,AttributeNames=[U]);g=T.describe_instances_health(EnvironmentName=R,AttributeNames=[U])['InstanceHealthList'];report('HEADING',A,'Environment overall health');report(I,V,'Health status: [{}].',F[W])\n\t\tif len(F[O])>0:report(D,C,X,F[O],buffered=J)\n\t\treport(I,A,'EC2 Instance summary');report(D,V,'{}',F['InstancesHealth']);report(I,A,'Per EC2 Instance report')\n\t\tfor G in g:\n\t\t\tif G[W]!='Ok':report(D,C,ERROR_MESSAGES['EC2Issues'],G[P],buffered=J);report(Q,A,X,G[O])\n\t\t\telse:report(D,'PASSED','EC2 Instance [{}].',G[P])\n\t\treport(I,A,'Load Balancer report')\n\t\tif env_type!='SingleInstance':\n\t\t\tif lb_type!='classic':\n\t\t\t\tH=boto3.client('elbv2')\n\t\t\t\tfor N in H.describe_listeners(LoadBalancerArn=S)['Listeners']:\n\t\t\t\t\treport(D,A,INFO_MESSAGES['ListenerCheck'],N[Y],N['Protocol']);report(D,A,Z)\n\t\t\t\t\tfor B in H.describe_target_health(TargetGroupArn=N['DefaultActions'][0]['TargetGroupArn'])['TargetHealthDescriptions']:\n\t\t\t\t\t\treport(Q,A,'Target: {}',B[a]['Id']);report(E,A,'Port: {}',B[a][Y]);report(E,A,'Health Check Port: {}',B['HealthCheckPort']);report(E,A,b,B[K][L])\n\t\t\t\t\t\tif B[K][L]!='healthy':report(E,C,c,buffered=J);report(M,C,d,B[K]['Reason']);report(M,C,e,B[K][f])\n\t\t\telse:\n\t\t\t\tH=boto3.client('elb');report(D,A,Z)\n\t\t\t\tfor B in H.describe_instance_health(LoadBalancerName=S)['InstanceStates']:\n\t\t\t\t\treport(Q,A,'Checking target: {}',B[P]);report(E,A,b,B[L])\n\t\t\t\t\tif B[L]!='InService':report(E,C,c,buffered=J);report(M,C,d,B['ReasonCode']);report(M,C,e,B[f])\n\t\treturn final_report()\n\texcept Exception as h:error_and_exit(h)\ndef script_handler(events,context):'Will be invoked by external modules.';A=events;B=A.get('EnvironmentName',_A);C=A.get('EnvironmentType',_A);D=A.get('LoadBalancer',_A);E=A.get('LoadBalancerType',_A);return{'FinalResult':get_health_info(B,C,D,E)}\n"
      },
      "outputs": [
        {
          "Name": "out",
          "Selector": "$.Payload.FinalResult",
          "Type": "String"
        }
      ]
    },
    {
      "name": "CollectLogsLink",
      "description": "Generates a link for a log bundle of your Elastic Beanstalk environment.",
      "action": "aws:executeScript",
      "onFailure": "Continue",
      "onCancel": "Abort",
      "timeoutSeconds": 180,
      "maxAttempts": 1,
      "inputs": {
        "Runtime": "python3.8",
        "Handler": "script_handler",
        "Attachment": "attachment.zip",
        "InputPayload": {
          "EnvironmentName": "{{ GetEnvironmentDetails.EnvironmentName }}",
          "ApplicationName": "{{ GetEnvironmentDetails.ApplicationName }}"
        },
        "Script": "_A=None\nimport boto3\nfrom modules.common.errors import error_and_exit\ndef get_environment_id(environment_name=_A):\n\t'Get the environment ID, by supplying the name.'\n\ttry:A=boto3.client('elasticbeanstalk');B=A.describe_environments(EnvironmentNames=[environment_name]);return B['Environments'][0]['EnvironmentId']\n\texcept Exception as C:error_and_exit(C)\ndef build_url(environment_name=_A,application_name=_A,aws_region=_A):'Build the logs URL.';A=aws_region;B='https://'+A+'.console.aws.amazon.com/elasticbeanstalk/home?region='+A+'#/environment/logs?applicationName='+application_name+'&environmentId='+get_environment_id(environment_name);return B\ndef script_handler(events,context):'Will be nvoked by external modules.\\n\\n    Returns\\n    -------\\n    type\\n        Environment properties.\\n    ';A=events;B=A['EnvironmentName'];C=A['ApplicationName'];D=context['global:REGION'];print('Please find your logs here: %s\\n',build_url(B,C,D));return{'FinalResult':'OK'}\n"
      },
      "outputs": [
        {
          "Name": "out",
          "Selector": "$.Payload.FinalResult",
          "Type": "String"
        }
      ]
    },
    {
      "name": "UploadLogs",
      "description": "Uploads log bundle to AWS Support.",
      "action": "aws:executeScript",
      "onFailure": "Continue",
      "onCancel": "Abort",
      "timeoutSeconds": 180,
      "maxAttempts": 2,
      "inputs": {
        "Runtime": "python3.8",
        "Handler": "script_handler",
        "Attachment": "attachment.zip",
        "InputPayload": {
          "EnvironmentName": "{{ GetEnvironmentDetails.EnvironmentName }}",
          "S3Uploader": "{{ AWSS3UploaderLink }}",
          "EC2Instances": "{{ GetEnvironmentDetails.EC2Instances }}"
        },
        "Script": "_C='bundle'\n_B='elasticbeanstalk'\n_A=None\nimport os,time,random,re,boto3,urllib\nfrom modules.common.errors import error_and_exit\ndef validate_S3_url(input):\n\t'Validate input S3 URL, for ensuring it matches the proper format.\\n\\n    Parameters\\n    ----------\\n    input : String\\n        S3 URL that needs to be checked.\\n\\n    Returns\\n    -------\\n    Bool\\n        Determines if the input us correct or not.\\n    '\n\tif len(input)<=0:return\n\tB=re.compile('https://d1mg6achc83nsz.cloudfront.net/[a-z0-9]+/us-east-1');A=B.search(input);return A.group(0)if A is not _A else _A\ndef check_logs_backoff(retries=5,backoff_in_seconds=1,ec2_count=_A,env_name=_A):\n\t'Check if logs are available using an exponential back-offs strategy.\\n\\n    Parameters\\n    ----------\\n    retries : Int\\n        How many iterations or attempts are required, at maximum.\\n    backoff_in_seconds : Int\\n        Time to wait between iterations.\\n    ec2_count : Int\\n        Numer of EC2 Instances that must produce logs.\\n    env_name : String\\n        Environment name.\\n\\n    Returns\\n    -------\\n    List\\n        List of EC2 Instances and logs.\\n    ';D=boto3.client(_B);A=0;B=True;time.sleep(5)\n\twhile B:\n\t\ttry:\n\t\t\tC=D.retrieve_environment_info(EnvironmentName=env_name,InfoType=_C)['EnvironmentInfo']\n\t\t\tif len(C)<ec2_count:raise Exception('Not all the logs are available yet...')\n\t\t\tB=False\n\t\texcept:\n\t\t\tif A==retries-1:error_and_exit('Unable to collect bundle logs.')\n\t\t\telse:E=backoff_in_seconds*2**A+random.uniform(0,1);time.sleep(E);A+=1\n\treturn C\ndef script_handler(events,context):\n\t'Will be invoked by external modules.';J='FinalResult';B=events;D=B['EnvironmentName'];K=B['S3Uploader'];E=len(B['EC2Instances']);F=validate_S3_url(K)\n\tif F is _A:print('The provided link does not match with the required format.');return{J:'OK'}\n\ttry:L=boto3.client(_B);L.request_environment_info(EnvironmentName=D,InfoType=_C)\n\texcept Exception as M:error_and_exit('The tool was not able to retrieve the logs at the moment.')\n\tN=check_logs_backoff(retries=5,backoff_in_seconds=1,ec2_count=E,env_name=D);G=sorted(N,key=lambda x:x['SampleTimestamp'],reverse=True)\n\tfor H in range(E):\n\t\ttry:\n\t\t\tC=G[H]['Message'];A=str(G[H]['Ec2InstanceId']+'.zip')\n\t\t\tif not C.lower().startswith('https'):error_and_exit('Download URL is not correct - %s.',C)\n\t\t\turllib.request.urlretrieve(C,A);time.sleep(2);O={'Content-Type':'application/zip','Content-Length':os.stat(A).st_size}\n\t\t\twith urllib.request.urlopen(f\"{F}/{A}\")as P:\n\t\t\t\tQ=P.read().decode('utf-8');print('Uploading - %s',A)\n\t\t\t\twith open(A,'rb')as R:\n\t\t\t\t\tS=urllib.request.Request(url=Q,data=R.read(),method='PUT',headers=O)\n\t\t\t\t\twith urllib.request.urlopen(S)as I:0\n\t\t\t\t\tprint('Status - %s',I.status);print('Reason - %s',I.reason)\n\t\texcept Exception as M:error_and_exit('Unable to process file - %s.',A)\n\tprint('The logs have been uploaded to the provided S3 Support link.');return{J:'OK'}\n"
      },
      "outputs": [
        {
          "Name": "out",
          "Selector": "$.Payload.FinalResult",
          "Type": "String"
        }
      ]
    },
    {
      "name": "Finish",
      "description": "Outputs a report of action items to help you troubleshoot issues that might be affecting the status of your Elastic Beanstalk environment.",
      "action": "aws:executeScript",
      "onFailure": "Continue",
      "onCancel": "Abort",
      "isCritical": true,
      "timeoutSeconds": 180,
      "maxAttempts": 2,
      "inputs": {
        "Runtime": "python3.8",
        "Handler": "script_handler",
        "Attachment": "attachment.zip",
        "InputPayload": {
          "IAMPermissionsCheck": "{{ IAMPermissionsCheck.out }}",
          "CheckVPCSubnets": "{{ CheckVPCSubnets.out }}",
          "CheckSecurityGroups": "{{ CheckSecurityGroups.out }}",
          "CheckEc2Health": "{{ CheckEc2Health.out }}",
          "CollectLogsLink": "{{ CollectLogsLink.out }}",
          "UploadLogs": "{{ UploadLogs.out }}"
        },
        "Script": "import sys\nsys.tracebacklimit=0\ndef script_handler(events,context):\n\t'Completing document exectuion.';E=events;D='Not executed';F=[];G=False\n\tfor A in E:\n\t\tB=E.get(A,D)\n\t\tif B=='OK':C='OK'\n\t\telif A in B or B==D:C=D\n\t\telse:C='WARNING - This step needs to be checked.';G=True\n\t\tF.append(f\"- [{A}] -> [{C}]\")\n\tH='\\n\\nThis runbook has completed its execution. Refer to previous steps for additional details.\\n\\nPlease find below a summary of the steps that may require your attention:\\n\\n{}\\n'.format('\\n\\n'.join(F))\n\tif G:raise Exception(H)\n\telse:return H\n"
      },
      "outputs": [
        {
          "Name": "out",
          "Selector": "$.Payload",
          "Type": "String"
        }
      ],
      "isEnd": true
    }
  ],
  "files": {
    "attachment.zip": {
      "checksums": {
        "sha256": "1e1114d257ef84c0d1215a12a6cea0e0df91e7e2082c239fdea1496104794232"
      }
    }
  },
  "outputs": [
    "Finish.out"
  ]
}
