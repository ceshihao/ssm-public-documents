{
  "description": "## Document Name - AWS-RestrictIncomingTraffic\n\n## What does this document do?\nThis document restricts incoming TCP traffic to EC2 security groups on specified ports.\nThe incoming traffic is restricted by removing the ingress rule that allows unrestricted incoming traffic from anywhere ('0.0.0.0/0' and '::/0') to the specified ports.\n\n## Notes\nThis document will successfully execute even if restricting the traffic fails for one or more security groups.\nPlease check the execution output for complete information on successes and failures.\n\n## Input Parameters\n* SecurityGroupIds: (Required) A comma separated list of security group IDs to restrict traffic for.\n* Ports: (Required) A comma separated list of ports to restrict incoming traffic for.\n* AutomationAssumeRole: (Optional) The ARN of the role that allows Automation to perform the actions on your behalf.\n\n## Output Parameters\n* RestrictIncomingTraffic.RestrictedSecurityGroupIds: A list of the security groups which were successfully restricted.\n* RestrictIncomingTraffic.UnrestrictedSecurityGroupIds: A maplist of the security groups which were not successfully restricted and the ports it failed for.\n\n## Minimum Permissions Required\n* `ec2:DescribeSecurityGroups` and `ec2:RevokeSecurityGroupIngress` on the targeted security groups.\n",
  "schemaVersion": "0.3",
  "assumeRole": "{{AutomationAssumeRole}}",
  "parameters": {
    "SecurityGroupIds": {
      "type": "StringList",
      "description": "(Required) A comma separated list of security group IDs to restrict traffic for.",
      "allowedPattern": "^sg-[a-z0-9]{8,17}$"
    },
    "Ports": {
      "type": "StringList",
      "description": "(Required) A comma separated list of ports to restrict incoming traffic for.",
      "allowedPattern": "^[0-9]*$"
    },
    "AutomationAssumeRole": {
      "type": "String",
      "description": "(Optional) The ARN of the role that allows Automation to perform the actions on your behalf.",
      "default": "^arn:aws[a-z0-9-]*:iam::\\d{12}:role\\/[\\w+=,.@_\\/-]+|^$"
    }
  },
  "outputs": [
    "RestrictIncomingTraffic.RestrictedSecurityGroupIds",
    "RestrictIncomingTraffic.UnrestrictedSecurityGroupIds"
  ],
  "mainSteps": [
    {
      "name": "RestrictIncomingTraffic",
      "action": "aws:executeScript",
      "onFailure": "Abort",
      "isCritical": true,
      "isEnd": false,
      "timeoutSeconds": 600,
      "description": "## RestrictIncomingTraffic\nRestricts ingress to the targeted security groups and ports.\n## Inputs\n* SecurityGroupIds: The list of security groups to restrict incoming traffic for.\n* Ports: The list of ports to restrict incoming traffic for.\n## Outputs\n* RestrictedSecurityGroupIds: A list of the security groups which were successfully restricted.\n* UnrestrictedSecurityGroupIds: A maplist of the security groups which were not successfully restricted and the ports it failed for.\n",
      "inputs": {
        "Runtime": "python3.11",
        "Handler": "restrict_incoming_traffic",
        "InputPayload": {
          "SecurityGroupIds": "{{SecurityGroupIds}}",
          "Ports": "{{Ports}}"
        },
        "Script": "import boto3\n\nTCP = 'tcp'\nPUBLIC_IPV4_CIDR = '0.0.0.0/0'\nPUBLIC_IPV6_CIDR = '::/0'\nec2_resource = boto3.resource(\"ec2\")\nec2_client = boto3.client(\"ec2\")\n\ndef is_sg_open_port_ipv4(port, sg_description):\n    port = int(port)\n    for rule in sg_description[\"SecurityGroups\"][0][\"IpPermissions\"]:\n        if \"FromPort\" in rule and rule['FromPort'] == port and rule['ToPort'] == port:\n            for ip_range in rule['IpRanges']:\n                if ip_range['CidrIp'] == PUBLIC_IPV4_CIDR:\n                    return True, rule\n    return False, \"None\"\n\ndef is_sg_open_port_ipv6(port, sg_description):\n    port = int(port)\n    for rule in sg_description[\"SecurityGroups\"][0][\"IpPermissions\"]:\n        if \"FromPort\" in rule and rule['FromPort'] == port and rule['ToPort'] == port:\n            for ip_range in rule['Ipv6Ranges']:\n                if ip_range['CidrIpv6'] == PUBLIC_IPV6_CIDR:\n                    return True, rule\n    return False, \"None\"\n\ndef restrict_incoming_traffic(event, context):\n    sg_ids = event[\"SecurityGroupIds\"]\n    ports = event[\"Ports\"]\n    Restricted_sg_ids = []\n    UnRestricted_sg_ids = []\n    errorMsg = \"N/A\"\n    try:\n        for sg_id in sg_ids:\n            isSuccessful = False\n            try:\n                sg_description = ec2_client.describe_security_groups(GroupIds = [sg_id])\n                sg_resource = ec2_resource.SecurityGroup(sg_id)\n                for port in ports:\n                    openv4, rule = is_sg_open_port_ipv4(port, sg_description)\n                    if openv4:\n                        response = sg_resource.revoke_ingress(\n                            GroupId = sg_id,\n                            IpPermissions = [{\n                                'FromPort': int(port),\n                                'IpProtocol': TCP,\n                                'ToPort': int(port),\n                                'IpRanges': [{'CidrIp': PUBLIC_IPV4_CIDR}]\n                            }],\n                            DryRun = False\n                        )\n                        if response:\n                            if \"Return\" in response:\n                                if response[\"Return\"]:\n                                    isSuccessful = True\n                        if not isSuccessful:\n                            errorMsg = \"Request revoke_ingress on port {} for security group '{}' failed for IPv4.\".format(port, sg_id)\n\n                    openv6, rule = is_sg_open_port_ipv6(port,sg_description)\n                    if openv6:\n                        response = sg_resource.revoke_ingress(\n                            GroupId = sg_id,\n                            IpPermissions = [{\n                                'FromPort': int(port),\n                                'IpProtocol': TCP,\n                                'ToPort': int(port),\n                                'Ipv6Ranges': [{'CidrIpv6': PUBLIC_IPV6_CIDR}]\n                            }],\n                            DryRun = False\n                        )\n                        if response:\n                            if \"Return\" in response:\n                                if response[\"Return\"] == True:\n                                    isSuccessful = True\n                        if isSuccessful:\n                            errorMsg = \"Request revoke_ingress on port {} for security group '{}' failed for IPv6.\".format(port, sg_id)\n\n                    if not openv6 and not openv4:\n                        isSuccessful = True\n\n            except Exception as e:\n                isSuccessful = False\n                errorMsg = str(e)\n\n            if isSuccessful:\n                Restricted_sg_ids.append(sg_id)\n            else:\n                UnRestricted_sg_ids.append({\"groupId\": sg_id, \"error\": errorMsg})\n\n    except Exception as e:\n        isSuccessful = False\n        errorMsg = str(e)\n\n    return {\n        \"RestrictedSecurityGroupIds\": Restricted_sg_ids,\n        \"UnrestrictedSecurityGroupIds\": UnRestricted_sg_ids\n    }\n"
      },
      "outputs": [
        {
          "Name": "RestrictedSecurityGroupIds",
          "Selector": "$.Payload.RestrictedSecurityGroupIds",
          "Type": "StringList"
        },
        {
          "Name": "UnrestrictedSecurityGroupIds",
          "Selector": "$.Payload.UnrestrictedSecurityGroupIds",
          "Type": "MapList"
        }
      ]
    },
    {
      "name": "RestrictIncomingTrafficPrefixList",
      "action": "aws:executeScript",
      "onFailure": "Continue",
      "isCritical": false,
      "isEnd": true,
      "timeoutSeconds": 600,
      "description": "## RestrictIncomingTrafficPrefixList\nRestricts ingress rules that use prefix lists in the targeted security groups and ports.\nRemoves prefix list rules that contain only public CIDRs (0.0.0.0/0 or ::/0).\nIf prefix list contains both public and private CIDRs, adds to UnrestrictedSecurityGroupIds.\n## Inputs\n* SecurityGroupIds: The list of security groups to restrict incoming traffic for.\n* Ports: The list of ports to restrict incoming traffic for.\n## Outputs\n* RestrictedSecurityGroupIds: A list of the security groups which were successfully restricted.\n* UnrestrictedSecurityGroupIds: A maplist of the security groups which were not successfully restricted and the ports it failed for.\n",
      "inputs": {
        "Runtime": "python3.11",
        "Handler": "restrict_incoming_traffic_prefix_lists",
        "InputPayload": {
          "SecurityGroupIds": "{{SecurityGroupIds}}",
          "Ports": "{{Ports}}"
        },
        "Script": "import boto3\nTCP = 'tcp'\nPUBLIC_IPV4_CIDR = '0.0.0.0/0'\nPUBLIC_IPV6_CIDR = '::/0'\nec2_resource = boto3.resource(\"ec2\")\nec2_client = boto3.client(\"ec2\")\n\ndef analyze_prefix_list(prefix_list_id):\n    \"\"\"\n    Analyzes a prefix list to determine if it contains public CIDR,\n    mixed CIDRs, or no public CIDRs.\n    \"\"\"\n    try:\n      has_public_cidr = False\n      has_other_cidrs = False\n      paginator = ec2_client.get_paginator('get_managed_prefix_list_entries')\n      \n      for page in paginator.paginate(PrefixListId=prefix_list_id):\n          for entry in page['Entries']:\n              if entry['Cidr'] in [PUBLIC_IPV4_CIDR, PUBLIC_IPV6_CIDR]:\n                  has_public_cidr = True\n              else:\n                  has_other_cidrs = True\n      \n              # Stop processing if we've found both types\n              if has_public_cidr and has_other_cidrs:\n                  return {\n                      'public_cidr': False,\n                      'public_and_private_cidr': True\n                  }\n      \n      return {\n          'public_cidr': has_public_cidr and not has_other_cidrs,\n          'public_and_private_cidr': has_public_cidr and has_other_cidrs\n      }\n    except Exception as e:\n        print(f\"Error checking prefix list {prefix_list_id}: {str(e)}\")\n        raise e\n\ndef find_prefix_lists_in_rules(sg_description, ports):\n    \"\"\"\n    Identifies prefix lists and their associated ports in security group rules\n    \"\"\"\n    prefix_list_rules = {}\n    \n    for rule in sg_description[\"SecurityGroups\"][0][\"IpPermissions\"]:\n        if ('FromPort' in rule and 'ToPort' in rule and \n            str(rule['FromPort']) in ports and \n            rule['FromPort'] == rule['ToPort']):\n            if 'PrefixListIds' in rule:\n                port = str(rule['FromPort'])\n                for prefix_list in rule['PrefixListIds']:\n                    prefix_list_id = prefix_list['PrefixListId']\n                    if prefix_list_id not in prefix_list_rules:\n                        prefix_list_rules[prefix_list_id] = {\n                            'ports': [],\n                            'prefix_list_obj': prefix_list\n                        }\n                    prefix_list_rules[prefix_list_id]['ports'].append(port)\n    \n    return prefix_list_rules\n\ndef restrict_incoming_traffic_prefix_lists(event, context):\n    \"\"\"\n    Lambda handler to process security groups and remove prefix lists containing only public CIDRs\n    \"\"\"\n    sg_ids = event[\"SecurityGroupIds\"]\n    ports = event[\"Ports\"]\n    Restricted_sg_ids = []\n    UnRestricted_sg_ids = []\n    \n    try:\n        for sg_id in sg_ids:\n            has_successful_removal = False\n            has_mixed_cidrs_or_failures = False\n            error_message = \"\"\n            try:\n                sg_description = ec2_client.describe_security_groups(GroupIds=[sg_id])\n                sg_resource = ec2_resource.SecurityGroup(sg_id)\n                \n                # Get all prefix lists and their associated ports\n                prefix_list_rules = find_prefix_lists_in_rules(sg_description, ports)\n                \n                if not prefix_list_rules:\n                    Restricted_sg_ids.append(sg_id)\n                    continue\n                \n                # Process each prefix list\n                for prefix_list_id, rule_info in prefix_list_rules.items():\n                    analysis = analyze_prefix_list(prefix_list_id)\n                    \n                    if analysis['public_and_private_cidr']:\n                        has_mixed_cidrs_or_failures = True\n                        error_message = f\"Prefix list {prefix_list_id} contains mixed public and private CIDRs\"\n                        continue\n                    \n                    if analysis['public_cidr']:\n                        # Remove the prefix list rule for all its ports\n                        for port in rule_info['ports']:\n                            response = sg_resource.revoke_ingress(\n                                GroupId=sg_id,\n                                IpPermissions=[{\n                                    'FromPort': int(port),\n                                    'IpProtocol': TCP,\n                                    'ToPort': int(port),\n                                    'PrefixListIds': [rule_info['prefix_list_obj']]\n                                }],\n                                DryRun=False\n                            )\n                            if response and \"Return\" in response and response[\"Return\"]:\n                                has_successful_removal = True\n                            else:\n                                error_message = f\"Failed to remove prefix list {prefix_list_id} for port {port}\"\n                                has_mixed_cidrs_or_failures = True\n                if has_mixed_cidrs_or_failures:\n                    UnRestricted_sg_ids.append({\n                        \"groupId\": sg_id,\n                        \"error\": error_message,\n                        \"partial_success\": has_successful_removal\n                    })\n                else:\n                    Restricted_sg_ids.append(sg_id)\n            except Exception as e:\n                UnRestricted_sg_ids.append({\"groupId\": sg_id, \"error\": str(e), \"partial_success\": has_successful_removal})\n\n    except Exception as e:\n        UnRestricted_sg_ids.append({\"groupId\": \"general\", \"error\": str(e), \"partial_success\": False})\n\n    return {\n        \"RestrictedSecurityGroupIds\": Restricted_sg_ids,\n        \"UnrestrictedSecurityGroupIds\": UnRestricted_sg_ids\n    }\n    \n"
      },
      "outputs": [
        {
          "Name": "RestrictedSecurityGroupIds",
          "Selector": "$.Payload.RestrictedSecurityGroupIds",
          "Type": "StringList"
        },
        {
          "Name": "UnrestrictedSecurityGroupIds",
          "Selector": "$.Payload.UnrestrictedSecurityGroupIds",
          "Type": "MapList"
        }
      ]
    }
  ]
}
