{
  "description": "The **AWSSupport-SetupConfig** runbook helps to setup AWS Config by creating the AWS Identity and Access Management (IAM) service-linked role, a configuration recorder powered by AWS Config and a delivery channel with an Amazon Simple Storage Service (Amazon S3) bucket where AWS Config sends configuration snapshots and configuration history files. The setup will create new resources only if they don't exist; if resources already exist, and you specify values for the `AggregatorAccountId` and `AggregatorAccountRegion` parameters, the runbook also creates permissions for data aggregation to collect AWS Config configuration and compliance data from multiple AWS accounts and multiple AWS Regions. To learn more about aggregating data from multiple accounts and Regions, see [Multi-Account Multi-Region Data Aggregation](https://docs.aws.amazon.com/config/latest/developerguide/aggregate-data.html) in the *AWS Config Developer Guide*. \n\nThis document if used for multi-account setup, requires AutomationExecutionRole called 'AWS-SystemsManager-AutomationExecutionRole'. Please read [Running automations in multiple AWS Regions and accounts](https://docs.aws.amazon.com/systems-manager/latest/userguide/running-automations-multiple-accounts-regions.html) for more information about running AWS Systems Manager automations across multiple AWS Regions and AWS accounts or AWS Organizations organizational units (OUs) from a central account.",
  "schemaVersion": "0.3",
  "assumeRole": "{{ AutomationAssumeRole }}",
  "parameters": {
    "S3BucketName": {
      "type": "String",
      "description": "(Optional) The name you want to apply to the Amazon S3 bucket created for the delivery channel. The account ID is appended to the end of the name.",
      "allowedPattern": "^[a-zA-Z0-9.\\-_]{1,255}$",
      "default": "aws-config-delivery-channel"
    },
    "ConfigurationRecorderName": {
      "type": "String",
      "description": "(Optional) The name to use for the AWS Config configuration recorder. If a recorder with this name already exists, it will be used instead of creating a new one.",
      "default": "default",
      "allowedPattern": "^[a-zA-Z0-9._-]{1,256}$"
    },
    "DeliveryChannelName": {
      "type": "String",
      "description": "(Optional) The name to use for the AWS Config delivery channel. If a delivery channel with this name already exists, it will be used instead of creating a new one.",
      "default": "default",
      "allowedPattern": "^[a-zA-Z0-9._-]{1,256}$"
    },
    "IncludeGlobalResourcesRegion": {
      "type": "String",
      "description": "(Optional) To avoid recording global resources (AWS resources that exist independently of any particular region and are accessible from all AWS regions within your account) data in each AWS Region, specify one AWS Region.",
      "default": "us-east-1",
      "allowedPattern": "^[a-z]{2}(-gov)?(-iso[a-z]?)?-[a-z]{2,10}-[0-9]{1,2}$"
    },
    "AutomationAssumeRole": {
      "type": "AWS::IAM::Role::Arn",
      "description": "(Required) The Amazon Resource Name (ARN) of the AWS Identity and Access Management (IAM) role that allows AWS Systems Manager Automation to perform the actions on your behalf. If no role is specified, AWS Systems Manager Automation uses the permissions of the user that starts this runbook."
    },
    "Partition": {
      "type": "String",
      "description": "(Optional) The partition you want to collect AWS Config configuration and compliance data from.",
      "default": "aws",
      "allowedPattern": "^(aws|aws-cn|aws-us-gov|aws-iso|aws-iso-b)$"
    },
    "AggregatorAccountId": {
      "type": "String",
      "description": "(Optional) The ID of the AWS account where an aggregator will be added to aggregate AWS Config configuration and compliance data from multiple accounts and AWS Regions. This account is also used by the aggregator to authorize the source accounts.",
      "default": "",
      "allowedPattern": "^($|\\d{12})$"
    },
    "AggregatorAccountRegion": {
      "type": "String",
      "description": "(Optional) The Region where an aggregator will be added to aggregate AWS Config configuration and compliance data from multiple accounts and Regions.",
      "default": "",
      "allowedPattern": "^$|^[a-z]{2}(-gov)?(-iso[a-z]?)?-[a-z]{2,10}-[0-9]{1,2}$"
    }
  },
  "mainSteps": [
    {
      "name": "CreateServiceLinkedRole",
      "description": "Creates the service-linked IAM role 'AWSServiceRoleForConfig' for AWS Config if it doesn't already exist. This role grants AWS Config permissions to collect configuration data from your AWS resources. If the role already exists, the runbook will use the existing role.",
      "timeoutSeconds": 600,
      "onFailure": "Abort",
      "isCritical": true,
      "action": "aws:executeScript",
      "nextStep": "CreateRecorder",
      "inputs": {
        "Handler": "script_handler",
        "Runtime": "python3.11",
        "Script": "# Copyright 2025 Amazon.com, Inc. or its affiliates. All Rights Reserved\n# SPDX-License-Identifier: LicenseRef-.amazon.com.-AmznSL-1.0\n# Licensed under the Amazon Software License  http://aws.amazon.com/asl/\n\nimport boto3\nfrom botocore.exceptions import ClientError\n\n\ndef script_handler(event: dict, _: object) -> None:\n    \"\"\"\n    Creates a service-linked role for AWS Config if it does not already exist.\n\n    Args:\n        event: AWS Lambda event object\n        _: AWS Lambda context object (unused)\n\n    Returns:\n        None\n\n    Raises:\n        RuntimeError: If the IAM role does not have sufficient permissions to create the service-linked role\n    \"\"\"\n    iam_client = boto3.client(\"iam\")\n    # if it does not already exist, create the service-linked role for config\n    try:\n        iam_client.create_service_linked_role(AWSServiceName=\"config.amazonaws.com\")\n    except ClientError as ex:\n        if ex.response[\"Error\"][\"Code\"] == \"AccessDenied\":\n            raise RuntimeError(\n                \"(Access Denied) The SSM Role does not have enough permission. Please check the role permission policy for CreateServiceLinkedRole API. Also check for any permission boundary or SCPs attached to the account\"\n            ) from None\n        if ex.response[\"Error\"][\"Code\"] == \"InvalidInputException\" or ex.response[\"Error\"][\"Code\"] == \"InvalidInput\":\n            print(\"Service role name AWSServiceRoleForConfig already exists. Using the existing Service linked role.\")\n        else:\n            raise RuntimeError(f\"Unexpected error: {ex}\") from None\n    return\n"
      }
    },
    {
      "name": "CreateRecorder",
      "action": "aws:executeScript",
      "description": "Creates or updates an AWS Config configuration recorder that monitors changes to your AWS resources. The recorder is configured to track all supported resource types. If a recorder already exists, the runbook will use and update the existing recorder.",
      "timeoutSeconds": 600,
      "onFailure": "Abort",
      "isCritical": true,
      "nextStep": "CreateBucket",
      "inputs": {
        "InputPayload": {
          "Partition": "{{ Partition }}",
          "AccountId": "{{ global:ACCOUNT_ID }}",
          "Region": "{{ global:REGION }}",
          "IncludeGlobalResourcesRegion": "{{ IncludeGlobalResourcesRegion }}",
          "RecorderName": "{{ ConfigurationRecorderName }}"
        },
        "Handler": "script_handler",
        "Runtime": "python3.11",
        "Script": "# Copyright 2025 Amazon.com, Inc. or its affiliates. All Rights Reserved\n# SPDX-License-Identifier: LicenseRef-.amazon.com.-AmznSL-1.0\n# Licensed under the Amazon Software License  http://aws.amazon.com/asl/\n\nimport boto3\nfrom botocore.exceptions import ClientError\n\n\ndef script_handler(event: dict, _: object) -> dict:\n    \"\"\"\n    Creates or updates an AWS Config configuration recorder.\n\n    Args:\n        event (dict): Input event containing:\n            - Region: AWS region\n            - Partition: AWS partition (e.g. aws, aws-cn)\n            - AccountId: AWS account ID\n            - IncludeGlobalResourcesRegion: Region for global resources\n            - RecorderName: Name for the configuration recorder\n        _ : Unused context parameter\n\n    Returns:\n        dict: Dictionary containing:\n            - recordername: Name of the configuration recorder\n\n    Raises:\n        RuntimeError: If the role lacks required permissions\n    \"\"\"\n    # get input parameters\n    region: str = event[\"Region\"]\n    partition: str = event.get(\"Partition\", \"aws\")\n    account_id: str = event[\"AccountId\"]\n    global_resource_region: str = event.get(\"IncludeGlobalResourcesRegion\", \"\")\n    # Use provided recorder name or default to \"default\"\n    configuration_recorder_name: str = event.get(\"RecorderName\", \"default\")\n    config_client = boto3.client(\"config\")\n    role_arn = f\"arn:{partition}:iam::{account_id}:role/aws-service-role/config.amazonaws.com/AWSServiceRoleForConfig\"\n\n    # Check if a recorder with the specified name already exists\n    try:\n        response = config_client.describe_configuration_recorders()\n        existing_recorders = response.get(\"ConfigurationRecorders\", [])\n\n        # Check if our named recorder already exists\n        named_recorder = next((r for r in existing_recorders if r[\"name\"] == configuration_recorder_name), None)\n\n        if named_recorder:\n            # Use the existing recorder with our specified name\n            role_arn = named_recorder[\"roleARN\"]\n            print(\n                f\"Configuration Recorder already exists with name {configuration_recorder_name}. Using the existing recorder.\"\n            )\n        elif existing_recorders:\n            # If our named recorder doesn't exist but others do, use the first one\n            configuration_recorder_name = existing_recorders[0][\"name\"]\n            role_arn = existing_recorders[0][\"roleARN\"]\n            print(\n                f\"Configuration Recorder already exists with name {configuration_recorder_name}. Using the existing recorder.\"\n            )\n\n        # Update or create the recorder with appropriate settings\n        if global_resource_region == region:\n            config_client.put_configuration_recorder(\n                ConfigurationRecorder={\n                    \"name\": configuration_recorder_name,\n                    \"roleARN\": role_arn,\n                    \"recordingGroup\": {\"allSupported\": True, \"includeGlobalResourceTypes\": True},\n                }\n            )\n            print(\n                f\"Configuration Recorder configured with name {configuration_recorder_name} (including global resources)\"\n            )\n        else:\n            config_client.put_configuration_recorder(\n                ConfigurationRecorder={\n                    \"name\": configuration_recorder_name,\n                    \"roleARN\": role_arn,\n                    \"recordingGroup\": {\"allSupported\": True, \"includeGlobalResourceTypes\": False},\n                }\n            )\n            print(\n                f\"Configuration Recorder configured with name {configuration_recorder_name} (excluding global resources)\"\n            )\n    except ClientError as ex:\n        if ex.response[\"Error\"][\"Code\"] == \"AccessDeniedException\":\n            raise RuntimeError(\n                \"(Access Denied) The SSM Role does not have enough permission. Please check the role permission policy for PutConfigurationRecorder API and DescribeConfigurationRecorders API. Also check for any permission boundary or SCPs attached to the account\"\n            ) from None\n        if ex.response[\"Error\"][\"Code\"] == \"MaxNumberOfConfigurationRecordersExceededException\":\n            # Currently, you can specify only one configuration recorder per region in your account.\n            print(\"Maximum number of Configuration Recorders exceeded. Using the existing recorder.\")\n        else:\n            raise RuntimeError(f\"Unexpected error: {ex}\") from None\n    return {\"recordername\": configuration_recorder_name}\n"
      },
      "outputs": [
        {
          "Selector": "$.Payload.recordername",
          "Name": "recordername",
          "Type": "String"
        }
      ]
    },
    {
      "name": "CreateBucket",
      "action": "aws:executeScript",
      "description": "Creates an Amazon S3 bucket named `{S3BucketName}-{ACCOUNT_ID}` to store AWS Config configuration snapshots and history files. If the bucket already exists, the runbook will use the existing bucket. The bucket is configured with the necessary permissions for AWS Config to deliver configuration data. If the bucket creation fails, the runbook will handle cleanup of any partially created resources.",
      "timeoutSeconds": 600,
      "onFailure": "Abort",
      "isCritical": true,
      "nextStep": "CreateDeliveryChannel",
      "inputs": {
        "InputPayload": {
          "Partition": "{{ Partition }}",
          "AccountId": "{{ global:ACCOUNT_ID }}",
          "Region": "{{ global:REGION }}",
          "S3BucketName": "{{ S3BucketName }}"
        },
        "Handler": "script_handler",
        "Runtime": "python3.11",
        "Script": "# Copyright 2025 Amazon.com, Inc. or its affiliates. All Rights Reserved\n# SPDX-License-Identifier: LicenseRef-.amazon.com.-AmznSL-1.0\n# Licensed under the Amazon Software License  http://aws.amazon.com/asl/\n\nimport json\n\nimport boto3\nfrom botocore.exceptions import ClientError\n\n\ndef script_handler(event: dict, _: object) -> dict:\n    \"\"\"\n    Creates or validates an S3 bucket for AWS Config delivery channel.\n\n    Args:\n        event (dict): Input event containing:\n            - Partition (str): AWS partition (e.g. 'aws')\n            - AccountId (str): AWS account ID\n            - Region (str): AWS region\n            - S3BucketName (str): Name of S3 bucket\n        _ : Unused context parameter\n\n    Returns:\n        dict: Contains 'flagcreate' boolean indicating if new bucket was created\n\n    Raises:\n        RuntimeError: If role lacks required S3 permissions\n    \"\"\"\n    # get input parameters\n    partition: str = event.get(\"Partition\", \"aws\")\n    account_id: str = event[\"AccountId\"]\n    region: str = event[\"Region\"]\n    s3_bucket_name: str = event[\"S3BucketName\"]\n    s3_client = boto3.client(\"s3\")\n    flagcreate: bool = False\n    s3_resource = boto3.resource(\"s3\")\n\n    try:\n        if s3_resource.Bucket(s3_bucket_name) in s3_resource.buckets.all():\n            print(f\"S3 Bucket {s3_bucket_name} already exists. Using the existing bucket for delivery Channel\")\n            flagcreate = False\n        else:\n            s3_bucket_name = f\"{s3_bucket_name}-{account_id}\"\n            bucket_policy: dict = {\n                \"Version\": \"2012-10-17\",\n                \"Statement\": [\n                    {\n                        \"Sid\": \"AWSConfigBucketPermissionsCheck\",\n                        \"Effect\": \"Allow\",\n                        \"Principal\": {\"Service\": [\"config.amazonaws.com\"]},\n                        \"Action\": \"s3:GetBucketAcl\",\n                        \"Resource\": f\"arn:{partition}:s3:::{s3_bucket_name}\",\n                    },\n                    {\n                        \"Sid\": \"AWSConfigBucketExistenceCheck\",\n                        \"Effect\": \"Allow\",\n                        \"Principal\": {\"Service\": [\"config.amazonaws.com\"]},\n                        \"Action\": \"s3:ListBucket\",\n                        \"Resource\": f\"arn:{partition}:s3:::{s3_bucket_name}\",\n                    },\n                    {\n                        \"Sid\": \"AWSConfigBucketDelivery\",\n                        \"Effect\": \"Allow\",\n                        \"Principal\": {\"Service\": [\"config.amazonaws.com\"]},\n                        \"Action\": \"s3:PutObject\",\n                        \"Resource\": f\"arn:{partition}:s3:::{s3_bucket_name}/*\",\n                        \"Condition\": {\"StringEquals\": {\"s3:x-amz-acl\": \"bucket-owner-full-control\"}},\n                    },\n                ],\n            }\n            # specify the region if not in us-east-1\n            # details: https://github.com/boto/boto3/issues/125\n            if region == \"us-east-1\":\n                s3_client.create_bucket(Bucket=s3_bucket_name)\n            else:\n                s3_client.create_bucket(Bucket=s3_bucket_name, CreateBucketConfiguration={\"LocationConstraint\": region})\n\n            s3_client.put_bucket_policy(Bucket=s3_bucket_name, Policy=json.dumps(bucket_policy))\n            flagcreate = True\n            print(f\"S3 Bucket {s3_bucket_name} created. Using this bucket for delivery Channel\")\n\n    except ClientError as ex:\n        if (\n            ex.response[\"Error\"][\"Code\"] == \"IllegalLocationConstraintException\"\n            or ex.response[\"Error\"][\"Code\"] == \"BucketAlreadyExists\"\n            or ex.response[\"Error\"][\"Code\"] == \"BucketAlreadyOwnedByYou\"\n        ):\n            print(f\"S3 Bucket {s3_bucket_name} already exists. Using the existing bucket for delivery Channel\")\n            flagcreate = False\n        else:\n            if ex.response[\"Error\"][\"Code\"] == \"AccessDenied\":\n                raise RuntimeError(\n                    \"(Access Denied) The SSM Role does not have enough permission. Please check the role permission policy for ListAllMyBuckets, CreateBucket and PutBucketPolicy API. Also check for any permission boundary or SCPs attached to the account\"\n                ) from None\n            raise RuntimeError(f\"Unexpected error: {ex}\") from None\n\n    return {\"flagcreate\": flagcreate}\n"
      },
      "outputs": [
        {
          "Selector": "$.Payload.flagcreate",
          "Name": "flagcreate",
          "Type": "Boolean"
        }
      ]
    },
    {
      "name": "CreateDeliveryChannel",
      "action": "aws:executeScript",
      "description": "Creates an AWS Config delivery channel that sends configuration snapshots and history files to the Amazon S3 bucket created in the previous step. The delivery channel is configured with a one-hour snapshot delivery frequency. If a delivery channel already exists, the runbook will use the existing channel. In case of failure, any newly created Amazon S3 bucket will be cleaned up automatically.",
      "timeoutSeconds": 600,
      "onFailure": "Abort",
      "isCritical": true,
      "nextStep": "StartRecorder",
      "inputs": {
        "InputPayload": {
          "AccountId": "{{ global:ACCOUNT_ID }}",
          "S3BucketName": "{{ S3BucketName }}",
          "flagcreate": "{{ CreateBucket.flagcreate }}",
          "DeliveryChannelName": "{{ DeliveryChannelName }}"
        },
        "Handler": "script_handler",
        "Runtime": "python3.11",
        "Script": "# Copyright 2025 Amazon.com, Inc. or its affiliates. All Rights Reserved\n# SPDX-License-Identifier: LicenseRef-.amazon.com.-AmznSL-1.0\n# Licensed under the Amazon Software License  http://aws.amazon.com/asl/\n\nimport boto3\nfrom botocore.exceptions import ClientError\n\n\ndef delete_bucket(bucket_name: str) -> None:\n    \"\"\"\n    Deletes an S3 bucket and all its objects.\n\n    Args:\n        bucket_name (str): Name of the S3 bucket to be deleted\n\n    Returns:\n        None\n    \"\"\"\n    try:\n        s3 = boto3.resource(\"s3\")\n        bucket = s3.Bucket(bucket_name)\n        bucket.objects.all().delete()\n        bucket.delete()\n    except Exception as e:\n        raise RuntimeError(f\"Unable to delete S3 bucket: {e}\") from None\n\n\ndef script_handler(event: dict, _: object) -> dict:\n    \"\"\"\n    Creates or manages an AWS Config delivery channel for configuration snapshots.\n\n    Args:\n        event (dict): Input event containing:\n            - AccountId (str): AWS account ID\n            - flagcreate (bool): Flag indicating whether to delete S3 bucket on error\n            - S3BucketName (str): Base name of S3 bucket for delivery channel\n            - DeliveryChannelName (str): Name for the delivery channel\n        _ : Unused context parameter\n\n    Returns:\n        dict: Contains the S3 bucket name used by the delivery channel\n            - DeliveryChannel_S3Bucket (str): Full name of S3 bucket\n\n    Raises:\n        Exception: If insufficient delivery policy permissions\n        RuntimeError: If access is denied due to insufficient role permissions\n    \"\"\"\n    # get input parameters\n    account_id: str = event[\"AccountId\"]\n    flag: bool = event[\"flagcreate\"]\n    s3_bucket_name: str = event[\"S3BucketName\"] + \"-\" + account_id\n    # Use provided delivery channel name or default to \"default\"\n    delivery_channel_name: str = event.get(\"DeliveryChannelName\", \"default\")\n    config_client = boto3.client(\"config\")\n\n    # Check if a delivery channel with the specified name already exists\n    try:\n        existing_channels = config_client.describe_delivery_channels()[\"DeliveryChannels\"]\n\n        # Check if our named channel already exists\n        named_channel = next((c for c in existing_channels if c.get(\"name\") == delivery_channel_name), None)\n\n        if named_channel:\n            # Use the existing channel with our specified name\n            print(f\"Delivery Channel already exists with name '{delivery_channel_name}'. Using the existing channel.\")\n        elif existing_channels:\n            # If our named channel doesn't exist but others do, use the first one's name\n            delivery_channel_name = existing_channels[0].get(\"name\", delivery_channel_name)\n            print(f\"Delivery Channel already exists with name '{delivery_channel_name}'. Using the existing channel.\")\n        else:\n            # Create a new delivery channel with our specified name\n            config_client.put_delivery_channel(\n                DeliveryChannel={\n                    \"name\": delivery_channel_name,\n                    \"s3BucketName\": s3_bucket_name,\n                    \"configSnapshotDeliveryProperties\": {\"deliveryFrequency\": \"One_Hour\"},\n                }\n            )\n            print(f\"Delivery Channel created with name '{delivery_channel_name}'\")\n    except ClientError as ex:\n        if flag:\n            print(f\"ClientError occurred. Deleting the S3 bucket {s3_bucket_name}\")\n            delete_bucket(s3_bucket_name)\n        if ex.response[\"Error\"][\"Code\"] == \"AccessDeniedException\":\n            raise RuntimeError(\n                \"(Access Denied) The SSM Role does not have enough permission. Please check the role permission policy for PutDeliveryChannel API and DescribeDeliveryChannel API. Also check for any permission boundary or SCPs attached to the account\"\n            ) from None\n        if ex.response[\"Error\"][\"Code\"] == \"MaxNumberOfDeliveryChannelsExceededException\":\n            print(\"Maximum number of Delivery Channels exceeded. Using the existing channel.\")\n        else:\n            raise RuntimeError(f\"Unexpected error: {ex}\") from None\n\n    # Get the current delivery channel configuration\n    delivery_channel = config_client.describe_delivery_channels()\n    return {\"DeliveryChannel_S3Bucket\": delivery_channel[\"DeliveryChannels\"][0][\"s3BucketName\"]}\n"
      }
    },
    {
      "name": "StartRecorder",
      "action": "aws:executeAwsApi",
      "onFailure": "Abort",
      "description": "Activates the AWS Config configuration recorder to begin monitoring and recording changes to your AWS resources. This step initiates the actual recording process after all the necessary components (service-linked role, recorder, Amazon S3 bucket, and delivery channel) have been set up.",
      "timeoutSeconds": 600,
      "isCritical": true,
      "nextStep": "PutAggregationAuthorization",
      "inputs": {
        "Service": "config",
        "Api": "StartConfigurationRecorder",
        "ConfigurationRecorderName": "{{ CreateRecorder.recordername }}"
      }
    },
    {
      "name": "PutAggregationAuthorization",
      "action": "aws:executeScript",
      "description": "Creates an aggregation authorization that allows the specified aggregator account `AggregatorAccountId` in the specified region `AggregatorAccountRegion` to collect AWS Config data from this account. This enables multi-account and multi-region data aggregation for centralized compliance monitoring. This step is skipped if either the `AggregatorAccountId` or `AggregatorAccountRegion` parameters are not specified.",
      "timeoutSeconds": 600,
      "onFailure": "Abort",
      "isCritical": true,
      "isEnd": true,
      "inputs": {
        "InputPayload": {
          "AggregatorAccountId": "{{ AggregatorAccountId }}",
          "AggregatorAccountRegion": "{{ AggregatorAccountRegion }}"
        },
        "Handler": "script_handler",
        "Runtime": "python3.11",
        "Script": "# Copyright 2025 Amazon.com, Inc. or its affiliates. All Rights Reserved\n# SPDX-License-Identifier: LicenseRef-.amazon.com.-AmznSL-1.0\n# Licensed under the Amazon Software License  http://aws.amazon.com/asl/\n\nimport boto3\nfrom botocore.exceptions import ClientError\n\n\ndef script_handler(event: dict, _: object) -> dict:\n    \"\"\"\n    Creates an aggregation authorization for AWS Config.\n\n    Args:\n        event (dict): Lambda event containing:\n            - AggregatorAccountId (str): AWS account ID of the aggregator\n            - AggregatorAccountRegion (str): AWS region of the aggregator\n        context (obj): Lambda context object\n\n    Returns:\n        dict: Response indicating success or opt-out status of authorization creation\n\n    Raises:\n        RuntimeError: If the role lacks permissions for PutAggregationAuthorization\n    \"\"\"\n    # get input parameters\n    aggregator_account_id: str = event[\"AggregatorAccountId\"]\n    aggregator_account_region: str = event[\"AggregatorAccountRegion\"]\n    config_client = boto3.client(\"config\")\n\n    # allow master account to aggregate config data\n    if aggregator_account_id and aggregator_account_region:\n        try:\n            config_client.put_aggregation_authorization(\n                AuthorizedAccountId=aggregator_account_id, AuthorizedAwsRegion=aggregator_account_region\n            )\n        except ClientError as ex:\n            if ex.response[\"Error\"][\"Code\"] == \"AccessDeniedException\":\n                raise RuntimeError(\n                    \"(Access Denied) The SSM Role does not have enough permission. Please check the role permission policy for PutAggregationAuthorization API. Also check for any permission boundary or SCPs attached to the account\"\n                ) from None\n            else:\n                raise RuntimeError(f\"Unexpected error: {ex}\") from None\n        return {\"aggregatorauthorization\": \"Authorization creation is successful\"}\n    return {\"aggregatorauthorization\": \"You did not opt in for creation of authorization\"}\n"
      },
      "outputs": [
        {
          "Selector": "$.Payload.aggregatorauthorization",
          "Name": "AggregatorAuthorization",
          "Type": "String"
        }
      ]
    }
  ]
}
