{
  "description": "### Document name - AWSFIS-Run-CPU-Stress\n\n## What does this document do?\nIt runs CPU stress on an instance via stress-ng tool. If stress-ng is not already installed on the instance, this SSM document will install it, unless InstallDependencies parameter is set to False.\nThis SSM document supports Amazon Linux and Ubuntu operating systems only.\n\n## Dependencies installed by this SSM Document\n* stress-ng\n* pgrep\nNote: This SSM document does not uninstall dependencies once installed. If you don't want this SSM document to install any dependencies, set InstallDependencies to False and bake the dependencies into your EC2 instance. For example, by using image-builder (https://aws.amazon.com/image-builder/).\n\n## Input Parameters\n* DurationSeconds: (Required) The duration - in seconds - of the fault injection.\n* CPU: Specify the number of CPU stressors to use (default: 0 which means \"all CPUs\")\n* LoadPercent: Specify the target CPU load percentage. Valid values are between 0 (no load) and 100 (full load) (default: 100)\n* InstallDependencies: If set to True, Systems Manager installs the required dependencies on the target instances (default: True).\n\n## Output Parameters\nNone.",
  "schemaVersion": "2.2",
  "parameters": {
    "DurationSeconds": {
      "type": "String",
      "description": "(Required) The duration - in seconds - of the fault injection.",
      "allowedPattern": "^[0-9]+$"
    },
    "CPU": {
      "type": "String",
      "description": "Specify the number of CPU stressors to use (default: 0 which means \"all CPUs\")",
      "default": "0",
      "allowedPattern": "^[0-9]+$"
    },
    "LoadPercent": {
      "type": "String",
      "description": "Specify the target CPU load percentage. Valid values are between 0 (no load) and 100 (full load) (default: 100)",
      "default": "100",
      "allowedPattern": "^(100|[1-9]?[0-9])$"
    },
    "InstallDependencies": {
      "type": "String",
      "description": "If set to True, Systems Manager installs the required dependencies on the target instances (default: True).",
      "default": "True",
      "allowedValues": [
        "True",
        "False"
      ]
    }
  },
  "mainSteps": [
    {
      "action": "aws:runShellScript",
      "name": "InstallDependencies",
      "precondition": {
        "StringEquals": [
          "platformType",
          "Linux"
        ]
      },
      "description": "## Parameter: InstallDependencies\nIf set to True, this step installs the required dependency via operating system's repository. It supports both\nDebian (apt) and CentOS (yum) based package managers.",
      "inputs": {
        "onFailure": "exit",
        "runCommand": [
          "#!/bin/bash\n\nvalidate_installation_settings() {\n  if [[ \"{{ InstallDependencies }}\" == False ]]; then\n    echo \"Dependencies are not installed - Please set InstallDependencies to True.\"\n    exit 1\n  fi\n  echo \"Installing required dependencies\"\n}\n\n#################################\n#       Dependency Logic        #\n#################################\n\nfunction install_sch_netem_module() {\n  ssm_working_dir=$(pwd)\n  # Work from a directory that Amazon SSM Agent creates\n  cd /etc/amazon/ssm/\n  current_working_dir=$(pwd)\n  kernel_version=$(uname -r)\n  # Default location of sch_netem module\n  sched_module_local_path=/lib/modules/\"$kernel_version\"/kernel/net/sched/\n  sch_netem_kernel_module_file=sch_netem.ko\n  # Check if there is no compressed and uncompressed version of the module\n  if [ ! -f \"${sched_module_local_path}$sch_netem_kernel_module_file\" ] && [ ! -f \"${sched_module_local_path}$sch_netem_kernel_module_file\".xz ]; then\n    echo \"sch_netem does not exist, installing\"\n    # We will download and install the sch_netem kernel module to avoid the need for a reboot, as\n    # would be required if we used `yum install kernel-modules-extra`.\n    temp_dir=kernel-lib\n    # If the yumdownloader comes back with no module available, then fail\n    if yumdownloader kernel-modules-extra-\"$kernel_version\" --destdir \"$temp_dir\" 2>&1 | grep \"No package kernel-modules-extra-$kernel_version available.\"; then\n      echo \"No sch_netem module for the kernel version $kernel_version\"\n      echo \"Exiting - Unable to install sch_netem. kernel module sch_netem must be installed for this document to run\"\n      rm -rf \"$temp_dir\"\n      exit 1\n    fi\n    # We need to CD into the temp_dir for cpio since it does not work with absolute or relative paths well\n    cd \"$temp_dir\"\n    # Unpacks the modules into lib/\n    # version is downloaded but will differ from $kernel_version, depending OS.\n    rpm2cpio kernel-modules-extra-\"$kernel_version\".rpm | cpio -id\n    # Move back to the working dir.\n    cd \"$current_working_dir\"\n    # if sch_netem exists in the rpm lib, move it to /etc/amazon/ssm\n    sch_netem_path=$(find \"$temp_dir\"/lib -name \"$sch_netem_kernel_module_file\".xz)\n    if [ -n \"${sch_netem_path}\" ]; then\n      echo \"Downloaded Kernel Modules, and sch_netem exists. Loading Module\"\n      mv \"${sch_netem_path}\" \"$current_working_dir\"\n      # Do not need the rest of the temp_dir\n      rm -rf \"$temp_dir\"\n      echo \"Unpacking sch_netem\"\n      xz -d \"$sch_netem_kernel_module_file\".xz\n      rm -f \"$sch_netem_kernel_module_file\".xz\n      # Create a symlink to the default location so that the module can be added to the list of available modules by depmod\n      ln -s \"$current_working_dir\"/$sch_netem_kernel_module_file /lib/modules/\"$kernel_version\"/\"$sch_netem_kernel_module_file\"\n      echo \"Loading sch_netem\"\n      # Refresh the list of available modules\n      depmod -a\n      modprobe sch_netem\n      # Check if loaded successfully\n      if lsmod | grep -wq \"sch_netem\"; then\n        echo \"$sch_netem_kernel_module_file module installed and loaded\"\n      else\n        echo \"Exiting - Error loading module, kernel module sch_netem.ko must be installed for this document to run\"\n        exit 1\n      fi\n    else\n      # make sure our temp file deleted.\n      rm -rf \"$temp_dir\"\n      echo \"Exiting - Unable to install sch_netem. kernel module sch_netem must be installed for this document to run\"\n      exit 1\n    fi\n  # Check if the module exists and enable it\n  elif [[ -f \"${sched_module_local_path}/$sch_netem_kernel_module_file\" ]]; then\n    if modinfo ${sched_module_local_path}/$sch_netem_kernel_module_file -F vermagic | awk '{print $1}' | grep -Fi \"$kernel_version\"; then\n      # Lets build an updated list of available modules first\n      depmod -a\n      # Insert module\n      modprobe sch_netem\n    fi\n  # if the compressed module exist, uncompress and enable\n  elif [[ -f \"${sched_module_local_path}$sch_netem_kernel_module_file\".xz ]] && [ ! -f \"${sched_module_local_path}$sch_netem_kernel_module_file\" ]; then\n    # Module exists, so we need to unpack it and insert the module in the kernel it\n    xz -d -k \"${sched_module_local_path}/$sch_netem_kernel_module_file\".xz\n    if modinfo ${sched_module_local_path}/$sch_netem_kernel_module_file -F vermagic | awk '{print $1}' | grep -Fi \"$kernel_version\"; then\n      # Lets build an updated list of available modules first\n      depmod -a\n      # Insert module\n      modprobe sch_netem\n    fi\n  fi\n  cd \"$ssm_working_dir\"\n}\n\nfunction check_and_install_netem() {\n  if ! lsmod | grep -wq \"sch_netem\"; then\n    # To avoid issues with SELinux we wrap everything in sudo.\n    # In order to call the install_sch_netem_module function wrapped with sudo,\n    # we need to pass it as a command rather than a function call.\n    SUDOINSTALL=$(declare -f install_sch_netem_module)\n    sudo bash -c \"$SUDOINSTALL; install_sch_netem_module\" 2>&1\n    # Check if loaded\n    if lsmod | grep -wq \"sch_netem\"; then\n      echo \"sch_netem.ko Module loaded\"\n    else\n      echo \"Exiting - Error loading module, kernel module sch_netem.ko must be installed for this document to run\"\n      exit 1\n    fi\n  fi\n}\n\nfunction adjust_rhel_package() {\n  # For centos/rhel 7 the package is iproute, so remove the suffix if iproute is there\n  # since this command is directly related to the use of sch_netem.\n  if [[ ${rhel_package} == *iproute-tc* ]] && [ \"$os_major_version_number\" -eq \"7\" ]; then\n    rhel_package=${rhel_package/iproute-tc/iproute}\n  fi\n}\n\n# Configure ATD service if required\nconfigure_atd() {\n  if ! systemctl is-enabled atd || ! systemctl is-active atd; then\n    echo \"Enabling and starting atd\"\n    systemctl enable atd\n    systemctl start atd\n  fi\n}\n\n########################################################################################################################\n # This script builds a list of available modules and enables sch_netem                                                #\n # sch_netem kernel module is responsible for emulating traffic,                                                       #\n # FIS SSM Documents use this module when creating network faults, such as the packet loss fault and the latency fault #\n########################################################################################################################\n# Build a list of the available modules\nenable_netem() {\n  if ! command -v depmod &> /dev/null; then\n    echo \"WARN depmod is not available. Command could fail due to missing sch_netem\"\n    return 0\n  else\n    depmod -a\n    # Enable the sch_netem module, if there is a failure, exit\n    if ! modprobe sch_netem; then\n      echo \"WARN Cannot enable sch_netem\"\n      echo \"WARN Command could fail due to missing sch_netem\"\n      return 0\n    fi\n  fi\n  return 0\n}\n\n# Check if dependencies are already installed\ncheck_existing_dependencies() {\n  if [[ \"$( command -v stress-ng 2>/dev/null )\" && \"$( command -v pgrep 2>/dev/null )\" ]]; then\n  \n    echo \"Dependencies are already installed.\"\n    exit\n  \n  fi\n}\n\n# Handle Amazon Linux installations\ninstall_amazon_linux() {\n  if ! grep -Fiq 'VERSION_ID=\"2023\"' /etc/os-release; then\n  \n    # Use amazon-linux-extras if available (Amazon Linux 2)\n    command -v amazon-linux-extras 2>/dev/null 1>&2 && amazon-linux-extras install testing\n  \n    yum -y install stress-ng procps-ng\n  elif grep -Fiq 'ID=\"amzn\"' /etc/os-release && grep -Fiq 'VERSION_ID=\"2023\"' /etc/os-release; then\n  \n    yum -y install stress-ng procps-ng\n  else\n    echo \"Exiting - This SSM document supports: Amazon Linux 2023, Amazon Linux 2, Ubuntu, CentOS 9 and RHEL (8, 9) operating systems\"\n    exit 1\n  fi\n}\n\n# Handle RHEL/CentOS installations\ninstall_rhel_centos() {\n  # Fetch OS Version\n  os_version_number=$(grep -oP '(?<=^VERSION_ID=).+' /etc/os-release | tr -d '\"')\n  # if the version has a decimal, this line will remove it\n  os_major_version_number=${os_version_number%.*}\n  # Replace with version number in the url if required\n  if ! rpm --quiet -q epel-release; then\n    epel_dl_url=\"https://dl.fedoraproject.org/pub/epel/epel-release-latest-VERSION.noarch.rpm\"\n    epel_with_version=\"${epel_dl_url/VERSION/$os_major_version_number}\"\n    yum -y install $epel_with_version\n  fi\n  rhel_package=\"stress-ng procps\"\n  \n  yum -y install $rhel_package\n}\n\n# Handle Ubuntu installations\ninstall_ubuntu() {\n  apt-get update -y\n  # when installing, sometimes ubuntu has stderr that are not breaking errors.\n  install_error=$(apt-get install -y stress-ng procps 2>&1)\n  if [[ -n \"$install_error\" ]]; then\n    echo \"$install_error\"\n  fi\n\n  ubuntu_commands=( stress-ng pgrep )\n  for dependency_command in \"${ubuntu_commands[@]}\"; do\n    if ! command -v $dependency_command >/dev/null 2>&1; then\n      echo \"Exiting - $dependency_command not installed\"\n      exit 1\n    fi\n  done\n}\n\n# Main function to orchestrate the installation process\nmain() {\n  check_existing_dependencies\n  validate_installation_settings\n\n  if [ -f \"/etc/system-release\" ] && grep -i 'Amazon Linux' /etc/system-release; then\n    install_amazon_linux\n  elif grep -Fiq 'ID=\"centos\"' /etc/os-release || grep -Fiq 'ID=\"rhel\"' /etc/os-release; then\n    install_rhel_centos\n  elif grep -i \"Ubuntu\" /etc/issue; then\n    install_ubuntu\n  else\n    echo \"Exiting - This SSM document supports: Amazon Linux 2023, Amazon Linux 2, Ubuntu, CentOS 9 and RHEL (8, 9) operating systems\"\n    exit 1\n  fi\n}\n\n# Execute main function\nmain\n"
        ]
      }
    },
    {
      "action": "aws:runShellScript",
      "name": "FaultInjection",
      "precondition": {
        "StringEquals": [
          "platformType",
          "Linux"
        ]
      },
      "description": "## Parameters: DurationSeconds and CPU\nThis step will stress the specified CPU number - or all CPUs if set to 0 (zero) - for the specified Duration time\nin seconds.",
      "inputs": {
        "maxAttempts": 1,
        "timeoutSeconds": 43200,
        "runCommand": [
          "#!/bin/bash\nset -o errexit -o errtrace -o nounset -o pipefail\n\n#####################################\n# General pre fault-execution logic #\n#####################################\n\n# To track how long the fault command took to run\nstart_time=$(date +%s)\n\n########################\n# Fault-specific logic #\n########################\n\nvalidate_parameter_within_range() {\n  local parameter=$1\n  local value=$2\n  local min=$3\n  local max=$4\n\n  if (( value >= min && value <= max )); then\n    return 0\n  fi\n\n  echo \"Parameter $parameter must be between $min and $max, was: '$value'\" >&2\n  exit 1\n}\n\nvalidate_process_not_running() {\n  local process_name=\"$1\"\n\n  # Check if process is running\n  if pgrep \"$process_name\" > /dev/null; then\n    echo \"Another '$process_name' command is running, exiting...\" >&2\n    exit 1\n  fi\n\n  return 0\n}\n\nvalidate_parameter_within_range \"DurationSeconds\" {{ DurationSeconds }} 1 43200\nvalidate_parameter_within_range \"LoadPercent\" {{ LoadPercent }} 0 100\nvalidate_process_not_running stress-ng\n\necho Initiating CPU stress for {{ DurationSeconds }} seconds...\nstress-ng --cpu {{ CPU }} --cpu-method matrixprod -t {{ DurationSeconds }}s --cpu-load {{ LoadPercent }}\necho Finished CPU stress.\n\n######################################\n# General post fault-execution logic #\n######################################\n\n# Function to check if a fault execution ran for the expected duration\n# Returns 0 if the fault execution ran for at least the expected duration\n# Exits with code 1 if the fault execution ran for less than the expected duration or if parameters are invalid\nrun_post_fault_injection() {\n  local start_time=$1\n  local duration=$2\n  \n  # Check if start_time is provided\n  if [[ -z $start_time ]]; then\n    echo \"start_time is not defined\" >&2\n    exit 1\n  fi\n  \n  # Calculate elapsed time\n  local elapsed_time=$(( $(date +%s) - start_time ))\n  \n  # Fail if the fault command exits successfully but the execution duration is less than the expected duration.\n  # This happens when stress-ng is killed prematurely using SIGTERM or SIGINT.\n  if [[ \"$elapsed_time\" -lt \"$duration\" ]]; then\n    echo \"Fault took $elapsed_time seconds to execute, which is less than expected duration $duration\" >&2\n    exit 1\n  fi\n  \n  return 0\n}\nrun_post_fault_injection \"$start_time\" {{ DurationSeconds }}"
        ]
      }
    }
  ]
}
