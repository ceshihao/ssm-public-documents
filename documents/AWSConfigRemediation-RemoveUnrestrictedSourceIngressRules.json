{
  "schemaVersion": "0.3",
  "description": "### Document Name - AWSConfigRemediation-RemoveUnrestrictedSourceIngressRules\n\n## What does this document do?\nThis runbook removes all ingress rules from the security group you specify that allow traffic from all source addresses using the [RevokeSecurityGroupIngress](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_RevokeSecurityGroupIngress.html) API.\n\n\n## Input Parameters\n* SecurityGroupId: (Required) The ID of the security group that you want to remove ingress rules that allow traffic from all source addresses from.\n* AutomationAssumeRole: (Required) The Amazon Resource Name (ARN) of the AWS Identity and Access Management (IAM) role that allows Systems Manager Automation to perform the actions on your behalf.\n\n## Output Parameters\n* RemoveUnrestrictedIngressRulesAndVerify.Response - The standard HTTP response from the RevokeSecurityGroupIngress API.\n",
  "assumeRole": "{{ AutomationAssumeRole }}",
  "parameters": {
    "AutomationAssumeRole": {
      "type": "AWS::IAM::Role::Arn",
      "description": "(Required) The Amazon Resource Name (ARN) of the AWS Identity and Access Management (IAM) role that allows Systems Manager Automation to perform the actions on your behalf."
    },
    "SecurityGroupId": {
      "type": "String",
      "description": "(Required) The ID of the security group that you want to remove ingress rules that allow traffic from all source addresses from.",
      "allowedPattern": "^sg-[a-z0-9]+$"
    }
  },
  "outputs": [
    "RemoveUnrestrictedIngressRulesAndVerify.Response"
  ],
  "mainSteps": [
    {
      "name": "RemoveUnrestrictedIngressRulesAndVerify",
      "action": "aws:executeScript",
      "timeoutSeconds": 600,
      "description": "## RemoveUnrestrictedIngressRulesAndVerify\nRemoves all ingress rules that allow traffic from all source addresses from the security group you specified in the SecurityGroupId parameter and verifies successful rules removal.\n## Outputs\n* Response: The standard HTTP response from the RevokeSecurityGroupIngress API.\n",
      "inputs": {
        "Runtime": "python3.11",
        "Handler": "remove_sg_unrestricted_ingress_rules",
        "InputPayload": {
          "SecurityGroupId": "{{ SecurityGroupId }}"
        },
        "Script": "import boto3\ndef remove_unrestricted_ingress_rules_ipv4(ec2, security_group_id):\n  paginator = ec2.get_paginator('describe_security_groups')\n  response_iterator = paginator.paginate(\n  Filters=[ {'Name': 'ip-permission.cidr', 'Values': [ '0.0.0.0/0' ] },],\n  GroupIds=[security_group_id]\n  )\n\n  ip_permissions = []\n  for sgs in response_iterator:\n    for sg in sgs.get('SecurityGroups'):\n      for ip in sg.get('IpPermissions'):\n        for rule in ip.get('IpRanges'):\n          if(rule['CidrIp'] == '0.0.0.0/0'):\n            permissions_dict = {'IpProtocol': ip['IpProtocol'], 'IpRanges': [{'CidrIp': '0.0.0.0/0'}]}\n            if not ip.get(\"FromPort\") is None:\n              permissions_dict[\"FromPort\"] = ip[\"FromPort\"]\n            if not ip.get(\"ToPort\") is None:\n              permissions_dict[\"ToPort\"] = ip[\"ToPort\"]\n            ip_permissions.append(permissions_dict)\n  if ip_permissions:\n    return ec2.revoke_security_group_ingress(GroupId=security_group_id, IpPermissions=ip_permissions)\n\ndef remove_unrestricted_ingress_rules_ipv6(ec2, security_group_id):\n    paginator = ec2.get_paginator('describe_security_groups')\n    response_iterator = paginator.paginate(\n    Filters=[ {'Name': 'ip-permission.ipv6-cidr', 'Values': [ '::/0' ] },],\n    GroupIds=[security_group_id]\n    )\n\n    ip_permissions = []\n    for sgs in response_iterator:\n      for sg in sgs.get('SecurityGroups'):\n        for ip in sg.get('IpPermissions'):\n          for rule in ip.get('Ipv6Ranges'):\n            if(rule['CidrIpv6'] == '::/0'):\n              permissions_dict = {'IpProtocol': ip['IpProtocol'], 'Ipv6Ranges': [{'CidrIpv6': '::/0'}]}\n              if not ip.get(\"FromPort\") is None:\n                permissions_dict[\"FromPort\"] = ip[\"FromPort\"]\n              if not ip.get(\"ToPort\") is None:\n                permissions_dict[\"ToPort\"] = ip[\"ToPort\"]\n              ip_permissions.append(permissions_dict)\n    if ip_permissions:\n        return ec2.revoke_security_group_ingress(GroupId=security_group_id, IpPermissions=ip_permissions)\n\ndef verify_sg_unrestricted_rules_removed(ec2, security_group_id):\n    error_message = f\"Verification Failed. Security Group {security_group_id} unrestricted ingress rules not removed \"\n\n    unrestricted_ingress_rules_ipv4 = ec2.describe_security_groups(GroupIds=[ security_group_id ], Filters=[  {'Name': 'ip-permission.cidr','Values': ['0.0.0.0/0' ]} ])\n    if unrestricted_ingress_rules_ipv4['SecurityGroups']:\n      raise Exception(error_message)\n\n    unrestricted_ingress_rules_ipv6 = ec2.describe_security_groups(GroupIds=[ security_group_id ], Filters=[ {'Name': 'ip-permission.ipv6-cidr','Values': ['::/0' ]} ])\n    if unrestricted_ingress_rules_ipv6['SecurityGroups']:\n      raise Exception(error_message)\n\ndef remove_sg_unrestricted_ingress_rules(event, context):\n    \n    ec2 = boto3.client('ec2')\n    security_group_id = event['SecurityGroupId']\n    ipv4_response = remove_unrestricted_ingress_rules_ipv4(ec2, security_group_id)\n    ipv6_response = remove_unrestricted_ingress_rules_ipv6(ec2, security_group_id)\n    \n    verify_sg_unrestricted_rules_removed(ec2, security_group_id)\n\n    response = []\n    if ipv4_response:\n      response.append(ipv4_response)\n    if ipv6_response:\n      response.append(ipv6_response)\n    return response"
      },
      "outputs": [
        {
          "Name": "Response",
          "Selector": "$.Payload",
          "Type": "MapList"
        }
      ]
    },
    {
      "name": "RemoveUnrestrictedIngressPrefixListRulesAndVerify",
      "action": "aws:executeScript",
      "timeoutSeconds": 600,
      "isEnd": true,
      "isCritical": false,
      "onFailure": "Continue",
      "description": "\"\"\"\n  Removes ingress rules from an AWS EC2 security group that use prefix lists containing only public CIDRs (0.0.0.0/0 or ::/0).\n  If a prefix list contains both public and private CIDRs, the script will fail during verification and require manual intervention.\n\n  Key functionalities:\n  1. Analyzes prefix lists associated with security group rules.\n  2. Removes rules that use prefix lists containing only public CIDRs.\n  3. Verifies rule removal and checks for mixed prefix lists after the operation.\n  4. Fails if any prefix list contains both public and private CIDRs (requires manual review).\n\n  Input:\n      - SecurityGroupId: The ID of the security group to process.\n\n  Output:\n      - Returns the response from the AWS EC2 API call to revoke ingress rules, or an empty dict if no changes were made.\n      - Throws exception if any prefix list contains both public and private CIDRs during verification.\n\"\"\"\n",
      "inputs": {
        "Runtime": "python3.11",
        "Handler": "remove_sg_unrestricted_ingress_prefix_list_rules",
        "InputPayload": {
          "SecurityGroupId": "{{ SecurityGroupId }}"
        },
        "Script": "import boto3\n\nPUBLIC_IPV4_CIDR = '0.0.0.0/0'\nPUBLIC_IPV6_CIDR = '::/0'\n\ndef analyze_prefix_list(ec2_client, prefix_list_id):\n    \"\"\"\n    Analyzes a prefix list to determine if it contains only public CIDR,\n    mixed CIDRs, or no public CIDRs.\n    \"\"\"\n    try:\n        has_public_cidr = False\n        has_other_cidrs = False\n        paginator = ec2_client.get_paginator('get_managed_prefix_list_entries')\n    \n        for page in paginator.paginate(PrefixListId=prefix_list_id):\n            for entry in page['Entries']:\n                if entry['Cidr'] in [PUBLIC_IPV4_CIDR, PUBLIC_IPV6_CIDR]:\n                    has_public_cidr = True\n                else:\n                    has_other_cidrs = True\n    \n                # Stop processing if we've found both types\n                if has_public_cidr and has_other_cidrs:\n                    return {\n                        'public_cidr': False,\n                        'public_and_private_cidr': True\n                    }\n    \n        return {\n            'public_cidr': has_public_cidr and not has_other_cidrs,\n            'public_and_private_cidr': has_public_cidr and has_other_cidrs\n        }\n    except Exception as e:\n        print(f\"Error checking prefix list {prefix_list_id}: {str(e)}\")\n        raise e\n\ndef remove_unrestricted_ingress_rules_prefix_lists(ec2, security_group_id):\n    \"\"\"\n    Removes ingress rules that use prefix lists containing only public CIDRs\n    \"\"\"\n    paginator = ec2.get_paginator('describe_security_groups')\n    response_iterator = paginator.paginate(GroupIds=[security_group_id])\n\n    ip_permissions = []\n    for sgs in response_iterator:\n        for sg in sgs.get('SecurityGroups'):\n            for ip in sg.get('IpPermissions'):\n                if 'PrefixListIds' in ip:\n                    for prefix_list in ip.get('PrefixListIds'):\n                        analysis = analyze_prefix_list(ec2, prefix_list['PrefixListId'])\n                        if analysis['public_cidr']:\n                            permissions_dict = {\n                                'IpProtocol': ip['IpProtocol'], \n                                'PrefixListIds': [prefix_list]\n                            }\n                            if not ip.get(\"FromPort\") is None:\n                                permissions_dict[\"FromPort\"] = ip[\"FromPort\"]\n                            if not ip.get(\"ToPort\") is None:\n                                permissions_dict[\"ToPort\"] = ip[\"ToPort\"]\n                            ip_permissions.append(permissions_dict)\n    if ip_permissions:\n        return ec2.revoke_security_group_ingress(GroupId=security_group_id, IpPermissions=ip_permissions)\n\ndef verify_sg_unrestricted_prefix_lists_removed(ec2, security_group_id):\n    \"\"\"\n    Verifies that no prefix lists containing only public CIDRs remain\n    and checks for any prefix lists with mixed public and private CIDRs\n    \"\"\"\n    error_message = f\"Verification Failed. Security Group {security_group_id} has issues with prefix lists:\\n\"\n    has_error = False\n    mixed_prefix_lists = []\n    public_prefix_lists = []\n\n    sg_description = ec2.describe_security_groups(GroupIds=[security_group_id])\n    for sg in sg_description['SecurityGroups']:\n        for ip in sg.get('IpPermissions'):\n            if 'PrefixListIds' in ip:\n                for prefix_list in ip.get('PrefixListIds'):\n                    analysis = analyze_prefix_list(ec2, prefix_list['PrefixListId'])\n                    if analysis['public_cidr']:\n                        public_prefix_lists.append({\n                            'prefix_list_id': prefix_list['PrefixListId'],\n                            'port_range': f\"{ip.get('FromPort', 'All')}-{ip.get('ToPort', 'All')}\"\n                        })\n                        has_error = True\n                    elif analysis['public_and_private_cidr']:\n                        mixed_prefix_lists.append({\n                            'prefix_list_id': prefix_list['PrefixListId'],\n                            'port_range': f\"{ip.get('FromPort', 'All')}-{ip.get('ToPort', 'All')}\"\n                        })\n                        has_error = True\n\n    if public_prefix_lists:\n        error_message += \"The following prefix lists contain only public CIDRs and should have been removed:\\n\"\n        for pl in public_prefix_lists:\n            error_message += f\"- Prefix List: {pl['prefix_list_id']}, Ports: {pl['port_range']}\\n\"\n\n    if mixed_prefix_lists:\n        error_message += \"The following prefix lists contain both public and private CIDRs and require manual review:\\n\"\n        for pl in mixed_prefix_lists:\n            error_message += f\"- Prefix List: {pl['prefix_list_id']}, Ports: {pl['port_range']}\\n\"\n\n    if has_error:\n        raise Exception(error_message)\n\ndef remove_sg_unrestricted_ingress_prefix_list_rules(event, context):\n    \"\"\"\n    Lambda handler to remove security group rules using prefix lists that contain only public CIDRs\n    \"\"\"\n    ec2 = boto3.client('ec2')\n    security_group_id = event['SecurityGroupId']\n    \n    # Remove unrestricted prefix list rules\n    response = remove_unrestricted_ingress_rules_prefix_lists(ec2, security_group_id)\n    \n    # Verify removal\n    verify_sg_unrestricted_prefix_lists_removed(ec2, security_group_id)\n\n    return [response] if response else []"
      },
      "outputs": [
        {
          "Name": "Response",
          "Selector": "$.Payload",
          "Type": "MapList"
        }
      ]
    }
  ]
}
