{
  "schemaVersion": "2.2",
  "description": "Deletes a Windows Registry value.",
  "parameters": {
    "Path": {
      "type": "String",
      "description": "The registry path where the value will be deleted from. The format for this parameter is \"HIVE:\\Path\", for example \"HKLM:\\SOFTWARE\".",
      "allowedPattern": "^((HKEY_LOCAL_MACHINE|HKLM|HKEY_CURRENT_CONFIG|HKCC|HKEY_CURRENT_USER|HKCU|HKEY_USERS|HKU|HKEY_CLASSES_ROOT|HKCR)+:\\\\)(()|([a-zA-Z0-9\\s_@\\-\\^!#.\\:\\/\\$%&+={}\\[\\]\\\\*]))+$"
    },
    "Name": {
      "type": "String",
      "description": "The name of the registry value to delete.",
      "allowedPattern": "^[^|\\n\\r]*$"
    },
    "PerformAction": {
      "type": "String",
      "description": "(Optional) Set this to 'Yes' to perform the action.",
      "default": "No",
      "allowedValues": [
        "No",
        "Yes"
      ]
    }
  },
  "mainSteps": [
    {
      "precondition": {
        "StringEquals": [
          "platformType",
          "Windows"
        ]
      },
      "action": "aws:runPowerShellScript",
      "name": "InvokeWindowsScript",
      "inputs": {
        "runCommand": [
          "$ErrorActionPreference = 'Stop'\n\nFunction ParseInputParameter {\n    param (\n        [string]$Name,\n        [string]$Value,\n        [string]$Regex\n    )\n\n    $ValidParameterRegex = '^--%[ +{|{].*}( +)?$'\n    if ($Value -notmatch $ValidParameterRegex) {\n        ExitWithFailureMessage -Message \"Invalid syntax for the parameter $Name\"\n    }\n    $parameterValue = $Value.Substring(3)\n\n    $trimmedParameterValue = $parameterValue.TrimStart().TrimEnd()\n    $trimmedParameterValue = $trimmedParameterValue.Substring(1)\n    $trimmedParameterValue = $trimmedParameterValue.Substring(0, $trimmedParameterValue.Length - 1)\n\n    if ($Regex -and $trimmedParameterValue -notmatch $Regex) {\n        ExitWithFailureMessage -Message \"Invalid syntax for the parameter $Name\"\n    } else {\n        $trimmedParameterValue\n    }\n}\n\nfunction ExitWithFailureMessage {\n    param (\n        [string]$Message,\n        [string]$ExceptionMessage,\n        [Switch]$PrintJson\n    )\n    if ([string]::IsNullOrWhitespace($ExceptionMessage)) {\n        $errorMessage = $Message\n    } else {\n        $errorMessage = '{0} {1}' -f $Message, $ExceptionMessage\n    }\n    if ($PrintJson) {ConvertTo-Json -InputObject @{error = $errorMessage} -Compress}\n    WriteStandardError -Message $errorMessage\n    [System.Environment]::Exit(1)\n}\n\nfunction ExitWithSuccessMessage {\n    param (\n        [string]$Message\n    )\n    Write-Host $Message\n    [System.Environment]::Exit(0)\n}\n\nfunction WriteStandardError {\n    param (\n        [string]$Message\n    )\n    $Host.UI.WriteErrorLine($Message)\n}\n\nfunction TestPerformAction {\n    param ( [string]$PerformAction )\n    if ($PerformAction -ne 'Yes') {\n        ExitWithFailureMessage -Message \"No action was taken because the PerformAction parameter is set to $PerformAction. To make the desired change, set this parameter to Yes.\"\n    }\n}\n\n$script:ResultProperty = 'results'\n$script:DataProperty = 'data'\n$script:NextTokenProperty = 'nextToken'\n\nfunction ConvertBase64ToString {\n    param (\n        [string]$Base64\n    )\n    $bytes = [System.Convert]::FromBase64String($Base64)\n    [System.Text.Encoding]::UTF8.GetString($bytes)\n}\n\nfunction ConvertStringToBase64 {\n    param (\n        [string]$String\n    )\n    $bytes = [System.Text.Encoding]::UTF8.GetBytes($String)\n    [System.Convert]::ToBase64String($bytes)\n}\n\nfunction GetCompressionBoolean {\n    param (\n        [ValidateSet('No','Yes')]\n        [string]$CompressOutput\n    )\n    if ($CompressOutput -eq 'Yes') {\n        $true\n    } else {\n        $false\n    }\n}\n\nfunction GetJson {\n    param ($InputObject)\n    ConvertTo-Json -InputObject $InputObject -Compress -Depth 5\n}\n\nfunction GetBase64EncodedGzipString {\n    param ($InputString)\n\n    $inputBytes = [System.Text.Encoding]::UTF8.GetBytes($InputString)\n\n    try {\n        $memoryStream = New-Object -TypeName 'System.IO.MemoryStream'\n        $compressionMode = [System.IO.Compression.CompressionMode]::Compress\n        $gzipStream = New-Object -TypeName 'System.IO.Compression.GzipStream' -ArgumentList @($memoryStream, $compressionMode)\n\n        $gzipStream.Write($inputBytes, 0, $inputBytes.Length)\n        $gzipStream.Close()\n        $memoryStream.Close()\n\n        [System.Convert]::ToBase64String($memoryStream.ToArray())\n    } finally {\n        $gzipStream.Dispose()\n        $memoryStream.Dispose()\n    }\n}\n\nfunction GetResultAsString {\n    param (\n        [PSObject]$Object,\n        [bool]$Completed,\n        [switch]$ConvertNextTokenToBase64,\n        [bool]$EnableCompression,\n        [bool]$ForceEmptyNextToken,\n        [string]$NextToken,\n        [string]$PaginationProperty,\n        [array]$StringReplacementRegex\n    )\n\n    if ([string]::IsNullOrWhiteSpace($NextToken)) {\n        if ($Completed -eq $false -and $Object.Count -ge 1 -and $ForceEmptyNextToken -ne $true) {\n            if ($PaginationProperty -eq '.') {\n                $NextToken = $Object[-1]\n            } else {\n                $NextToken = $Object[-1].$PaginationProperty\n            }\n        }\n    }\n\n    if ($ForceEmptyNextToken) {\n        $NextToken = [string]::Empty\n    } elseif ($ConvertNextTokenToBase64) {\n        $NextToken = ConvertStringToBase64 -String $NextToken\n    }\n\n    $data = @{\n        $script:ResultProperty    = $Object\n        $script:NextTokenProperty = $NextToken\n    }\n\n    if ($EnableCompression -eq $true) {\n        $string = GetJson -InputObject $data\n\n        if ($StringReplacementRegex.Count -eq 2) {\n            $string = $string -replace $StringReplacementRegex\n        }\n\n        $data = GetBase64EncodedGzipString -InputString $string\n    }\n\n    $output = GetJson -InputObject @{\n        $script:DataProperty = $data\n    }\n    if ($StringReplacementRegex.Count -eq 2) {\n        $output -replace $StringReplacementRegex\n    } else {\n        $output\n    }\n}\n\nfunction GetMaximumOutputBytes {\n    param (\n        $AllowTruncatedOutput,\n        [int]$MaximumOutputSize = 2500\n    )\n    if ($AllowTruncatedOutput -eq 'Yes') {\n        0\n    } else {\n        $padding = (GetResultAsString -Object @() -Completed $false -EnableCompression $false).length\n        $MaximumOutputSize - $padding\n    }\n}\n\nfunction ProcessItems {\n    param (\n        [scriptblock]$ScriptBlock,\n        [switch]$ConvertNextTokenToBase64,\n        [int]$ChunksPerLoop = 1,\n        [bool]$EnableCompression,\n        [int]$MaximumOutputBytes,\n        [string]$PaginationProperty,\n        [string]$PropertyToRemove,\n        [string]$NextToken,\n        [switch]$SetNextTokenBeforeAdding,\n        [array]$StringReplacementRegex\n    )\n\n    $chunkedOutputArray = New-Object -TypeName 'System.Collections.ArrayList'\n\n    $outputResult = [string]::Empty\n\n    $outputTooBig = $false\n    $counter = 0\n\n    $getResultString = @{\n        EnableCompression = $EnableCompression\n        PaginationProperty = $PaginationProperty\n        StringReplacementRegex = $StringReplacementRegex\n    }\n\n    foreach ($item in (& $ScriptBlock)) {\n        if ($outputTooBig -eq $true) { break }\n\n        if ($NextToken -ne '*') {\n            if ($PaginationProperty -eq '.' -and $item -le $NextToken) {\n                continue\n            } elseif ($PaginationProperty -ne '.' -and $item.$PaginationProperty -le $NextToken) {\n                continue\n            }\n        }\n\n        if ($SetNextTokenBeforeAdding) {\n            if ($PaginationProperty -eq '.') {\n                $newNextToken = $item\n            } else {\n                $newNextToken = $item.$PaginationProperty\n            }\n        }\n\n        if ($PropertyToRemove) {\n            $item.PSObject.properties.remove($PropertyToRemove)\n        }\n\n        $null = $chunkedOutputArray.Add($item)\n\n        if ($counter -lt $ChunksPerLoop) {\n            $counter++\n            continue\n        }\n\n        $counter = 0\n\n        $properties = @{\n            Object = $chunkedOutputArray\n            Completed = $outputTooBig\n        }\n        if ($ConvertNextTokenToBase64) {\n            $properties.Add('ConvertNextTokenToBase64', $ConvertNextTokenToBase64)\n        }\n        if ($SetNextTokenBeforeAdding) {\n            $properties.Add('NextToken', $newNextToken)\n        }\n        $tempResult = GetResultAsString @properties @getResultString\n\n        if ($MaximumOutputBytes -eq 0 -or $tempResult.Length -le $MaximumOutputBytes) {\n            $outputResult = $tempResult\n        } else {\n            $outputTooBig = $true\n            break\n        }\n    }\n\n    # Processing remaining items if the output isn't too big yet\n    if ($outputTooBig -eq $false) {\n        $properties = @{\n            Object = $chunkedOutputArray\n            Completed = $outputTooBig\n            ForceEmptyNextToken = $true\n        }\n        if ($ConvertNextTokenToBase64) {\n            $properties.Add('ConvertNextTokenToBase64', $ConvertNextTokenToBase64)\n        }\n        if ($SetNextTokenBeforeAdding) {\n            $properties.Add('NextToken', $newNextToken)\n        }\n        $tempResult = GetResultAsString @getResultString @properties\n        if ($MaximumOutputBytes -eq 0 -or $tempResult.Length -le $MaximumOutputBytes) {\n            $outputResult = $tempResult\n        }\n    }\n\n    $outputResult\n}\n\n$Path = Write-Output --%{{{ Path }}}\n$Path = ParseInputParameter -Name 'Path' -Value $Path\n\n$Name = Write-Output --%{{{ Name }}}\n$Name = ParseInputParameter -Name 'Name' -Value $Name\n\n$PerformAction = Write-Output --%{{{ PerformAction }}}\n$PerformAction = ParseInputParameter -Name 'PerformAction' -Value $PerformAction -Regex '(Yes|No)'\nTestPerformAction -PerformAction $PerformAction\n\nfunction TestRegistryValueExists {\n    param (\n        $Query,\n        $SubKey,\n        $Name\n    )\n\n    $registryKey = $Query.OpenSubKey($SubKey, $false)\n    if ($null -eq $registryKey) {return $false}\n\n    $values = $registryKey.GetValueNames()\n    if ($Name -in $values) {\n        return $true\n    } else {\n        return $false\n    }\n}\n\n$hive = ($Path.Split('\\')).GetValue(0)\n$registrySubKey = $Path.Replace($hive, [string]::Empty).TrimStart('\\')\n\nif ([string]::IsNullOrWhiteSpace($registrySubKey)) {\n    ExitWithFailureMessage -Message 'Registry values at the hive level cannot be deleted.' -PrintJson\n}\n\n[hashtable]$hivePrefixToName = @{\n    'HKLM:'                = [Microsoft.Win32.RegistryHive]::LocalMachine;\n    'HKEY_LOCAL_MACHINE:'  = [Microsoft.Win32.RegistryHive]::LocalMachine;\n    'HKCU:'                = [Microsoft.Win32.RegistryHive]::CurrentUser;\n    'HKEY_CURRENT_USER:'   = [Microsoft.Win32.RegistryHive]::CurrentUser;\n    'HKCC:'                = [Microsoft.Win32.RegistryHive]::CurrentConfig;\n    'HKEY_CURRENT_CONFIG:' = [Microsoft.Win32.RegistryHive]::CurrentConfig;\n    'HKEY_USERS:'          = [Microsoft.Win32.RegistryHive]::Users;\n    'HU:'                  = [Microsoft.Win32.RegistryHive]::Users;\n    'HKEY_CLASSES_ROOT:'   = [Microsoft.Win32.RegistryHive]::ClassesRoot;\n    'HKCR:'                = [Microsoft.Win32.RegistryHive]::ClassesRoot\n}\n$query = [Microsoft.Win32.RegistryKey]::OpenBaseKey($hivePrefixToName[$hive], [Microsoft.Win32.RegistryView]'Default')\n\nif (-not(TestRegistryValueExists -Query $query -SubKey $registrySubKey -Name $Name)) {\n    ExitWithFailureMessage -Message 'The specified registry value does not exist.'\n}\n\n$regKey = $query.OpenSubKey($registrySubKey, $true)\nif ($null -eq $regKey) {\n    ExitWithFailureMessage -Message 'The specified registry key is invalid.' -PrintJson\n}\n\ntry {\n    $null = $regKey.DeleteValue($Name)\n    ExitWithSuccessMessage 'The specified registry value has been deleted.'\n} catch {\n    ExitWithFailureMessage -Message 'Failed to delete the specified registry value.' -PrintJson\n}\n"
        ]
      }
    }
  ]
}
