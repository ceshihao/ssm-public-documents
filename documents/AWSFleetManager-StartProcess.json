{
  "schemaVersion": "2.2",
  "description": "Start process.",
  "parameters": {
    "Name": {
      "type": "String",
      "description": "File path and file name of the program or document to be executed.",
      "allowedPattern": "^\\w[^\\\\/\"'|\\r\\n]*$|^([A-Za-z0-9-_\\/+]{4})*([A-Za-z0-9-_\\/+]{4}|[A-Za-z0-9-_\\/+]{3}=|[A-Za-z0-9-_\\/+]{2}==)$|^\\w:$|^\\w:\\\\[^\"'|\\r\\n]*$|^\\/[^\"'|\\r\\n]*$|^([A-Za-z0-9-_\\/+]{4})*([A-Za-z0-9-_\\/+]{4}|[A-Za-z0-9-_\\/+]{3}=|[A-Za-z0-9-_\\/+]{2}==)$"
    },
    "WorkingDirectory": {
      "type": "String",
      "description": "(Optional) Specify the location of the file that will be run. The default is the current directory.",
      "default": "",
      "allowedPattern": "^\\w:$|^\\w:\\\\[^\"'|\\r\\n]*$|^\\/[^\"'|\\r\\n]*$|^([A-Za-z0-9-_\\/+]{4})*([A-Za-z0-9-_\\/+]{4}|[A-Za-z0-9-_\\/+]{3}=|[A-Za-z0-9-_\\/+]{2}==)$|^$"
    },
    "PerformAction": {
      "type": "String",
      "description": "(Optional) Set this to 'Yes' to perform the action.",
      "default": "No",
      "allowedValues": [
        "No",
        "Yes"
      ]
    }
  },
  "mainSteps": [
    {
      "precondition": {
        "StringEquals": [
          "platformType",
          "Windows"
        ]
      },
      "action": "aws:runPowerShellScript",
      "name": "InvokeWindowsScript",
      "inputs": {
        "runCommand": [
          "$ErrorActionPreference = 'Stop'\n\nFunction ParseInputParameter {\n    param (\n        [string]$Name,\n        [string]$Value,\n        [string]$Regex\n    )\n\n    $ValidParameterRegex = '^--%[ +{|{].*}( +)?$'\n    if ($Value -notmatch $ValidParameterRegex) {\n        ExitWithFailureMessage -Message \"Invalid syntax for the parameter $Name\"\n    }\n    $parameterValue = $Value.Substring(3)\n\n    $trimmedParameterValue = $parameterValue.TrimStart().TrimEnd()\n    $trimmedParameterValue = $trimmedParameterValue.Substring(1)\n    $trimmedParameterValue = $trimmedParameterValue.Substring(0, $trimmedParameterValue.Length - 1)\n\n    if ($Regex -and $trimmedParameterValue -notmatch $Regex) {\n        ExitWithFailureMessage -Message \"Invalid syntax for the parameter $Name\"\n    } else {\n        $trimmedParameterValue\n    }\n}\n\nfunction ExitWithFailureMessage {\n    param (\n        [string]$Message,\n        [string]$ExceptionMessage,\n        [Switch]$PrintJson\n    )\n    if ([string]::IsNullOrWhitespace($ExceptionMessage)) {\n        $errorMessage = $Message\n    } else {\n        $errorMessage = '{0} {1}' -f $Message, $ExceptionMessage\n    }\n    if ($PrintJson) {ConvertTo-Json -InputObject @{error = $errorMessage} -Compress}\n    WriteStandardError -Message $errorMessage\n    [System.Environment]::Exit(1)\n}\n\nfunction ExitWithFailureMessageAndExitCode {\n    param (\n        [string]$Message,\n        [string]$ExceptionMessage,\n        [int]$ExitCode,\n        [Switch]$PrintJson\n    )\n    if ([string]::IsNullOrWhitespace($ExceptionMessage)) {\n        $errorMessage = $Message\n    } else {\n        $errorMessage = '{0} {1}' -f $Message, $ExceptionMessage\n    }\n    if ($PSBoundParameters.ContainsKey('ExitCode') -eq $true) {\n        $exitCode = $ExitCode\n    } else {\n        $exitCode = 1\n    }\n    if ($PrintJson) {\n        $ErrorObject = @{\n            error = $errorMessage\n            exitCode = $exitCode\n        }\n        ConvertTo-Json -InputObject $ErrorObject -Compress\n    }\n    WriteStandardError -Message $errorMessage\n    [System.Environment]::Exit($exitCode)\n}\n\nfunction ExitWithSuccessMessage {\n    param (\n        [string]$Message\n    )\n    Write-Host $Message\n    [System.Environment]::Exit(0)\n}\n\nfunction WriteStandardError {\n    param (\n        [string]$Message\n    )\n    $Host.UI.WriteErrorLine($Message)\n}\n\nfunction TestPerformAction {\n    param ( [string]$PerformAction )\n    if ($PerformAction -ne 'Yes') {\n        ExitWithFailureMessage -Message \"No action was taken because the PerformAction parameter is set to $PerformAction. To make the desired change, set this parameter to Yes.\"\n    }\n}\n\n$script:ResultProperty = 'results'\n$script:DataProperty = 'data'\n$script:NextTokenProperty = 'nextToken'\n\nfunction ConvertBase64ToString {\n    param (\n        [string]$Base64\n    )\n    $bytes = [System.Convert]::FromBase64String($Base64)\n    [System.Text.Encoding]::UTF8.GetString($bytes)\n}\n\nfunction ConvertStringToBase64 {\n    param (\n        [string]$String\n    )\n    $bytes = [System.Text.Encoding]::UTF8.GetBytes($String)\n    [System.Convert]::ToBase64String($bytes)\n}\n\nfunction GetCompressionBoolean {\n    param (\n        [ValidateSet('No','Yes')]\n        [string]$CompressOutput\n    )\n    if ($CompressOutput -eq 'Yes') {\n        $true\n    } else {\n        $false\n    }\n}\n\nfunction GetJson {\n    param ($InputObject)\n    ConvertTo-Json -InputObject $InputObject -Compress -Depth 5\n}\n\nfunction GetBase64EncodedGzipString {\n    param ($InputString)\n\n    $inputBytes = [System.Text.Encoding]::UTF8.GetBytes($InputString)\n\n    try {\n        $memoryStream = New-Object -TypeName 'System.IO.MemoryStream'\n        $compressionMode = [System.IO.Compression.CompressionMode]::Compress\n        $gzipStream = New-Object -TypeName 'System.IO.Compression.GzipStream' -ArgumentList @($memoryStream, $compressionMode)\n\n        $gzipStream.Write($inputBytes, 0, $inputBytes.Length)\n        $gzipStream.Close()\n        $memoryStream.Close()\n\n        [System.Convert]::ToBase64String($memoryStream.ToArray())\n    } finally {\n        $gzipStream.Dispose()\n        $memoryStream.Dispose()\n    }\n}\n\nfunction GetResultAsString {\n    param (\n        [PSObject]$Object,\n        [bool]$Completed,\n        [switch]$ConvertNextTokenToBase64,\n        [bool]$EnableCompression,\n        [bool]$ForceEmptyNextToken,\n        [string]$NextToken,\n        [string]$PaginationProperty,\n        [array]$StringReplacementRegex\n    )\n\n    if ([string]::IsNullOrWhiteSpace($NextToken)) {\n        if ($Completed -eq $false -and $Object.Count -ge 1 -and $ForceEmptyNextToken -ne $true) {\n            if ($PaginationProperty -eq '.') {\n                $NextToken = $Object[-1]\n            } else {\n                $NextToken = $Object[-1].$PaginationProperty\n            }\n        }\n    }\n\n    if ($ForceEmptyNextToken) {\n        $NextToken = [string]::Empty\n    } elseif ($ConvertNextTokenToBase64) {\n        $NextToken = ConvertStringToBase64 -String $NextToken\n    }\n\n    $data = @{\n        $script:ResultProperty    = $Object\n        $script:NextTokenProperty = $NextToken\n    }\n\n    if ($EnableCompression -eq $true) {\n        $string = GetJson -InputObject $data\n\n        if ($StringReplacementRegex.Count -eq 2) {\n            $string = $string -replace $StringReplacementRegex\n        }\n\n        $data = GetBase64EncodedGzipString -InputString $string\n    }\n\n    $output = GetJson -InputObject @{\n        $script:DataProperty = $data\n    }\n    if ($StringReplacementRegex.Count -eq 2) {\n        $output -replace $StringReplacementRegex\n    } else {\n        $output\n    }\n}\n\nfunction GetMaximumOutputBytes {\n    param (\n        $AllowTruncatedOutput,\n        [int]$MaximumOutputSize = 2500\n    )\n    if ($AllowTruncatedOutput -eq 'Yes') {\n        0\n    } else {\n        $padding = (GetResultAsString -Object @() -Completed $false -EnableCompression $false).length\n        $MaximumOutputSize - $padding\n    }\n}\n\nfunction ProcessItems {\n    param (\n        [scriptblock]$ScriptBlock,\n        [switch]$ConvertNextTokenToBase64,\n        [int]$ChunksPerLoop = 1,\n        [bool]$EnableCompression,\n        [int]$MaximumOutputBytes,\n        [string]$PaginationProperty,\n        [string]$PropertyToRemove,\n        [string]$NextToken,\n        [switch]$SetNextTokenBeforeAdding,\n        [array]$StringReplacementRegex\n    )\n\n    $chunkedOutputArray = New-Object -TypeName 'System.Collections.ArrayList'\n\n    $outputResult = [string]::Empty\n\n    $outputTooBig = $false\n    $counter = 0\n\n    $getResultString = @{\n        EnableCompression = $EnableCompression\n        PaginationProperty = $PaginationProperty\n        StringReplacementRegex = $StringReplacementRegex\n    }\n\n    foreach ($item in (& $ScriptBlock)) {\n        if ($outputTooBig -eq $true) { break }\n\n        if ($NextToken -ne '*') {\n            if ($PaginationProperty -eq '.' -and $item -le $NextToken) {\n                continue\n            } elseif ($PaginationProperty -ne '.' -and $item.$PaginationProperty -le $NextToken) {\n                continue\n            }\n        }\n\n        if ($SetNextTokenBeforeAdding) {\n            if ($PaginationProperty -eq '.') {\n                $newNextToken = $item\n            } else {\n                $newNextToken = $item.$PaginationProperty\n            }\n        }\n\n        if ($PropertyToRemove) {\n            $item.PSObject.properties.remove($PropertyToRemove)\n        }\n\n        $null = $chunkedOutputArray.Add($item)\n\n        if ($counter -lt $ChunksPerLoop) {\n            $counter++\n            continue\n        }\n\n        $counter = 0\n\n        $properties = @{\n            Object = $chunkedOutputArray\n            Completed = $outputTooBig\n        }\n        if ($ConvertNextTokenToBase64) {\n            $properties.Add('ConvertNextTokenToBase64', $ConvertNextTokenToBase64)\n        }\n        if ($SetNextTokenBeforeAdding) {\n            $properties.Add('NextToken', $newNextToken)\n        }\n        $tempResult = GetResultAsString @properties @getResultString\n\n        if ($MaximumOutputBytes -eq 0 -or $tempResult.Length -le $MaximumOutputBytes) {\n            $outputResult = $tempResult\n        } else {\n            $outputTooBig = $true\n            break\n        }\n    }\n\n    # Processing remaining items if the output isn't too big yet\n    if ($outputTooBig -eq $false) {\n        $properties = @{\n            Object = $chunkedOutputArray\n            Completed = $outputTooBig\n            ForceEmptyNextToken = $true\n        }\n        if ($ConvertNextTokenToBase64) {\n            $properties.Add('ConvertNextTokenToBase64', $ConvertNextTokenToBase64)\n        }\n        if ($SetNextTokenBeforeAdding) {\n            $properties.Add('NextToken', $newNextToken)\n        }\n        $tempResult = GetResultAsString @getResultString @properties\n        if ($MaximumOutputBytes -eq 0 -or $tempResult.Length -le $MaximumOutputBytes) {\n            $outputResult = $tempResult\n        }\n    }\n\n    $outputResult\n}\n\n$Name = Write-Output --%{{{ Name }}}\n$Name = ParseInputParameter -Name 'Name' -Value $Name\n\n$WorkingDirectory = Write-Output --%{{{ WorkingDirectory }}}\n$WorkingDirectory = ParseInputParameter -Name 'WorkingDirectory' -Value $WorkingDirectory\n\n$PerformAction = Write-Output --%{{{ PerformAction }}}\n$PerformAction = ParseInputParameter -Name 'PerformAction' -Value $PerformAction -Regex '(Yes|No)'\nTestPerformAction -PerformAction $PerformAction\n\n# exit codes\n$INVALID_WORKING_DIRECTORY_PATH_ERROR = 201\n$FAILED_PROCESS_ERROR = 202\n$INVALID_PATH_ERROR = 203\n\n# check for base64 - input param validation\n$base64Regex = '^([A-Za-z0-9-_\\/+]{4})*([A-Za-z0-9-_\\/+]{4}|[A-Za-z0-9-_\\/+]{3}=|[A-Za-z0-9-_\\/+]{2}==)$'\n$windowsPathRegex = '^\\w:$|^\\w:\\\\[^\"''|\\r\\n]*$'\n\nif ($Name -match $base64Regex){\n    $Name = ConvertBase64ToString -Base64 $Name\n}\n\n# Name can either be a path value or a document/process name\n# verifying for the path input only (if the user has specified)\nif ($Name -match $windowsPathRegex){\n    try {$Name = (Resolve-Path -Path $Name).Path}\n    catch {ExitWithFailureMessageAndExitCode -Message \"The specified path $Name is invalid.\" -ExitCode $INVALID_PATH_ERROR -PrintJson}\n}\n\nif ($WorkingDirectory -match $base64Regex) {\n    $WorkingDirectory = ConvertBase64ToString -Base64 $WorkingDirectory\n}\n\n# check if $WorkingDirectory matches with windowsPathRegex (only if user has entered a value)\nif (-not([string]::IsNullOrWhiteSpace($WorkingDirectory))) {\n    if ($WorkingDirectory -notmatch $windowsPathRegex){\n        ExitWithFailureMessageAndExitCode -Message \"The specified working directory path $WorkingDirectory is invalid.\" -ExitCode $INVALID_PATH_ERROR -PrintJson\n    }\n    try {$WorkingDirectory = (Resolve-Path -Path $WorkingDirectory).Path}\n    catch {ExitWithFailureMessageAndExitCode -Message \"The specified working directory path $WorkingDirectory is invalid.\" -ExitCode $INVALID_PATH_ERROR -PrintJson}\n}\n\ntry{\n    if ($WorkingDirectory.length -gt 0){\n        if (Test-Path -Path $WorkingDirectory -PathType Container){\n            $app = Start-Process -FilePath $Name -WorkingDirectory $WorkingDirectory -PassThru\n        }\n        else{\n            ExitWithFailureMessageAndExitCode -Message \"Can't start the process $Name because the specified working directory is not valid.\" -ExitCode $INVALID_WORKING_DIRECTORY_PATH_ERROR -PrintJson\n        }\n    }\n    else{\n        $app = Start-Process -FilePath $Name -PassThru\n    }\n    $output = \"Process $Name has started with process Id \" + $app.Id + \".\"\n    ExitWithSuccessMessage $output -PrintJson\n}\ncatch{\n    ExitWithFailureMessageAndExitCode -Message \"Failed to start the process $Name.\" -ExitCode $FAILED_PROCESS_ERROR -PrintJson\n}\n"
        ]
      }
    },
    {
      "precondition": {
        "StringEquals": [
          "platformType",
          "Linux"
        ]
      },
      "action": "aws:runShellScript",
      "name": "InvokeLinuxScript",
      "inputs": {
        "runCommand": [
          "#!/bin/bash\nset -e\n\nif [ -f /etc/os-release ]; then\n    . /etc/os-release\n    OS_RELEASE=\"$ID${VERSION_ID:+.${VERSION_ID}}\"\nelif [ -f /etc/centos-release ]; then\n    OS_RELEASE=\"centos.$(awk '{print $3}' /etc/centos-release)\"\nelif [ -f /etc/redhat-release ]; then\n    OS_RELEASE=\"rhel.$(lsb_release -r | awk '{print $2}')\"\nfi\n\ncase \"$OS_RELEASE\" in\n    amzn.2018.03|centos.6*|debian.9|rhel.6*|ubuntu.*)\n        command_path='/bin/'\n        ;;\n    amzn.2*|centos.*|debian.*|fedora.*|rhel.*|sles*)\n        command_path='/usr/bin/'\n        ;;\n    *)\n        # Catch all without the full path for untested platforms\n        command_path=''\nesac\n\nExitWithFailureMessage() {\n    MESSAGE=\"$1\"\n    JSON=\"$2\"\n    if [[ \"$JSON\" == \"PRINT_JSON\" ]]; then\n        \"${command_path}echo\" \"{\\\"error\\\":\\\"$MESSAGE\\\"}\"\n    fi\n    WriteStandardError \"$MESSAGE\"\n    exit 1\n}\n\n# exit codes. 0-100 are reserved exit codes. 101-150 codes are for linux, 151-200 are for macos and 200 onwards codes are for windows.\nExitWithFailureMessageAndExitCode() {\n    MESSAGE=\"$1\"\n    EXITCODE=\"$2\"\n    JSON=\"$3\"\n    if [[ \"$JSON\" == \"PRINT_JSON\" ]]; then\n        \"${command_path}echo\" \"{\\\"error\\\":\\\"$MESSAGE\\\",\\\"exitCode\\\":\\\"$EXITCODE\\\"}\"\n    fi\n    WriteStandardError \"$MESSAGE\"\n    exit \"$EXITCODE\"\n}\n\nExitWithSuccessMessage() {\n    \"${command_path}echo\" \"$1\"\n    exit 0\n}\n\nWriteStandardError() {\n    MESSAGE=\"$1\"\n    (>&2 \"${command_path}echo\" \"$MESSAGE\")\n}\n\nTestPerformAction() {\n    if [[ \"$1\" != \"Yes\" ]]; then\n        ExitWithFailureMessage \"No action was taken because the PerformAction parameter is set to $1. To make the desired change, set this parameter to Yes.\"\n    fi\n}\n\nJQ=\"jq\"\nVERSION=\"1.6\"\nPRODUCT_PATH=\"/opt/amazon/ssm/fleet_manager\"\nJQ_BINARY=\"$PRODUCT_PATH/$JQ-$VERSION\"\n\nCheckSha256FileHash() {\n    FILE_PATH=\"$1\"\n    SHA256=\"$2\"\n\n    if [ -f \"$FILE_PATH\" ]; then\n        TEST=$(\"${command_path}echo\" \"$SHA256  $FILE_PATH\" | /usr/bin/sha256sum -c 2>&1) || return 1\n        return 0\n    fi\n\n    return 1\n}\n\nSetLockedDownPermissions() {\n    \"${command_path}chmod\" u+rwx \"$1\"\n    \"${command_path}chmod\" go-rwx \"$1\"\n    \"${command_path}chown\" \"$(/usr/bin/whoami)\":\"$(/usr/bin/id --group --name)\" \"$1\"\n}\n\nCreateLockedDownFolder() {\n    \"${command_path}mkdir\" -p \"$1\"\n    SetLockedDownPermissions \"$1\"\n}\n\nDownloadFile() {\n    SOURCE=\"$1\"\n    DESTINATION=\"$2\"\n    if [ -f /usr/bin/curl ]; then\n        /usr/bin/curl -s \"$SOURCE\" -o \"$DESTINATION\"\n    elif [ -f /usr/bin/wget ]; then\n        /usr/bin/wget -q \"$SOURCE\" -O \"$DESTINATION\"\n    else\n        ExitWithFailureMessage \"Unable to download the source using 'curl' or 'wget'. Failing execution.\" 'PRINT_JSON'\n    fi\n}\n\nIfRunningKernelVersion2() {\n    \"${command_path}uname\" -r | grep -q '^2\\.' || return 1\n}\n\nGetJQSHA256Hash() {\n    case \"$1\" in\n        'aarch64')\n            \"${command_path}echo\" \"a6e84e979b91b26763c700d4ba6c616554444bbbf0cf1863e96611b0e68b88f2\"\n            ;;\n        'armv6l')\n            \"${command_path}echo\" \"4717f1350a963e5ae5446e61eb21e3936754f84dd13586d494dcd6b497b267c1\"\n            ;;\n        'armv7l')\n            \"${command_path}echo\" \"e097be6c7ef954d581a359ad2d7aa4ec19c89bd3b9ab55919c826a1d30373a5c\"\n            ;;\n        'i686')\n            \"${command_path}echo\" \"062902c5a177cb80866d556a07e10331d9f8b8b676ffb1b7cd2985a9c2e539c8\"\n            ;;\n        'x86_64')\n            \"${command_path}echo\" \"15d1d1b093481c737603247a785731b7f32f3b4dccd63f77186de8bfe4f6fd68\"\n            ;;\n        'x86_64_kernel2')\n            \"${command_path}echo\" \"af986793a515d500ab2d35f8d2aecd656e764504b789b66d7e1a0b727a124c44\"\n            ;;\n        *)\n            ExitWithFailureMessage \"The CPU architecture '$1' is not supported. Failing execution.\" 'PRINT_JSON'\n            ;;\n    esac\n}\n\nRandomString() {\n    \"${command_path}cat\" /dev/urandom | /usr/bin/tr -dc 'a-zA-Z0-9' | /usr/bin/fold -w ${1:-32} | /usr/bin/head -n 1\n}\n\nInstallJQ() {\n    CreateLockedDownFolder \"$PRODUCT_PATH\"\n\n    CPU_ARCH=$(\"${command_path}uname\" -m)\n    IfRunningKernelVersion2 && CPU_ARCH=\"${CPU_ARCH}_kernel2\"\n    JQ_SHA256=$(GetJQSHA256Hash \"$CPU_ARCH\")\n\n    CheckSha256FileHash \"$JQ_BINARY\" \"$JQ_SHA256\" || {\n        JQ_TEMP_BINARY=\"$PRODUCT_PATH/$(RandomString)\"\n\n        OS_NAME=$(\"${command_path}uname\" -s)\n        REGION=\"us-east-1\"\n        S3_BUCKET=\"aws-fleet-manager-artifacts-us-east-1\"\n        S3_DNS=\"s3.us-east-1.amazonaws.com\"\n        SOURCE=\"https://$S3_BUCKET.$S3_DNS/$JQ/$VERSION/$OS_NAME/$CPU_ARCH/$JQ\"\n        DownloadFile \"$SOURCE\" \"$JQ_TEMP_BINARY\"\n\n        CheckSha256FileHash \"$JQ_TEMP_BINARY\" \"$JQ_SHA256\" || {\n            \"${command_path}rm\" --force \"$JQ_TEMP_BINARY\"\n            ExitWithFailureMessage \"Downloading the $JQ binary failed. Failing execution.\"\n        }\n\n        \"${command_path}mv\" \"$JQ_TEMP_BINARY\" \"$JQ_BINARY\"\n    }\n\n    SetLockedDownPermissions \"$JQ_BINARY\"\n}\n\nInstallJQ\n\nConvertBase64ToString() {\n    \"${command_path}echo\" \"$1\" | /usr/bin/base64 --decode\n}\n\nConvertStringToBase64() {\n    \"${command_path}echo\" \"$1\" | /usr/bin/base64 --wrap=0\n}\n\nGetBase64EncodedGzipString() {\n    \"${command_path}echo\" \"$1\" | \"${command_path}gzip\" -f --best | /usr/bin/base64 --wrap=0\n}\n\nGetResultAsString() {\n    TempString=\"$1\"\n    ItemCount=\"$2\"\n    OutputTooBig=\"$3\"\n    EnableCompression=\"$4\"\n    ForceEmptyNextToken=\"$5\"\n    ConvertToBase64=\"$6\"\n\n    nextToken='\"\"'\n    if [ \"$OutputTooBig\" == \"0\" ] && [ \"$ItemCount\" -ge 1 ] && [ \"$ForceEmptyNextToken\" != \"Yes\" ]; then\n        nextToken=$(\"${command_path}echo\" \"$TempString\" | \"$JQ_BINARY\" '.[-1].null' | \"$JQ_BINARY\" -r .)\n    fi\n\n    if [ \"$ConvertToBase64\" == \"CONVERT_NEXT_TOKEN_TO_BASE64\" ] && [ \"$nextToken\" != '\"\"' ]; then\n        nextToken=\"\\\"$(\"${command_path}echo\" \"$nextToken\" | /usr/bin/base64 --wrap=0)\\\"\"\n    fi\n\n    data=$(\"${command_path}echo\" [\"$nextToken\", \"$TempString\"] | \"$JQ_BINARY\" -c '{nextToken: .[0], results: .[1]}')\n\n    if [ \"$EnableCompression\" == \"Yes\" ]; then\n        compressed=$(GetBase64EncodedGzipString \"$data\")\n        \"$JQ_BINARY\" -n -c \"{data:\\\"$compressed\\\"}\"\n    else\n        \"${command_path}echo\" \"$data\" | \"$JQ_BINARY\" -c '{data: .}'\n    fi\n}\n\nGetMaximumOutputBytes() {\n    AllowTruncatedOutput=\"$1\"\n    MAXIMUM_OUTPUT_SIZE=2500\n\n    if [[ \"$AllowTruncatedOutput\" == 'Yes' ]]; then\n        \"${command_path}echo\" 0\n    else\n        padding=$(\"${command_path}echo\" '{\"data\":{\"nextToken\":\"\",\"results\":\"\"}}' | /usr/bin/awk '{print length}')\n        \"${command_path}echo\" \"$((MAXIMUM_OUTPUT_SIZE-padding))\"\n    fi\n}\n\nProcessItems() {\n    ITEMS=\"$1\"\n    CONVERT_TO_BASE64=\"$2\"\n\n    declare -a chunkedArray\n\n    counter=0\n    chunksPerLoop=5\n    outputTooBig=0\n\n    OIFS=\"$IFS\"\n    IFS=$'\\n'\n    for item in $(\"$JQ_BINARY\" -c '.[]' <<< \"$ITEMS\"); do\n        if [[ \"$outputTooBig\" == 1 ]]; then\n            break\n        fi\n\n        chunkedArray+=(\"$item\")\n\n        if [ \"$counter\" -lt \"$chunksPerLoop\" ]; then\n            counter=$((counter+1))\n            continue\n        fi\n\n        counter=0\n\n        tempString=$(\"$JQ_BINARY\" -c --slurp . <<< \"${chunkedArray[@]}\")\n        arrayLength=$(\"$JQ_BINARY\" '. | length' <<< \"$tempString\")\n        tempContent=$(GetResultAsString \"$tempString\" \"$arrayLength\" \"$outputTooBig\" \"$CompressOutput\" 'No' \"$CONVERT_TO_BASE64\")\n\n        tempContentLength=$(\"${command_path}echo\" \"$tempContent\" | /usr/bin/awk '{print length}')\n        if [ \"$MaximumOutputBytes\" -eq 0 ] || [ \"$tempContentLength\" -le \"$MaximumOutputBytes\" ]; then\n            outputContent=$tempContent\n        else\n            outputTooBig=1\n        fi\n    done\n    IFS=\"$OIFS\"\n\n    # If the output is not too large, processing any remaining items\n    if [ $outputTooBig -eq 0 ]; then\n        tempString=$(\"$JQ_BINARY\" -c --slurp . <<< \"${chunkedArray[@]}\")\n        arrayLength=$(\"$JQ_BINARY\" '. | length' <<< \"$tempString\")\n        tempContent=$(GetResultAsString \"$tempString\" \"$arrayLength\" \"$outputTooBig\" \"$CompressOutput\" 'Yes' \"$CONVERT_TO_BASE64\")\n\n        tempContentLength=$(\"${command_path}echo\" \"$tempContent\" | /usr/bin/awk '{print length}')\n        if [ \"$MaximumOutputBytes\" -eq 0 ] || [ \"$tempContentLength\" -le \"$MaximumOutputBytes\" ]; then\n            outputContent=\"$tempContent\"\n        fi\n    fi\n\n    \"${command_path}echo\" \"$outputContent\"\n}\n\nNAME='{{ Name }}'\nWORKINGDIRECTORY='{{ WorkingDirectory }}'\nPERFORMACTION='{{ PerformAction }}'\nTestPerformAction \"$PERFORMACTION\"\n\n# exit codes\nINVALID_WORKING_DIRECTORY_PATH_ERROR=101\nFAILED_PROCESS_ERROR=102\nINVALID_PATH_ERROR=103\n\n# input parameter validation\nbase64Regex='^(?!\\/)([A-Za-z0-9-_\\/+]{4})*([A-Za-z0-9-_\\/+]{4}|[A-Za-z0-9-_\\/+]{3}=|[A-Za-z0-9-_\\/+]{2}==)$'\nlinuxPathRegex='^\\/[^\"''|\\r\\n]*$'\n\nif [ $(\"${command_path}echo\" \"$NAME\" | \"${command_path}grep\" -P \"$base64Regex\") ]; then\n    NAME=$(ConvertBase64ToString \"$NAME\")\nfi\n\n# validation for $NAME only when user has specified a full path\nif [[ $(\"${command_path}echo\" \"$NAME\" | \"${command_path}grep\" -P \"$linuxPathRegex\") ]]; then\n    if [ ! -d \"$NAME\" ]; then\n        ExitWithFailureMessageAndExitCode \"The specified path \"$NAME\" is invalid.\" \"$INVALID_PATH_ERROR\" 'PRINT_JSON'\n    fi\nfi\n\n# checking whether user has entered a value for Working Directory (optional parameter)\nif [ \"${#WORKINGDIRECTORY}\" -gt 0 ]; then\n    if [ $(\"${command_path}echo\" \"$WORKINGDIRECTORY\" | \"${command_path}grep\" -P \"$base64Regex\") ]; then\n        WORKINGDIRECTORY=$(ConvertBase64ToString \"$WORKINGDIRECTORY\")\n    fi\n\n    if [[ ! $(\"${command_path}echo\" \"$WORKINGDIRECTORY\" | \"${command_path}grep\" -P \"$linuxPathRegex\") ]]; then\n        ExitWithFailureMessageAndExitCode \"The specified path \"$WORKINGDIRECTORY\" is invalid.\" \"$INVALID_PATH_ERROR\" 'PRINT_JSON'\n    fi\nfi\n\nif command -v \"$NAME\" >/dev/null 2>&1; then\n    if [ \"${#WORKINGDIRECTORY}\" -gt 0 ]; then\n        if [[ -d \"$WORKINGDIRECTORY\" ]]; then\n            cd \"$WORKINGDIRECTORY\" && nohup \"$NAME\" >/dev/null 2>&1 & disown\n            ExitWithSuccessMessage \"Process \"$NAME\" has started with process Id $!.\" 'PRINT_JSON'\n        else\n            ExitWithFailureMessageAndExitCode \"Can't start the process \"$Name\" because the specified working directory is not valid.\" \"$INVALID_WORKING_DIRECTORY_PATH_ERROR\" 'PRINT_JSON'\n        fi\n    else\n        nohup \"$NAME\" >/dev/null 2>&1 & disown\n        ExitWithSuccessMessage \"Process \"$NAME\" has started with process Id $!.\" 'PRINT_JSON'\n    fi\nelse\n    ExitWithFailureMessageAndExitCode \"Failed to start the process \"$NAME\".\" \"$FAILED_PROCESS_ERROR\" 'PRINT_JSON'\nfi\n"
        ]
      }
    },
    {
      "precondition": {
        "StringEquals": [
          "platformType",
          "MacOS"
        ]
      },
      "action": "aws:runShellScript",
      "name": "InvokeMacOSScript",
      "inputs": {
        "runCommand": [
          "#!/bin/bash\nset -e\n\nExitWithFailureMessage() {\n    MESSAGE=\"$1\"\n    JSON=\"$2\"\n    if [[ \"$JSON\" == \"PRINT_JSON\" ]]; then\n        /bin/echo \"{\\\"error\\\":\\\"$MESSAGE\\\"}\"\n    fi\n    WriteStandardError \"$MESSAGE\"\n    exit 1\n}\n\nExitWithSuccessMessage() {\n    /bin/echo \"$1\"\n    exit 0\n}\n\nWriteStandardError() {\n    MESSAGE=\"$1\"\n    (>&2 /bin/echo \"$MESSAGE\")\n}\n\nTestPerformAction() {\n    if [[ \"$1\" != \"Yes\" ]]; then\n        ExitWithFailureMessage \"No action was taken because the PerformAction parameter is set to $1. To make the desired change, set this parameter to Yes.\"\n    fi\n}\n\nJQ=\"jq\"\nVERSION=\"1.6\"\nPRODUCT_PATH=\"/opt/amazon/ssm/fleet_manager\"\nJQ_BINARY=\"$PRODUCT_PATH/$JQ-$VERSION\"\n\nCheckSha256FileHash() {\n    FILE_PATH=\"$1\"\n    SHA256=\"$2\"\n\n    if [ -f \"$FILE_PATH\" ]; then\n        TEST=$(/bin/echo \"$SHA256  $FILE_PATH\" | /usr/bin/shasum -c 2>&1) || return 1\n        return 0\n    fi\n\n    return 1\n}\n\nSetLockedDownPermissions() {\n    /bin/chmod u+rwx \"$1\"\n    /bin/chmod go-rwx \"$1\"\n    /usr/sbin/chown \"$(/usr/bin/whoami)\":\"$(/usr/bin/id -g -nr)\" \"$1\"\n}\n\nCreateLockedDownFolder() {\n    /bin/mkdir -p \"$1\"\n    SetLockedDownPermissions \"$1\"\n}\n\nDownloadFile() {\n    SOURCE=\"$1\"\n    DESTINATION=\"$2\"\n    /usr/bin/curl -s \"$SOURCE\" -o \"$DESTINATION\"\n}\n\nGetJQSHA256Hash() {\n    case \"$1\" in\n        'x86_64')\n            /bin/echo \"5c0a0a3ea600f302ee458b30317425dd9632d1ad8882259fcaf4e9b868b2b1ef\"\n            ;;\n        *)\n            ExitWithFailureMessage \"The CPU architecture '$1' is not supported. Failing execution.\" 'PRINT_JSON'\n            ;;\n    esac\n}\n\nRandomString() {\n    /usr/bin/openssl rand -base64 6\n}\n\nInstallJQ() {\n    CreateLockedDownFolder \"$PRODUCT_PATH\"\n\n    CPU_ARCH=$(/usr/bin/uname -m)\n    JQ_SHA256=$(GetJQSHA256Hash \"$CPU_ARCH\")\n\n    CheckSha256FileHash \"$JQ_BINARY\" \"$JQ_SHA256\" || {\n        JQ_TEMP_BINARY=\"$PRODUCT_PATH/$(RandomString)\"\n\n        OS_NAME=$(/usr/bin/uname -s)\n        REGION=\"us-east-1\"\n        S3_BUCKET=\"aws-fleet-manager-artifacts-us-east-1\"\n        S3_DNS=\"s3.us-east-1.amazonaws.com\"\n        SOURCE=\"https://$S3_BUCKET.$S3_DNS/$JQ/$VERSION/$OS_NAME/$CPU_ARCH/$JQ\"\n        DownloadFile \"$SOURCE\" \"$JQ_TEMP_BINARY\"\n\n        CheckSha256FileHash \"$JQ_TEMP_BINARY\" \"$JQ_SHA256\" || {\n            /bin/rm -f \"$JQ_TEMP_BINARY\"\n            ExitWithFailureMessage \"Downloading the $JQ binary failed. Failing execution.\"\n        }\n\n        /bin/mv \"$JQ_TEMP_BINARY\" \"$JQ_BINARY\"\n    }\n\n    SetLockedDownPermissions \"$JQ_BINARY\"\n}\n\nInstallJQ\n\nConvertBase64ToString() {\n    /bin/echo \"$1\" | /usr/bin/base64 --decode\n}\n\nConvertStringToBase64() {\n    /bin/echo \"$1\" | /usr/bin/base64\n}\n\nGetBase64EncodedGzipString() {\n    /bin/echo \"$1\" | /usr/bin/gzip -f --best | /usr/bin/base64\n}\n\nGetResultAsString() {\n    TempString=\"$1\"\n    ItemCount=\"$2\"\n    OutputTooBig=\"$3\"\n    EnableCompression=\"$4\"\n    ForceEmptyNextToken=\"$5\"\n    ConvertToBase64=\"$6\"\n\n    nextToken='\"\"'\n    if [ \"$OutputTooBig\" == \"0\" ] && [ \"$ItemCount\" -ge 1 ] && [ \"$ForceEmptyNextToken\" != \"Yes\" ]; then\n        nextToken=$(/bin/echo \"$TempString\" | \"$JQ_BINARY\" '.[-1].null' | \"$JQ_BINARY\" -r .)\n    fi\n\n    if [ \"$ConvertToBase64\" == \"CONVERT_NEXT_TOKEN_TO_BASE64\" ] && [ \"$nextToken\" != '\"\"' ]; then\n        nextToken=\"\\\"$(/bin/echo \"$nextToken\" | /usr/bin/base64)\\\"\"\n    fi\n\n    data=$(/bin/echo [\"$nextToken\", \"$TempString\"] | \"$JQ_BINARY\" -c '{nextToken: .[0], results: .[1]}')\n\n    if [ \"$EnableCompression\" == \"Yes\" ]; then\n        compressed=$(GetBase64EncodedGzipString \"$data\")\n        \"$JQ_BINARY\" -n -c \"{data:\\\"$compressed\\\"}\"\n    else\n        /bin/echo \"$data\" | \"$JQ_BINARY\" -c '{data: .}'\n    fi\n}\n\nGetMaximumOutputBytes() {\n    AllowTruncatedOutput=\"$1\"\n    MAXIMUM_OUTPUT_SIZE=2500\n\n    if [[ \"$AllowTruncatedOutput\" == 'Yes' ]]; then\n        /bin/echo 0\n    else\n        padding=$(/bin/echo '{\"data\":{\"nextToken\":\"\",\"results\":\"\"}}' | /usr/bin/awk '{print length}')\n        /bin/echo \"$((MAXIMUM_OUTPUT_SIZE-padding))\"\n    fi\n}\n\nProcessItems() {\n    ITEMS=\"$1\"\n    CONVERT_TO_BASE64=\"$2\"\n\n    declare -a chunkedArray\n\n    counter=0\n    chunksPerLoop=5\n    outputTooBig=0\n\n    OIFS=\"$IFS\"\n    IFS=$'\\n'\n    for item in $(\"$JQ_BINARY\" -c '.[]' <<< \"$ITEMS\"); do\n        if [[ \"$outputTooBig\" == 1 ]]; then\n            break\n        fi\n\n        chunkedArray+=(\"$item\")\n\n        if [ \"$counter\" -lt \"$chunksPerLoop\" ]; then\n            counter=$((counter+1))\n            continue\n        fi\n\n        counter=0\n\n        tempString=$(\"$JQ_BINARY\" -c --slurp . <<< \"${chunkedArray[@]}\")\n        arrayLength=$(\"$JQ_BINARY\" '. | length' <<< \"$tempString\")\n        tempContent=$(GetResultAsString \"$tempString\" \"$arrayLength\" \"$outputTooBig\" \"$CompressOutput\" 'No' \"$CONVERT_TO_BASE64\")\n\n        tempContentLength=$(/bin/echo \"$tempContent\" | /usr/bin/awk '{print length}')\n        if [ \"$MaximumOutputBytes\" -eq 0 ] || [ \"$tempContentLength\" -le \"$MaximumOutputBytes\" ]; then\n            outputContent=\"$tempContent\"\n        else\n            outputTooBig=1\n        fi\n    done\n    IFS=\"$OIFS\"\n\n    # If the output is not too large, processing any remaining items\n    if [ \"$outputTooBig\" -eq \"0\" ]; then\n        tempString=$(\"$JQ_BINARY\" -c --slurp . <<< \"${chunkedArray[@]}\")\n        arrayLength=$(\"$JQ_BINARY\" '. | length' <<< \"$tempString\")\n        tempContent=$(GetResultAsString \"$tempString\" \"$arrayLength\" \"$outputTooBig\" \"$CompressOutput\" 'Yes' \"$CONVERT_TO_BASE64\")\n\n        tempContentLength=$(/bin/echo \"$tempContent\" | /usr/bin/awk '{print length}')\n        if [ \"$MaximumOutputBytes\" -eq 0 ] || [ \"$tempContentLength\" -le \"$MaximumOutputBytes\" ]; then\n            outputContent=\"$tempContent\"\n        fi\n    fi\n\n    /bin/echo \"$outputContent\"\n}\n\nNAME='{{ Name }}'\nWORKINGDIRECTORY='{{ WorkingDirectory }}'\nPERFORMACTION='{{ PerformAction }}'\nTestPerformAction \"$PERFORMACTION\"\n\n# exit codes\nINVALID_WORKING_DIRECTORY_PATH_ERROR=151\nFAILED_PROCESS_ERROR=152\nINVALID_PATH_ERROR=153\n\n# input parameter validation\nbase64Regex='^(?!\\/)([A-Za-z0-9-_\\/+]{4})*([A-Za-z0-9-_\\/+]{4}|[A-Za-z0-9-_\\/+]{3}=|[A-Za-z0-9-_\\/+]{2}==)$'\npathRegex='^\\/[^\"''|\\r\\n]*$'\n\nif [ $(/bin/echo \"$NAME\" | /usr/bin/perl -ne \"print if /$base64Regex/\") ]; then\n    NAME=$(ConvertBase64ToString \"$NAME\")\nfi\n\n# validation for $NAME only when user has specified a full path\nif [[ $('/bin/echo' \"$NAME\" | /usr/bin/perl -ne \"print if /$pathRegex/\") ]]; then\n    if [ ! -d \"$NAME\" ]; then\n        ExitWithFailureMessageAndExitCode \"The specified path \"$NAME\" is invalid.\" \"$INVALID_PATH_ERROR\" 'PRINT_JSON'\n    fi\nfi\n\n# checking whether user has entered a value for Working Directory (optional parameter)\nif [ \"${#WORKINGDIRECTORY}\" -gt 0 ]; then\n    if [ $(/bin/echo \"$WORKINGDIRECTORY\" | /usr/bin/perl -ne \"print if /$base64Regex/\") ]; then\n        WORKINGDIRECTORY=$(ConvertBase64ToString \"$WORKINGDIRECTORY\")\n    fi\n\n    if [[ ! $(\"${command_path}echo\" \"$WORKINGDIRECTORY\" | \"${command_path}grep\" -P \"$pathRegex\") ]]; then\n        ExitWithFailureMessageAndExitCode \"The specified path \"$WORKINGDIRECTORY\" is invalid.\" \"$INVALID_PATH_ERROR\" 'PRINT_JSON'\n    fi\nfi\n\nif command -v \"$NAME\"; then\n    if [ \"${#WORKINGDIRECTORY}\" -gt 0 ]; then\n        if [[ -d \"$WORKINGDIRECTORY\" ]]; then\n            cd \"$WORKINGDIRECTORY\" && \"$NAME\" & disown\n            ExitWithSuccessMessage \"Process \"$NAME\" has started with process Id $!.\" 'PRINT_JSON'\n        else\n            ExitWithFailureMessageAndExitCode \"Can't start the process \"$NAME\" because the specified working directory is not valid.\" \"$INVALID_WORKING_DIRECTORY_PATH_ERROR\" 'PRINT_JSON'\n        fi\n    else\n        \"$NAME\" & disown\n        ExitWithSuccessMessage \"Process \"$NAME\" has started with process Id $!.\" 'PRINT_JSON'\n    fi\nelse\n    ExitWithFailureMessageAndExitCode \"Failed to start the process \"$NAME\".\" \"$FAILED_PROCESS_ERROR\" 'PRINT_JSON'\nfi\n"
        ]
      }
    }
  ]
}
