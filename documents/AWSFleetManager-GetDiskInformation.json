{
  "schemaVersion": "2.2",
  "description": "Retrieves disk information for the attached EBS volumes.",
  "parameters": {
    "Action": {
      "type": "String",
      "description": "(Optional) The action to perform. When ListDisks is used, lists the disk and volume information for every attached EBS volume.",
      "default": "ListDisks",
      "allowedValues": [
        "ListDisks",
        "ListAvailableDriveLetters"
      ]
    },
    "VolumeIds": {
      "type": "String",
      "description": "A comma-separated list specifying the EBS VolumeIds from which to obtain volume metadata.",
      "default": "",
      "allowedPattern": "^$|^vol-[a-z0-9]{8,17},?$|^(vol-[a-z0-9]{8,17},?){1,20}$"
    },
    "NextToken": {
      "type": "String",
      "description": "(Optional) Used for the pagination of data. To return all results, specify a value of \"*\". When used with the ListDisks action, set this value to the NextToken returned from the previous response.",
      "default": "*",
      "allowedPattern": "^\\*$|^([A-Za-z0-9-_\\/+]{4})*([A-Za-z0-9-_\\/+]{4}|[A-Za-z0-9-_\\/+]{3}=|[A-Za-z0-9-_\\/+]{2}==)$",
      "minChars": 1,
      "maxChars": 32
    },
    "AllowTruncatedOutput": {
      "type": "String",
      "description": "(Optional) Specifies whether the standard output can be truncated or not. If set to \"No\", the standard output size will be limited to stay with Systems Manager API limits. If set to \"Yes\", the standard output will not be limited.",
      "default": "Yes",
      "allowedValues": [
        "No",
        "Yes"
      ]
    },
    "CompressOutput": {
      "type": "String",
      "description": "(Optional) Defines whether output is compressed. If set to \"No\", returns a JSON string. If set to \"Yes\", returns a gzip and BASE64 encoded archive that contains the JSON string.",
      "default": "No",
      "allowedValues": [
        "No",
        "Yes"
      ]
    }
  },
  "mainSteps": [
    {
      "precondition": {
        "StringEquals": [
          "platformType",
          "Windows"
        ]
      },
      "action": "aws:runPowerShellScript",
      "name": "InvokeWindowsScript",
      "inputs": {
        "runCommand": [
          "$ErrorActionPreference = 'Stop'\n\nFunction ParseInputParameter {\n    param (\n        [string]$Name,\n        [string]$Value,\n        [string]$Regex\n    )\n\n    $ValidParameterRegex = '^--%[ +{|{].*}( +)?$'\n    if ($Value -notmatch $ValidParameterRegex) {\n        ExitWithFailureMessage -Message \"Invalid syntax for the parameter $Name\"\n    }\n    $parameterValue = $Value.Substring(3)\n\n    $trimmedParameterValue = $parameterValue.TrimStart().TrimEnd()\n    $trimmedParameterValue = $trimmedParameterValue.Substring(1)\n    $trimmedParameterValue = $trimmedParameterValue.Substring(0, $trimmedParameterValue.Length - 1)\n\n    if ($Regex -and $trimmedParameterValue -notmatch $Regex) {\n        ExitWithFailureMessage -Message \"Invalid syntax for the parameter $Name\"\n    } else {\n        $trimmedParameterValue\n    }\n}\n\nfunction ExitWithFailureMessage {\n    param (\n        [string]$Message,\n        [string]$ExceptionMessage,\n        [Switch]$PrintJson\n    )\n    if ([string]::IsNullOrWhitespace($ExceptionMessage)) {\n        $errorMessage = $Message\n    } else {\n        $errorMessage = '{0} {1}' -f $Message, $ExceptionMessage\n    }\n    if ($PrintJson) {ConvertTo-Json -InputObject @{error = $errorMessage} -Compress}\n    WriteStandardError -Message $errorMessage\n    [System.Environment]::Exit(1)\n}\n\nfunction ExitWithFailureMessageAndExitCode {\n    param (\n        [string]$Message,\n        [string]$ExceptionMessage,\n        [int]$ExitCode,\n        [Switch]$PrintJson\n    )\n    if ([string]::IsNullOrWhitespace($ExceptionMessage)) {\n        $errorMessage = $Message\n    } else {\n        $errorMessage = '{0} {1}' -f $Message, $ExceptionMessage\n    }\n    if ($PSBoundParameters.ContainsKey('ExitCode') -eq $true) {\n        $exitCode = $ExitCode\n    } else {\n        $exitCode = 1\n    }\n    if ($PrintJson) {\n        $ErrorObject = @{\n            error = $errorMessage\n            exitCode = $exitCode\n        }\n        ConvertTo-Json -InputObject $ErrorObject -Compress\n    }\n    WriteStandardError -Message $errorMessage\n    [System.Environment]::Exit($exitCode)\n}\n\nfunction ExitWithSuccessMessage {\n    param (\n        [string]$Message\n    )\n    Write-Host $Message\n    [System.Environment]::Exit(0)\n}\n\nfunction WriteStandardError {\n    param (\n        [string]$Message\n    )\n    $Host.UI.WriteErrorLine($Message)\n}\n\n$script:ResultProperty = 'results'\n$script:DataProperty = 'data'\n$script:NextTokenProperty = 'nextToken'\n\nfunction ConvertBase64ToString {\n    param (\n        [string]$Base64\n    )\n    $bytes = [System.Convert]::FromBase64String($Base64)\n    [System.Text.Encoding]::UTF8.GetString($bytes)\n}\n\nfunction ConvertStringToBase64 {\n    param (\n        [string]$String\n    )\n    $bytes = [System.Text.Encoding]::UTF8.GetBytes($String)\n    [System.Convert]::ToBase64String($bytes)\n}\n\nfunction GetCompressionBoolean {\n    param (\n        [ValidateSet('No','Yes')]\n        [string]$CompressOutput\n    )\n    if ($CompressOutput -eq 'Yes') {\n        $true\n    } else {\n        $false\n    }\n}\n\nfunction GetJson {\n    param ($InputObject)\n    ConvertTo-Json -InputObject $InputObject -Compress -Depth 5\n}\n\nfunction GetBase64EncodedGzipString {\n    param ($InputString)\n\n    $inputBytes = [System.Text.Encoding]::UTF8.GetBytes($InputString)\n\n    try {\n        $memoryStream = New-Object -TypeName 'System.IO.MemoryStream'\n        $compressionMode = [System.IO.Compression.CompressionMode]::Compress\n        $gzipStream = New-Object -TypeName 'System.IO.Compression.GzipStream' -ArgumentList @($memoryStream, $compressionMode)\n\n        $gzipStream.Write($inputBytes, 0, $inputBytes.Length)\n        $gzipStream.Close()\n        $memoryStream.Close()\n\n        [System.Convert]::ToBase64String($memoryStream.ToArray())\n    } finally {\n        $gzipStream.Dispose()\n        $memoryStream.Dispose()\n    }\n}\n\nfunction GetResultAsString {\n    param (\n        [PSObject]$Object,\n        [bool]$Completed,\n        [switch]$ConvertNextTokenToBase64,\n        [bool]$EnableCompression,\n        [bool]$ForceEmptyNextToken,\n        [string]$NextToken,\n        [string]$PaginationProperty,\n        [array]$StringReplacementRegex\n    )\n\n    if ([string]::IsNullOrWhiteSpace($NextToken)) {\n        if ($Completed -eq $false -and $Object.Count -ge 1 -and $ForceEmptyNextToken -ne $true) {\n            if ($PaginationProperty -eq '.') {\n                $NextToken = $Object[-1]\n            } else {\n                $NextToken = $Object[-1].$PaginationProperty\n            }\n        }\n    }\n\n    if ($ForceEmptyNextToken) {\n        $NextToken = [string]::Empty\n    } elseif ($ConvertNextTokenToBase64) {\n        $NextToken = ConvertStringToBase64 -String $NextToken\n    }\n\n    $data = @{\n        $script:ResultProperty    = $Object\n        $script:NextTokenProperty = $NextToken\n    }\n\n    if ($EnableCompression -eq $true) {\n        $string = GetJson -InputObject $data\n\n        if ($StringReplacementRegex.Count -eq 2) {\n            $string = $string -replace $StringReplacementRegex\n        }\n\n        $data = GetBase64EncodedGzipString -InputString $string\n    }\n\n    $output = GetJson -InputObject @{\n        $script:DataProperty = $data\n    }\n    if ($StringReplacementRegex.Count -eq 2) {\n        $output -replace $StringReplacementRegex\n    } else {\n        $output\n    }\n}\n\nfunction GetMaximumOutputBytes {\n    param (\n        $AllowTruncatedOutput,\n        [int]$MaximumOutputSize = 2500\n    )\n    if ($AllowTruncatedOutput -eq 'Yes') {\n        0\n    } else {\n        $padding = (GetResultAsString -Object @() -Completed $false -EnableCompression $false).length\n        $MaximumOutputSize - $padding\n    }\n}\n\nfunction ProcessItems {\n    param (\n        [scriptblock]$ScriptBlock,\n        [switch]$ConvertNextTokenToBase64,\n        [int]$ChunksPerLoop = 1,\n        [bool]$EnableCompression,\n        [int]$MaximumOutputBytes,\n        [string]$PaginationProperty,\n        [string]$PropertyToRemove,\n        [string]$NextToken,\n        [switch]$SetNextTokenBeforeAdding,\n        [array]$StringReplacementRegex\n    )\n\n    $chunkedOutputArray = New-Object -TypeName 'System.Collections.ArrayList'\n\n    $outputResult = [string]::Empty\n\n    $outputTooBig = $false\n    $counter = 0\n\n    $getResultString = @{\n        EnableCompression = $EnableCompression\n        PaginationProperty = $PaginationProperty\n        StringReplacementRegex = $StringReplacementRegex\n    }\n\n    foreach ($item in (& $ScriptBlock)) {\n        if ($outputTooBig -eq $true) { break }\n\n        if ($NextToken -ne '*') {\n            if ($PaginationProperty -eq '.' -and $item -le $NextToken) {\n                continue\n            } elseif ($PaginationProperty -ne '.' -and $item.$PaginationProperty -le $NextToken) {\n                continue\n            }\n        }\n\n        if ($SetNextTokenBeforeAdding) {\n            if ($PaginationProperty -eq '.') {\n                $newNextToken = $item\n            } else {\n                $newNextToken = $item.$PaginationProperty\n            }\n        }\n\n        if ($PropertyToRemove) {\n            $item.PSObject.properties.remove($PropertyToRemove)\n        }\n\n        $null = $chunkedOutputArray.Add($item)\n\n        if ($counter -lt $ChunksPerLoop) {\n            $counter++\n            continue\n        }\n\n        $counter = 0\n\n        $properties = @{\n            Object = $chunkedOutputArray\n            Completed = $outputTooBig\n        }\n        if ($ConvertNextTokenToBase64) {\n            $properties.Add('ConvertNextTokenToBase64', $ConvertNextTokenToBase64)\n        }\n        if ($SetNextTokenBeforeAdding) {\n            $properties.Add('NextToken', $newNextToken)\n        }\n        $tempResult = GetResultAsString @properties @getResultString\n\n        if ($MaximumOutputBytes -eq 0 -or $tempResult.Length -le $MaximumOutputBytes) {\n            $outputResult = $tempResult\n        } else {\n            $outputTooBig = $true\n            break\n        }\n    }\n\n    # Processing remaining items if the output isn't too big yet\n    if ($outputTooBig -eq $false) {\n        $properties = @{\n            Object = $chunkedOutputArray\n            Completed = $outputTooBig\n            ForceEmptyNextToken = $true\n        }\n        if ($ConvertNextTokenToBase64) {\n            $properties.Add('ConvertNextTokenToBase64', $ConvertNextTokenToBase64)\n        }\n        if ($SetNextTokenBeforeAdding) {\n            $properties.Add('NextToken', $newNextToken)\n        }\n        $tempResult = GetResultAsString @getResultString @properties\n        if ($MaximumOutputBytes -eq 0 -or $tempResult.Length -le $MaximumOutputBytes) {\n            $outputResult = $tempResult\n        }\n    }\n\n    $outputResult\n}\n\n$Action = Write-Output --%{{{ Action }}}\n$Action = ParseInputParameter -Name 'Action' -Value $Action\n\n$VolumeIds = Write-Output --%{{{ VolumeIds }}}\n$VolumeIds = ParseInputParameter -Name 'VolumeIds' -Value $VolumeIds\n\n$NextToken = Write-Output --%{{{ NextToken }}}\n$NextToken = ParseInputParameter -Name 'NextToken' -Value $NextToken\n\n$AllowTruncatedOutput = Write-Output --%{{{ AllowTruncatedOutput }}}\n$AllowTruncatedOutput = ParseInputParameter -Name 'AllowTruncatedOutput' -Value $AllowTruncatedOutput -Regex '(Yes|No)'\n\n$CompressOutput = Write-Output --%{{{ CompressOutput }}}\n$CompressOutput = ParseInputParameter -Name 'CompressOutput' -Value $CompressOutput -Regex '(Yes|No)'\n\nif ($NextToken -ne '*') {\n    try {\n        $NextToken = ConvertBase64ToString -Base64 $NextToken\n    } catch {\n        ExitWithFailureMessage -Message 'The specified NextToken is invalid.' -PrintJson\n    }\n}\n\n$enableCompression = GetCompressionBoolean -CompressOutput $CompressOutput\n$maximumOutputBytes = GetMaximumOutputBytes -AllowTruncatedOutput $AllowTruncatedOutput\n\n$DEVICE_NAME_PATTERN = '^(xvd[a-z])|(\\/dev\\/sda1)|(vol\\.)|(AWS\\.)'\n$EBS_VOLUME_MATCH = '(?<=vol)[0-9a-zA-Z]*(?= *_)'\n$EBS_VOLUME_MATCH2 = '(?<=vol)(.*)'\n\nfunction TestValidVolumeId {\n    param([string]$VolumeId)\n    if ($VolumeId -match $DEVICE_NAME_PATTERN) {\n        return $true\n    }\n    if ($VolumeId.StartsWith('AWS') -or $VolumeId.StartsWith('vol')) {\n        return $true\n    }\n    return $false\n}\n\n# An unknown error occurred.\n$UKNOWN_ERROR = 1\n# A given device name is invalid or malformed, e.g. `vol-<abcd>`.\n$INVALID_DEVICE_NAME = 2\n# No EBS volume exists that is attached with a given DeviceId.\n$PHYSICAL_DISK_NOT_EXIST = 3\n\nswitch ($Action) {\n    'ListDisks' {\n        [scriptblock]$scriptblock = {\n            $volumeIdsToProcess = $VolumeIds.split(',') | Sort-Object\n\n            # Get a list of the physical disks that match the VolumeIds (if provided), and sort them by DeviceId\n            if ($volumeIdsToProcess) {\n                $physicalDisksToProcess = foreach ($volumeId in $volumeIdsToProcess) {\n                    if ((TestValidVolumeId -VolumeId $volumeId) -eq $false) {\n                        ExitWithFailureMessageCustomExitCode -Message \"Volume name $volumeId is invalid\" -ExitCode $INVALID_DEVICE_NAME -PrintJson\n                    }\n                    if ($volumeId.StartsWith('vol-')) {\n                        $volumeId = \"$($volumeId.Substring(0, 3))$($volumeId.Substring(4))\"\n                        $physicalDisk = Get-PhysicalDisk | Where-Object { $_.SerialNumber.StartsWith($volumeId) }\n                    } else {\n                        $physicalDisk = Get-PhysicalDisk -UniqueId $volumeId -ErrorAction SilentlyContinue\n                    }\n                    if (-not $physicalDisk) {\n                        ExitWithFailureMessageCustomExitCode -Message \"No Physical Disk exists matching the name '$volumeId'.\" -ExitCode $PHYSICAL_DISK_NOT_EXIST -PrintJson\n                    }\n                    $physicalDisk\n                }\n                $physicalDisksToProcess = $physicalDisksToProcess | Sort-Object -Property DeviceId\n            } else {\n                $physicalDisksToProcess = Get-PhysicalDisk | Sort-Object -Property DeviceId | ForEach-Object {\n                    if (TestValidVolumeId -VolumeId $_.UniqueId) {\n                        $_\n                    }\n                }\n            }\n\n            # Process the physical disks to generate the SSM Document output\n            $diskProperties = @(\n                'PartitionStyle'\n                'ProvisioningType'\n                'OperationalStatus'\n                'HealthStatus',\n                'BootFromDisk'\n                'IsBoot'\n                'IsClustered'\n                'IsReadOnly'\n                'IsSystem'\n                'NumberOfPartitions'\n                'UniqueId'\n            )\n            foreach ($pd in $physicalDisksToProcess) {\n                try {\n                    $deviceId = $pd | Select-Object -ExpandProperty DeviceId\n\n                    # Search for logical disks\n                    $logicalDiskList = New-Object -TypeName 'System.Collections.Generic.List[PSCustomObject]'\n                    Get-Disk -Number $deviceId -ErrorAction SilentlyContinue | ForEach-Object {\n                        $logicalDiskList.Add(($_ | Select-Object $diskProperties))\n                    }\n\n                    # Search for volumes\n                    $volumeList = New-Object -TypeName 'System.Collections.Generic.List[PSCustomObject]'\n                    Get-Partition -DiskNumber $deviceId -ErrorAction SilentlyContinue | Where-Object { $_.Type -NE \"Reserved\" } | ForEach-Object {\n                        $mountPath = ''\n                        $vol = Get-Volume -Partition $_ -ErrorAction SilentlyContinue\n\n                        # Identify the mount path (as a DriveLetter or an AccessPath)\n                        if ($vol.DriveLetter) {\n                            $mountPath = $vol.DriveLetter\n                        } elseif ($_.AccessPaths | Where-Object { $_ -like '?:*' }) {\n                            $mountPath = $_.AccessPaths | Where-Object { $_ -like '?:*' } | Select-Object -First 1\n                        }\n\n                        $volumeList.Add([PSCustomObject]@{\n                                PartitionNumber = $_.PartitionNumber\n                                HealthStatus    = $vol.HealthStatus\n                                DriveType       = $vol.DriveType\n                                MountPath       = $mountPath\n                                FileSystem      = $vol.FileSystem\n                                FileSystemLabel = $vol.FileSystemLabel\n                                ObjectId        = $vol.ObjectId\n                                Path            = $vol.Path\n                                Offset          = $_.Offset\n                                Size            = $vol.Size\n                                SizeRemaining   = $vol.SizeRemaining\n                            })\n                    }\n\n                    # Turn the physical disk serial number back into an EBS VolumeId\n                    $volumeNumber = $pd.SerialNumber | Select-String $EBS_VOLUME_MATCH | ForEach-Object { $_.Matches.Value }\n                    if ($null -eq $volumeNumber) {\n                        $volumeNumber = $pd.SerialNumber | Select-String $EBS_VOLUME_MATCH2 | ForEach-Object { $_.Matches.Value }\n                    }\n                    $ebsVolumeId = \"vol-$volumeNumber\"\n\n                    [PSCustomObject][ordered]@{\n                        VolumeId     = $ebsVolumeId\n                        DeviceId     = $pd.DeviceId\n                        PhysicalDisk = @{\n                            DeviceId          = $pd.DeviceId\n                            SerialNumber      = $pd.SerialNumber\n                            HealthStatus      = $pd.HealthStatus\n                            OperationalStatus = $pd.OperationalStatus\n                            CanPool           = $pd.CanPool\n                            CannotPoolReason  = $pd.CannotPoolReason\n                        }\n                        LogicalDisks = $logicalDiskList.ToArray()\n                        Volumes      = $volumeList.ToArray()\n                    }\n                } catch {\n                    ExitWithFailureMessageCustomExitCode -Message \"Unknown error occurred while attempting to fetch volume metadata for the specified devices.\" -ExitCode $UKNOWN_ERROR -PrintJson\n                }\n            }\n        }\n\n        $processItems = @{\n            ScriptBlock              = $scriptblock\n            ConvertNextTokenToBase64 = $true\n            ChunksPerLoop            = 1\n            EnableCompression        = $enableCompression\n            MaximumOutputBytes       = $maximumOutputBytes\n            NextToken                = $NextToken\n            PaginationProperty       = 'DeviceId'\n            SetNextTokenBeforeAdding = $true\n        }\n    }\n\n    'ListAvailableDriveLetters' {\n        [scriptblock]$scriptblock = {\n            try {\n                $AllLetters = 65..90 | ForEach-Object { [char]$_ }\n                $UsedLetters = (Get-CimInstance Win32_LogicalDisk | Select-Object -ExpandProperty DeviceId).Replace(':', '')\n                $AllLetters | Where-Object { $UsedLetters -notcontains $_ }\n            } catch {\n                ExitWithFailureMessageCustomExitCode -Message 'An unknown error occurred while attempting to fetch available drive letters.' -ExitCode $UKNOWN_ERROR -PrintJson\n            }\n        }\n        $processItems = @{\n            ScriptBlock              = $scriptblock\n            ConvertNextTokenToBase64 = $true\n            ChunksPerLoop            = 1\n            EnableCompression        = $enableCompression\n            MaximumOutputBytes       = $maximumOutputBytes\n            NextToken                = $NextToken\n        }\n    }\n}\n\nProcessItems @processItems\n"
        ]
      }
    }
  ]
}
