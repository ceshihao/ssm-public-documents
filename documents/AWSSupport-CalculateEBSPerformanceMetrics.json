{
  "description": "The **AWSSupport-CalculateEBSPerformanceMetrics** runbook helps diagnose Amazon Elastic Block Store (Amazon EBS) performance issues by calculating and publishing performance metrics to an Amazon CloudWatch dashboard. The dashboard displays the estimated average IOPS and throughput for a target Amazon EBS volume or all the volumes attached to the target Amazon Elastic Compute Cloud (Amazon EC2) instance. For EC2 instances, it also shows the instance's average IOPS and throughput. The runbook outputs the link to the newly created Amazon CloudWatch dashboard that displays the relevant calculated Amazon CloudWatch metrics. The Amazon CloudWatch dashboard is created in your account with the name: `AWSSupport-<ResourceId>-EBS-Performance-<automation:EXECUTION_ID>`. The runbook requires the following permissions: `ec2:DescribeVolumes`, `ec2:DescribeInstances`, `ec2:DescribeInstanceTypes`, and `cloudwatch:PutDashboard`.\n\n#### Important:\n> * The creation of custom metrics and the CloudWatch dashboard may result in your account incurring additional costs. For more information see [Amazon CloudWatch pricing guide](https://aws.amazon.com/cloudwatch/pricing).",
  "schemaVersion": "0.3",
  "assumeRole": "{{ AutomationAssumeRole }}",
  "parameters": {
    "AutomationAssumeRole": {
      "type": "AWS::IAM::Role::Arn",
      "description": "(Optional) The Amazon Resource Name (ARN) of the AWS Identity and Access Management (IAM) role that allows Systems Manager Automation to perform the actions on your behalf. If no role is specified, Systems Manager Automation uses the permissions of the user that starts this runbook.",
      "allowedPattern": "^$|^arn:(aws|aws-cn|aws-us-gov|aws-iso|aws-iso-b):iam::[0-9]{12,13}:role/.*$",
      "default": ""
    },
    "ResourceId": {
      "type": "String",
      "description": "(Required) The ID of the EC2 Instance or EBS Volume.",
      "allowedPattern": "^i-[a-z0-9]{8,17}$|^vol-[a-z0-9]{8,17}$"
    },
    "StartTime": {
      "type": "String",
      "description": "(Required) The start time to view the data in CloudWatch. The time must be in the format `yyyy-mm-ddThh:mm:ss` and in UTC.",
      "allowedPattern": "^[0-9]{4}-[0-9]{2}-[0-9]{2}T[0-9]{2}:[0-9]{2}:[0-9]{2}$"
    },
    "EndTime": {
      "type": "String",
      "description": "(Required) The end time to view the data in CloudWatch. The time must be in the format `yyyy-mm-ddThh:mm:ss` and in UTC.",
      "allowedPattern": "^[0-9]{4}-[0-9]{2}-[0-9]{2}T[0-9]{2}:[0-9]{2}:[0-9]{2}$"
    }
  },
  "mainSteps": [
    {
      "name": "CheckResourceIdAndTimeStamps",
      "description": "Checks if the target resource specified in `ResourceId` exists, and the timestamps specified in `StartTime` and `EndTime` are valid.",
      "action": "aws:executeScript",
      "onFailure": "Abort",
      "isCritical": true,
      "nextStep": "CreateCloudWatchDashboard",
      "inputs": {
        "Runtime": "python3.8",
        "Handler": "validate_parameters",
        "Script": "# Copyright 2023 Amazon.com, Inc. or its affiliates. All Rights Reserved\n# SPDX-License-Identifier: LicenseRef-.amazon.com.-AmznSL-1.0\n# Licensed under the Amazon Software License  http://aws.amazon.com/asl/\n\nfrom datetime import datetime\n\nimport boto3\nfrom botocore.errorfactory import ClientError\n\nec2_client = boto3.client(\"ec2\")\n\n\ndef validate_parameters(event, context):\n    start_time = event[\"start_time\"]\n    end_time = event[\"end_time\"]\n    resource_id = event[\"resource_id\"]\n    timestamp_validation(start_time, end_time)\n    resource_validation(resource_id)\n\n\ndef timestamp_validation(start_time, end_time):\n    try:\n        t1 = datetime.strptime(start_time, \"%Y-%m-%dT%H:%M:%S\")\n        t2 = datetime.strptime(end_time, \"%Y-%m-%dT%H:%M:%S\")\n        diff_minutes = (t2 - t1).total_seconds() / 60\n        if diff_minutes > 0 and diff_minutes < 1:\n            raise ValueError(\n                f\"[ERROR] The 'EndTime' ({t1}) should be at least 1 minute greater than 'StartTime' ({t2})\"\n            )\n        elif diff_minutes <= 0:\n            raise ValueError(f\"[ERROR] The 'StartTime' ({t1}) should not be greater or equal than 'EndTime' ({t2})\")\n        else:\n            print(\"[INFO] 'StartTime' and 'EndTime' timestamps are valid.\")\n\n    except Exception as e:\n        raise ValueError(f\"[ERROR] An error occurred when trying to validate the input parameters: {str(e)}\") from None\n\n\ndef resource_validation(resource_id):\n    try:\n        if resource_id.startswith(\"vol-\"):\n            ec2_client.describe_volumes(VolumeIds=[resource_id])\n        elif resource_id.startswith(\"i-\"):\n            ec2_client.describe_instances(InstanceIds=[resource_id])\n        else:\n            raise ValueError(f\"[ERROR] The resource ID is not a valid EBS volume or EC2 instance: {resource_id}\")\n\n    except ClientError as error:\n        raise ValueError(\n            f\"[ERROR] An error occurred when describing the target resource {resource_id} - {str(error)}\"\n        ) from None\n\n    print(f\"[INFO] Resource ID {resource_id} is valid.\")\n",
        "InputPayload": {
          "resource_id": "{{ ResourceId }}",
          "start_time": "{{ StartTime }}",
          "end_time": "{{ EndTime }}"
        }
      }
    },
    {
      "name": "CreateCloudWatchDashboard",
      "description": "Calculates the performance metrics and creates the Amazon CloudWatch dashboard.",
      "action": "aws:executeScript",
      "isCritical": true,
      "isEnd": true,
      "onFailure": "Abort",
      "inputs": {
        "Runtime": "python3.8",
        "Handler": "create_dashboard",
        "Script": "# Copyright 2023 Amazon.com, Inc. or its affiliates. All Rights Reserved\n# SPDX-License-Identifier: LicenseRef-.amazon.com.-AmznSL-1.0\n# Licensed under the Amazon Software License  http://aws.amazon.com/asl/\n\nimport datetime\nimport json\nimport sys\nfrom typing import Any, List\n\nimport boto3\nfrom botocore.errorfactory import ClientError\n\n\n# calculate period based on the start_time\ndef get_period_value(start_time):\n    if (datetime.datetime.today() - start_time).days < 15:\n        # Data points with a period of 60 seconds are available for 15 days\n        period = 60\n    elif (datetime.datetime.today() - start_time).days < 63:\n        # 300 seconds are available for 63 days\n        period = 300\n    else:\n        # 3600 seconds are available for 455 days\n        period = 3600\n\n    return period\n\n\n# get all the attached volumes to an EC2\ndef get_attached_volumes(instance_id, ec2_client):\n    try:\n        describe_volumes_op = ec2_client.describe_volumes(\n            Filters=[{\"Name\": \"attachment.instance-id\", \"Values\": [instance_id]}]\n        )\n\n        return [vol[\"VolumeId\"] for vol in describe_volumes_op[\"Volumes\"]]\n    except ClientError as error:\n        raise RuntimeError(\n            f\"[ERROR] An error ocurred when trying to describe the volumes attached to the instance - {str(error)}.\"\n        ) from None\n\n\n# returns volume details like size and type\ndef get_volume_details(vol_id, ec2_client):\n    try:\n        response = ec2_client.describe_volumes(VolumeIds=[vol_id])\n\n        return {\"vol_size\": response[\"Volumes\"][0][\"Size\"], \"vol_type\": response[\"Volumes\"][0][\"VolumeType\"]}\n    except ClientError as error:\n        raise RuntimeError(f\"[ERROR] An error ocurred when trying to describe the volume {str(error)}.\") from None\n\n\n# calculates gp2 limits\ndef calculate_gp2_limits(vol_size):\n    # Baseline performance of 3 IOPS/GB (minimum 100 IOPS) to a maximum of 16,000 IOPS\n    baseline_iops = min(max(3 * vol_size, 100), 16000)\n\n    # Throughput for volumes less than 170 will be maxed out at 128 mb/s else 250 mb/s\n    max_burst_throughput = 128 if vol_size < 170 else 250\n    baseline_throughput = min(baseline_iops / 4, max_burst_throughput)\n\n    # check if burstable or not\n    burstable_iops = 3000 if baseline_iops < 3000 else -1\n\n    if burstable_iops < 0:\n        return {\"iops\": baseline_iops, \"throughput\": baseline_throughput}\n    else:\n        return {\n            \"iops\": baseline_iops,\n            \"max_iops\": burstable_iops,\n            \"throughput\": baseline_throughput,\n            \"max_throughput\": max_burst_throughput,\n        }\n\n\n# calculates gp3 limits\ndef calculate_gp3_limits(volume_id, ec2_client):\n    try:\n        response = ec2_client.describe_volumes(VolumeIds=[volume_id])\n\n        return {\"iops\": response[\"Volumes\"][0][\"Iops\"], \"throughput\": response[\"Volumes\"][0][\"Throughput\"]}\n    except ClientError as error:\n        raise RuntimeError(f\"[ERROR] An error ocurred when trying to describe the volume - {str(error)}.\") from None\n\n\n# calculates io1 and io2 limits\ndef calculate_io_limits(volume_id, ec2_client):\n    try:\n        response = ec2_client.describe_volumes(VolumeIds=[volume_id])\n\n        iops = response[\"Volumes\"][0][\"Iops\"]\n\n        if iops <= 32000:\n            return {\"iops\": iops, \"throughput\": min(iops / 4, 500)}\n        else:\n            return {\"iops\": iops, \"throughput\": min(iops / 64, 1000)}\n    except ClientError as error:\n        raise RuntimeError(f\"[ERROR] An error ocurred when trying to describe the volume - {str(error)}.\") from None\n\n\n# calculates st1 limits\ndef calculate_st1_limits(vol_size):\n    # throughput\n    burstable_throughput = round(min(vol_size * 250 / 1024, 500))\n    baseline_throughput = round(min(vol_size * 40 / 1024, 500), 1)\n    # Iops\n    burstable_iops = burstable_throughput\n    baseline_iops = baseline_throughput\n\n    if baseline_throughput < 500:\n        return {\n            \"iops\": baseline_iops,\n            \"throughput\": baseline_throughput,\n            \"max_iops\": burstable_iops,\n            \"max_throughput\": burstable_throughput,\n        }\n    else:\n        return {\"iops\": baseline_iops, \"throughput\": baseline_throughput}\n\n\n# calculates sc1 limits\ndef calculate_sc1_limits(vol_size):\n    # throughput\n    burstable_throughput = round(min(vol_size * 80 / 1024, 250))\n    baseline_throughput = round(min(vol_size * 12 / 1024, 250), 1)\n    # iops\n    burstable_iops = burstable_throughput\n    baseline_iops = baseline_throughput\n\n    return {\n        \"iops\": baseline_iops,\n        \"throughput\": baseline_throughput,\n        \"max_iops\": burstable_iops,\n        \"max_throughput\": burstable_throughput,\n    }\n\n\n# get the limits of EC2 instance\ndef get_ec2_info(instance_id, ec2_client):\n    try:\n        describe_instances_op = ec2_client.describe_instances(InstanceIds=[instance_id])\n        instance_class = describe_instances_op[\"Reservations\"][0][\"Instances\"][0][\"InstanceType\"]\n        ebs_optimized = describe_instances_op[\"Reservations\"][0][\"Instances\"][0][\"EbsOptimized\"]\n\n        return {\"instance_class\": instance_class, \"ebs_optimized\": ebs_optimized}\n    except ClientError as error:\n        raise RuntimeError(f\"[ERROR] An error ocurred when trying to describe the instance - {str(error)}.\") from None\n\n\ndef get_ec2_annotations(ec2_client, metric_type, ec2_info):\n    annotations = []\n\n    instance_type_info = ec2_client.describe_instance_types(\n        InstanceTypes=[ec2_info[\"instance_class\"]],\n        Filters=[{\"Name\": \"ebs-info.ebs-optimized-support\", \"Values\": [\"supported\", \"default\"]}],\n    )\n\n    if ec2_info[\"ebs_optimized\"]:\n        baseline_iops = instance_type_info[\"InstanceTypes\"][0][\"EbsInfo\"][\"EbsOptimizedInfo\"][\"BaselineIops\"]\n        maximum_iops = instance_type_info[\"InstanceTypes\"][0][\"EbsInfo\"][\"EbsOptimizedInfo\"][\"MaximumIops\"]\n        baseline_throughput = instance_type_info[\"InstanceTypes\"][0][\"EbsInfo\"][\"EbsOptimizedInfo\"][\n            \"BaselineThroughputInMBps\"\n        ]\n        maximum_throughput = instance_type_info[\"InstanceTypes\"][0][\"EbsInfo\"][\"EbsOptimizedInfo\"][\n            \"MaximumThroughputInMBps\"\n        ]\n\n        if metric_type == \"iops\":\n            # if baseline is same as maximum\n            if baseline_iops == maximum_iops:\n                annotations = [{\"label\": \"Maximum IOPS\", \"value\": maximum_iops}]\n            else:\n                annotations = [\n                    {\n                        \"label\": \"Baseline IOPS\",\n                        \"value\": baseline_iops,\n                    },\n                    {\"label\": \"Maximum IOPS\", \"value\": maximum_iops},\n                ]\n        else:\n            # if baseline is same as maximum\n            if baseline_throughput == maximum_throughput:\n                annotations = [{\"label\": \"Maximum Throughput (Mib/s)\", \"value\": maximum_throughput}]\n            else:\n                annotations = [\n                    {\n                        \"label\": \"Baseline Throughput (Mib/s)\",\n                        \"value\": baseline_throughput,\n                    },\n                    {\"label\": \"Maximum Throughput (Mib/s)\", \"value\": maximum_throughput},\n                ]\n\n    return {\"horizontal\": annotations}\n\n\n# generates volume annotations for throughput and iops\ndef get_volume_annotations(ec2_client, metric_type, vol_type, vol_id, vol_size):\n    annotations = []\n    if vol_type == \"gp2\":\n        vol_limits = calculate_gp2_limits(vol_size)\n    elif vol_type == \"gp3\":\n        vol_limits = calculate_gp3_limits(vol_id, ec2_client)\n    elif vol_type[:-1] == \"io\":\n        vol_limits = calculate_io_limits(vol_id, ec2_client)\n    elif vol_type == \"st1\":\n        vol_limits = calculate_st1_limits(vol_size)\n    elif vol_type == \"sc1\":\n        vol_limits = calculate_sc1_limits(vol_size)\n    else:\n        print(f\"[ERROR] Unsupported volume type: {vol_type}\")\n        sys.exit(1)\n\n    if metric_type == \"throughput\":\n        if vol_type in [\"io1\", \"io2\", \"gp3\"]:\n            annotations = [\n                {\"label\": \"Baseline/Maximum Throughput (MB/s)\", \"value\": vol_limits[\"throughput\"]},\n            ]\n        else:\n            if vol_limits.get(\"max_throughput\"):\n                annotations = [\n                    {\"label\": \"Baseline Throughput (MB/s)\", \"value\": vol_limits[\"throughput\"]},\n                    {\"label\": \"Maximum Throughput (MB/s)\", \"value\": vol_limits[\"max_throughput\"]},\n                ]\n            else:\n                annotations = [{\"label\": \"Baseline/Maximum Throughput (MB/s)\", \"value\": vol_limits[\"throughput\"]}]\n    elif metric_type == \"iops\":\n        if vol_type in [\"io1\", \"io2\", \"gp3\"]:\n            annotations = [{\"label\": \"Baseline/Maximum IOPS\", \"value\": vol_limits[\"iops\"]}]\n        else:\n            if vol_limits.get(\"max_iops\"):\n                annotations = [\n                    {\"label\": \"Baseline IOPS\", \"value\": vol_limits[\"iops\"]},\n                    {\"label\": \"Maximum IOPS\", \"value\": vol_limits[\"max_iops\"]},\n                ]\n            else:\n                annotations = [{\"label\": \"Baseline/Maximum IOPS\", \"value\": vol_limits[\"iops\"]}]\n\n    return {\"horizontal\": annotations}\n\n\n# creates volume level widgets per volume\ndef create_volume_widget(\n    region, vol_id, vol_details, period, start_time, end_time, ec2_client, metric_counter=0, y_no=5\n):\n    metrics_req = [\n        \"VolumeIdleTime\",\n        \"VolumeReadOps\",\n        \"VolumeWriteOps\",\n        \"VolumeReadBytes\",\n        \"VolumeWriteBytes\",\n        \"BurstBalance\",\n    ]\n    is_burstable = True if vol_details[\"vol_type\"] in [\"gp2\", \"st1\", \"sc1\"] else False\n\n    if metric_counter == 0:\n        metrics_numbrs = {metrics_req[i]: f\"m{i + 1}\" for i in range(len(metrics_req))}\n        exprs = {\"avg_iops\": \"e1\", \"avg_throughput\": \"e2\"}\n    else:\n        metric_increment = (len(metrics_req) * metric_counter) + 1\n        metrics_numbrs = {metrics_req[i]: f\"m{i + metric_increment}\" for i in range(len(metrics_req))}\n        exprs_increment = 2 * metric_counter\n        exprs = {\"avg_iops\": f\"e{exprs_increment + 1}\", \"avg_throughput\": f\"e{exprs_increment + 2}\"}\n\n    throughput_annotations = get_volume_annotations(\n        ec2_client, \"throughput\", vol_details[\"vol_type\"], vol_id, vol_details[\"vol_size\"]\n    )\n    iops_annotations = get_volume_annotations(\n        ec2_client, \"iops\", vol_details[\"vol_type\"], vol_id, vol_details[\"vol_size\"]\n    )\n\n    return [\n        {\n            \"type\": \"text\",\n            \"height\": 1,\n            \"width\": 24,\n            \"y\": y_no + (metric_counter * 10),\n            \"x\": 0,\n            \"properties\": {\n                \"markdown\": f\"### Volume: {vol_id} | Type: {vol_details['vol_type']}\",\n                \"background\": \"transparent\",\n            },\n        },\n        {\n            \"type\": \"metric\",\n            \"width\": 12,\n            \"height\": 9,\n            \"x\": 0,\n            \"y\": y_no + 5 + (metric_counter * 10),\n            \"properties\": {\n                \"view\": \"timeSeries\",\n                \"stacked\": False,\n                \"metrics\": [\n                    [\n                        {\n                            \"expression\": f\"IF(({period} - {metrics_numbrs['VolumeIdleTime']}) > 0, ({metrics_numbrs['VolumeReadOps']} + {metrics_numbrs['VolumeWriteOps']}) / ({period} - {metrics_numbrs['VolumeIdleTime']}), 0)\",\n                            \"label\": \"Estimated Average IOPS\",\n                            \"id\": exprs[\"avg_iops\"],\n                            \"visible\": True,\n                        }\n                    ],\n                    [\n                        \"AWS/EBS\",\n                        \"VolumeIdleTime\",\n                        \"VolumeId\",\n                        vol_id,\n                        {\"id\": metrics_numbrs[\"VolumeIdleTime\"], \"visible\": False},\n                    ],\n                    [\n                        \"AWS/EBS\",\n                        \"VolumeReadOps\",\n                        \"VolumeId\",\n                        vol_id,\n                        {\"id\": metrics_numbrs[\"VolumeReadOps\"], \"visible\": False},\n                    ],\n                    [\n                        \"AWS/EBS\",\n                        \"VolumeWriteOps\",\n                        \"VolumeId\",\n                        vol_id,\n                        {\"id\": metrics_numbrs[\"VolumeWriteOps\"], \"visible\": False},\n                    ],\n                    [\n                        \"AWS/EBS\",\n                        \"BurstBalance\",\n                        \"VolumeId\",\n                        vol_id,\n                        {\n                            \"id\": metrics_numbrs[\"BurstBalance\"],\n                            \"visible\": is_burstable,\n                            \"color\": \"#000000\",\n                            \"yAxis\": \"right\",\n                            \"stat\": \"Average\",\n                        },\n                    ],\n                ],\n                \"region\": region,\n                \"period\": period,\n                \"stat\": \"Sum\",\n                \"title\": \"Estimated Average IOPS\",\n                \"start\": start_time.strftime(\"%Y-%m-%dT%H:%M:%SZ\"),\n                \"end\": end_time.strftime(\"%Y-%m-%dT%H:%M:%SZ\"),\n                \"annotations\": iops_annotations,\n            },\n        },\n        {\n            \"type\": \"metric\",\n            \"width\": 12,\n            \"height\": 9,\n            \"x\": 12,\n            \"y\": y_no + 5 + (metric_counter * 10),\n            \"properties\": {\n                \"view\": \"timeSeries\",\n                \"stacked\": False,\n                \"metrics\": [\n                    [\n                        {\n                            \"expression\": f\"IF(({period} - {metrics_numbrs['VolumeIdleTime']}) > 0, (({metrics_numbrs['VolumeReadBytes']} + {metrics_numbrs['VolumeWriteBytes']}) / ({period} - {metrics_numbrs['VolumeIdleTime']})) / 1024 / 1024, 0)\",\n                            \"label\": \"Estimated Average Throughput\",\n                            \"id\": exprs[\"avg_throughput\"],\n                            \"visible\": True,\n                        }\n                    ],\n                    [\n                        \"AWS/EBS\",\n                        \"VolumeIdleTime\",\n                        \"VolumeId\",\n                        vol_id,\n                        {\"id\": metrics_numbrs[\"VolumeIdleTime\"], \"visible\": False},\n                    ],\n                    [\n                        \"AWS/EBS\",\n                        \"VolumeReadBytes\",\n                        \"VolumeId\",\n                        vol_id,\n                        {\"id\": metrics_numbrs[\"VolumeReadBytes\"], \"visible\": False},\n                    ],\n                    [\n                        \"AWS/EBS\",\n                        \"VolumeWriteBytes\",\n                        \"VolumeId\",\n                        vol_id,\n                        {\"id\": metrics_numbrs[\"VolumeWriteBytes\"], \"visible\": False},\n                    ],\n                    [\n                        \"AWS/EBS\",\n                        \"BurstBalance\",\n                        \"VolumeId\",\n                        vol_id,\n                        {\n                            \"id\": metrics_numbrs[\"BurstBalance\"],\n                            \"visible\": is_burstable,\n                            \"color\": \"#000000\",\n                            \"yAxis\": \"right\",\n                            \"stat\": \"Average\",\n                        },\n                    ],\n                ],\n                \"region\": region,\n                \"period\": period,\n                \"stat\": \"Sum\",\n                \"title\": \"Estimated Average Throughput\",\n                \"start\": start_time.strftime(\"%Y-%m-%dT%H:%M:%SZ\"),\n                \"end\": end_time.strftime(\"%Y-%m-%dT%H:%M:%SZ\"),\n                \"annotations\": throughput_annotations,\n                \"yAxis\": {\"left\": {\"label\": \"MB/s\", \"showUnits\": False}},\n            },\n        },\n    ]\n\n\n# create ec2 related widget\ndef create_instance_widget(ec2_client, region, instance_id, vol_ids, ec2_info, period, start_time, end_time):\n    vol_iops_metrics = []\n    vol_throughput_metrics = []\n\n    iops_annotation = get_ec2_annotations(ec2_client, \"iops\", ec2_info)\n    throughput_annotations = get_ec2_annotations(ec2_client, \"throughput\", ec2_info)\n\n    for i in range(len(vol_ids)):\n        # all volume Read/WriteOps metrics\n        vol_iops_metrics.append(\n            [\"AWS/EBS\", \"VolumeIdleTime\", \"VolumeId\", vol_ids[i], {\"id\": f\"m{i * 6 + 1}\", \"visible\": False}]\n        )\n        vol_iops_metrics.append(\n            [\"AWS/EBS\", \"VolumeReadOps\", \"VolumeId\", vol_ids[i], {\"id\": f\"m{i * 6 + 2}\", \"visible\": False}]\n        )\n        vol_iops_metrics.append(\n            [\"AWS/EBS\", \"VolumeWriteOps\", \"VolumeId\", vol_ids[i], {\"id\": f\"m{i * 6 + 3}\", \"visible\": False}]\n        )\n\n        # all volume Read/WriteBytes metrics\n        vol_throughput_metrics.append(\n            [\"AWS/EBS\", \"VolumeIdleTime\", \"VolumeId\", vol_ids[i], {\"id\": f\"m{i * 6 + 1}\", \"visible\": False}]\n        )\n        vol_throughput_metrics.append(\n            [\"AWS/EBS\", \"VolumeReadBytes\", \"VolumeId\", vol_ids[i], {\"id\": f\"m{i * 6 + 4}\", \"visible\": False}]\n        )\n        vol_throughput_metrics.append(\n            [\"AWS/EBS\", \"VolumeWriteBytes\", \"VolumeId\", vol_ids[i], {\"id\": f\"m{i * 6 + 5}\", \"visible\": False}]\n        )\n\n    # iops calculations\n    iops_metrics_sum = \" + \".join([f\"m{i * 6 + 2} + m{i * 6 + 3}\" for i in range(len(vol_ids))])\n    iops_expression = f\"({iops_metrics_sum}) / {period}\"\n\n    # throughput calculations\n    throughput_metrics_sum = \" + \".join([f\"m{i * 6 + 4} + m{i * 6 + 5}\" for i in range(len(vol_ids))])\n    throuhgput_expression = f\"(({throughput_metrics_sum}) / {period}) / 1024 / 1024\"\n\n    iops_metrics: List[Any] = []\n    iops_metrics.append(\n        [\n            {\n                \"expression\": iops_expression,\n                \"label\": f\"{instance_id} - Average Total IOPS\",\n                \"id\": f\"e{len(vol_ids) * 2 + 1}\",\n                \"visible\": True,\n            }\n        ]\n    )\n    iops_metrics.extend(vol_iops_metrics)\n\n    throuhput_metrics: List[Any] = []\n    throuhput_metrics.append(\n        [\n            {\n                \"expression\": throuhgput_expression,\n                \"label\": f\"{instance_id} - Average Total Throughput\",\n                \"id\": f\"e{len(vol_ids) * 2 + 2}\",\n                \"visible\": True,\n            }\n        ]\n    )\n    throuhput_metrics.extend(vol_throughput_metrics)\n\n    if ec2_info[\"ebs_optimized\"]:\n        if (\n            iops_annotation[\"horizontal\"][0][\"label\"] == \"Baseline IOPS\"\n            or throughput_annotations[\"horizontal\"][0][\"label\"] == \"Baseline Throughput (MB/s)\"\n        ):\n            iops_metrics.append(\n                [\n                    \"AWS/EC2\",\n                    \"EBSIOBalance%\",\n                    \"InstanceId\",\n                    instance_id,\n                    {\n                        \"id\": \"n1\",\n                        \"region\": region,\n                        \"yAxis\": \"right\",\n                        \"stat\": \"Average\",\n                        \"label\": f\"{instance_id} - EBSIOBalance%\",\n                    },\n                ]\n            )\n            throuhput_metrics.append(\n                [\n                    \"AWS/EC2\",\n                    \"EBSByteBalance%\",\n                    \"InstanceId\",\n                    instance_id,\n                    {\n                        \"id\": \"n2\",\n                        \"region\": region,\n                        \"yAxis\": \"right\",\n                        \"stat\": \"Average\",\n                        \"label\": f\"{instance_id} - EBSByteBalance%\",\n                    },\n                ]\n            )\n\n    return [\n        {\n            \"type\": \"metric\",\n            \"width\": 12,\n            \"height\": 9,\n            \"x\": 0,\n            \"y\": 8,\n            \"properties\": {\n                \"view\": \"timeSeries\",\n                \"stacked\": False,\n                \"metrics\": iops_metrics,\n                \"region\": region,\n                \"period\": period,\n                \"stat\": \"Sum\",\n                \"title\": \"Average Total IOPS\",\n                \"start\": start_time.strftime(\"%Y-%m-%dT%H:%M:%SZ\"),\n                \"end\": end_time.strftime(\"%Y-%m-%dT%H:%M:%SZ\"),\n                \"annotations\": iops_annotation,\n            },\n        },\n        {\n            \"type\": \"metric\",\n            \"width\": 12,\n            \"height\": 9,\n            \"x\": 12,\n            \"y\": 8,\n            \"properties\": {\n                \"view\": \"timeSeries\",\n                \"stacked\": False,\n                \"metrics\": throuhput_metrics,\n                \"region\": region,\n                \"period\": period,\n                \"stat\": \"Sum\",\n                \"title\": \"Average Total Throughput\",\n                \"start\": start_time.strftime(\"%Y-%m-%dT%H:%M:%SZ\"),\n                \"end\": end_time.strftime(\"%Y-%m-%dT%H:%M:%SZ\"),\n                \"annotations\": throughput_annotations,\n                \"yAxis\": {\"left\": {\"label\": \"MB/s\", \"showUnits\": False}},\n            },\n        },\n    ]\n\n\n# create volume dashboard\ndef create_volume_dashboard(region, vol_ids, period, start_time, end_time, dashboard_name, ec2_client, y_no=5):\n    widgets = [\n        {\n            \"type\": \"text\",\n            \"height\": 6,\n            \"width\": 24,\n            \"y\": 16,\n            \"x\": 0,\n            \"properties\": {\n                \"markdown\": \"### EBS Volume(s) Metrics\\n\\n| Calculated Metric | Mathematical Expression | Unit |\\n| -------- | ------------------------- | ------ |\\n| Estimated Average IOPS | (SUM(VolumeReadOps) + SUM(VolumeWriteOps)) / (Period - SUM(VolumeIdleTime)) | IOPS |\\n| Estimated Average Throughput | (SUM(VolumeReadBytes) + SUM(VolumeWriteBytes)) / (Period - SUM(VolumeIdleTime)) / 1024 / 1024 | MiB/s |\\n\\n\\n**Note:** If `Estimated Average IOPS` / `Estimated Average Throughput` is more than `Maximum IOPS` / `Maximum Throughput`, then microbusting is happening for that particular volume. **Realtime analysis for Microbusting may vary, to confirm further you can use OS-level tool that has a finer granularity than CloudWatch.** Also, the maximum performance for certain volume types can only be achieved if `BurstBalance%` is greater than zero.\\n\\nFor more information, please review - [How can I identify if my Amazon EBS volume is micro-bursting and then prevent this from happening?](https://repost.aws/knowledge-center/ebs-identify-micro-bursting)\"\n            },\n        }\n    ]\n\n    for i in range(len(vol_ids)):\n        # get volume details\n        vol_details = get_volume_details(vol_ids[i], ec2_client)\n        vol_widgets = create_volume_widget(\n            region, vol_ids[i], vol_details, period, start_time, end_time, ec2_client, i, y_no\n        )\n\n        # add the volume widgets\n        widgets.extend(vol_widgets)\n\n    # footer widget\n    footer_widget = {\n        \"type\": \"text\",\n        \"height\": 3,\n        \"width\": 24,\n        \"y\": (len(vol_ids) * 10) + y_no,\n        \"x\": 0,\n        \"properties\": {\n            \"markdown\": f\"**In order to delete the dashboard, run the CLI command** \\n\\n ```\\n $ aws cloudwatch delete-dashboards --dashboard-names {dashboard_name} --region {region}\\n ``` \\n\\n **Note:** You will need `cloudwatch:DeleteDashboards` IAM permission to delete the dashboard.\"\n        },\n    }\n\n    widgets.append(footer_widget)\n\n    return widgets\n\n\ndef create_instance_dashboard(region, instance_id, vol_ids, period, start_time, end_time, dashboard_name, ec2_client):\n    ec2_info = get_ec2_info(instance_id, ec2_client)\n\n    widgets = [\n        {\n            \"type\": \"text\",\n            \"height\": 8,\n            \"width\": 24,\n            \"y\": 0,\n            \"x\": 0,\n            \"properties\": {\n                \"markdown\": f\"# Aggregated Metrics for EC2 Instance {instance_id}\\n- Instance Type: {ec2_info['instance_class']}\\n- EBS Optimized: {ec2_info['ebs_optimized']} \\n\\n\\n[button: More details on EBS Optimized instances](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-optimized.html)\\n[button:More details on EBS Volume Types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-volume-types.html)\\n\\n[button: How do I use CloudWatch to view the aggregate Amazon EBS performance metrics for an EC2 instance?](https://repost.aws/knowledge-center/ebs-aggregate-cloudwatch-performance)\\n\\n| Calculated Metric | Mathematical Expression | Unit |\\n| -------- | ------------------------- | ------ |\\n| Average Total IOPS | SUM(For All Volumes[(SUM(VolumeReadOps) + SUM(VolumeWriteOps))]) / Period | IOPS |\\n| Average Total Throughput | SUM(For All Volumes[(SUM(VolumeReadBytes) + SUM(VolumeWriteBytes))]) / Period / 1024 / 1024 | MiB/s |\\n\\n**Note:** The maximum performance can only be achieved if `BurstBalance%` for EBS volume or `EBSIOBalance%`, `EBSByteBalance%` for instance is greater than zero.\"\n            },\n        }\n    ]\n\n    ec2_widget = create_instance_widget(\n        ec2_client, region, instance_id, vol_ids, ec2_info, period, start_time, end_time\n    )\n    widgets.extend(ec2_widget)\n\n    volume_widgets = create_volume_dashboard(\n        region, vol_ids, period, start_time, end_time, dashboard_name, ec2_client, 16\n    )\n    widgets.extend(volume_widgets)\n\n    return widgets\n\n\ndef create_dashboard(events, context):\n    # variables from events/context\n    region = context[\"global:REGION\"]\n    partition = context[\"global:AWS_PARTITION\"]\n    execution_id = context[\"automation:EXECUTION_ID\"]\n    start_time = datetime.datetime.strptime(events.get(\"start_time\"), \"%Y-%m-%dT%H:%M:%S\")\n    end_time = datetime.datetime.strptime(events.get(\"end_time\"), \"%Y-%m-%dT%H:%M:%S\")\n    resource_id = events.get(\"resource_id\")\n\n    # ec2 client\n    ec2_client = boto3.client(\"ec2\", region_name=region)\n    cw_client = boto3.client(\"cloudwatch\", region_name=region)\n\n    # calculate period\n    period = get_period_value(start_time)\n\n    dashboard_name = f\"AWSSupport-{resource_id}-EBS-Performance-{execution_id}\"\n\n    if resource_id.startswith(\"vol-\"):\n        widgets = create_volume_dashboard(\n            region, [resource_id], period, start_time, end_time, dashboard_name, ec2_client\n        )\n\n    elif resource_id.startswith(\"i-\"):\n        vol_ids = get_attached_volumes(resource_id, ec2_client)\n        widgets = create_instance_dashboard(\n            region, resource_id, vol_ids, period, start_time, end_time, dashboard_name, ec2_client\n        )\n    else:\n        raise ValueError(f\"[ERROR] The resource ID is not a valid EBS volume or EC2 instance: {resource_id}\")\n\n    dashboard = {\n        \"start\": start_time.strftime(\"%Y-%m-%dT%H:%M:%S\"),\n        \"end\": end_time.strftime(\"%Y-%m-%dT%H:%M:%S\"),\n        \"periodOverride\": \"inherit\",\n        \"widgets\": widgets,\n    }\n\n    try:\n        cw_client.put_dashboard(DashboardName=dashboard_name, DashboardBody=json.dumps(dashboard))\n        domain_url_mapping = {\n            \"aws\": \"aws.amazon.com\",\n            \"aws-cn\": \"amazonaws.cn\",\n            \"aws-us-gov\": \"amazonaws-us-gov.com\",\n        }\n        domain_url = domain_url_mapping[partition]\n        cw_dashboard_url = (\n            f\"https://console.{domain_url}/cloudwatch/home?region={region}#dashboards:name={dashboard_name}\"\n        )\n        message = f\"Open the CloudWatch Dashboard URL in your browser to see the performance metrics for the target resource '{resource_id}'.\\nYou can delete the CloudWatch Dashboard from the CloudWatch console.\\n\"\n        return {\"message\": message, \"url\": cw_dashboard_url}\n\n    except ClientError as error:\n        raise RuntimeError(\n            f\"[ERROR] An error occurred when trying to create the CloudWatch dashboard - {str(error)}\"\n        ) from None\n",
        "InputPayload": {
          "resource_id": "{{ ResourceId }}",
          "start_time": "{{ StartTime }}",
          "end_time": "{{ EndTime }}"
        }
      },
      "outputs": [
        {
          "Name": "CloudWatchDashboardLink",
          "Selector": "$.Payload.url",
          "Type": "String"
        },
        {
          "Name": "CloudWatchDashboardMessage",
          "Selector": "$.Payload.message",
          "Type": "String"
        }
      ]
    }
  ],
  "outputs": [
    "CreateCloudWatchDashboard.CloudWatchDashboardLink",
    "CreateCloudWatchDashboard.CloudWatchDashboardMessage"
  ]
}
