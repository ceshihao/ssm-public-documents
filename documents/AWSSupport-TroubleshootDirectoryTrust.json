{
  "description": "AWS Support - Directory Service Troubleshooter",
  "schemaVersion": "0.3",
  "assumeRole": "{{ AutomationAssumeRole }}",
  "parameters": {
    "DirectoryId": {
      "type": "String",
      "description": "(Optional) The Id of the directory to troubleshoot.",
      "allowedPattern": "^d-[a-z0-9]{10}$",
      "default": ""
    },
    "TrustId": {
      "type": "String",
      "description": "(Optional) The Id of the trust relationship to troubleshoot.",
      "allowedPattern": "^$|^t-[0-9a-f]{10}$",
      "default": ""
    },
    "RemoteDomainCidrs": {
      "type": "StringList",
      "description": "(Required) The CIDR(s) of the remote domain you are attempting to establish a Trust Relationship with. You can add multiple CIDRs using comma-separated values. Valid formats: 172.31.48.0/20, 192.168.1.10/32, etc.",
      "allowedPattern": "^(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(/(3[0-2]|[1-2][0-9]|[1-9]))$"
    },
    "RemoteDomainName": {
      "type": "String",
      "description": "(Required) The FQDN of the remote domain you are attempting to establish a Trust Relationship with.",
      "allowedPattern": "^([a-zA-Z0-9]+[\\.-])+([a-zA-Z0-9])+[.]?$"
    },
    "AutomationAssumeRole": {
      "type": "AWS::IAM::Role::Arn",
      "description": "(Optional) The Amazon Resource Name (ARN) of the AWS Identity and Access Management (IAM) role that allows Systems Manager Automation to perform the actions on your behalf. If no role is specified, Systems Manager Automation uses the permissions of the user that starts this runbook.",
      "default": ""
    },
    "RequiredTrafficSG": {
      "type": "String",
      "description": "(Optional) Directory Service inbound and outbound Security Group traffic requirements. These are the default required ports. You should not modify this value.",
      "allowedPattern": "^\\{(\\\"(inbound|outbound)\\\"\\:\\{(\\\"(tcp|udp|icmp|\\-1)\\\"\\:\\[\\[\\-?\\d+,\\-?\\d+\\](,\\[\\-?\\d+,\\-?\\d+\\]){0,10}\\],?){1,10}\\},?){1,2}\\}",
      "default": "{\"inbound\":{\"tcp\":[[53,53],[88,88],[135,135],[389,389],[445,445],[464,464],[636,636],[1024,65535]],\"udp\":[[53,53],[88,88],[123,123],[138,138],[389,389],[445,445],[464,464]],\"icmp\":[[-1,-1]]},\"outbound\":{\"-1\":[[0,65535]]}}"
    },
    "RequiredTrafficACL": {
      "type": "String",
      "description": "(Optional) Directory Service inbound and outbound Network ACL traffic requirements. These are the default required ports. You should not modify this value.",
      "allowedPattern": "^\\{(\\\"(inbound|outbound)\\\"\\:\\{(\\\"(tcp|udp|icmp|\\-1)\\\"\\:\\[\\[\\-?\\d+,\\-?\\d+\\](,\\[\\-?\\d+,\\-?\\d+\\]){0,10}\\],?){1,10}\\},?){1,2}\\}",
      "default": "{\"inbound\":{\"tcp\":[[53,53],[88,88],[135,135],[389,389],[445,445],[464,464],[636,636],[1024,65535]],\"udp\":[[53,53],[88,88],[123,123],[138,138],[389,389],[445,445],[464,464]],\"icmp\":[[-1,-1]]},\"outbound\":{\"-1\":[[0,65535]]}}"
    }
  },
  "outputs": [
    "evaluateRemoteDomainCidr.output",
    "evalDirectorySecurityGroup.output",
    "evalAclEntries.output"
  ],
  "mainSteps": [
    {
      "name": "assertDirectoryType",
      "action": "aws:assertAwsResourceProperty",
      "description": "Confirms the directory type is AWS Managed Microsoft AD.",
      "onFailure": "Abort",
      "inputs": {
        "Service": "ds",
        "Api": "DescribeDirectories",
        "DirectoryIds": [
          "{{ DirectoryId }}"
        ],
        "PropertySelector": "$.DirectoryDescriptions[0].Type",
        "DesiredValues": [
          "MicrosoftAD"
        ]
      },
      "isCritical": true,
      "nextStep": "getDirectoryInfo"
    },
    {
      "name": "getDirectoryInfo",
      "action": "aws:executeAwsApi",
      "description": "Gets information about the AWS Managed Microsoft AD.",
      "onFailure": "Abort",
      "inputs": {
        "Service": "ds",
        "Api": "DescribeDirectories",
        "DirectoryIds": [
          "{{ DirectoryId }}"
        ]
      },
      "outputs": [
        {
          "Name": "directoryDnsIpAddrs",
          "Selector": "$.DirectoryDescriptions[0].DnsIpAddrs",
          "Type": "StringList"
        },
        {
          "Name": "directoryVpcId",
          "Selector": "$.DirectoryDescriptions[0].VpcSettings.VpcId",
          "Type": "String"
        },
        {
          "Name": "directorySecurityGroupId",
          "Selector": "$.DirectoryDescriptions[0].VpcSettings.SecurityGroupId",
          "Type": "String"
        },
        {
          "Name": "directorySubnets",
          "Selector": "$.DirectoryDescriptions[0].VpcSettings.SubnetIds",
          "Type": "StringList"
        }
      ],
      "nextStep": "branchOnGetDirectoryTrust"
    },
    {
      "name": "branchOnGetDirectoryTrust",
      "action": "aws:branch",
      "description": "Branches automation if a value is provided for the TrustId input parameter.",
      "onFailure": "Abort",
      "inputs": {
        "Choices": [
          {
            "NextStep": "getDirectoryTrust",
            "Variable": "{{ TrustId }}",
            "StartsWith": "t-"
          }
        ],
        "Default": "getDirectoryConditionalForwarder"
      },
      "nextStep": "getDirectoryConditionalForwarder",
      "isCritical": true
    },
    {
      "name": "getDirectoryTrust",
      "action": "aws:executeAwsApi",
      "description": "Gets information about the trust relationship.",
      "onFailure": "Continue",
      "inputs": {
        "Service": "ds",
        "Api": "DescribeTrusts",
        "DirectoryId": "{{ DirectoryId }}",
        "TrustIds": [
          "{{ TrustId }}"
        ]
      },
      "outputs": [
        {
          "Name": "directoryTrustState",
          "Selector": "$.Trusts[0].TrustState",
          "Type": "String"
        },
        {
          "Name": "directoryTrust",
          "Selector": "$.Trusts[0]",
          "Type": "StringMap"
        }
      ],
      "nextStep": "getDirectoryConditionalForwarder"
    },
    {
      "name": "getDirectoryConditionalForwarder",
      "action": "aws:executeAwsApi",
      "description": "Gets the conditional forwarder DNS IP addresses for the RemoteDomainName.",
      "onFailure": "Abort",
      "inputs": {
        "Service": "ds",
        "Api": "DescribeConditionalForwarders",
        "DirectoryId": "{{ DirectoryId }}",
        "RemoteDomainNames": [
          "{{ RemoteDomainName }}"
        ]
      },
      "outputs": [
        {
          "Name": "directoryForwarderDnsIpAddrs",
          "Selector": "$.ConditionalForwarders[0].DnsIpAddrs",
          "Type": "StringList"
        }
      ],
      "nextStep": "getDirectoryIPRoutes"
    },
    {
      "name": "getDirectoryIPRoutes",
      "action": "aws:executeAwsApi",
      "description": "Gets information about IP routes that have been added to the AWS Managed Microsoft AD.",
      "onFailure": "Abort",
      "inputs": {
        "Service": "ds",
        "Api": "ListIpRoutes",
        "DirectoryId": "{{ DirectoryId }}"
      },
      "outputs": [
        {
          "Name": "directoryIPRoutes",
          "Selector": "$.IpRoutesInfo",
          "Type": "MapList"
        }
      ],
      "nextStep": "getDirectorySubnetCidrs"
    },
    {
      "name": "getDirectorySubnetCidrs",
      "action": "aws:executeAwsApi",
      "description": "Gets the CIDR blocks of the AWS Managed Microsoft AD subnets.",
      "onFailure": "Abort",
      "inputs": {
        "Service": "ec2",
        "Api": "DescribeSubnets",
        "SubnetIds": [
          "{{ getDirectoryInfo.directorySubnets }}"
        ]
      },
      "outputs": [
        {
          "Name": "directorySubnetCidrs",
          "Selector": "$.Subnets..CidrBlock",
          "Type": "StringList"
        }
      ],
      "nextStep": "getDirectorySecurityGroup"
    },
    {
      "name": "getDirectorySecurityGroup",
      "action": "aws:executeAwsApi",
      "description": "Gets information about the security groups associated with the AWS Managed Microsoft AD.",
      "onFailure": "Abort",
      "inputs": {
        "Service": "ec2",
        "Api": "DescribeSecurityGroups",
        "GroupIds": [
          "{{ getDirectoryInfo.directorySecurityGroupId }}"
        ]
      },
      "outputs": [
        {
          "Name": "directorySecurityGroups",
          "Selector": "$.SecurityGroups",
          "Type": "MapList"
        }
      ],
      "nextStep": "getDirectoryAcl"
    },
    {
      "name": "getDirectoryAcl",
      "action": "aws:executeAwsApi",
      "description": "Gets information about the network ACLs associated with the AWS Managed Microsoft AD.",
      "onFailure": "Abort",
      "inputs": {
        "Service": "ec2",
        "Api": "DescribeNetworkAcls",
        "Filters": [
          {
            "Name": "association.subnet-id",
            "Values": "{{ getDirectoryInfo.directorySubnets }}"
          }
        ]
      },
      "outputs": [
        {
          "Name": "directoryAcls",
          "Selector": "$.NetworkAcls",
          "Type": "MapList"
        }
      ],
      "nextStep": "evaluateRemoteDomainCidr"
    },
    {
      "name": "evaluateRemoteDomainCidr",
      "action": "aws:executeScript",
      "description": "Confirms the RemoteDomainCidrs are valid values. Confirms that the AWS Managed Microsoft AD has conditional forwarders for the RemoteDomainCidrs , and that the requisite IP routes have been added to the AWS Managed Microsoft AD if the RemoteDomainCidrs are non-RFC 1918 IP addresses.",
      "timeoutSeconds": 45,
      "onFailure": "Continue",
      "inputs": {
        "InputPayload": {
          "remoteCidrs": "{{ RemoteDomainCidrs }}",
          "directoryIPRoutes": "{{ getDirectoryIPRoutes.directoryIPRoutes }}"
        },
        "Handler": "function_handler",
        "Runtime": "python3.11",
        "Script": "# Copyright 2025 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n# SPDX-License-Identifier: LicenseRef-.amazon.com.-AmznSL-1.0\n# Licensed under the Amazon Software License  http://aws.amazon.com/asl/\n\n\n# Handler Function\ndef function_handler(events, context):\n    err = False\n    directory_forwarder_dns_ipaddrs = []  # events['directoryForwarderDnsIpAddrs']\n    directory_ip_routes = events[\"directoryIPRoutes\"]\n    remote_cidrs = events[\"remoteCidrs\"]\n\n    # Check if all DNS entries in the Conditional Forwarder have a valid route if public\n    # The directoryForwarderDnsIpAddrs for the RemoteDomainName\n    for dns in directory_forwarder_dns_ipaddrs:\n        err = err or check_if_route_exist(dns, directory_ip_routes)\n\n    # Check if all remote CIDR entries have a valid route if public\n    for cidr in remote_cidrs:\n        err = err or check_if_route_exist(cidr, directory_ip_routes)\n\n    if err:\n        return {\n            \"error\": err,\n            \"output\": \"Error: One or more CIDR/IP requires an IP route to be reachable. See ExecutionLog\",\n        }\n    else:\n        return {\"error\": err, \"output\": \"Success: No issues with required IP routes\"}\n\n\n# Checks if an IP route exists for any public (non-RFC 1918) IP addresses\n# of the remote Active Directory. The function checks the CIDRs provided in the document input\n# and DNS entries of the Conditional Forwarders for the RemoteDomainName in the document input\ndef check_if_route_exist(net4, routes):\n    from ipaddress import ip_network\n\n    err = False\n    try:\n        net = ip_network(net4)\n        if not net.is_private:\n            while len(routes) > 0:\n                if net.overlaps(ip_network(routes[0])):\n                    # print(\"An IP Route exists for the public DNS \", dnsIp)\n                    print(\"An IP Route exists for the public DNS \", net4)\n                    break\n                routes.pop(0)\n            else:\n                print(\n                    \"Error: No IP routes have been added for\",\n                    net,\n                    \". A route must be added in order to route traffic to the remote directory.\",\n                )\n                err = True\n        else:\n            print(\"Success:\", net, \"does not require an IP route because is private\")\n\n        return err\n\n    except Exception as e:\n        print(\"Error: Please enter an acceptable host or network IP Address.\", str(e))\n        return True\n"
      },
      "outputs": [
        {
          "Name": "output",
          "Selector": "$.Payload.output",
          "Type": "String"
        },
        {
          "Name": "error",
          "Selector": "$.Payload.err",
          "Type": "Boolean"
        }
      ],
      "nextStep": "evalDirectorySecurityGroup"
    },
    {
      "name": "evalDirectorySecurityGroup",
      "action": "aws:executeScript",
      "description": "Evaluates security group rules.",
      "timeoutSeconds": 45,
      "onFailure": "Continue",
      "inputs": {
        "InputPayload": {
          "remoteCidrs": "{{ RemoteDomainCidrs }}",
          "directorySecurityGroups": "{{ getDirectorySecurityGroup.directorySecurityGroups }}",
          "requiredTraffic": "{{ RequiredTrafficSG }}"
        },
        "Handler": "function_handler",
        "Runtime": "python3.11",
        "Script": "# Copyright 2025 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n# SPDX-License-Identifier: LicenseRef-.amazon.com.-AmznSL-1.0\n# Licensed under the Amazon Software License  http://aws.amazon.com/asl/\n\n\n# Handler Function\ndef function_handler(events, context):\n    import json\n\n    directory_security_groups = events[\"directorySecurityGroups\"]\n    remote_cidrs = events[\"remoteCidrs\"]\n    required_traffic = json.loads(events[\"requiredTraffic\"])\n    print(\"RequiredTraffic\", required_traffic)\n\n    # required = {\n    #    'inbound': {\n    #        'tcp':[[2,20],[636,636],[53,53],[1024,65535]],\n    #        'udp':[[2,20],[53,53],[138,138]],\n    #        'icmp':[[-1,-1]]\n    #    },\n    #    'outbound': {\n    #        '-1':[[0,65535]]\n    #   }\n    # }\n\n    err = False\n    source = {\"network-cidrs\": remote_cidrs, \"security-groups\": []}\n    err = eval_security_groups_traffic(directory_security_groups, source, required_traffic)\n\n    if err:\n        return {\"error\": err, \"output\": \"Error: Required traffic is not allowed in Security Groups. See ExecutionLog\"}\n    else:\n        return {\"error\": err, \"output\": \"Success: Required traffic is allowed in Security Groups\"}\n\n\ndef eval_security_groups_traffic(sgs, source, traffic):\n    from ipaddress import ip_network\n\n    try:\n        err = False\n        for sg in sgs:\n            for protocol, ranges in traffic.get(\"inbound\", []).items():\n                for range in ranges:\n                    allowed = False\n                    for r in sg.get(\"IpPermissions\", []):\n                        if r[\"IpProtocol\"] in (protocol, \"-1\"):\n                            if (\"FromPort\" not in r and \"ToPort\" not in r) or (\n                                r[\"FromPort\"] <= range[0] and r[\"ToPort\"] >= range[1]\n                            ):  # \"Rule allows port %s\" % r['fromPort']\n                                for user_id_group_pair in r.get(\"UserIdGroupPairs\", []):\n                                    for group_id in source.get(\"security-groups\", []):\n                                        if user_id_group_pair[\"GroupId\"] == group_id:\n                                            allowed = True\n                                            break\n                                for ip_range in r[\"IpRanges\"]:\n                                    for network_cidr in source.get(\"network-cidrs\", []):\n                                        if ip_network(ip_range[\"CidrIp\"], strict=False).overlaps(\n                                            ip_network(network_cidr, strict=False)\n                                        ):\n                                            allowed = True\n                                            break\n                    if not allowed:\n                        print(\n                            \"No inbound Security Group rule in\",\n                            sg[\"GroupId\"],\n                            \"allows connectivity for\",\n                            protocol.replace(\"-1\", \"all\").upper(),\n                            \"in range:\",\n                            range,\n                        )\n                        err = True\n\n            for protocol, ranges in traffic.get(\"outbound\", []).items():\n                for range in ranges:\n                    allowed = False\n                    for r in sg.get(\"IpPermissionsEgress\", []):\n                        if r[\"IpProtocol\"] in (protocol, \"-1\"):\n                            if (\"FromPort\" not in r and \"ToPort\" not in r) or (\n                                r[\"FromPort\"] <= range[0] and r[\"ToPort\"] >= range[1]\n                            ):  # \"Rule allows port %s\" % r['fromPort']\n                                for user_id_group_pair in r.get(\"UserIdGroupPairs\", []):\n                                    for group_id in source.get(\"security-groups\", []):\n                                        if user_id_group_pair[\"GroupId\"] == group_id:\n                                            allowed = True\n                                            break\n                                for ip_range in r[\"IpRanges\"]:\n                                    for network_cidr in source.get(\"network-cidrs\", []):\n                                        if ip_network(ip_range[\"CidrIp\"], strict=False).overlaps(\n                                            ip_network(network_cidr, strict=False)\n                                        ):\n                                            allowed = True\n                                            break\n                    if not allowed:\n                        print(\n                            \"No outbound Security Group rule in\",\n                            sg[\"GroupId\"],\n                            \"allows connectivity for\",\n                            protocol.replace(\"-1\", \"all\").upper(),\n                            \"in range:\",\n                            range,\n                        )\n                        err = True\n        return err\n\n    except Exception as e:\n        print(\"Failed to evaluate Security Groups.\", str(e))\n        return True\n"
      },
      "outputs": [
        {
          "Name": "output",
          "Selector": "$.Payload.output",
          "Type": "String"
        },
        {
          "Name": "error",
          "Selector": "$.Payload.err",
          "Type": "Boolean"
        }
      ],
      "nextStep": "evalAclEntries"
    },
    {
      "name": "evalAclEntries",
      "action": "aws:executeScript",
      "description": "Evaluates network ACLs.",
      "timeoutSeconds": 45,
      "onFailure": "Continue",
      "inputs": {
        "InputPayload": {
          "remoteCidrs": "{{ RemoteDomainCidrs }}",
          "directoryAcl": "{{ getDirectoryAcl.directoryAcls }}",
          "requiredTraffic": "{{ RequiredTrafficACL }}"
        },
        "Handler": "function_handler",
        "Runtime": "python3.11",
        "Script": "# Copyright 2025 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n# SPDX-License-Identifier: LicenseRef-.amazon.com.-AmznSL-1.0\n# Licensed under the Amazon Software License  http://aws.amazon.com/asl/\n\n\ndef function_handler(events, context):\n    import json\n\n    err = False\n    directory_network_acls = events[\"directoryAcl\"]\n    remote_cidrs = events[\"remoteCidrs\"]\n    required_traffic = json.loads(events[\"requiredTraffic\"])\n\n    source = {\"network-cidrs\": remote_cidrs, \"security-groups\": []}\n    allows = eval_acl_rules(directory_network_acls, source, required_traffic)\n    # print_allowed(allows)\n    err = check_allowed(allows, required_traffic)\n\n    if err:\n        return {\"error\": err, \"output\": \"Error: Required traffic is not allowed in Network ACLs. See ExecutionLog\"}\n    else:\n        return {\"error\": err, \"output\": \"Success: Required traffic is allowed in Network ACLs\"}\n\n\ndef print_allowed(allows):\n    for nacl_id, nacl in allows.items():\n        print(\"NetworkAclId\", nacl_id, \"Inbound:\", list(nacl[0].items()), \" <> Outbound:\", list(nacl[1].items()))\n\n\ndef eval_acl_rules(rules, source, traffic):\n    from collections import defaultdict\n    from ipaddress import ip_network\n\n    in_allow = defaultdict(list)\n    out_allow = defaultdict(list)\n    allows = defaultdict(list)\n\n    try:\n        for nacl in rules:\n            for r in sorted(nacl[\"Entries\"], key=lambda k: k[\"RuleNumber\"], reverse=True):\n                # print(nacl['NetworkAclId'],out_allow)\n                for network_cidr in source.get(\"network-cidrs\", []):\n                    protocol = get_std_protocol(r[\"Protocol\"])\n                    # print(r['RuleNumber'],protocol,r['RuleAction'],r['Egress'],r['CidrBlock'],network_cidr,ip_network(r['CidrBlock'], strict=False).overlaps(ip_network(network_cidr, strict=False)))\n                    if ip_network(r[\"CidrBlock\"], strict=False).overlaps(ip_network(network_cidr, strict=False)):\n                        if \"PortRange\" not in r:\n                            f = 0\n                            t = 65535\n                        else:\n                            f = r[\"PortRange\"][\"From\"]\n                            t = r[\"PortRange\"][\"To\"]\n\n                        if not r[\"Egress\"]:\n                            if r[\"RuleAction\"] == \"allow\":\n                                in_allow[protocol] = range_add([f, t], in_allow[protocol])\n                            else:\n                                in_allow[protocol] = range_diff([f, t], in_allow[protocol])\n                        else:\n                            if r[\"RuleAction\"] == \"allow\":\n\n                                out_allow[protocol] = range_add([f, t], out_allow[protocol])\n                            else:\n                                out_allow[protocol] = range_diff([f, t], out_allow[protocol])\n\n            allows[nacl[\"NetworkAclId\"]].append(in_allow.copy())  # [0]\n            allows[nacl[\"NetworkAclId\"]].append(out_allow.copy())  # [1]\n            in_allow.clear()\n            out_allow.clear()\n\n        return allows\n\n    except Exception as e:\n        print(\"Failed to evaluate Network ACLs.\", str(e))\n        return allows\n\n\ndef get_std_protocol(acl_protocol):\n    # defined at https://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml\n    customprotocol = {\n        \"-1\": \"-1\",\n        \"hopopt\": \"0\",\n        \"icmp\": \"1\",\n        \"igmp\": \"2\",\n        \"ggp\": \"3\",\n        \"ipv4\": \"4\",\n        \"st\": \"5\",\n        \"tcp\": \"6\",\n        \"cbt\": \"7\",\n        \"egp\": \"8\",\n        \"igp\": \"9\",\n        \"bbn-rcc-mon\": \"10\",\n        \"nvp-ii\": \"11\",\n        \"pup\": \"12\",\n        \"argus\": \"13\",\n        \"emcon\": \"14\",\n        \"xnet\": \"15\",\n        \"chaos\": \"16\",\n        \"udp\": \"17\",\n        \"mux\": \"18\",\n        \"dcn-meas\": \"19\",\n        \"hmp\": \"20\",\n        \"prm\": \"21\",\n        \"xns-idp\": \"22\",\n        \"trunk-1\": \"23\",\n        \"trunk-2\": \"24\",\n        \"leaf-1\": \"25\",\n        \"leaf-2\": \"26\",\n        \"rdp\": \"27\",\n        \"irtp\": \"28\",\n        \"iso-tp4\": \"29\",\n        \"netblt\": \"30\",\n        \"mfe-nsp\": \"31\",\n        \"merit-inp\": \"32\",\n        \"dccp\": \"33\",\n        \"3pc\": \"34\",\n        \"idpr\": \"35\",\n        \"xtp\": \"36\",\n        \"ddp\": \"37\",\n        \"idpr-cmtp\": \"38\",\n        \"tp++\": \"39\",\n        \"il\": \"40\",\n        \"ipv6\": \"41\",\n        \"sdrp\": \"42\",\n        \"ipv6-route\": \"43\",\n        \"ipv6-frag\": \"44\",\n        \"idrp\": \"45\",\n        \"rsvp\": \"46\",\n        \"gre\": \"47\",\n        \"dsr\": \"48\",\n        \"bna\": \"49\",\n        \"esp\": \"50\",\n        \"ah\": \"51\",\n        \"i-nlsp\": \"52\",\n        \"swipe\": \"53\",\n        \"narp\": \"54\",\n        \"mobile\": \"55\",\n        \"tlsp\": \"56\",\n        \"ipv6-icmp\": \"58\",\n        \"ipv6-nonxt\": \"59\",\n        \"ipv6-opts\": \"60\",\n        \"61\": \"61\",\n        \"cftp\": \"62\",\n        \"63\": \"63\",\n        \"sat-expak\": \"64\",\n        \"kryptolan\": \"65\",\n        \"rvd\": \"66\",\n        \"ippc\": \"67\",\n        \"68\": \"68\",\n        \"sat-mon\": \"69\",\n        \"visa\": \"70\",\n        \"ipcv\": \"71\",\n        \"cpnx\": \"72\",\n        \"cphb\": \"73\",\n        \"wsn\": \"74\",\n        \"pvp\": \"75\",\n        \"br-sat-mon\": \"76\",\n        \"sun-nd\": \"77\",\n        \"wb-mon\": \"78\",\n        \"wb-expak\": \"79\",\n        \"iso-ip\": \"80\",\n        \"vmtp\": \"81\",\n        \"secure-vmtp\": \"82\",\n        \"vines\": \"83\",\n        \"ttp\": \"84\",\n        \"nsfnet-igp\": \"85\",\n        \"dgp\": \"86\",\n        \"tcf\": \"87\",\n        \"eigrp\": \"88\",\n        \"ospfigp\": \"89\",\n        \"sprite-rpc\": \"90\",\n        \"larp\": \"91\",\n        \"mtp\": \"92\",\n        \"ax.25\": \"93\",\n        \"ipip\": \"94\",\n        \"micp\": \"95\",\n        \"scc-sp\": \"96\",\n        \"etherip\": \"97\",\n        \"encap\": \"98\",\n        \"99\": \"99\",\n        \"gmtp\": \"100\",\n        \"ifmp\": \"101\",\n        \"pnni\": \"102\",\n        \"pim\": \"103\",\n        \"aris\": \"104\",\n        \"scps\": \"105\",\n        \"qnx\": \"106\",\n        \"a/n\": \"107\",\n        \"ipcomp\": \"108\",\n        \"snp\": \"109\",\n        \"compaq-peer\": \"110\",\n        \"ipx-in-ip\": \"111\",\n        \"vrrp\": \"112\",\n        \"pgm\": \"113\",\n        \"114\": \"114\",\n        \"l2tp\": \"115\",\n        \"dd\": \"116\",\n        \"iatp\": \"117\",\n        \"stp\": \"118\",\n        \"srp\": \"119\",\n        \"uti\": \"120\",\n        \"smp\": \"121\",\n        \"sm\": \"122\",\n        \"ptp\": \"123\",\n        \"isis-over-ipv4\": \"124\",\n        \"fire\": \"125\",\n        \"crtp\": \"126\",\n        \"crudp\": \"127\",\n        \"sscopmce\": \"128\",\n        \"iplt\": \"129\",\n        \"sps\": \"130\",\n        \"pipe\": \"131\",\n        \"sctp\": \"132\",\n        \"fc\": \"133\",\n        \"rsvp-e2e-ignore\": \"134\",\n        \"mobility-header\": \"135\",\n        \"udplite\": \"136\",\n        \"mpls-in-ip\": \"137\",\n        \"manet\": \"138\",\n        \"hip\": \"139\",\n        \"shim6\": \"140\",\n        \"wesp\": \"141\",\n        \"rohc\": \"142\",\n        \"253\": \"253\",\n        \"254\": \"254\",\n    }\n    inv_map = {v: k for k, v in customprotocol.items()}\n    return inv_map.get(acl_protocol)\n\n\ndef range_add(new, interv):\n    interv.append(new)\n    interv = [x for x in interv if x != [] and len(x) == 2 and all(isinstance(val, int) for val in x)]\n    interv.sort()\n    res = []\n    while len(interv) > 0:\n        if len(interv) == 1:\n            res.append(interv[0])\n            interv.pop(0)\n            continue\n        if interv[0][1] >= interv[1][0]:\n            tmp = [interv[0][0], max(interv[0][1], interv[1][1])]\n            interv[0] = tmp\n            interv.pop(1)\n            continue\n        res.append(interv[0])\n        interv.pop(0)\n    return res\n\n\ndef range_diff(new, interv):\n    interv = range_add([], interv)\n    if len(new) == 0:\n        new = [0, 0]\n    interv = [x for x in interv if x != [] and len(x) == 2 and all(isinstance(val, int) for val in x)]\n    interv.sort()\n    res = []\n    for t in interv:\n        s1, e1 = t\n        s2, e2 = new\n        s = sorted((s1, s2, e1, e2))\n        if s[0] == s1 and s[0] != s[1]:\n            v = s[1] if e1 < s2 else s[1] - 1\n            res.append([s[0], v])\n        if s[3] == e1 and s[2] != s[3]:\n            v = s[2] if e2 < s1 else s[2] + 1\n            res.append([v, s[3]])\n    if len(res) == 0:\n        res = [[0, 0]]\n    return res\n\n\ndef check_allowed(allows, traffic):\n    err = False\n    for nacl_id, nacl in allows.items():\n        for protocol, ranges in traffic.get(\"inbound\", []).items():\n            for range in ranges:\n                allowed = False\n                for r in nacl[0].get(\"-1\", []):\n                    if r[0] <= range[0] and r[1] >= range[1]:\n                        allowed = True\n                        break\n                for r in nacl[0].get(protocol, []):\n                    if r[0] <= range[0] and r[1] >= range[1]:\n                        allowed = True\n                        break\n            if not allowed:\n                print(\n                    \"Error: No inbound ACL rule in\",\n                    nacl_id,\n                    \"allows connectivity for\",\n                    protocol.replace(\"-1\", \"all\").upper(),\n                    \"in range:\",\n                    range,\n                )\n                err = True\n            else:\n                break\n\n        for protocol, ranges in traffic.get(\"outbound\", []).items():\n            for range in ranges:\n                allowed = False\n                for r in nacl[1].get(\"-1\", []):\n                    if r[0] <= range[0] and r[1] >= range[1]:\n                        allowed = True\n                        break\n                for r in nacl[1].get(protocol, []):\n                    if r[0] <= range[0] and r[1] >= range[1]:\n                        allowed = True\n                        break\n            if not allowed:\n                print(\n                    \"Error: No outbound ACL rule in\",\n                    nacl_id,\n                    \"allows connectivity for\",\n                    protocol.replace(\"-1\", \"all\").upper(),\n                    \"in range:\",\n                    range,\n                )\n                err = True\n            else:\n                break\n\n    return err\n"
      },
      "outputs": [
        {
          "Name": "output",
          "Selector": "$.Payload.output",
          "Type": "String"
        },
        {
          "Name": "error",
          "Selector": "$.Payload.err",
          "Type": "Boolean"
        }
      ],
      "isEnd": true
    }
  ]
}
