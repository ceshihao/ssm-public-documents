{
  "schemaVersion": "1.0",
  "description": "Get performance counters.",
  "sessionType": "InteractiveCommands",
  "parameters": {
    "CPU": {
      "type": "String",
      "default": "Yes",
      "description": "(Optional) Get CPU performance.",
      "allowedValues": [
        "Yes",
        "No"
      ]
    },
    "DriveRead": {
      "type": "String",
      "default": "Yes",
      "description": "(Optional) Get Drive Reads performance.",
      "allowedValues": [
        "Yes",
        "No"
      ]
    },
    "DriveWrite": {
      "type": "String",
      "default": "Yes",
      "description": "(Optional) Get Drive Writes performance.",
      "allowedValues": [
        "Yes",
        "No"
      ]
    },
    "NetworkSend": {
      "type": "String",
      "default": "Yes",
      "description": "(Optional) Get Network Sends performance.",
      "allowedValues": [
        "Yes",
        "No"
      ]
    },
    "NetworkReceive": {
      "type": "String",
      "default": "Yes",
      "description": "(Optional) Get Network Receive performance.",
      "allowedValues": [
        "Yes",
        "No"
      ]
    },
    "Memory": {
      "type": "String",
      "default": "Yes",
      "description": "(Optional) Get Memory performance.",
      "allowedValues": [
        "Yes",
        "No"
      ]
    },
    "PrintInteractiveStatements": {
      "type": "String",
      "description": "(Optional) If set to 'No', the execution will not print text that indicates a keystoke is required to continue execution.",
      "default": "No",
      "allowedValues": [
        "Yes",
        "No"
      ]
    }
  },
  "properties": {
    "windows": {
      "commands": "$ErrorActionPreference = 'Stop'\n\nFunction ParseInputParameter {\n    param (\n        [string]$Name,\n        [string]$Value,\n        [string]$Regex\n    )\n\n    $ValidParameterRegex = '^--%[ +{|{].*}( +)?$'\n    if ($Value -notmatch $ValidParameterRegex) {\n        ExitWithFailureMessage -Message \"Invalid syntax for the parameter $Name\"\n    }\n    $parameterValue = $Value.Substring(3)\n\n    $trimmedParameterValue = $parameterValue.TrimStart().TrimEnd()\n    $trimmedParameterValue = $trimmedParameterValue.Substring(1)\n    $trimmedParameterValue = $trimmedParameterValue.Substring(0, $trimmedParameterValue.Length - 1)\n\n    if ($Regex -and $trimmedParameterValue -notmatch $Regex) {\n        ExitWithFailureMessage -Message \"Invalid syntax for the parameter $Name\"\n    } else {\n        $trimmedParameterValue\n    }\n}\n\nfunction ExitWithFailureMessage {\n    param (\n        [string]$Message,\n        [string]$ExceptionMessage,\n        [Switch]$PrintJson\n    )\n    if ([string]::IsNullOrWhitespace($ExceptionMessage)) {\n        $errorMessage = $Message\n    } else {\n        $errorMessage = '{0} {1}' -f $Message, $ExceptionMessage\n    }\n    if ($PrintJson) {ConvertTo-Json -InputObject @{error = $errorMessage} -Compress}\n    WriteStandardError -Message $errorMessage\n    [System.Environment]::Exit(1)\n}\n\nfunction ExitWithSuccessMessage {\n    param (\n        [string]$Message\n    )\n    Write-Host $Message\n    [System.Environment]::Exit(0)\n}\n\nfunction WriteStandardError {\n    param (\n        [string]$Message\n    )\n    $Host.UI.WriteErrorLine($Message)\n}\n\n$CPU = Write-Output --%{{{ CPU }}}\n$CPU = ParseInputParameter -Name 'CPU' -Value $CPU -Regex '(Yes|No)'\n\n$DriveRead = Write-Output --%{{{ DriveRead }}}\n$DriveRead = ParseInputParameter -Name 'DriveRead' -Value $DriveRead -Regex '(Yes|No)'\n\n$DriveWrite = Write-Output --%{{{ DriveWrite }}}\n$DriveWrite = ParseInputParameter -Name 'DriveWrite' -Value $DriveWrite -Regex '(Yes|No)'\n\n$NetworkSend = Write-Output --%{{{ NetworkSend }}}\n$NetworkSend = ParseInputParameter -Name 'NetworkSend' -Value $NetworkSend -Regex '(Yes|No)'\n\n$NetworkReceive = Write-Output --%{{{ NetworkReceive }}}\n$NetworkReceive = ParseInputParameter -Name 'NetworkReceive' -Value $NetworkReceive -Regex '(Yes|No)'\n\n$Memory = Write-Output --%{{{ Memory }}}\n$Memory = ParseInputParameter -Name 'Memory' -Value $Memory -Regex '(Yes|No)'\n\n$PrintInteractiveStatements = Write-Output --%{{{ PrintInteractiveStatements }}}\n$PrintInteractiveStatements = ParseInputParameter -Name 'PrintInteractiveStatements' -Value $PrintInteractiveStatements -Regex '(Yes|No)'\n\n$Counters = New-Object -TypeName 'System.Collections.ArrayList'\n\nFunction UpdateCountersJson {\n    param(\n        [Parameter(Mandatory = $true)]\n        [string]$ValueName,\n        [Parameter(Mandatory = $true)]\n        [string]$Value,\n        [Parameter(Mandatory = $true)]\n        [string]$Unit,\n        [Parameter(Mandatory = $true)]\n        [string]$Device,\n        [Parameter(Mandatory = $true)]\n        [string]$Name\n    )\n\n    $Output = @( @{name = \"$ValueName\"; value = \"$Value\"; unit = \"$Unit\" } )\n    $CounterObj = $Counters | ConvertFrom-Json\n    $CounterObj.groups.$Device.counters.$Name += $Output\n    $CounterObj = ConvertTo-Json -InputObject $CounterObj -Depth 6 -Compress\n\n    return $CounterObj\n}\n\nFunction Main {\n    $null = $Counters.Clear()\n    [int]$Timestamp = Get-Date -UFormat %s\n\n    $Output = @{ 'timestamp' = \"$Timestamp\";\n        'groups' = @{\n            'cpus' = @{\n                'counters' = @{\n                    'total_cpu_utilization' = @();\n                }\n            }\n            'disks' = @{\n                'counters' = @{\n                    'total_disk_bytes_read_write' = @();\n                }\n            }\n            'ethernet_adapters' = @{\n                'counters' = @{\n                    'total_data_bytes_sent_received' = @();\n                }\n            }\n            'memory' = @{\n                'counters' = @{\n                    'total_memory_bytes_used' = @();\n                }\n            }\n        }\n    } | ConvertTo-Json -Depth 6 -Compress\n\n    $null = $Counters.Add(\"$Output\")\n\n    if ($CPU -eq 'Yes') {\n        $Processors = Get-CimInstance -Query 'select Name, PercentProcessorTime from Win32_PerfFormattedData_PerfOS_Processor'\n        $Unit = 'Percent'\n        $Device = 'cpus'\n        $Name = 'total_cpu_utilization'\n\n        foreach ($processor in $Processors) {\n            $ValueName = $processor.Name\n            if ($ValueName -like '_Total') {\n                $ValueName = 'total_cpu'\n                $Value = $processor.PercentProcessorTime\n                $Counters = UpdateCountersJson -Device $Device -Name $Name -ValueName $ValueName -Value $Value -Unit $Unit\n            }\n        }\n    }\n\n    if (($DriveRead -eq 'Yes') -or ($DriveWrite -eq 'Yes')) {\n        $Drivesinfo = Get-CimInstance -Query 'SELECT * from Win32_PerfFormattedData_PerfDisk_LogicalDisk'\n        $Unit = 'KilobytesSecond'\n        $Device = 'disks'\n        $Name = 'total_disk_bytes_read_write'\n\n        if ($DriveRead -eq 'Yes') {\n            $ValueName = 'total_drivereads'\n\n            foreach ($drive in $Drivesinfo) {\n                $DriveName = $drive.Name\n                if ($DriveName -like '_Total') {\n                    $Value = $drive.DiskReadBytesPersec / 1000\n                    $Counters = UpdateCountersJson -Device $Device -Name $Name -ValueName $ValueName -Value $Value -Unit $Unit\n                }\n            }\n        }\n\n        if ($DriveWrite -eq 'Yes') {\n            $ValueName = 'total_drivewrites'\n\n            foreach ($drive in $Drivesinfo) {\n                $DriveName = $drive.Name\n                if ($DriveName -like '_Total') {\n                    $Value = $drive.DiskWriteBytesPersec / 1000\n                    $Counters = UpdateCountersJson -Device $Device -Name $Name -ValueName $ValueName -Value $Value -Unit $Unit\n                }\n            }\n        }\n    }\n\n    if (($NetworkSend -eq 'Yes') -or ($NetworkReceive -eq 'Yes')) {\n        $Interfaces = ([System.Net.NetworkInformation.NetworkInterface]::GetAllNetworkInterfaces())\n        $Unit = 'KilobytesSecond'\n        $Device = 'ethernet_adapters'\n        $Name = 'total_data_bytes_sent_received'\n\n        foreach ($adapter in $Interfaces) {\n            $ValueSent0 = $adapter.GetIPStatistics().BytesSent / 1000\n            $ValueRecieved0 = $adapter.GetIPStatistics().BytesReceived / 1000\n            $TotalSent0 = $TotalSent0 + $ValueSent0\n            $TotalRecieved0 = $TotalRecieved0 + $ValueRecieved0\n        }\n\n        Start-Sleep -Seconds 1\n\n        if ($NetworkSend -eq 'Yes') {\n            $ValueName = 'total_datasent'\n\n            foreach ($adapter in $Interfaces) {\n                $Value = $adapter.GetIPStatistics().BytesSent / 1000\n                $TotalSent1 = $TotalSent1 + $Value\n            }\n\n            $TotalSent = $TotalSent1 - $TotalSent0\n            $Counters = UpdateCountersJson -ValueName $ValueName -Value $TotalSent -Unit $Unit -Device $Device -Name $Name\n        }\n\n        if ($NetworkReceive -eq 'Yes') {\n            $ValueName = 'total_datareceived'\n\n            foreach ($adapter in $Interfaces) {\n                $Value = $adapter.GetIPStatistics().BytesReceived / 1000\n                $TotalRecieved1 = $TotalRecieved1 + $Value\n            }\n\n            $TotalRecieved = $TotalRecieved1 - $TotalRecieved0\n            $Counters = UpdateCountersJson -ValueName $ValueName -Value $TotalRecieved -Unit $Unit -Device $Device -Name $Name\n        }\n\n    }\n\n    if ($Memory -eq 'Yes') {\n        $ComputerMemory = Get-CimInstance -ClassName win32_operatingsystem\n        $Name = 'total_memory_bytes_used'\n        $Device = 'memory'\n        $ValueName = 'memory_used'\n        $Unit = 'Megabytes'\n        $Value = ($ComputerMemory.TotalVisibleMemorySize - $ComputerMemory.FreePhysicalMemory) / 1024\n        $Counters = UpdateCountersJson -Device $Device -Name $Name -ValueName $ValueName -Value $Value -Unit $Unit\n    }\n\n    $Counters\n}\n\ndo {\n    Main\n    ''\n\n    if ($PrintInteractiveStatements -eq 'Yes') {\n        $continue = Read-Host -Prompt 'Press q to end loop, or any other key to continue ...'\n    } else {\n        $continue = Read-Host\n    }\n} while ($continue -ne 'q')\n",
      "runAsElevated": true
    },
    "linux": {
      "commands": "JQ=\"jq\"\nVERSION=\"1.6\"\nPRODUCT_PATH=\"/opt/amazon/ssm/fleet_manager\"\nJQ_BINARY=\"$PRODUCT_PATH/$JQ-$VERSION\"\n\nCheckSha256FileHash() {\n    FILE_PATH=\"$1\"\n    SHA256=\"$2\"\n\n    if [ -f \"$FILE_PATH\" ]; then\n        TEST=$(\"${command_path}echo\" \"$SHA256  $FILE_PATH\" | /usr/bin/sha256sum -c 2>&1) || return 1\n        return 0\n    fi\n\n    return 1\n}\n\nSetLockedDownPermissions() {\n    \"${command_path}chmod\" u+rwx \"$1\"\n    \"${command_path}chmod\" go-rwx \"$1\"\n    \"${command_path}chown\" \"$(/usr/bin/whoami)\":\"$(/usr/bin/id --group --name)\" \"$1\"\n}\n\nCreateLockedDownFolder() {\n    \"${command_path}mkdir\" -p \"$1\"\n    SetLockedDownPermissions \"$1\"\n}\n\nDownloadFile() {\n    SOURCE=\"$1\"\n    DESTINATION=\"$2\"\n    if [ -f /usr/bin/curl ]; then\n        /usr/bin/curl -s \"$SOURCE\" -o \"$DESTINATION\"\n    elif [ -f /usr/bin/wget ]; then\n        /usr/bin/wget -q \"$SOURCE\" -O \"$DESTINATION\"\n    else\n        ExitWithFailureMessage \"Unable to download the source using 'curl' or 'wget'. Failing execution.\" 'PRINT_JSON'\n    fi\n}\n\nGetJQSHA256Hash() {\n    case \"$1\" in\n        'aarch64')\n            \"${command_path}echo\" \"a6e84e979b91b26763c700d4ba6c616554444bbbf0cf1863e96611b0e68b88f2\"\n            ;;\n        'armv6l')\n            \"${command_path}echo\" \"4717f1350a963e5ae5446e61eb21e3936754f84dd13586d494dcd6b497b267c1\"\n            ;;\n        'armv7l')\n            \"${command_path}echo\" \"e097be6c7ef954d581a359ad2d7aa4ec19c89bd3b9ab55919c826a1d30373a5c\"\n            ;;\n        'i686')\n            \"${command_path}echo\" \"062902c5a177cb80866d556a07e10331d9f8b8b676ffb1b7cd2985a9c2e539c8\"\n            ;;\n        'x86_64')\n            \"${command_path}echo\" \"15d1d1b093481c737603247a785731b7f32f3b4dccd63f77186de8bfe4f6fd68\"\n            ;;\n        *)\n            ExitWithFailureMessage \"The CPU architecture '$1' is not supported. Failing execution.\" 'PRINT_JSON'\n            ;;\n    esac\n}\n\nRandomString() {\n    \"${command_path}cat\" /dev/urandom | /usr/bin/tr -dc 'a-zA-Z0-9' | /usr/bin/fold -w ${1:-32} | /usr/bin/head -n 1\n}\n\nInstallJQ() {\n    CreateLockedDownFolder \"$PRODUCT_PATH\"\n\n    CPU_ARCH=$(\"${command_path}uname\" -m)\n    JQ_SHA256=$(GetJQSHA256Hash \"$CPU_ARCH\")\n\n    CheckSha256FileHash \"$JQ_BINARY\" \"$JQ_SHA256\" || {\n        JQ_TEMP_BINARY=\"$PRODUCT_PATH/$(RandomString)\"\n\n        OS_NAME=$(\"${command_path}uname\" -s)\n        REGION=\"us-east-1\"\n        S3_BUCKET=\"aws-fleet-manager-artifacts-us-east-1\"\n        S3_DNS=\"s3.us-east-1.amazonaws.com\"\n        SOURCE=\"https://$S3_BUCKET.$S3_DNS/$JQ/$VERSION/$OS_NAME/$CPU_ARCH/$JQ\"\n        DownloadFile \"$SOURCE\" \"$JQ_TEMP_BINARY\"\n\n        CheckSha256FileHash \"$JQ_TEMP_BINARY\" \"$JQ_SHA256\" || {\n            \"${command_path}rm\" --force \"$JQ_TEMP_BINARY\"\n            ExitWithFailureMessage \"Downloading the $JQ binary failed. Failing execution.\"\n        }\n\n        \"${command_path}mv\" \"$JQ_TEMP_BINARY\" \"$JQ_BINARY\"\n    }\n\n    SetLockedDownPermissions \"$JQ_BINARY\"\n}\n\nInstallJQ\n\nMain () {\n    Counters=''\n\n    #Grab first dataset and sleep for one second, that way can properly get two datasets to figure out bytes per seconds\n    if [ \"$CPU\" = 'Yes' ] || [ \"$DriveRead\" = 'Yes' ] || [ \"$DriveWrite\" = 'Yes' ] || [ \"$NetworkSend\" = 'Yes' ] || [ \"$NetworkReceive\" = 'Yes' ]; then\n        while IFS= read -r cpuline; do\n            case \"$cpuline\" in\n                \"cpu \"*)\n                    totalidle0=$(\"${command_path}echo\" \"$cpuline\" | \"${command_path}grep\" -e 'cpu ' | /usr/bin/awk '{print $5+$6}')\n                    totalnoneidle0=$(\"${command_path}echo\" \"$cpuline\" | \"${command_path}grep\" -e 'cpu ' | /usr/bin/awk '{print $2+$3+$4+$7+$8+$9}')\n                    overalltotal0=$((totalidle0 + totalnoneidle0))\n                    ;;\n            esac\n        done <\"$cpustatfile\"\n\n        while IFS= read -r partitions; do\n            driveread0=$(\"${command_path}echo\" \"$partitions\" | \"${command_path}grep\" -e '[a-z][a-z][a-z][a-z] ' | /usr/bin/awk '{print $4}')\n            drivewritten0=$(\"${command_path}echo\" \"$partitions\" | \"${command_path}grep\" -e '[a-z][a-z][a-z][a-z] ' | /usr/bin/awk '{print $8}')\n            totalread0=$((totalread0 + driveread0))\n            totalwritten0=$((totalwritten0 + drivewritten0))\n        done <\"$diskstatfile\"\n\n        while IFS= read -r netline; do\n            case \"$netline\" in\n                *':'*)\n                    bytessent0=$(\"${command_path}echo\" \"$netline\" | /usr/bin/awk '{print $10}')\n                    bytesreceived0=$(\"${command_path}echo\" \"$netline\" | /usr/bin/awk '{print $2}')\n                    totalsent0=$((totalsent0 + bytessent0))\n                    totalreceived0=$((totalreceived0 + bytesreceived0))\n                    ;;\n            esac\n        done <\"$netstatfile\"\n\n        sleep 1\n    fi\n\n    timestamp=$(date +%s)\n    Counters=$(\"${command_path}echo\" \"[ $timestamp ]\" | \"$JQ_BINARY\" -c '{timestamp: .[0]}')\n\n    if [ \"$CPU\" = 'Yes' ]; then\n        cpuCounters=$(\"${command_path}echo\" '{\"groups\": {\"cpus\": {\"counters\": {\"total_cpu_utilization\": []}}}}' | \"$JQ_BINARY\" -c '.')\n        Counters=$(\"$JQ_BINARY\" -c --argjson Counters \"$Counters\" --argjson output \"$cpuCounters\" -n '$Counters * $output')\n\n        unit='Percent'\n        name='total_cpu'\n\n        while IFS= read -r cpuline; do\n            case \"$cpuline\" in\n                \"cpu \"*)\n                    idle1=$(\"${command_path}echo\" \"$cpuline\" | \"${command_path}grep\" -e 'cpu ' | /usr/bin/awk '{print $5+$6}')\n                    noneidle1=$(\"${command_path}echo\" \"$cpuline\" | \"${command_path}grep\" -e 'cpu ' | /usr/bin/awk '{print $2+$3+$4+$7+$8+$9}')\n                    overalltotal1=$((idle1 + noneidle1))\n                    totaldif=$((overalltotal1 - overalltotal0))\n                    ideldif=$((idle1 - totalidle0))\n                    value=\\\"\"$(\"${command_path}echo\" \"[$totaldif, $ideldif]\" | \"$JQ_BINARY\" -c '(1000*(.[0] - .[1])/.[0]/10)')\"\\\"\n                    output=$(\"${command_path}echo\" \"[ \\\"$name\\\", \"$value\", \\\"$unit\\\"]\" | \"$JQ_BINARY\" -c '{name: .[0], value: .[1], unit: .[2]}')\n                    Counters=$(\"${command_path}echo\" \"$Counters\" | \"$JQ_BINARY\" -c --argjson output \"$output\" '.groups.cpus.counters.total_cpu_utilization += [$output]')\n                    ;;\n            esac\n        done <\"$cpustatfile\"\n    fi\n\n    if [ \"$DriveRead\" = 'Yes' ] || [ \"$DriveWrite\" = 'Yes' ]; then\n        drivereadCounters=$(\"${command_path}echo\" '{\"groups\": {\"disks\": {\"counters\": {\"total_disk_bytes_read_write\": []}}}}' | \"$JQ_BINARY\" -c '.')\n        Counters=$(\"$JQ_BINARY\" -c --argjson Counters \"$Counters\" --argjson drivereadCounters \"$drivereadCounters\" -n '$Counters * $drivereadCounters')\n        unit='KilobytesSecond'\n\n        if [ \"$DriveRead\" = 'Yes' ]; then\n            while IFS= read -r partitions; do\n                driveread1=$(\"${command_path}echo\" \"$partitions\" | \"${command_path}grep\" -e '[a-z][a-z][a-z][a-z] ' | /usr/bin/awk '{print $4}')\n                totalread1=$((totalread1 + driveread1))\n            done <\"$diskstatfile\"\n\n            name='total_drivereads'\n            value=\\\"$(\"${command_path}echo\" \"[$totalread1, $totalread0]\" | \"$JQ_BINARY\" -c '((.[0] - .[1])/1000)')\\\"\n            output=$(\"${command_path}echo\" \"[ \\\"$name\\\", \"$value\", \\\"$unit\\\"]\" | \"$JQ_BINARY\" -c '{name: .[0], value: .[1], unit: .[2]}')\n            Counters=$(\"${command_path}echo\" \"$Counters\" | \"$JQ_BINARY\" -c --argjson output \"$output\" '.groups.disks.counters.total_disk_bytes_read_write += [$output]')\n        fi\n\n        if [ \"$DriveWrite\" = 'Yes' ]; then\n            while IFS= read -r partitions; do\n                drivewritten1=$(\"${command_path}echo\" \"$partitions\" | \"${command_path}grep\" -e '[a-z][a-z][a-z][a-z] ' | /usr/bin/awk '{print $8}')\n                totalwritten1=$((totalwritten1 + drivewritten1))\n            done <\"$diskstatfile\"\n\n            name='total_drivewrites'\n            value=\\\"$(\"${command_path}echo\" \"[$totalwritten1, $totalwritten0]\" | \"$JQ_BINARY\" -c '((.[0] - .[1])/1000)')\\\"\n            output=$(\"${command_path}echo\" \"[ \\\"$name\\\", \"$value\", \\\"$unit\\\"]\" | \"$JQ_BINARY\" -c '{name: .[0], value: .[1], unit: .[2]}')\n            Counters=$(\"${command_path}echo\" \"$Counters\" | \"$JQ_BINARY\" -c --argjson output \"$output\" '.groups.disks.counters.total_disk_bytes_read_write += [$output]')\n        fi\n    fi\n\n    if [ \"$NetworkSend\" = 'Yes' ] || [ \"$NetworkReceive\" = 'Yes' ]; then\n            netCounters=$(\"${command_path}echo\" '{\"groups\": {\"ethernet_adapters\": {\"counters\": {\"total_data_bytes_sent_received\": []}}}}' | \"$JQ_BINARY\" -c '.')\n            Counters=$(\"$JQ_BINARY\" -c --argjson Counters \"$Counters\" --argjson netCounters \"$netCounters\" -n '$Counters * $netCounters')\n            unit='KilobytesSecond'\n\n        if [ \"$NetworkSend\" = 'Yes' ]; then\n            while IFS= read -r netline; do\n                case \"$netline\" in\n                    *':'*)\n                        bytessent1=$(\"${command_path}echo\" \"$netline\" | /usr/bin/awk '{print $10}')\n                        totalsent1=$((totalsent1 + bytessent1))\n                        ;;\n                esac\n            done <\"$netstatfile\"\n\n            name='total_datasent'\n            value=\\\"$(\"${command_path}echo\" \"[$totalsent1, $totalsent0]\" | \"$JQ_BINARY\" -c '((.[0] - .[1])/1000)')\\\"\n            output=$(\"${command_path}echo\" \"[ \\\"$name\\\", \"$value\", \\\"$unit\\\"]\" | \"$JQ_BINARY\" -c '{name: .[0], value: .[1], unit: .[2]}')\n            Counters=$(\"${command_path}echo\" \"$Counters\" | \"$JQ_BINARY\" -c --argjson output \"$output\" '.groups.ethernet_adapters.counters.total_data_bytes_sent_received += [$output]')\n        fi\n\n        if [ \"$NetworkReceive\" = 'Yes' ]; then\n            while IFS= read -r netline; do\n                case \"$netline\" in\n                    *':'*)\n                        bytesreceived1=$(\"${command_path}echo\" \"$netline\" | /usr/bin/awk '{print $2}')\n                        totalreceived1=$((totalreceived1 + bytesreceived1))\n                        ;;\n                esac\n            done <\"$netstatfile\"\n\n            name='total_datareceived'\n            value=\\\"$(\"${command_path}echo\" \"[$totalreceived1, $totalreceived0]\" | \"$JQ_BINARY\" -c '((.[0] - .[1])/1000)')\\\"\n            output=$(\"${command_path}echo\" \"[ \\\"$name\\\", \"$value\", \\\"$unit\\\"]\" | \"$JQ_BINARY\" -c '{name: .[0], value: .[1], unit: .[2]}')\n            Counters=$(\"${command_path}echo\" \"$Counters\" | \"$JQ_BINARY\" -c --argjson output \"$output\" '.groups.ethernet_adapters.counters.total_data_bytes_sent_received += [$output]')\n        fi\n\n    fi\n\n    if [ \"$Memory\" = 'Yes' ]; then\n        memCounters=$(\"${command_path}echo\" '{\"groups\": {\"memory\": {\"counters\": {\"total_memory_bytes_used\": []}}}}' | \"$JQ_BINARY\" -c '.')\n        Counters=$(\"$JQ_BINARY\" -c --argjson Counters \"$Counters\" --argjson memCounters \"$memCounters\" -n '$Counters * $memCounters')\n        name='memory_used'\n        unit='Megabytes'\n        meminfo=$(\"${command_path}cat\" /proc/meminfo)\n        total=$(\"${command_path}echo\" \"$meminfo\" | \"${command_path}grep\" -e '^MemTotal' | /usr/bin/awk '{print $2}')\n        available=$(\"${command_path}echo\" \"$meminfo\" | \"${command_path}grep\" -e '^MemAvailable' | /usr/bin/awk '{print $2}')\n        value=\\\"$(\"${command_path}echo\" \"[$total, $available]\" | \"$JQ_BINARY\" -c '((.[0] - .[1])/1024)')\\\"\n        output=$(\"${command_path}echo\" \"[ \\\"$name\\\", \"$value\", \\\"$unit\\\"]\" | \"$JQ_BINARY\" -c '{name: .[0], value: .[1], unit: .[2]}')\n        Counters=$(\"${command_path}echo\" \"$Counters\" | \"$JQ_BINARY\" -c --argjson output \"$output\" '.groups.memory.counters.total_memory_bytes_used += [$output]')\n    fi\n\n    \"${command_path}echo\" \"$Counters\"\n}\n\nCPU='{{ CPU }}'\nDriveRead='{{ DriveRead }}'\nDriveWrite='{{ DriveWrite }}'\nNetworkSend='{{ NetworkSend }}'\nNetworkReceive='{{ NetworkReceive }}'\nMemory='{{ Memory }}'\nPrintInteractiveStatements='{{ PrintInteractiveStatements }}'\n\ncpustatfile='/proc/stat'\ndiskstatfile='/proc/diskstats'\nnetstatfile='/proc/net/dev'\n\nwhile [ \"$Reply\" != 'q' ]; do\n    Main\n    \"${command_path}echo\"\n\n    if [ \"$PrintInteractiveStatements\" = 'Yes' ]; then\n        /usr/bin/printf 'Press q to end loop, or any other key to continue ...'\n    fi\n\n    read -r Reply\ndone\n",
      "runAsElevated": true
    }
  }
}
