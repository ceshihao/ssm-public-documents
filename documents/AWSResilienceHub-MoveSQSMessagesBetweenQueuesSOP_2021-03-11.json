{
  "description": "## Id\nAWSResilienceHub-MoveSQSMessagesBetweenQueuesSOP_2021-03-11\n\n## Intent\nMoves messages from one queue to another. Can be used to restore messages from Dead Letter queue back to main operation one or visa versa\n\n## Type\nSOP\n\n## Risk\nMedium\n\n## Requirements\n  * Source SQS Queue, with queue policy that allows sendMessage, recieveMessage and deleteMessage actions\n  * Target SQS Queue, with queue policy that allows sendMessage, recieveMessage and deleteMessage actions\n\n## Permissions required for AutomationAssumeRole\n  * sqs:SendMessage\n  * sqs:DeleteMessage\n  * sqs:ReceiveMessage\n  * sqs:GetQueueAttributes\n\n##### In case queues are encrypted with a KMS key\n  * kms:GenerateDataKey\n  * kms:Decrypt\n  * kms:Encrypt\n\n##### To write logs to CloudWatch\n  * logs:CreateLogStream\n  * logs:PutLogEvents\n  * logs:DescribeLogGroups\n  * logs:DescribeLogStreams\n\n## Cancellation behavior\nFail\n\n## Inputs\n### (Required) AutomationAssumeRole\n  * type: String\n  * description: ARN of the IAM role with permissions listed above\n\n### (Required) SourceQueueUrl\n  * type: String\n  * description: The URL of the source SQS Queue\n\n### (Required) TargetQueueUrl\n  * type: String\n  * description: The URL of the target SQS Queue\n\n### (Required) NumberOfMessagesToTransfer\n  * type: Integer\n  * description: The number of messages to be sent\n\n### (Optional) MessagesTransferBatchSize\n  * type: Integer\n  * description: The number of messages that going to be transferred per batch. Maximum is 10\n  * default: 10\n\n### (Optional) ForceExecution\n  * type: Boolean\n  * description: (Optional) If True, validation of input parameters will be skipped\n  * default: false\n\n## Details\nThis document reads the specified number of messages from the source queue, attempts to send them to the\ntarget queue, and then deletes sent messages from the source queue.\nRe-executing this document can lead to duplicate messages in the target queue if the message was not successfully transferred during the previous attempt.\nNumber of messages, latency (e.g. cross-region transfer) and message size can lead to a significant time for transferring messages. Since there is a hard cap of 10 minutes for executeScript action, the script would automatically stop after 9 minutes and report on how many messages have been sent so far.\nValidates if given 'Source' and 'Target' queues are different types (FIFO, Standard). If so, the script will throw an error. Customers can suppress the validation by passing `ForceExecution` parameter.\nBear in mind that in case of FIFO queue, messages might be re-ordered while being transferred to the target one.\n\n## Steps executed in normal flow\n  * RecordStartTime\n  * TransferMessages\n  * OutputRecoveryTime\n\n## Outputs\n### OutputRecoveryTime.RecoveryTime\n  * type: Integer\n  * description: SOP execution time in seconds\n\n### TransferMessages.TimeElapsed\n  * type: String\n  * description: Time in seconds elapsed during message transfer\n\n### TransferMessages.NumberOfMessagesTransferredToTarget\n  * type: Integer\n  * description: Number of messages transfered to target\n\n### TransferMessages.NumberOfMessagesFailedToSendToTarget\n  * type: Integer\n  * description: Number of messages failed to be moved to target\n\n### TransferMessages.NumberOfMessagesFailedToDeleteFromSource\n  * type: Integer\n  * description: Number of messages failed to be removed from source after transfer",
  "schemaVersion": "0.3",
  "assumeRole": "{{AutomationAssumeRole}}",
  "parameters": {
    "SourceQueueUrl": {
      "type": "String",
      "description": "(Required) The URL of the source SQS Queue."
    },
    "TargetQueueUrl": {
      "type": "String",
      "description": "(Required) The URL of the target SQS Queue."
    },
    "NumberOfMessagesToTransfer": {
      "type": "Integer",
      "description": "(Required) The number of messages to be sent."
    },
    "MessagesTransferBatchSize": {
      "type": "Integer",
      "description": "(Optional) The number of messages that going to be transferred per batch. Maximum is 10",
      "default": 10
    },
    "ForceExecution": {
      "type": "Boolean",
      "description": "(Optional) Specifies whether to execute the Automation without validation of input parameters",
      "default": false
    },
    "AutomationAssumeRole": {
      "type": "String",
      "description": "(Required) The ARN of the role that allows Automation to perform the actions on your behalf."
    }
  },
  "outputs": [
    "OutputRecoveryTime.RecoveryTime",
    "TransferMessages.NumberOfMessagesTransferredToTarget",
    "TransferMessages.NumberOfMessagesFailedToSendToTarget",
    "TransferMessages.NumberOfMessagesFailedToDeleteFromSource",
    "TransferMessages.TimeElapsed"
  ],
  "mainSteps": [
    {
      "name": "RecordStartTime",
      "description": "Start recording execution time",
      "action": "aws:executeScript",
      "outputs": [
        {
          "Name": "StartTime",
          "Selector": "$.Payload",
          "Type": "String"
        }
      ],
      "inputs": {
        "Runtime": "python3.8",
        "Handler": "start_time",
        "Script": "import logging\nimport time\nfrom datetime import datetime, timezone\n\nimport boto3\nfrom botocore.exceptions import ClientError\nfrom dateutil import parser\n\nlogger = logging.getLogger()\nlogger.setLevel(logging.INFO)\n\n\n\ndef start_time(events, context):\n    return datetime.now(timezone.utc).isoformat()"
      }
    },
    {
      "name": "TransferMessages",
      "description": "Execute script that reads messages from source source, sends them to target source, confirms that messages were received and removes them from source afterwards. Returns the number of messages moved, failed, and failed to be removed from source but transferred to target.",
      "action": "aws:executeScript",
      "outputs": [
        {
          "Name": "NumberOfMessagesTransferredToTarget",
          "Selector": "$.Payload.NumberOfMessagesTransferredToTarget",
          "Type": "Integer"
        },
        {
          "Name": "NumberOfMessagesFailedToSendToTarget",
          "Selector": "$.Payload.NumberOfMessagesFailedToSendToTarget",
          "Type": "Integer"
        },
        {
          "Name": "NumberOfMessagesFailedToDeleteFromSource",
          "Selector": "$.Payload.NumberOfMessagesFailedToDeleteFromSource",
          "Type": "Integer"
        },
        {
          "Name": "TimeElapsed",
          "Selector": "$.Payload.TimeElapsed",
          "Type": "String"
        }
      ],
      "inputs": {
        "Runtime": "python3.7",
        "Handler": "transfer_messages",
        "InputPayload": {
          "SourceQueueUrl": "{{SourceQueueUrl}}",
          "TargetQueueUrl": "{{TargetQueueUrl}}",
          "NumberOfMessagesToTransfer": "{{NumberOfMessagesToTransfer}}",
          "MessagesTransferBatchSize": "{{MessagesTransferBatchSize}}",
          "ForceExecution": "{{ForceExecution}}"
        },
        "Script": "import json\nimport logging\nimport random\nimport time\nimport uuid\nfrom datetime import datetime\nfrom typing import Callable, List, Optional\n\nimport boto3\nfrom botocore.config import Config\nfrom botocore.exceptions import ClientError\n\nlogger = logging.getLogger()\nlogger.setLevel(logging.INFO)\n\n\n\n\ndef transform_messages(messages: List[dict], transform_message_function: Callable) -> List[dict]:\n    \"\"\"\n    Transform all messages\n    :param messages: messages to transform\n    :param transform_message_function: method to transform one message\n    :return: transformed messages\n    \"\"\"\n    transformed_messages: List[dict] = []\n    for message in messages:\n        message = transform_message_function(message)\n        transformed_messages.append(message)\n    return transformed_messages\n\n\n\ndef transform_message_and_attributes(message: dict) -> dict:\n    \"\"\"\n    General method to transform one message\n    :param message: Message to transform\n    :return: transformed message\n    \"\"\"\n    message_to_send = {'Id': message.get('MessageId'),\n                       'MessageBody': message.get('Body')}\n    if message.get('MessageAttributes') is not None:\n        message_to_send['MessageAttributes'] = message.get('MessageAttributes')\n    attributes = message.get('Attributes')\n    if attributes is not None:\n        aws_trace_header = attributes.get('AWSTraceHeader')\n        if aws_trace_header is not None:\n            message_to_send['MessageSystemAttributes'] = \\\n                {'AWSTraceHeader': {'StringValue': aws_trace_header,\n                                    'DataType': 'String'}}\n    return message_to_send\n\n\n\ndef transform_message_from_fifo_to_fifo(message: dict) -> dict:\n    \"\"\"\n    Transform one message from FIFO to FIFO\n    :param message: Message to transform\n    :return: transformed message\n    \"\"\"\n    message_to_send = transform_message_and_attributes(message)\n\n    attributes = message.get('Attributes')\n    if attributes is not None:\n        message_to_send['MessageDeduplicationId'] = attributes.get('MessageDeduplicationId')\n        message_to_send['MessageGroupId'] = str(attributes.get('MessageGroupId'))\n    return message_to_send\n\n\n\ndef transform_message_from_standard_to_fifo(message: dict) -> dict:\n    \"\"\"\n    Transform one message from Standard to FIFO\n    :param message: Message to transform\n    :return: transformed message\n    \"\"\"\n    message_to_send = transform_message_and_attributes(message)\n    message_to_send['MessageDeduplicationId'] = str(uuid.uuid4())\n    message_to_send['MessageGroupId'] = str(uuid.uuid4())\n    return message_to_send\n\n\n\ndef send_messages(messages_to_send: List[dict], target_queue_url: str) -> dict:\n    \"\"\"\n    Send messages by batch operation\n    :param messages_to_send: messages to send\n    :param target_queue_url: URL of the queue to send\n    :return: response of send_message_batch method\n    \"\"\"\n    config = Config(retries={'max_attempts': 20, 'mode': 'standard'})\n    sqs_client = boto3.client(\"sqs\", config=config)\n    send_message_batch_response: dict = sqs_client.send_message_batch(QueueUrl=target_queue_url,\n                                                                      Entries=messages_to_send)\n    return send_message_batch_response\n\n\n\ndef receive_messages(source_queue_url: str, messages_transfer_batch_size: int, wait_timeout: int = 0) -> \\\n        Optional[List[dict]]:\n    \"\"\"\n    Receive messages\n    :param wait_timeout: The duration i seconds for which the call waits for a message to arrive in the queue\n    :param messages_transfer_batch_size: how many messages to receive\n    :param source_queue_url:  URL of the queue where from messages are received\n    :return: response of receive_message method\n    \"\"\"\n    config = Config(retries={'max_attempts': 20, 'mode': 'standard'})\n    sqs_client = boto3.client(\"sqs\", config=config)\n    receive_message_response: dict = \\\n        sqs_client.receive_message(QueueUrl=source_queue_url,\n                                   MaxNumberOfMessages=messages_transfer_batch_size,\n                                   WaitTimeSeconds=wait_timeout,\n                                   MessageAttributeNames=['All'],\n                                   AttributeNames=['All'])\n    return receive_message_response.get('Messages')\n\n\n\ndef transfer_messages(events: dict, context: dict) -> dict:\n    \"\"\"\n    Move received_messages from one queue to another.\n    \"\"\"\n    if \"SourceQueueUrl\" not in events or \"TargetQueueUrl\" not in events \\\n            or \"NumberOfMessagesToTransfer\" not in events or \"ForceExecution\" not in events \\\n            or \"MessagesTransferBatchSize\" not in events:\n        raise KeyError(\"Requires SourceQueueUrl and TargetQueueUrl and NumberOfMessagesToTransfer and \"\n                       \"MessagesTransferBatchSize and ForceExecution in events\")\n    config = Config(retries={'max_attempts': 20, 'mode': 'standard'})\n    sqs_client = boto3.client(\"sqs\", config=config)\n    start_execution = datetime.utcnow()\n\n    source_queue_url: str = events['SourceQueueUrl']\n    target_queue_url: str = events['TargetQueueUrl']\n    force_execution: bool = bool(events['ForceExecution'])\n    number_of_messages_to_transfer: int = int(events['NumberOfMessagesToTransfer'])\n    messages_transfer_batch_size: int = int(events['MessagesTransferBatchSize'])\n\n    is_source_queue_fifo: bool = is_queue_fifo(source_queue_url, sqs_client)\n    is_target_queue_fifo: bool = is_queue_fifo(target_queue_url, sqs_client)\n\n    if force_execution is False and is_source_queue_fifo != is_target_queue_fifo:\n        raise ValueError(f'The source queue and target queue have different types when ForceExecution '\n                         f'parameter is {force_execution}: ')\n\n    number_of_messages_transferred_to_target = 0\n    number_of_messages_failed_to_send_to_target = 0\n    number_of_messages_failed_to_delete_from_source = 0\n    start = now = int(time.time())\n    max_duration_seconds = 9 * 60\n    loop_count = 1\n    number_of_messages_received_from_source = 0\n\n    if number_of_messages_to_transfer == 0:\n        return get_statistics(loop_count, now, number_of_messages_failed_to_delete_from_source,\n                              number_of_messages_failed_to_send_to_target,\n                              number_of_messages_transferred_to_target, source_queue_url, start,\n                              start_execution, max_duration_seconds)\n\n    while number_of_messages_received_from_source < number_of_messages_to_transfer \\\n            and (now - start) < max_duration_seconds:\n        logger.debug(f'Entered into loop #{loop_count} '\n                     f'with number_of_messages_transferred_to_target < number_of_messages_to_transfer = '\n                     f'{number_of_messages_transferred_to_target} < {number_of_messages_to_transfer}, '\n                     f'(now - start) < max_duration_seconds = {now - start} < {max_duration_seconds}')\n\n        messages_transfer_batch_size_for_each_call = \\\n            min((number_of_messages_to_transfer - number_of_messages_received_from_source),\n                messages_transfer_batch_size)\n\n        received_messages: Optional[List[dict]] = receive_messages(\n            source_queue_url, messages_transfer_batch_size_for_each_call, 5\n        )\n        if not received_messages:\n            logger.debug('Received no messages from source, repeating')\n            now = int(time.time())\n            continue\n\n        number_of_messages_received_from_source += len(received_messages)\n\n        messages_to_send: List[dict] = []\n        if is_source_queue_fifo and is_target_queue_fifo:  # If both queues are FIFO\n            messages_to_send = transform_messages(received_messages, transform_message_from_fifo_to_fifo)\n        elif not is_source_queue_fifo and not is_target_queue_fifo:  # If both queues are standard\n            messages_to_send = transform_messages(received_messages, transform_message_and_attributes)\n        elif is_source_queue_fifo and not is_target_queue_fifo:\n            messages_to_send = transform_messages(received_messages, transform_message_and_attributes)\n        elif not is_source_queue_fifo and is_target_queue_fifo:\n            messages_to_send = transform_messages(received_messages, transform_message_from_standard_to_fifo)\n\n        send_message_batch_response: dict = send_messages(messages_to_send, target_queue_url)\n        successfully_sent_results = send_message_batch_response.get('Successful')\n        if successfully_sent_results is not None:\n            successfully_sent_results_number = len(successfully_sent_results)\n            logger.info(f'Succeed to send {successfully_sent_results_number} message(-s) '\n                        f'during the loop #{loop_count}: '\n                        f'{successfully_sent_results}')\n\n            message_id_to_receipt_handle = {message.get('MessageId'): message.get('ReceiptHandle')\n                                            for message in received_messages}\n            delete_message_entries: List = [{'Id': result.get('Id'),\n                                             'ReceiptHandle': message_id_to_receipt_handle.get(result.get('Id'))}\n                                            for result in successfully_sent_results]\n            delete_message_batch_response: dict = sqs_client.delete_message_batch(QueueUrl=source_queue_url,\n                                                                                  Entries=delete_message_entries)\n            failed_delete_messages: List[dict] = delete_message_batch_response.get('Failed')\n            if failed_delete_messages is not None:\n                failed_delete_messages_number = len(failed_delete_messages)\n                logger.info(f'Failed to delete {failed_delete_messages_number} message(-s) '\n                            f'during the loop #{loop_count}: '\n                            f'{failed_delete_messages}')\n                number_of_messages_failed_to_delete_from_source += failed_delete_messages_number\n\n            succeed_delete_messages = delete_message_batch_response.get('Successful')\n            if succeed_delete_messages is not None:\n                logger.info(f'Succeed to delete {len(succeed_delete_messages)} message(-s) '\n                            f'during the loop #{loop_count}: '\n                            f'{succeed_delete_messages}')\n                number_of_messages_transferred_to_target += len(succeed_delete_messages)\n\n        failed_send_results: dict = send_message_batch_response.get('Failed')\n        if failed_send_results is not None:\n            failed_send_results_number = len(failed_send_results)\n            logger.info(f'Failed to send {failed_send_results_number} message(-s) '\n                        f'during the loop #{loop_count}: '\n                        f'{failed_send_results}')\n            number_of_messages_failed_to_send_to_target += failed_send_results_number\n\n        now = int(time.time())\n        loop_count += 1\n\n    return get_statistics(loop_count, now, number_of_messages_failed_to_delete_from_source,\n                          number_of_messages_failed_to_send_to_target,\n                          number_of_messages_transferred_to_target, source_queue_url, start,\n                          start_execution, max_duration_seconds)\n\n\n\ndef get_statistics(loop_count: int, now, number_of_messages_failed_to_delete_from_source: int,\n                   number_of_messages_failed_to_send_to_target: int,\n                   number_of_messages_transferred_to_target: int,\n                   source_queue_url: str, start, start_execution, max_duration_seconds: int):\n    statistics = {'NumberOfMessagesTransferredToTarget': number_of_messages_transferred_to_target,\n                  'NumberOfMessagesFailedToDeleteFromSource':\n                      number_of_messages_failed_to_delete_from_source,\n                  'NumberOfMessagesFailedToSendToTarget': number_of_messages_failed_to_send_to_target,\n                  'TimeElapsed': str((datetime.utcnow() - start_execution).total_seconds())}\n    logger.info(f'Quiting the loop to receive the messages from source queue with URL = {source_queue_url} '\n                f'because there are no messages received during the loop #{loop_count} and {(now - start)} '\n                f'second(-s) of script\\'s execution or the maximum time in {max_duration_seconds} was elapsed. '\n                f'Statistics: {statistics}')\n    return statistics\n\n\n\ndef is_queue_fifo(queue_url: str, sqs_client):\n    try:\n        sqs_client.get_queue_attributes(QueueUrl=queue_url, AttributeNames=['FifoQueue'])\n    except ClientError as e:\n        if e.response['Error']['Code'] == 'InvalidAttributeName':\n            logger.info(f'The queue with url = {queue_url} is not a FIFO')\n            return False\n        else:\n            logger.error(e)\n            raise e\n    return True"
      }
    },
    {
      "name": "OutputRecoveryTime",
      "description": "Calculate execution time",
      "action": "aws:executeScript",
      "outputs": [
        {
          "Name": "RecoveryTime",
          "Selector": "$.Payload",
          "Type": "Integer"
        }
      ],
      "inputs": {
        "Runtime": "python3.8",
        "Handler": "recovery_time",
        "Script": "import logging\nimport time\nfrom datetime import datetime, timezone\n\nimport boto3\nfrom botocore.exceptions import ClientError\nfrom dateutil import parser\n\nlogger = logging.getLogger()\nlogger.setLevel(logging.INFO)\n\n\n\ndef recovery_time(events, context):\n    return (datetime.now(timezone.utc) - parser.parse(events['StartTime'])).seconds",
        "InputPayload": {
          "StartTime": "{{ RecordStartTime.StartTime }}"
        }
      }
    }
  ]
}
