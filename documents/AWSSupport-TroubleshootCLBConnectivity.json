{
  "description": "The **AWSSupport-TroubleshootCLBConnectivity** runbook helps you troubleshoot connectivity issues between an AWS Classic Load Balancer (CLB) and its registered Amazon Elastic Compute Cloud (Amazon EC2) instances. This runbook also reviews health checks for the CLB, verifies that best practices are being followed, and creates an Amazon CloudWatch troubleshooting dashboard for you. You can optionally upload the automation output to a specified Amazon Simple Storage Service (Amazon S3) bucket. To help with the security of the data gathered from the automation, the automation evaluates the Amazon S3 bucket configuration to determine if the bucket grants public `read` or `write` access permissions, and it is owned by the AWS account of the user or IAM role in which the Automation runs. If your Amazon S3 bucket uses server-side encryption with AWS Key Management Service keys (SSE-KMS), make sure the user or AWS Identity and Access Management (IAM) role being used to run this automation has the `kms:GenerateDataKey` permissions on the AWS KMS key.\n\n### Important\nCharges are incurred when you exceed the CloudWatch dashboards free tier. For more information, see [Amazon CloudWatch Pricing](https://aws.amazon.com/cloudwatch/pricing/).\n###",
  "schemaVersion": "0.3",
  "assumeRole": "{{ AutomationAssumeRole }}",
  "outputs": [
    "RunBestPractices.Summary",
    "RunConnectivityChecks.Summary",
    "CreateTroubleshootingDashboard.Output",
    "UploadOutputToS3.Output"
  ],
  "parameters": {
    "LoadBalancerName": {
      "type": "String",
      "description": "(Required) The name of the AWS Classic Load Balancer (CLB).",
      "allowedPattern": "^(?![\\- ])[a-zA-Z0-9][a-zA-Z0-9\\s\\-]{1,32}(?<!\\-)$"
    },
    "InvestigationType": {
      "type": "String",
      "allowedValues": [
        "Connectivity Issues",
        "Best Practices",
        "Troubleshooting Dashboard"
      ],
      "description": "(Required) The operation you want the runbook to perform."
    },
    "AutomationAssumeRole": {
      "type": "AWS::IAM::Role::Arn",
      "description": "(Optional) The Amazon Resource Name (ARN) of the AWS Identity and Access Management (IAM) role that allows Systems Manager Automation to perform the actions on your behalf. If no role is specified, Systems Manager Automation uses the permissions of the user that starts this runbook.",
      "default": ""
    },
    "S3Location": {
      "type": "AWS::S3::Bucket::Name",
      "description": "(Optional) The name of the Amazon Simple Storage Service (Amazon S3) bucket you want to send the automation results to. Verify the bucket policy and ACLs do not grant any unnecessary read or write permissions to principals that do not need access to the contents of the bucket. We recommend creating a new temporary Amazon S3 bucket for the purpose of this automation.",
      "default": ""
    },
    "S3LocationPrefix": {
      "type": "String",
      "description": "(Optional) The Amazon S3 object path in the Amazon S3 bucket. For example, if you specify 'CollectedLogs', the results will be uploaded to 's3://DOC-EXAMPLE-BUCKET/CollectedLogs/{{InvestigationType}}_{{automation:EXECUTION_ID}}.txt'.",
      "default": "",
      "allowedPattern": "^$|^[a-zA-Z0-9\\.\\-_\\\\!*'()/]{1,256}$"
    }
  },
  "mainSteps": [
    {
      "name": "VerifyLoadBalancerName",
      "action": "aws:executeScript",
      "description": "Verifies that the CLB you specify in the \"LoadBalancerName\" parameter exists.",
      "inputs": {
        "Runtime": "python3.8",
        "Handler": "validate_inputs",
        "Script": "# Copyright 2022 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n# SPDX-License-Identifier: LicenseRef-.amazon.com.-AmznSL-1.0\n# Licensed under the Amazon Software License  http://aws.amazon.com/asl/\n\nimport sys\nimport boto3\nfrom lib.helper import handle_aws_api\n\nsys.tracebacklimit = 0\nelb_client = boto3.client('elb')\n\ndef validate_inputs(events, context=None):\n\n    clb_name = events['LoadBalancerName']\n    \n    # handle_aws_api() implements AWS API exception handling\n    handle_aws_api(\n        elb_client.describe_load_balancers,\n        LoadBalancerNames = [clb_name]\n    )\n\n\n",
        "InputPayload": {
          "LoadBalancerName": "{{LoadBalancerName}}"
        },
        "Attachment": "attachment.zip"
      }
    },
    {
      "name": "BranchOnInvestigationType",
      "action": "aws:branch",
      "description": "Branches based on the value specified for the \"InvestigationType\" parameter.",
      "inputs": {
        "Choices": [
          {
            "NextStep": "RunConnectivityChecks",
            "Variable": "{{ InvestigationType }}",
            "StringEquals": "Connectivity Issues"
          },
          {
            "NextStep": "RunBestPractices",
            "Variable": "{{ InvestigationType }}",
            "StringEquals": "Best Practices"
          },
          {
            "NextStep": "CreateTroubleshootingDashboard",
            "Variable": "{{ InvestigationType }}",
            "StringEquals": "Troubleshooting Dashboard"
          }
        ]
      }
    },
    {
      "name": "RunConnectivityChecks",
      "action": "aws:executeScript",
      "description": "Performs connectivity checks to the CLB. Details on connectivity will be included in the action output.",
      "inputs": {
        "Runtime": "python3.8",
        "Handler": "run_connectivity_checks",
        "Script": "# Copyright 2022 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n# SPDX-License-Identifier: LicenseRef-.amazon.com.-AmznSL-1.0\n# Licensed under the Amazon Software License  http://aws.amazon.com/asl/\n\nimport re\nimport sys\nfrom lib.messages import (INFO_MESSAGE, _insert_status)\nfrom lib.helper import fetch_lb_assoc_info, fetch_lb_info\nfrom lib.network import (\n    validate_subnets, \n    validate_subnets_ephemeral, \n    validate_sgs, \n    check_for_igw\n)\n\ndef run_connectivity_checks(events, context=None):\n    \n    resp = fetch_lb_info(events[\"LoadBalancerName\"])\n    load_balancer, vpc = resp[\"EnvCLB\"], resp[\"EnvVpc\"]\n\n    env_info = fetch_lb_assoc_info(load_balancer)\n    enis, instances = env_info[\"ENIs\"], env_info[\"Instances\"]\n    subnet_map = env_info[\"SubnetMap\"]\n    rtb_map = env_info[\"RTBMap\"]\n\n    # https://docs.aws.amazon.com/elasticloadbalancing/latest/classic/elb-internet-facing-load-balancers.html\n    # IPv6 communciation between LB + Target Instances not supported. Keep track of resources that only have IPv6 configured\n    ipv6_resources = env_info[\"IPV6\"]\n\n    health_dst = load_balancer[\"HealthCheck\"][\"Target\"]\n    health_ports = re.findall('[0-9]+', health_dst)\n    if not health_ports:\n        raise Exception(_insert_status(\"FAIL\", \"Invalid health check port configuration tied to CLB. No port numbers returned. Exiting...\"))\n    \n    health_port = int(health_ports[0])\n    backend_ports = { obj[\"Listener\"][\"InstancePort\"] for obj in load_balancer[\"ListenerDescriptions\"] }.union({health_port})\n    front_ports =  { obj[\"Listener\"][\"LoadBalancerPort\"] for obj in load_balancer[\"ListenerDescriptions\"] }\n    \n    cross_zone = load_balancer.get(\"CrossZoneLoadBalancing\")\n    if not cross_zone:\n        raise Exception(_insert_status(\"FAIL\", \"Invalid cross-zone configuration. Cross-zone is not found on the response output (should reflect enabled/disabled). Exiting...\"))\n    cross_zone = cross_zone[\"Enabled\"]\n\n    vpc_cidr = vpc[\"CidrBlock\"]\n    listener_subnets = [ subnet_map[eni[\"SubnetId\"]] for eni in enis ]\n    instance_subnets = [ subnet_map[instance[\"SubnetId\"]] for instance in instances ]\n\n    # Create dummy representations of Outbound + Inbound SGs/ACLs for Internal/External LB scheme\n    external_cidr = vpc_cidr if load_balancer[\"Scheme\"] == \"internal\" else \"0.0.0.0/0\"\n    external_dst_acl_repr = [ { \"CidrBlock\": external_cidr } ]\n    external_dst_sg_repr  = [ { \"PrivateIpAddress\": external_cidr } ]\n\n    listener_to_instance_acl_check = validate_subnets(listener_subnets, instance_subnets, backend_ports, cross_zone, \"Outbound\")\n    instance_to_listener_acl_check = validate_subnets(instance_subnets, listener_subnets, backend_ports, cross_zone, \"Inbound\")\n    outside_to_listener_acl_check  = validate_subnets(listener_subnets, external_dst_acl_repr, front_ports, True, \"Inbound\")\n\n    listener_empeheral_acl_check_outbound = validate_subnets_ephemeral(listener_subnets, instance_subnets, \"Outbound\")\n    listener_empeheral_acl_check_inbound  = validate_subnets_ephemeral(listener_subnets, instance_subnets, \"Inbound\")\n    instance_empeheral_acl_check_outbound = validate_subnets_ephemeral(instance_subnets, listener_subnets, \"Outbound\")\n\n    listener_outbound_sg_check = validate_sgs(enis, instances, backend_ports, True, \"Outbound\")\n    instance_inbound_sg_check  = validate_sgs(instances, enis, backend_ports, cross_zone, \"Inbound\")\n    listener_inbound_sg_check  = validate_sgs(enis, external_dst_sg_repr, front_ports, True, \"Inbound\")\n\n    # For LB Scheme, if Internet-Facing check if there are routes to an IGW\n    igw_route = None\n    if load_balancer[\"Scheme\"] == \"internet-facing\":\n        rtb_ids   = { rtb_id for subnet in listener_subnets for rtb_id in subnet[\"RouteTableIds\"] }\n        igw_route = check_for_igw( [(rtb_id, rtb_map[rtb_id]) for rtb_id in rtb_ids] )\n        # check_for_igw returns (rtb_with_igw, rtb_no_igw)\n    print(igw_route)\n    acl_results = [\n        listener_to_instance_acl_check,\n        instance_to_listener_acl_check,\n        outside_to_listener_acl_check\n    ]\n    acl_ephemeral_results = [\n        listener_empeheral_acl_check_outbound,\n        listener_empeheral_acl_check_inbound,\n        instance_empeheral_acl_check_outbound,\n    ]\n    sg_results = [\n        listener_outbound_sg_check,\n        instance_inbound_sg_check,\n        listener_inbound_sg_check\n    ]\n    igw_results = igw_route\n\n    _, summary, detailed = generate_report(acl_results, acl_ephemeral_results, sg_results, igw_results, ipv6_resources)\n\n    return { \"Summary\": summary, \"Detailed\": detailed }\n    \ndef generate_report(acl_checks, acl_ephemeral_checks, sg_checks, igw_checks, ipv6_resources):\n\n    def case_repr(condition, content):\n        return _insert_status(condition, f\"{list(content)}\")\n\n    def ipv6_resources_skipped(test_name, ipv6_resources):\n        report = \"\"\n        for resource_type, resource_ids in ipv6_resources.items():\n            report += \"\\n  - {}: {}\".format(resource_type, resource_ids if resource_ids else \"None\")\n        report = \"\\n{0}:\\n{1}\".format(test_name, report)\n        return report\n\n    def sg_result_analysis(test_name, sg_results):\n        \n        report = \"\"\n        ports, sgs, cidrs = set(), set(), set()\n        for resource_id, results in sg_results.items():\n            results = \"\"\n            for port, fails in sg_results[resource_id].items():\n                cidr_checks = fails[\"CidrCheckFails\"]\n                group_checks = fails[\"GroupCheckFails\"]\n                results += \"  - Destination CIDR checks PASS on port {0}? {1:>{width}} {2}\\n\".format(port, \"=>\", case_repr(not bool(cidr_checks), cidr_checks), width=7-len(str(port))) \n                results += \"  - Destination security group ID checks PASS on port {0}? {1:>{width}} {2}\\n\".format(port, \"=>\", case_repr(not bool(group_checks), group_checks), width=7-len(str(port)))\n\n                if cidr_checks != set():\n                    ports.add(port)\n                    cidrs = cidrs.union(cidr_checks)\n                if group_checks != set():\n                    ports.add(port)\n                    sgs = sgs.union(group_checks)\n\n            report += \"- Checks for {0!r}:\\n{1}\\n\".format(resource_id, results)\n        report = \"\\n{0}:\\n{1}\".format(test_name, report)\n        return report, [list(ports), list(sgs), list(cidrs)]\n\n    def acl_result_analysis(test_name, acl_results):\n\n        report = \"\"\n        ports, cidrs = set(), set()\n        for resource_id, results in acl_results.items():\n            results = \"\"\n            for port, fails in acl_results[resource_id].items():\n                acl_checks = fails[\"StdACLCheckFails\"]\n                results += \"  - ACL Checks PASS on port {0}? {1:>{width}} {2}\\n\".format(port, \"=>\", case_repr(not bool(acl_checks), acl_checks), width=7-len(str(port)))\n\n                if acl_checks != set():\n                    ports.add(port)\n                    cidrs = cidrs.union(acl_checks)\n    \n            report += \"- Checks for {0!r}:\\n{1}\\n\".format(resource_id, results)\n        report = \"\\n{0}:\\n{1}\".format(test_name, report)\n        return report, [list(ports), list(cidrs)]\n\n    def acl_ephemeral_result_analysis(test_name, acl_ephemeral_results):\n\n        report = \"\"\n        cidrs = set()\n        for resource_id, results in acl_ephemeral_results.items():\n            ephemeral_checks = acl_ephemeral_results[resource_id][\"EphemeralACLCheckFails\"]\n            report += \"- Checks for {0!r}:\\n\".format(resource_id)\n            report += \"  - Ephemeral ACL Checks PASS? => {0}\\n\\n\".format(case_repr(not bool(ephemeral_checks), ephemeral_checks))\n\n            if ephemeral_checks != set():\n                cidrs = cidrs.union(ephemeral_checks)\n    \n        report = \"\\n{0}:\\n{1}\\n\".format(test_name, report)\n        return report, [list(cidrs)]\n\n    acl_results = []\n    acl_results.append(acl_result_analysis(\"Listener-to-Target Instance ACL Results\", acl_checks[0]))\n    acl_results.append(acl_result_analysis(\"Instance-to-Listener ACL Results\", acl_checks[1]))\n    acl_results.append(acl_result_analysis(\"Outside-to-Listener Instance ACL Results\", acl_checks[2]))\n    \n    acl_ephem_results = []\n    acl_ephem_results.append(acl_ephemeral_result_analysis(\"Listener Ephemeral Outbound ACL Results\", acl_ephemeral_checks[0]))\n    acl_ephem_results.append(acl_ephemeral_result_analysis(\"Listener Ephemeral Inbound ACL Results\", acl_ephemeral_checks[1]))\n    acl_ephem_results.append(acl_ephemeral_result_analysis(\"Instance Ephemeral Outbound ACL Results\", acl_ephemeral_checks[2]))\n\n    sg_results = []\n    sg_results.append(sg_result_analysis(\"Load Balancer Outbound Security Groups\", sg_checks[0]))\n    sg_results.append(sg_result_analysis(\"Instances Inbound Security Groups\", sg_checks[1]))\n    sg_results.append(sg_result_analysis(\"Load Balancer Inbound Security Groups\", sg_checks[2]))\n\n    def summary():\n        \n        ipv6_instances = ipv6_resources[\"Instances\"]\n        ipv6_subnets = ipv6_resources[\"Subnets\"]\n\n        acl_condensed = [result[1] for result in acl_results]\n        acl_ephem_condensed = [result[1] for result in acl_ephem_results]\n        sg_condensed = [result[1] for result in sg_results]\n        \n        summary_report = \"Summary\".center(50, \"=\") + \"\\n\"\n\n        acl_report = \"\"\n        acl_status = False # Assume no errors had occurred by default\n        ports = set(sum([result[0] for result in acl_condensed], [])) or None\n        cidrs = set(sum([result[1] for result in acl_condensed], [])) or None\n\n        acl_status = bool(acl_status or ports)\n        if not ports and not ipv6_subnets:\n            acl_report = \"{0}\".format(INFO_MESSAGE.get(\"NET_CHECK_01\"))\n        else: \n            acl_report = \"{0}\\n\".format(INFO_MESSAGE.get(\"NET_CHECK_05\"))\n            acl_report += f\"  - Network ports found to be blocked: {ports}\\n\"\n            acl_report += f\"  - Destination CIDRs/IPs found to be unreachable: {cidrs}\\n\" if cidrs else \"\"\n            acl_report += f\"  - IPV6 Only EC2 Instances which are unreachable by default: {ipv6_subnets}\\n\" if ipv6_subnets else \"\"\n        \n        acl_ephem_report = \"\"\n        acl_ephem_status = False\n        cidrs = set(sum([result[0] for result in acl_ephem_condensed], [])) or None\n\n        acl_ephem_status = bool(acl_ephem_status or cidrs)\n        if not cidrs and not ipv6_subnets:\n            acl_ephem_report = \"{0}\".format(INFO_MESSAGE.get(\"NET_CHECK_02\"))\n        else:\n            acl_ephem_report = \"{0}\\n\".format(INFO_MESSAGE.get(\"NET_CHECK_06\"))\n            acl_ephem_report += f\"  - Destination CIDRs/IPs found to be unreachable: {cidrs}\\n\" if cidrs else \"\"\n            acl_ephem_report += f\"  - IPV6 Only Subnets containing IPv6-only resources: {ipv6_subnets}\\n\" if ipv6_subnets else \"\"\n\n        sg_report = \"\"\n        sg_status = False\n        ports = set(sum([result[0] for result in sg_condensed], [])) or None\n        sgs = set(sum([result[1] for result in sg_condensed], [])) or None\n        cidrs = set(sum([result[2] for result in sg_condensed], [])) or None\n    \n        sg_status = bool(sg_status or ports)\n        if not ports and not ipv6_instances:\n            sg_report = \"{0}\".format(INFO_MESSAGE.get(\"NET_CHECK_03\"))\n        else: \n            sg_report = \"{0}\\n\".format(INFO_MESSAGE.get(\"NET_CHECK_07\"))\n            sg_report += f\"  - Network ports found to be blocked: {ports}\\n\"\n            sg_report += f\"  - Destination security groups found to be unreachable: {sgs}\\n\" if sgs else \"\"\n            sg_report += f\"  - Destination CIDRs/IPs found to be unreachable: {cidrs}\\n\" if cidrs else \"\"\n            sg_report += f\"  - IPV6 Only EC2 Instances which are unreachable by default: {ipv6_instances}\\n\" if ipv6_instances else \"\"\n\n        igw_report = \"\"\n        igw_status = False\n        if igw_checks:\n            igw_status = bool(igw_status or igw_checks[0])\n            if igw_checks[0]:\n                igw_report = \"{0}\".format(INFO_MESSAGE.get(\"NET_CHECK_04\"))\n            else:\n                igw_report = \"{0}\\n\".format(INFO_MESSAGE.get(\"NET_CHECK_08\"))\n                igw_report += f\"  - Listener routes that do not have a path to the Internet Gateway (IGW): {igw_checks[1]}\\n\"\n\n        overall_status = bool(acl_status or acl_ephem_status or sg_status or igw_status)\n\n        summary_report += \"- {0}\\n\".format(acl_report)\n        summary_report += \"- {0}\\n\".format(acl_ephem_report)\n        summary_report += \"- {0}\\n\".format(sg_report)\n        summary_report += \"- {0}\\n\".format(igw_report) if igw_report else \"\"\n        summary_report += \"\\n\"\n\n        if acl_status or acl_ephem_status:\n            summary_report += \"- {0}\\n\".format(INFO_MESSAGE.get(\"NET_SUGGESTION_01\"))\n        if sg_status:\n            summary_report += \"- {0}\\n\".format(INFO_MESSAGE.get(\"NET_SUGGESTION_02\"))\n        if ipv6_instances or ipv6_subnets: # Need to add rest of IPv6 later. Temporary placeholder until better IPv6 blocker checks are implemented\n            summary_report += \"- {0}\\n\".format(INFO_MESSAGE.get(\"NET_SUGGESTION_03\"))\n\n\n        return overall_status, summary_report\n\n    def detailed():\n        ipv6_report = \"IPv6 Resources Skipped\".center(50, \"=\")\n        result = ipv6_resources_skipped(\"IPv6 Resources Skipped\", ipv6_resources)\n        ipv6_report += result\n        std_acl_report = \"Standard Network ACL Tests\".center(50, \"=\")\n        for result in acl_results:\n            std_acl_report += result[0]\n        ephem_acl_report = \"Ephemeral ACL Tests\".center(50, \"=\")\n        for result in acl_ephem_results:\n            ephem_acl_report += result[0]\n        sg_report = \"Security Group Tests\".center(50, \"=\")\n        for result in sg_results:\n            sg_report += result[0]\n\n        detailed_report = \"{}\\n{}\\n{}\\n{}\\n\".format(ipv6_report, std_acl_report, ephem_acl_report, sg_report)\n\n        return detailed_report\n\n    overall_status, summary_report = summary()\n    detailed_report = detailed()\n\n    return overall_status, summary_report, detailed_report\n",
        "InputPayload": {
          "LoadBalancerName": "{{ LoadBalancerName }}"
        },
        "Attachment": "attachment.zip"
      },
      "outputs": [
        {
          "Name": "Summary",
          "Selector": "$.Payload.Summary",
          "Type": "String"
        },
        {
          "Name": "Detailed",
          "Selector": "$.Payload.Detailed",
          "Type": "String"
        }
      ],
      "nextStep": "BranchOnS3Location"
    },
    {
      "name": "RunBestPractices",
      "action": "aws:executeScript",
      "description": "Verifies that the CLB configuration adheres to Elastic Load Balancing best practices.",
      "inputs": {
        "Runtime": "python3.8",
        "Handler": "best_prac",
        "Script": "# Copyright 2022 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n# SPDX-License-Identifier: LicenseRef-.amazon.com.-AmznSL-1.0\n# Licensed under the Amazon Software License  http://aws.amazon.com/asl/\n\nimport boto3\nimport sys\nfrom lib.helper import fetch_lb_info, handle_aws_api\nfrom lib.messages import _STATUS\n\nec2_client = boto3.client(\"ec2\")\nelb_client = boto3.client(\"elb\")\n\ndef best_prac(events, context=None):\n\n    report = \"\"\n    try:\n        global ELB \n        global elb_client \n\n        resp = fetch_lb_info(events[\"LoadBalancerName\"])\n\n        elbInfo = resp[\"EnvCLB\"]\n        \n        ELB = events[\"LoadBalancerName\"]\n\n        report += \"{0}\\n\".format(access_logs_check(elbInfo))\n        report += \"{0}\\n\".format(securelistener_check(elbInfo))\n        report += \"{0}\\n\".format(num_subnet_check(elbInfo))\n        report += \"\\n\"\n\n        return { \"Summary\": report }\n\n    except Exception as e:\n        raise Exception(f\"Error: An error ocurred when checking Elastic Load Balancing best practices: {str(e)}\")\n  \ndef access_logs_check(elbInfo):\n\n    try:\n        report = \"Access Logs Check\".center(50, \"=\") + \"\\n\"\n        if elbInfo['AccessLog'][\"Enabled\"]:\n            report += \"- {} Access logs are Enabled on the Load Balancer. \\n\\n\".format(_STATUS['PASS'])\n            report += \"  - Access Logs Details:\\n\"\n            report += \"    - Emit Interval: {} minutes\\n\".format(elbInfo['AccessLog']['EmitInterval'])\n            report += \"    - Bucket Location: {}\\n\".format(elbInfo['AccessLog']['S3BucketName'])\n            \n            bucket_prefix = elbInfo['AccessLog'][\"S3BucketPrefix\"]\n            if bucket_prefix:\n                report += \"/{}\".format(bucket_prefix)\n\n            report += \"\\n\"\n        else:\n            report += \"- {} Access logs are Not Enabled on the Load Balancer.\\n\".format(_STATUS['FAIL'])\n\n        return report\n\n    except Exception as e:\n        raise Exception(\"Error: An error occurred when accesing the logs - {}\\n\".format(str(e)))\n\ndef securelistener_check(elbInfo):\n\n    predefined_ssl_policies = handle_aws_api(elb_client.describe_load_balancer_policies)[\"PolicyDescriptions\"]\n    predefined_ssl_policies = [policy[\"PolicyName\"] for policy in predefined_ssl_policies if policy[\"PolicyTypeName\"] == \"SSLNegotiationPolicyType\"]\n\n    latest_ssl_policies = [\n        \"ELBSecurityPolicy-TLS-1-2-2017-01\",\n        \"ELBSecurityPolicy-TLS-1-1-2017-01\"\n    ]\n    \n    report = \"Secure Listener and Security Policies Check\".center(50, \"=\") + \"\\n\"\n\n    secure = False\n    for listener in elbInfo[\"ListenerDescriptions\"]:\n\n        if listener[\"Listener\"][\"Protocol\"] in [\"HTTPS\",\"SSL\",\"TLS\"]:\n            secure = True\n            report += \"- Secure Listener present for protocol {} and port {}\\n\".format((listener[\"Listener\"][\"Protocol\"]),(listener[\"Listener\"][\"LoadBalancerPort\"]))\n\n            policies = listener[\"PolicyNames\"]\n            elb_listener_policy_info = handle_aws_api(elb_client.describe_load_balancer_policies,\n                LoadBalancerName=ELB,\n                PolicyNames=policies\n            )[\"PolicyDescriptions\"][0]\n\n            # Original implementation assumes 0th index is the Reference-Security-Policy (non-custom, pre-defined policy). Following original\n            ref_policy_attr = elb_listener_policy_info[\"PolicyAttributeDescriptions\"][0]\n            if ref_policy_attr[\"AttributeName\"] == \"Reference-Security-Policy\":\n                if ref_policy_attr['AttributeValue'] not in latest_ssl_policies:\n                    report += \"-   {} Outdated pre-defined security policy attached to the listener: {}.\\n\".format(_STATUS['FAIL'], ref_policy_attr['AttributeValue'])\n                else:\n                    report += \"-   {} Your balancer is using the Latest Security Policy for this listener.\\n\".format(_STATUS['PASS'])\n            else:\n                report += \"-   {} Your balancer is using custom security policy. This tool only checks pre-defined security policies.\\n\".format(_STATUS['FAIL'])\n\n    if secure == False:\n        report += \"- {} Your balancer does not have a secure listener. Traffic from the client to ELB will be in plain text.\\n\".format(_STATUS['FAIL'])\n\n    return report\n\ndef crosszone_enable_check(elbInfo, one_enabled_AZ):\n\n    report = \"\"\n    if one_enabled_AZ == False:\n        if (elbInfo[\"CrossZoneLoadBalancing\"][\"Enabled\"]) == True:\n            report += \"- {} Cross-zone is enabled.\\n\".format(_STATUS['PASS'])\n        else:\n            report += \"- {} Cross-zone is disabled. It is recommended to enable cross-zone for higher availability.\\n\".format(_STATUS['FAIL'])\n\n    return report\n\n# Check if there are backends in only one AZ. This will be checked only if the ELB has more than one AZ enabled\ndef backends_in_oneAZ_check(elbInfo):\n\n    report = \"\"\n\n    elb_AZ1 = []\n    backend_subnet = {}\n    backend_AZ_subnet = {}\n    backend_AZ_instanceID = {}\n    backend_subnet_AZ = {}\n    instanceID_healthstatus = {}\n    backend_instance_ids_inenabledAZ = []\n    backend_instance_ids = [ instance[\"InstanceId\"] for instance in elbInfo[\"Instances\"] ]\n\n    page_iterator = handle_aws_api(ec2_client.get_paginator(\"describe_instances\").paginate,\n        InstanceIds=backend_instance_ids\n    )\n    for page in page_iterator:\n        for reservation in page[\"Reservations\"]:\n            for instance_info in reservation[\"Instances\"]:\n                backend_subnet[instance_info[\"InstanceId\"]] = instance_info[\"SubnetId\"]\n\n    subnet_backend = {n:[k for k in backend_subnet.keys() if backend_subnet[k] == n] for n in set(backend_subnet.values())}\n    \n    page_iterator = handle_aws_api(ec2_client.get_paginator(\"describe_subnets\").paginate,\n        SubnetIds=elbInfo['Subnets']\n    )\n\n    page_iterator = handle_aws_api(ec2_client.get_paginator(\"describe_subnets\").paginate,\n        SubnetIds=list(subnet_backend.keys())\n    )\n    for page in page_iterator:\n        for subnet in page['Subnets']:\n            backend_subnet_AZ[subnet[\"SubnetId\"]] = subnet[\"AvailabilityZone\"]\n            elb_AZ1.append(subnet[\"AvailabilityZone\"])\n        \n    backend_AZ_subnet = {n:[k for k in backend_subnet_AZ.keys() if backend_subnet_AZ[k] == n] for n in set(backend_subnet_AZ.values())}\n    for AZ in elb_AZ1:\n        for sub in backend_AZ_subnet[AZ]:\n            for instance in subnet_backend[sub]:\n                backend_AZ_instanceID.setdefault(AZ,[]).append(instance)\n\n    for instance_list in backend_AZ_instanceID.values():\n        for instance in instance_list:\n            backend_instance_ids_inenabledAZ.append(instance)\n\n    instance_healths = handle_aws_api(elb_client.describe_instance_health, \n        LoadBalancerName = ELB,\n        Instances=[{\"InstanceId\": instance} for instance in backend_instance_ids_inenabledAZ]\n    )[\"InstanceStates\"]\n    instanceID_healthstatus = { instance[\"InstanceId\"]: instance[\"State\"] for instance in instance_healths }\n\n    for AZ in backend_AZ_instanceID:\n\n        instance_state_perAZ = {}\n        for instance in backend_AZ_instanceID[AZ]:\n            instance_state_perAZ[instance] = instanceID_healthstatus[instance]\n\n        if \"InService\" in instance_state_perAZ.values():\n            report += f\"- {_STATUS['PASS']} Availability zone (AZ): {AZ} has at least one healthy backend EC2 instance.\\n\"\n        else:\n            report += f\"- {_STATUS['FAIL']} Availability zone (AZ): {AZ} contains no healthy backend EC2 instances.\\n\"\n    \n    return report\n\ndef num_subnet_check(elbInfo):\n\n    report = \"High Availability Check\".center(50, \"=\") + \"\\n\"\n\n    one_enabled_AZ = False\n\n    if len(elbInfo['Subnets']) == 1:\n        report += f\"- {_STATUS['FAIL']} You have only one subnet ({elbInfo['Subnets'][0]}) associated with the CLB in AZ: {elbInfo['AvailabilityZones'][0]}. As a best practice, you should have at least two subnets in different availability zones to provide higher availability for your load balancer.\\n\"\n        one_enabled_AZ = True\n\n    else:\n        report += f\"- {_STATUS['PASS']} More than one subnet ({ *elbInfo['Subnets'][:-1], }, and {elbInfo['Subnets'][-1]}) associated with the CLB.\\n\"\n\n    report += \"{0}\".format(crosszone_enable_check(elbInfo, one_enabled_AZ))\n    report += \"{0}\".format(backends_in_oneAZ_check(elbInfo))\n\n    return report\n",
        "InputPayload": {
          "LoadBalancerName": "{{ LoadBalancerName }}"
        },
        "Attachment": "attachment.zip"
      },
      "outputs": [
        {
          "Name": "Summary",
          "Selector": "$.Payload.Summary",
          "Type": "String"
        }
      ],
      "nextStep": "BranchOnS3Location"
    },
    {
      "name": "CreateTroubleshootingDashboard",
      "action": "aws:executeScript",
      "inputs": {
        "Runtime": "python3.8",
        "Handler": "cw_dashboards",
        "Script": "# Copyright 2022 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n# SPDX-License-Identifier: LicenseRef-.amazon.com.-AmznSL-1.0\n# Licensed under the Amazon Software License  http://aws.amazon.com/asl/\n\n\nimport boto3\nimport json\nfrom lib.helper import fetch_lb_info, handle_aws_api\n\ndef cw_dashboards(events, context):\n    \n    try:\n        global elbInfo\n        global ELB\n\n        resp = fetch_lb_info(events['LoadBalancerName'])\n        elbInfo = resp['EnvCLB']\n        ELB = events['LoadBalancerName']\n\n        elb_5xx_error_metrics = [\"HTTPCode_ELB_5XX\", \"HTTPCode_Backend_5XX\", \"RequestCount\", \"Latency\", \"SurgeQueueLength\", \"SpilloverCount\", \"UnHealthyHostCount\", \"HealthyHostCount\"]\n        elb_latency_metrics = [\"Latency\", \"RequestCount\", \"HealthyHostCount\", \"UnHealthyHostCount\", \"SurgeQueueLength\"]\n        elb_4xx_error_metrics = [\"HTTPCode_ELB_4XX\", \"HTTPCode_Backend_4XX\", \"SurgeQueueLength\"]\n        elb_health_check_metrics = [\"HealthyHostCount\", \"UnHealthyHostCount\", \"Latency\", \"BackendConnectionErrors\", \"RequestCount\"]\n\n        common_props = {\"type\": \"text\",\"x\": 6,\"y\": 0,\"width\": 12,\"height\": 6 }\n\n        elb_5xx_markdown_widget = {**common_props, \"properties\": {\"markdown\": \"\\n## Troubleshooting ELB 5XX Errors\\n\\n&nbsp;\\n### 504 Gateway_Timeout Errors:\\n* Recommended Metrics to check\\n\\nMetric Name | Relevant Statistics | Dimensions\\n----|----|----\\nHTTPCode_ELB_5XX | Sum | ELB, Per AZ\\nHTTPCode_Backend_5XX | Sum | ELB, Per AZ\\nRequestCount | Sum | ELB, Per AZ\\nLatency | Maximum | ELB, Per AZ\\nBackendConnectionErrors | Sum | ELB, Per AZ\\n\\n&nbsp;\\n* Documentation:\\n     * [Troubleshooting HTTP 504 Errors](https://aws.amazon.com/premiumsupport/knowledge-center/504-error-classic/)\\n\\n&nbsp;\\n### 503 Service_Unavailable Errors:\\n* Recommended Metrics to check\\n\\nMetric Name | Relevant Statistics | Dimensions\\n----|----|----\\nHTTPCode_ELB_5XX | Sum | ELB, Per AZ\\nHTTPCode_Backend_5XX | Sum | ELB, Per AZ\\nRequestCount | Sum | ELB, Per AZ\\nSurgeQueueLength | Maximum | ELB, Per AZ\\nSpilloverCount | Sum | ELB, Per AZ\\nHealthyHostCount | Average, Minimum, Maximum | ELB, Per AZ\\nUnHealthyHostCount | Average, Maximum, Minimum | ELB, Per AZ\\n\\n&nbsp;\\n* Documentation:\\n  * [Troubleshooting 503 Service_Unavailable Errors](https://aws.amazon.com/premiumsupport/knowledge-center/503-error-classic/)\\n\\n&nbsp;\\n### 502 Bad_Gateway Errors:\\n* Recommended Metrics to check\\n\\nMetric Name | Relevant Statistics | Dimensions\\n----|----|----\\nHTTPCode_ELB_5XX | Sum | ELB, Per AZ\\nHTTPCode_Backend_5XX | Sum | ELB, Per AZ\\nRequestCount | Sum | ELB, Per AZ\\n\\n&nbsp;\\n* Documentation:\\n  * [Troubleshooting 502 Service_Unavailable Errors](https://aws.amazon.com/premiumsupport/knowledge-center/load-balancer-http-502-errors/)\\n\"}}\n        dash_5xx_name = \"5XX_Errors\"\n        clb_5xx_errors = create_dashboard(elb_5xx_error_metrics, elb_5xx_markdown_widget, dash_5xx_name, context)\n\n        dash_latency_name = \"Latency\"\n        elb_latency_markdown_widget = {**common_props, \"properties\": {\"markdown\": \"\\n## Troubleshooting ELB Latency Issues\\n* Recommended Metrics to check\\n\\nMetric Name | Relevant Statistics | Dimensions\\n----|----|----\\nLatency | Average, Maximum | ELB, Per Az\\nRequestCount | Sum | ELB, Per AZ\\nHealthyHostCount | Average, Minimum, Maximum | ELB, Per AZ\\nUnHealthyHostCount | Average, Maximum, Minimum | ELB, Per AZ\\nSurgeQueueLength | Sum | ELB, Per AZ\\n\\n&nbsp;\\n* Documentation:\\n     * [Troubleshooting Latency Issues](https://aws.amazon.com/premiumsupport/knowledge-center/elb-latency-troubleshooting/)\\n\"}}\n        clb_latency = create_dashboard(elb_latency_metrics, elb_latency_markdown_widget, dash_latency_name, context)\n\n        dash_4xx_name = \"4XX_Errors\"\n        elb_4xx_markdown_widget = {**common_props, \"properties\": {\"markdown\": \"\\n## Troubleshooting ELB 4XX Errors\\n* Recommended Metrics to check\\n\\nMetric Name | Relevant Statistics | Dimensions\\n----|----|----\\nHTTPCode_ELB_4XX | Sum | ELB, Per AZ\\nHTTPCode_Backend_4XX | Sum | ELB, Per AZ\\nSurgeQueueLength (Helpful in 408 error) | Sum | ELB, Per AZ\\n\\n&nbsp;\\n* Documentation:\\n     * [Troubleshooting Latency Issues](https://docs.aws.amazon.com/elasticloadbalancing/latest/classic/ts-elb-error-message.html)\\n\"}}\n        clb_4xx_errors = create_dashboard(elb_4xx_error_metrics, elb_4xx_markdown_widget, dash_4xx_name, context)\n\n        dash_healthcheck_name = \"Health_Check\"\n        elb_healthcheck_markdown_widget = {**common_props, \"properties\": {\"markdown\": \"\\n## Troubleshooting ELB Health Check Issues\\n* Recommended Metrics to check\\n\\nMetric Name | Relevant Statistics | Dimensions\\n----|----|----\\nHealthyHostCount | Average, Minimum, Maximum | ELB, Per AZ\\nUnHealthyHostCount | Average, Maximum, Minimum | ELB, Per AZ\\nLatency | Average, Maximum | ELB, Per AZ\\nBackendConnectionErrors | Sum | ELB, Per AZ\\nRequestCount | Sum | ELB, Per AZ\\n\\n&nbsp;\\n* Documentation:\\n     * [Troubleshooting Health Check Issues](https://docs.aws.amazon.com/elasticloadbalancing/latest/classic/ts-elb-healthcheck.html/)\\n\"}}\n        clb_healthcheck = create_dashboard(elb_health_check_metrics, elb_healthcheck_markdown_widget, dash_healthcheck_name, context)\n\n        return { \"Output\": { \"5XX_Errors\": clb_5xx_errors, \"4XX_Errors\": clb_4xx_errors, \"Latency\": clb_latency, \"Health_Check\": clb_healthcheck } }\n    \n    except Exception as e:\n        raise Exception(f'Error: An error ocurred when creating the CloudWatch Dashboard: {str(e)}')\n\n\ndef create_dashboard(metric_list, markdown_widget, dash_name, context):\n    \n    cw_client  = boto3.client(\"cloudwatch\")\n    ec2_client = boto3.client(\"ec2\")\n    \n    dash_widgets = []\n    x, y          = [0, 0]\n    width, height = [12, 6]\n    max_width     = 12\n    dash_widgets.append(markdown_widget)\n    x = 0\n    y = 6\n    \n    ELB_AZs = []\n    region = context['global:REGION']\n    partition = context['global:AWS_PARTITION']\n\n    for subnets in elbInfo['Subnets']:\n\n        subnet_describe = handle_aws_api(ec2_client.describe_subnets,\n            SubnetIds=[subnets]\n        )\n\n        ELB_AZs.append(subnet_describe['Subnets'][0]['AvailabilityZone'])\n\n    \n    for i in metric_list:\n\n        metric_value = [ [\"AWS/ELB\", i , \"LoadBalancerName\", ELB] ]\n        for AZ in ELB_AZs:\n            metric_value.append([ \"AWS/ELB\", i , \"LoadBalancerName\", ELB, \"AvailabilityZone\", AZ ])\n\n        if (i == \"Latency\") or (i == \"UnHealthyHostCount\") or (i == \"SurgeQueueLength\"):\n            metric_widget = { \n                \"type\": \"metric\", \n                \"x\": x, \n                \"y\": y, \n                \"width\": width, \n                \"height\": height, \n                \"properties\": {\n                    \"metrics\": metric_value, \n                    \"view\": \"timeSeries\", \n                    \"stacked\": False, \n                    \"period\": 60, \n                    \"stat\": \"Maximum\", \n                    \"region\": region, \n                    \"title\": f\"{i} (Maximum)\" \n                }\n            }\n\n        elif (i == \"HealthyHostCount\"):\n            metric_widget = { \n                \"type\": \"metric\", \n                \"x\": x, \n                \"y\": y, \n                \"width\": width, \n                \"height\":height, \n                \"properties\": { \n                    \"metrics\": metric_value, \n                    \"view\": \"timeSeries\", \n                    \"stacked\": False, \n                    \"period\": 60, \n                    \"stat\":\"Minimum\", \n                    \"region\": region, \n                    \"title\": f\"{i} (Minimum)\"\n                }\n            }\n\n        else:\n            metric_widget = { \n                \"type\": \"metric\", \n                \"x\": x, \n                \"y\": y, \n                \"width\": width, \n                \"height\": height, \n                \"properties\": { \n                    \"metrics\": metric_value, \n                    \"view\": \"timeSeries\", \n                    \"stacked\": False, \n                    \"period\": 60, \n                    \"stat\": \"Sum\", \n                    \"region\": region, \n                    \"title\": f\"{i} (Sum)\"\n                }\n            }\n\n\n        x += width\n        if (x  > max_width):\n           x = 0\n           y += height\n\n        dash_widgets.append(metric_widget)\n        \n    elb_body = {'widgets' : dash_widgets}\n    elb_body_json = json.dumps(elb_body)\n\n    elb_dashboard_name = ELB + \"_\" + dash_name + \"_Analysis\"\n\n    handle_aws_api(cw_client.put_dashboard,\n        DashboardName = elb_dashboard_name,\n        DashboardBody = elb_body_json\n    )\n\n\n    region_link = {\n        \"aws\": \"{0}.console.aws.amazon.com/cloudwatch/home?region={0}\",\n        \"aws-us-gov\": \"{0}.console.amazonaws-us-gov.com/cloudwatch/home?region={0}\",\n        \"aws-cn\": \"{0}.console.amazonaws.cn/cloudwatch/home?region={0}\"\n    }\n    \n    return 'https://{}#dashboards:name={}'.format(region_link[partition].format(region), elb_dashboard_name)\n",
        "InputPayload": {
          "LoadBalancerName": "{{ LoadBalancerName }}"
        },
        "Attachment": "attachment.zip"
      },
      "outputs": [
        {
          "Name": "Output",
          "Selector": "$.Payload.Output",
          "Type": "StringMap"
        }
      ],
      "description": "Creates an Amazon CloudWatch dashboard for your CLB.",
      "nextStep": "BranchOnS3Location"
    },
    {
      "name": "BranchOnS3Location",
      "action": "aws:branch",
      "description": "Branches the workflow based on whether you provided a value for the \"S3Location\" parameter.",
      "isEnd": true,
      "inputs": {
        "Choices": [
          {
            "Not": {
              "Variable": "{{ S3Location }}",
              "StringEquals": ""
            },
            "NextStep": "GetS3BucketPublicStatus"
          }
        ]
      }
    },
    {
      "name": "GetS3BucketPublicStatus",
      "description": "Checks if the Amazon S3 bucket specified in the \"S3Location\" allows anonymous, or public read or write access permissions.",
      "action": "aws:executeScript",
      "timeoutSeconds": 300,
      "inputs": {
        "Runtime": "python3.8",
        "Handler": "is_bucket_public",
        "Script": "# Copyright 2022 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n# SPDX-License-Identifier: LicenseRef-.amazon.com.-AmznSL-1.0\n# Licensed under the Amazon Software License  http://aws.amazon.com/asl/\n\nimport sys\nimport boto3\nfrom botocore.errorfactory import ClientError\n\nsys.tracebacklimit=0\nclient = boto3.client('s3')\n\ndef get_public_access_settings(account_id, bucket_name=None):\n    try:\n        default_value = {\n                'BlockPublicAcls': False,\n                'IgnorePublicAcls': False,\n                'BlockPublicPolicy': False,\n                'RestrictPublicBuckets': False\n            }\n        if bucket_name is None:\n            settings = boto3.client('s3control').get_public_access_block(\n                AccountId=account_id)\n        else:\n            settings = client.get_public_access_block(\n                Bucket=bucket_name,\n                ExpectedBucketOwner=account_id)\n\n        return settings.get('PublicAccessBlockConfiguration', default_value)\n    \n    except ClientError as e:\n        if e.response['Error']['Code'] == 'NoSuchPublicAccessBlockConfiguration':\n            return default_value\n        else:\n            raise Exception('Error: An error occurred when retrieving the Amazon S3 Public Access Settings - {}'.format(e.response['Error']['Message']))\n\n    except Exception as e:\n        print('Error: An error occurred when retrieving the Amazon S3 Public Access Settings - {}. The runbooks will assume that Public Access Settings are all set to False.'.format(str(e)))\n        return default_value\n\ndef get_block_public_access(bucket_name, account_id):\n    # Assumes by default that the configuration allows public access policies\n    block_ignore_public_acl = False\n    block_ignore_public_policy = False\n\n    try:\n        # Get Block public access settings for Account (account_id)\n        account_settings = get_public_access_settings(account_id)\n        \n        if account_settings.get('IgnorePublicAcls'):\n            block_ignore_public_acl = True\n        if account_settings.get('RestrictPublicBuckets'):\n            block_ignore_public_policy = True\n        \n        # Get Block public access settings for Bucket (bucket_name)\n        settings = get_public_access_settings(account_id,bucket_name)\n        \n        if settings.get('IgnorePublicAcls'):\n            block_ignore_public_acl = block_ignore_public_acl or True\n        if settings.get('RestrictPublicBuckets'):\n            block_ignore_public_policy = block_ignore_public_policy or True\n\n        if block_ignore_public_policy:\n            print('Info: Block public access settings are configured to ignore any public bucket policy.')\n            \n        if block_ignore_public_acl:\n            print('Info: Block public access settings are configured to ignore public ACLs.')\n            \n        return block_ignore_public_acl, block_ignore_public_policy\n        \n    except Exception as e:\n        print(f'Error: {str(e)}')\n        return block_ignore_public_acl, block_ignore_public_policy\n    \ndef is_bucket_policy_public(bucket_name, account_id):\n    # When evaluating a bucket, the code assumes that the bucket is public.\n    try:\n        is_public = client.get_bucket_policy_status(Bucket=bucket_name,\n            ExpectedBucketOwner=account_id)['PolicyStatus']['IsPublic']\n        \n        if is_public:\n            print('Warning: Bucket policy is marked as public.')\n            return True\n        else:\n            print('Info: Bucket policy is marked as private.')\n            return False\n        \n    except ClientError as e:\n        if e.response[\"Error\"][\"Code\"] == \"NoSuchBucketPolicy\":\n            print('Info: Bucket has no policy associated.')\n            return False\n        else:\n            print('Error: An error occurred when retrieving the Amazon S3 Bucket Policy Status - {}. The runbooks will assume Bucket policy is marked as public.'.format(str(e)))\n            return True\n\n    except Exception as e:\n        print(f'Error: {str(e)}')\n        return True\n\ndef is_bucket_acl_public(bucket_name, account_id):\n    PUBLIC_GROUP = { 'http://acs.amazonaws.com/groups/global/AllUsers': 'All Users' }\n    # Anonymous canonical user ID https://docs.aws.amazon.com/AmazonS3/latest/dev/acl-overview.html\n    ANONYMOUS_USER = '65a011a29cdf8ec533ec3d1ccaae921c'\n    READ_WRITE_PERMISSIONS = ('READ','FULL_CONTROL', 'WRITE')\n    try:\n        bucket_acl_response = client.get_bucket_acl(Bucket=bucket_name, \n            ExpectedBucketOwner=account_id)\n\n        for grant in bucket_acl_response['Grants']:\n            uri = grant['Grantee'].get('URI')\n            uid = grant['Grantee'].get('ID')\n            \n            if uri in PUBLIC_GROUP.keys() and grant['Permission'] in READ_WRITE_PERMISSIONS:\n                print('Warning: Bucket ACL is marked as public for All Users.')\n                return True\n            if uid == ANONYMOUS_USER and grant['Permission'] in READ_WRITE_PERMISSIONS:\n                print('Warning: Bucket ACL is marked as public for Anonymous users.')\n                return True\n\n        print('Info: Bucket ACL is marked as private.')\n        return False\n    \n    except ClientError as e:\n        print('Error: An error occurred when retrieving the Amazon S3 ACLs - {}. The runbooks will assume the ACL grants public access.'.format(str(e)))\n        return True\n    except Exception as e:\n        print(f'Error: {str(e)}')\n        return True\n    \ndef is_bucket_public(events,context):\n    bucket_name = events.get('S3Location','')\n    account_id = context['global:ACCOUNT_ID']\n    \n    if not bucket_name:\n        return\n\n    try:\n        block_public_policy, block_public_acl = get_block_public_access(bucket_name, account_id)\n        \n        if block_public_policy and block_public_acl:\n            #Block and/or account public access settings are configured to ignore both public ACLs and any public bucket policy.'\n            return\n        \n        policy_is_public = is_bucket_policy_public(bucket_name, account_id)\n        acl_is_public =  is_bucket_acl_public(bucket_name, account_id)\n        \n        if (not policy_is_public or block_public_policy) and not acl_is_public:\n            return\n            \n        if block_public_acl and not policy_is_public:\n            return\n      \n        raise Exception(f'Error: The runbook has found that the S3 bucket could be publicly accessible. This runbook prevents a file from being uploaded to S3 if it can be potentially exposed to unauthorized people.')\n    \n    except Exception as e:\n        raise Exception(f'Block Public Policy: {block_public_policy} | Block Public ACL: {block_public_acl} | Policy Is Public: {policy_is_public} | ACL Is Public: {acl_is_public} | Context: {context} | Error: {str(e)}')\n\n",
        "InputPayload": {
          "S3Location": "{{ S3Location }}"
        }
      },
      "nextStep": "UploadOutputToS3"
    },
    {
      "name": "UploadOutputToS3",
      "action": "aws:executeScript",
      "description": "Creates a text file with the results of the automation and uploads it to the Amazon S3 bucket you specified in the \"S3Location\" parameter.",
      "inputs": {
        "Runtime": "python3.8",
        "Handler": "result_to_s3",
        "Script": "# Copyright 2022 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n# SPDX-License-Identifier: LicenseRef-.amazon.com.-AmznSL-1.0\n# Licensed under the Amazon Software License  http://aws.amazon.com/asl/\n\nimport boto3\nimport sys\nfrom lib.helper import handle_aws_api\n\nssm_client = boto3.client(\"ssm\")\ns3_client = boto3.client(\"s3\")\n\ndef result_to_s3(events, context):\n    s3_bucket = events.get(\"S3Location\",\"\")\n    account_id = context[\"global:ACCOUNT_ID\"]\n    check_performed = events[\"InvestigationType\"]\n    automation_execution_id = context['automation:EXECUTION_ID']\n    object_path = events.get(\"S3LocationPrefix\", \"\").strip(\"/ \")\n\n    get_execution_details = handle_aws_api(ssm_client.get_automation_execution,\n        AutomationExecutionId=automation_execution_id\n    )\n\n    outputs = get_execution_details['AutomationExecution']['Outputs']\n    list_keys = []\n    for k in outputs.keys():\n        list_keys.append(k)\n\n    rev_ouputs = {}\n    for i in reversed(list_keys):\n        rev_ouputs[i] = outputs[i]\n        \n    outputfile = f'Automation Execution ID: {automation_execution_id}\\n'\n    outputfile += f'Investigation Type: {check_performed}\\n\\n'\n    file_name = \"{}_{}.txt\".format(check_performed.replace(\" \", \"_\"), automation_execution_id)\n\n    if object_path:\n        file_name = \"{}/{}\".format(object_path, file_name)\n\n    s3_uri = \"s3://{}/{}\".format(s3_bucket, file_name)\n\n    s3_console_uri = \"https://s3.console.aws.amazon.com/s3/object\"\n    if context[\"global:AWS_PARTITION\"] == \"aws-cn\":\n        s3_console_uri = \"https://console.amazonaws.cn/s3/object\"\n    elif context[\"global:AWS_PARTITION\"] == \"aws-us-gov\":\n        s3_console_uri = \"https://console.amazonaws-us-gov.com/s3/object\"\n\n    s3_console_url = \"{}/{}?region={}&prefix={}\".format(\n        s3_console_uri,\n        s3_bucket,\n        context[\"global:REGION\"],\n        file_name,\n    )\n\n    main_steps = (\"RunConnectivityChecks\", \"RunBestPractices\", \"CreateTroubleshootingDashboard\")\n    for k,v in rev_ouputs.items():\n        step_name = str(k).split('.')[0]\n        if step_name in main_steps:\n            step_output = str(v).replace('\\\\n', '\\n').translate(str.maketrans({'[': None, '\\'': None, ']': None, '\"': None, '{': None, '}': None}))\n            if \"No output available\" not in step_output:\n                outputfile += \"\\nStep Name: \" + step_name + \"\\n\"+\"Output:\\n\" + step_output + \"\\n\"\n   \n    outputfile += \"\\nS3 Console URL: \" + s3_console_url\n    outputfile += \"\\nS3 resource URI: \" + s3_uri\n\n    handle_aws_api(s3_client.put_object,\n        Body=outputfile,\n        Bucket=s3_bucket,\n        Key=file_name,\n        ExpectedBucketOwner=account_id\n    )\n    \n    print (\"The Automation execution report was uploaded to your S3 location.\")\n    \n    return { \"Output\": {\"S3URI\": s3_uri, \"S3ConsoleURL\": s3_console_url} }\n\n\n    \n",
        "InputPayload": {
          "InvestigationType": "{{ InvestigationType }}",
          "S3Location": "{{ S3Location }}",
          "S3LocationPrefix": "{{ S3LocationPrefix }}"
        },
        "Attachment": "attachment.zip"
      },
      "outputs": [
        {
          "Name": "Output",
          "Selector": "$.Payload.Output",
          "Type": "StringMap"
        }
      ]
    }
  ],
  "files": {
    "attachment.zip": {
      "checksums": {
        "sha256": "a76574f10c39191b4c8da1946194ae6cefb3e569edbd5497b6c818fc256caf11"
      }
    }
  }
}
