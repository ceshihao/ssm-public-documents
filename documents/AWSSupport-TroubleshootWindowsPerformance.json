{
  "description": "The **AWSSupport-TroubleshootWindowsPerformance** helps to troubleshoot ongoing performance issues on Amazon Elastic Compute Cloud (Amazon EC2) Windows managed instances. The runbook captures logs from the target instance and provides a summary of CPU, memory, disk, and network performance metrics. Optionally, the automation allows you to capture a process dump for the process that is potentially causing performance degradation. The automation can install the latest [EC2Rescue tool](https://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/Windows-Server-EC2Rescue.html) to capture the Windows Events and System logs of your choice. All the captured logs are placed in the folder `$env:ProgramData\\Amazon\\SSM\\TroubleshootWindowsPerformance\\` and can optionally be uploaded to an Amazon Simple Storage Service (Amazon S3) bucket of your choice. Please delete these logs manually when they are no longer required. This runbook does not analyze the process dump and logs captured by EC2Rescue, those are available for you to help you troubleshooting performance issues.\n\n### Prerequisites:\n> * Windows PowerShell 4.0 or later.\n> * [AWS Tools for PowerShell](https://aws.amazon.com/powershell/) must be installed if you choose to upload logs to an Amazon S3 bucket.\n> * The instance requires a valid AWS Identity and Access Management (IAM) instance profile that provides permissions for Systems Manager and the Amazon S3 bucket if the `LogUploadBucketName` is specified.",
  "schemaVersion": "0.3",
  "assumeRole": "{{ AutomationAssumeRole }}",
  "parameters": {
    "AutomationAssumeRole": {
      "type": "AWS::IAM::Role::Arn",
      "description": "(Optional) The Amazon Resource Name (ARN) of the AWS Identity and Access Management (IAM) role that allows Systems Manager Automation to perform the actions on your behalf. If no role is specified, Systems Manager Automation uses the permissions of the user that starts this runbook.",
      "default": ""
    },
    "InstanceId": {
      "type": "AWS::EC2::Instance::Id",
      "description": "(Required) The ID of the Amazon EC2 Windows instance you want to troubleshoot performance issues."
    },
    "CaptureProcessDump": {
      "type": "String",
      "description": "(Optional) The process dump type to capture. The automation can capture one process dump for the process which is potentially causing the performance impact in the beginning of the automation. The instance root volume will require to have at least 10 GB free space (greater than 10% of the disk size when the root volume size is bigger than 100 GB and 10GB plus the total memory size consumed by the process when the process consumes more than 10GB memory).",
      "allowedValues": [
        "None",
        "Highest CPU",
        "Highest Memory"
      ],
      "default": "None"
    },
    "LogCaptureDuration": {
      "type": "String",
      "description": "(Optional) The number of minutes this automation should capture logs while the issue is present. Default is `5` minutes. You can specify a value between `1` and up to `15` minutes.",
      "default": "5",
      "allowedPattern": "^([1-9]|1[0-5])$"
    },
    "LogUploadBucketName": {
      "type": "AWS::S3::Bucket::Name",
      "description": "(Optional) The Amazon S3 bucket in your account to upload the logs to. Please make sure the bucket is configured with server-side encryption (SSE), and the bucket policy does not grant unnecessary read/write permissions to parties that do not need to access the logs. Also please make sure EC2 Windows instance has necessary access to the S3 Bucket.",
      "default": ""
    },
    "InstallEC2RescueTool": {
      "type": "String",
      "description": "(Optional) Set it to `Yes` if you allow the runbook to install the latest version of the `EC2Rescue` tool to capture the Windows Events and System logs. Default value `No`.",
      "allowedValues": [
        "No",
        "Yes"
      ],
      "default": "No"
    },
    "Acknowledgement": {
      "type": "String",
      "description": "(Required) Please read the complete details of the actions performed by this automation runbook and write `Yes, I understand and acknowledge` if you acknowledge the steps.",
      "allowedPattern": "^Yes, I understand and acknowledge$"
    }
  },
  "mainSteps": [
    {
      "description": "Ensures there is only one execution of this runbook targeting the same instance. If the runbook finds another in progress execution targeting the same instance, it returns an error and ends.",
      "name": "CheckConcurrency",
      "action": "aws:executeScript",
      "timeoutSeconds": 600,
      "nextStep": "AssertInstanceIsWindows",
      "onFailure": "Abort",
      "inputs": {
        "InputPayload": {
          "TargetResourceId": "{{ InstanceId }}",
          "ParameterName": "InstanceId"
        },
        "Handler": "check_concurrency.script_handler",
        "Runtime": "python3.8",
        "Attachment": "check_concurrency.zip"
      }
    },
    {
      "name": "AssertInstanceIsWindows",
      "action": "aws:assertAwsResourceProperty",
      "nextStep": "AssertInstanceIsManagedInstance",
      "description": "Checks if the EC2 instance platform is `windows`, otherwise the automation ends.",
      "onFailure": "Abort",
      "timeoutSeconds": 300,
      "isCritical": true,
      "inputs": {
        "Service": "ec2",
        "Api": "DescribeInstances",
        "InstanceIds": [
          "{{ InstanceId }}"
        ],
        "PropertySelector": "$.Reservations[0].Instances[0].Platform",
        "DesiredValues": [
          "windows"
        ]
      }
    },
    {
      "name": "AssertInstanceIsManagedInstance",
      "action": "aws:assertAwsResourceProperty",
      "description": "Ensures the EC2 instance is managed by AWS Systems Manager, otherwise the automation ends.",
      "onFailure": "Abort",
      "inputs": {
        "Service": "ssm",
        "Api": "DescribeInstanceInformation",
        "InstanceInformationFilterList": [
          {
            "key": "InstanceIds",
            "valueSet": [
              "{{ InstanceId }}"
            ]
          }
        ],
        "PropertySelector": "$.InstanceInformationList[0].PingStatus",
        "DesiredValues": [
          "Online"
        ]
      },
      "isCritical": true,
      "nextStep": "VerifyPrerequisites"
    },
    {
      "name": "VerifyPrerequisites",
      "action": "aws:runCommand",
      "description": "Verifies if the Windows EC2 instance meets the pre-requisites required by this runbook.",
      "onFailure": "Abort",
      "isCritical": true,
      "inputs": {
        "InstanceIds": [
          "{{ InstanceId }}"
        ],
        "DocumentName": "AWS-RunPowerShellScript",
        "Parameters": {
          "commands": [
            "# Copyright 2024 Amazon.com, Inc. or its affiliates. All Rights Reserved.",
            "# SPDX-License-Identifier: LicenseRef-.amazon.com.-AmznSL-1.0",
            "# Licensed under the Amazon Software License  http://aws.amazon.com/asl/",
            "",
            "try {",
            "",
            "    $OsInfo = Get-CimInstance -ClassName Win32_OperatingSystem | Select-Object -Property Caption, Version",
            "    $OSVersion = [System.Version]$OsInfo.Version  ",
            "    $PSVersion = $PSVersionTable.PSVersion",
            "    $PSSupported = [System.Version]\"4.0\"",
            "    $OSVersionSupported = [System.Version]\"6.3\"",
            "    $S3BucketName = \"{{ LogUploadBucketName }}\"",
            "",
            "    # Check if the OS version and PowerShell version meet the requirements.",
            "    if (!($OSVersion -ge $OSVersionSupported -and $PSVersion -ge $PSSupported)) {",
            "        Write-Output \"[FAILED] This automation requires PowerShell version >= 4.0 running on Windows Server 2012 R2 and above. Current OS Version: $($OsInfo.Caption) ($($OSVersion.Major).$($OSVersion.Minor)) with PowerShell Version $($PSVersion.Major).$($PSVersion.Minor)\"",
            "        Exit 1",
            "    }",
            "    if (!($S3BucketName -eq \"\") -and !(Get-Module -ListAvailable -Name AWSPowershell)) {",
            "        Write-Output \"AWS Tools for Windows PowerShell is required to upload the logs to Amazon S3. Please install the latest version of the AWS Tools for Windows PowerShell and try again.\"",
            "        Write-Output \"Download location: https://aws.amazon.com/powershell/\"",
            "        Exit 1",
            "    }",
            "    ",
            "    Write-Output \"[Passed] This instance meets the requirements of this automation.\"",
            "    Exit 0",
            "}",
            "catch {",
            "    Write-Error \"[FAILED] Failed to verify prerequisites $($_.Exception.Message)\"",
            "    Exit 1",
            "}"
          ]
        }
      },
      "nextStep": "BranchOnProcessDump"
    },
    {
      "name": "BranchOnProcessDump",
      "action": "aws:branch",
      "description": "Branches on based on the value of the input parameter `CaptureProcessDump`.",
      "onFailure": "Abort",
      "isEnd": true,
      "isCritical": true,
      "inputs": {
        "Choices": [
          {
            "Variable": "{{ CaptureProcessDump }}",
            "StringEquals": "None",
            "NextStep": "CapturePerformanceLogs"
          }
        ],
        "Default": "CaptureProcessDump"
      }
    },
    {
      "name": "CaptureProcessDump",
      "action": "aws:runCommand",
      "description": "Captures a process dump for the process which might be causing the performance issues. The instance root volume will require to have at least 10 GB of free space (greater than 10% of the disk size when the root volume size is bigger than 100 GB and 10GB plus the total memory size consumed by the process when the process consumes more than 10GB memory).",
      "onFailure": "Continue",
      "timeoutSeconds": 900,
      "inputs": {
        "DocumentName": "AWS-RunPowerShellScript",
        "InstanceIds": [
          "{{ InstanceId }}"
        ],
        "Parameters": {
          "commands": [
            "# Copyright 2024 Amazon.com, Inc. or its affiliates. All Rights Reserved.",
            "# SPDX-License-Identifier: LicenseRef-.amazon.com.-AmznSL-1.0",
            "# Licensed under the Amazon Software License  http://aws.amazon.com/asl/",
            "",
            "$ExecutionId = \"{{ automation:EXECUTION_ID }}\"",
            "$CaptureProcessDump = \"{{ CaptureProcessDump }}\"",
            "# Get the system information and calculate available space",
            "$SystemDriveLetter = [Environment]::GetEnvironmentVariable(\"SystemDrive\")",
            "$driveInfo = Get-CimInstance Win32_LogicalDisk -Filter \"DeviceID='$SystemDriveLetter'\"",
            "$SpaceAvailableinGB = [math]::Round($driveInfo.FreeSpace / 1GB, 2)",
            "$DiskSizeinGB = [math]::Round($driveInfo.Size / 1GB, 2)",
            "$SpaceAvailableinPercentage = [math]::Round(($SpaceAvailableinGB / $DiskSizeinGB) * 100, 2)",
            "# Set BasePath for the captured processdump file",
            "$BasePath = \"$env:ProgramData\\Amazon\\SSM\\TroubleshootWindowsPerformance\\$ExecutionId\"",
            "New-Item -ItemType Directory -Force -Path $BasePath -ErrorAction SilentlyContinue | Out-Null",
            "",
            "# CaptureProcessDump function",
            "function CaptureProcessDump {",
            "    [CmdletBinding()]",
            "    param(",
            "        [Parameter(Mandatory = $True)]",
            "        [int]$ProcessId,",
            "        [Parameter(Mandatory = $True)]",
            "        [string]$DumpProcessPath,",
            "        [Parameter(Mandatory = $True)]",
            "        [string]$ProcessName,",
            "        [Parameter(Mandatory = $True)]",
            "        [string]$ProcessHandle",
            "    )",
            "",
            "    # Add the type definition",
            "    # Reference: https://learn.microsoft.com/en-us/windows/win32/api/minidumpapiset/nf-minidumpapiset-minidumpwritedump",
            "    Add-Type -TypeDefinition @\"",
            "    using System;",
            "    using System.Diagnostics;",
            "    using System.Runtime.InteropServices;",
            "    using System.Security.Principal;",
            "    public class GetProcessDump",
            "    {",
            "        [DllImport(\"Dbghelp.dll\")]",
            "        public static extern bool MiniDumpWriteDump(",
            "            int hProcess,",
            "            int ProcessId,",
            "            int hFile,",
            "            int DumpType,",
            "            int ExceptionParam,",
            "            int UserStreamParam,",
            "            int CallbackParam);",
            "    }",
            "\"@",
            "",
            "    # Create a filestream for dump process",
            "    try {",
            "        $FileObj = [System.IO.File]::Create($DumpProcessPath)",
            "    }",
            "    catch {",
            "        Write-Output \"`n[FAILED] Initialization of the dump process failed. Create file failed! `n $($_.Exception.Message)\"",
            "        Exit 1",
            "    }",
            "    $DumpError = $null",
            "    $DumpType = 0x00061907",
            "    # Reference: https://learn.microsoft.com/en-us/windows/win32/api/minidumpapiset/ne-minidumpapiset-minidump_type",
            "    <# DumpType 0x00061907 refers to a full memory dump for a process. It's a caculated value based on below ones.",
            "    MiniDumpIgnoreInaccessibleMemory = 0x00020000",
            "    MiniDumpWithDataSegs       = 0x00000001",
            "    MiniDumpWithFullMemory      = 0x00000002",
            "    MiniDumpWithFullMemoryInfo    = 0x00000800",
            "    MiniDumpWithHandleData      = 0x00000004",
            "    MiniDumpWithProcessThreadData  = 0x00000100",
            "    MiniDumpWithThreadInfo      = 0x00001000",
            "    MiniDumpWithTokenInformation   = 0x00040000",
            "    => 0x00061907",
            "    #>",
            "",
            "    try {",
            "        $DumpProcess = [GetProcessDump]::MiniDumpWriteDump($ProcessHandle, $ProcessId, $FileObj.Handle, $DumpType, [int]::Zero, [int]::Zero, [int]::Zero)",
            "        $FileObj.Close()",
            "    }",
            "    catch {",
            "        $DumpError = [System.Runtime.InteropServices.Marshal]::GetLastWin32Error()",
            "        Write-Output \"[FAILED] Failed to capture a process dump for the Process: $ProcessName with ID: $ProcessId. Error: $DumpError\"",
            "        Remove-Item $FileObj.Name",
            "        Exit 1",
            "    }",
            "",
            "    if (!$DumpProcess) {",
            "        Remove-Item $FileObj.Name",
            "        Write-Output \"[FAILED] Failed to capture a process dump for the Process: $ProcessName with ID: $ProcessId.\"",
            "        Exit 1",
            "    }",
            "    else {",
            "        Write-Output \"`n[PASSED] Dump captured successfully for the process: $ProcessName with ID: $ProcessId. `nThe dump file will not be deleted by this automation, please manually delete it after analysis. `nThe dump file location: $DumpProcessPath\"",
            "        Exit 0",
            "    }",
            "}",
            "# Main Script to check disk space and capture dump",
            "try {",
            "    if ($CaptureProcessDump -eq \"Highest Memory\") {",
            "        $TopProcess = Get-Process | Sort-Object -Property WorkingSet64 -Descending | Select-Object -First 1 | Select-Object -Property ProcessName, Id",
            "        $ProcessName = $TopProcess.ProcessName",
            "        [int]$ProcessId = $TopProcess.Id",
            "    }",
            "    elseif ($CaptureProcessDump -eq \"Highest CPU\") {",
            "        # Using Get-CimInstance instead of Get-Counter '\\Process(*)\\% Processor Time' to avoid issues with OS in non english languages",
            "        # Also not using \"Get-Process | Sort-Object CPU -Descending\" to avoid detecting CPU usage time instead of current usage percentage",
            "        $TopProcess = Get-CimInstance -ClassName Win32_PerfFormattedData_PerfProc_Process | Where-Object { $_.Name -notmatch \"^(Idle|_Total|System)$\" } | Sort-Object -Property PercentProcessorTime -Descending | Select-Object -First 1",
            "        $ProcessName = $TopProcess.Name",
            "        [int]$ProcessId = $TopProcess.IDProcess",
            "    }",
            "    else {",
            "        Write-Output \"[FAILED] The parameter value for 'CaptureProcessDump' is unexpected!\"",
            "        Exit 1",
            "    }",
            "    # Calculate the required space for capturing a process dump based on the top memory/CPU usage, give an extra 10GB to save disk space",
            "    $ProcessUsedMemorySize = (Get-Process -Id $ProcessId | Select-Object @{Name = 'peakPagedMemorySize64'; Expression = { [Math]::Ceiling($_.peakPagedMemorySize64 / 1GB) } }).peakPagedMemorySize64",
            "    $SpaceRequiredForDump = 10 + $ProcessUsedMemorySize",
            "",
            "    # Check if the available space meets the required criteria.",
            "    if ($SpaceAvailableinGB -ge 10 -and $SpaceAvailableinPercentage -ge 10 -and $SpaceAvailableinGB -ge $SpaceRequiredForDump) {",
            "        Write-Output \"The instance has enough space to dump impacting process. Currently available space: $SpaceAvailableinGB GB is more than minimum required Space. Proceeding further to capture dump.\"",
            "        # Capture process dump",
            "        $ProcessHandle = (Get-Process -Id $ProcessId).Handle",
            "        try {",
            "            if ($null -eq $ProcessHandle -or $ProcessHandle -eq [int]::Zero) {",
            "                Write-Output \"[FAILED] Could not retrieve process $ProcessName with PID: $ProcessId. Could not dump a system process.\"",
            "                Exit 1",
            "            }",
            "            $DumpProcessPath = \"$BasePath\\$ProcessName\" + \"_\" + \"$ProcessId\" + \"_\" + (Get-Date).ToString(\"HH-mm-ss\") + \".dmp\"",
            "            CaptureProcessDump -ProcessId $ProcessId -ProcessName $ProcessName -ProcessHandle $ProcessHandle -DumpProcessPath $DumpProcessPath",
            "            Exit 0",
            "        }",
            "        catch {",
            "            Write-Output \"[FAILED] Failed to dump process, error: $_\"",
            "            Exit 1",
            "        }",
            "    }",
            "    elseif (!($SpaceAvailableinGB -ge $SpaceRequiredForDump)) {",
            "        Write-Output \"[FAILED] The instance doesn't have enough space to dump impacting process. Currently available space on root disk: $SpaceAvailableinGB GB. The target dump process $ProcessName with $ProcessId that requires $SpaceRequiredForDump GB free space.\"",
            "        Exit 1",
            "    }",
            "    else {",
            "        Write-Output \"[FAILED] The instance doesn't have enough space to dump impacting process. Total disk size of the root disk: $DiskSizeinGB GB. Currently available space: $SpaceAvailableinGB GB.\"",
            "        Exit 1",
            "    }",
            "}",
            "catch {",
            "    Write-Output \"[FAILED] Failed step with error: $_\"",
            "    Exit 1",
            "}"
          ]
        }
      },
      "isCritical": false,
      "nextStep": "CapturePerformanceLogs"
    },
    {
      "name": "CapturePerformanceLogs",
      "action": "aws:runCommand",
      "timeoutSeconds": 7200,
      "description": "Creates Windows Performance Monitor counters and captures performance logs.",
      "onFailure": "step:CleanUpLogsOnFailure",
      "inputs": {
        "InstanceIds": [
          "{{ InstanceId }}"
        ],
        "DocumentName": "AWS-RunPowerShellScript",
        "Parameters": {
          "commands": [
            "# Copyright 2024 Amazon.com, Inc. or its affiliates. All Rights Reserved.",
            "# SPDX-License-Identifier: LicenseRef-.amazon.com.-AmznSL-1.0",
            "# Licensed under the Amazon Software License  http://aws.amazon.com/asl/",
            "",
            "$ExecutionId = \"{{automation:EXECUTION_ID}}\"",
            "$InstanceId = \"{{InstanceId}}\"",
            "[int]$LogCaptureDuration = \"{{LogCaptureDuration}}\"",
            "$BasePath = \"$env:ProgramData\\Amazon\\SSM\\TroubleshootWindowsPerformance\\$ExecutionId\"",
            "$PerfmonOutputPrefix = $InstanceId + \"_perfmon_\"",
            "$WprOutputFile = \"$BasePath\\\" + $InstanceId + \"_WPR_\" + (Get-Date).ToString(\"HH-mm-ss\") + \".etl\"",
            "$DataCollectorSetName = \"TroubleshootWindowsPerformance_\" + \"$ExecutionId\"",
            "$DataCollectorSet = New-Object -ComObject Pla.DataCollectorSet",
            "[int]$DurationInSecond = $LogCaptureDuration * 60",
            "",
            "# Windows Performance Recorder (WPR) is a tool of Windows Performance Toolkit. It supports different parameters in different versions. This runbook uses these two paramters -skipPdbGen and -compress parameters",
            "# https://learn.microsoft.com/en-us/windows-hardware/test/wpt/wpr-command-line-options?source=recommendations#syntax-3",
            "# Version \"10.0.19041.1\" supports -skipPdbGen and version \"10.0.22621.1\" supports -compress",
            "$SkipPdbGenWprVersion = [Version]\"10.0.19041.1\"",
            "$CompressWprVersion = [Version]\"10.0.22621.1\"",
            "",
            "New-Item -ItemType Directory -Force -Path $BasePath -ErrorAction SilentlyContinue | Out-Null",
            "",
            "function CheckDiskSpace {",
            "    # Checks disk space to ensure more than 10 GB and 10% of the disk space is remaining before proceeding to capture the logs",
            "    $SystemDriveLetter = [Environment]::GetEnvironmentVariable(\"SystemDrive\")",
            "    $DriveInfo = Get-CimInstance Win32_LogicalDisk -Filter \"DeviceID='$SystemDriveLetter'\"",
            "    $SpaceAvailableinGB = [math]::Round($DriveInfo.FreeSpace / 1GB, 2)",
            "    $DiskSizeinGB = [math]::Round($DriveInfo.Size / 1GB, 2)",
            "    $SpaceAvailableinPercentage = [math]::Round(($SpaceAvailableinGB / $DiskSizeinGB) * 100, 2)",
            "",
            "    if ($SpaceAvailableinGB -ge 10 -and $SpaceAvailableinPercentage -ge 10) {",
            "        Write-Output \"The instance has enough space to capture performance logs.\"",
            "    }",
            "    else {",
            "        Write-Output \"[FAILED] The instance does not have enough space to capture performance logs. Total disk size: $DiskSizeinGB GB. Currently available space: $SpaceAvailableinGB GB. The instance root volume requires to have free space of greater than 10 GB, 10% of the disk size.\"",
            "        Exit 1",
            "    }",
            "}",
            "",
            "function StartProcessWithArgument {",
            "    param (",
            "        [string]$ProcessPath,",
            "        [string]$Arguments",
            "    )",
            "    # initiating the process to run logman and WPR to capture logs",
            "    $process = New-Object System.Diagnostics.Process",
            "    $process.StartInfo.FileName = $ProcessPath",
            "    $process.StartInfo.Arguments = $Arguments",
            "    $process.StartInfo.UseShellExecute = $false",
            "    $process.StartInfo.RedirectStandardOutput = $true",
            "    $process.StartInfo.RedirectStandardError = $true",
            "",
            "    try {",
            "        $process.Start() | Out-Null",
            "        $CommandOutput = $process.StandardOutput.ReadToEnd()",
            "        $CommandError = $process.StandardError.ReadToEnd()",
            "        $process.WaitForExit()",
            "        return $CommandOutput, $CommandError",
            "    }",
            "    catch {",
            "        Write-Output \"[FAILED] Failed to start process: $_\"",
            "        Exit 1",
            "    }",
            "}",
            "function GetWprStatus {",
            "",
            "    if (!(Get-Command -Name \"wpr.exe\" -ErrorAction SilentlyContinue)) {",
            "        Write-Output \"Windows Performance Recorder (WPR) not found. WPR Log capture will be skipped.\"",
            "        return $null",
            "    }",
            "    $WprPaths = Get-Command -Name wpr.exe -All",
            "    $WprInfo = $WprPaths | ForEach-Object {",
            "        $CurrentWprVersion = [Version]($_.FileVersionInfo.ProductVersion)",
            "        [PSCustomObject]@{",
            "            Path    = $_.Source",
            "            Version = $CurrentWprVersion",
            "        }",
            "    } | Sort-Object Version -Descending | Select-Object -First 1",
            "",
            "    $CommandOutput, $CommandError = StartProcessWithArgument -ProcessPath $WprInfo.path -Arguments \"-status\"",
            "    $StatusPattern = \"WPR recording is in progress\"",
            "    $StatusMatch = $CommandOutput | Select-String -Pattern $StatusPattern",
            "    $IsWprRecordingInProgress = $null -ne $StatusMatch",
            "",
            "    try {",
            "        return $WprInfo, $IsWprRecordingInProgress",
            "    }",
            "    catch {",
            "        Write-Output \"Failed to get WPR details: $_\"",
            "        return $null",
            "    }",
            "}",
            "function StopWpr {",
            "    param (",
            "        [Version]$SkipPdbGenWprVersion,",
            "        [Version]$CompressWprVersion,",
            "        [string]$WprOutputFile",
            "    )",
            "    # Retrieve WPR information and check if recording is in progress",
            "    $WprInfo, $IsWprRecordingInProgress = GetWprStatus",
            "    $WprPath = $WprInfo.Path",
            "    $CurrentWprVersion = $WprInfo.Version",
            "    if ($IsWprRecordingInProgress -eq $true) {",
            "        Try {",
            "            Write-Output \"Stopping WPR capture process.\"",
            "            # Start the process with the specified stop arguments",
            "            StartProcessWithArgument -ProcessPath $WprPath -Arguments $(",
            "                if ($CurrentWprVersion -ge $CompressWprVersion) {",
            "                    \"-Stop $WprOutputFile -skipPdbGen -compress\"",
            "                }",
            "                elseif ($CurrentWprVersion -ge $SkipPdbGenWprVersion) {",
            "                    \"-Stop $WprOutputFile -skipPdbGen\"",
            "                }",
            "                else {",
            "                    \"-Stop $WprOutputFile\"",
            "                }",
            "            ) | Out-Null",
            "            Write-Output \"WPR capture process is in 'Stopped' state.\"",
            "        }",
            "        catch {",
            "            Write-Output \"[FAILED] Failed to stop WPR capture process with error: $_\"",
            "            Exit 1",
            "        }",
            "    }",
            "    else {",
            "        Write-Output \"WPR capture process is in 'Stopped' state.\"",
            "    }",
            "}",
            "function StartWpr {",
            "    $WprInfo, $IsWprRecordingInProgress = GetWprStatus",
            "    $WprPath = $WprInfo.Path",
            "    if ($IsWprRecordingInProgress -eq $false) {",
            "        Try {",
            "            # Capture WPR log with start arguments for multiple profiles for CPU, Memory, Disk, network etc.",
            "            StartProcessWithArgument -ProcessPath $WprPath -Arguments \"-start CPU.light -start Network.Light -start DiskIO.light -start GeneralProfile.light -start Heap.light -recordtempto $BasePath -filemode\" | Out-Null",
            "            Write-Output \"Starting Windows Performance Recording (WPR) capture process.\"",
            "        }",
            "        catch {",
            "            Write-Output \"[FAILED] Failed to start WPR capture process with error: $_\"",
            "            Exit 1",
            "        }",
            "    }",
            "    else {",
            "        Write-Output \"WPR capture process is in 'Running' state.\"",
            "    }",
            "}",
            "function StopPerfmonCounter {",
            "    param (",
            "        [string]$DataCollectorSetName,",
            "        [System.MarshalByRefObject]$DataCollectorSet",
            "    )",
            "    try {",
            "        $DataCollectorSet.Commit(\"$DataCollectorSetName\", $null, 0x1000) | Out-Null",
            "        if ($null -eq $DataCollectorSet.Status) {",
            "            Write-Output \"Data Collector Set ${DataCollectorSetName} was not found.\"",
            "        }",
            "        elseif ($DataCollectorSet.Status -eq 0) {",
            "            Write-Output \"Data Collector Set ${DataCollectorSetName} is currently in 'Stopped' state.\"",
            "        }",
            "        elseif ($DataCollectorSet.Status -eq 1) {",
            "            Write-Output \"The Data Collector Set ${DataCollectorSetName} is currently in 'Running' state.\"",
            "            Write-Output \"Stopping Data Collector Set ${DataCollectorSetName} and generating report\"",
            "            $DataCollectorSet.Stop($true)",
            "            if ($DataCollectorSet.Status -eq 0) {",
            "                Write-Output \"Data Collector Set ${DataCollectorSetName} is currently in 'Stopped' state.\"",
            "            }",
            "        }",
            "        elseif ($DataCollectorSet.Status -eq 2) {",
            "            Write-Output \"The Data Collector Set ${DataCollectorSetName} is currently generating logs.\"",
            "            while ($DataCollectorSet.Status -ne 0) {",
            "                Start-Sleep -Seconds 300  # Sleep 5 minutes and check again",
            "            }",
            "            Write-Output \"The Data Collector Set ${DataCollectorSetName} has finished generating logs and is currently in 'Stopped' state.\"",
            "        }",
            "        else {",
            "            Write-Output \"Data Collector Set ${DataCollectorSetName} currently in unknown state.\"",
            "            Exit 1",
            "        }",
            "    }",
            "    catch {",
            "        Write-Output \"[FAILED] Failed to stop Data Collector Set ${DataCollectorSetName}: $($_.Exception.Message)\"",
            "        Exit 1",
            "    }",
            "}",
            "function DeletePerfmonCounter {",
            "    param (",
            "        [System.MarshalByRefObject]$DataCollectorSet",
            "    )",
            "    try {",
            "        Write-Output \"Attempting to delete Data Collector Set ${DataCollectorSetName}.\"",
            "        $DataCollectorSet.Delete()",
            "        if ($null -eq $DataCollectorSet.Status) {",
            "            Write-Output \"Data Collector Set ${DataCollectorSetName} deleted successfully.\"",
            "        }",
            "    }",
            "    catch {",
            "        Write-Output \"[FAILED] Failed to stop delete Data Collector Set ${DataCollectorSetName}: $($_.Exception.Message)\"",
            "    }",
            "}",
            "function CreateAndStartPerfmonCounter {",
            "    param (",
            "        [string]$DataCollectorSetName,",
            "        [string]$PerfmonOutputPrefix,",
            "        [string]$BasePath,",
            "        [System.MarshalByRefObject]$DataCollectorSet",
            "    )",
            "    Write-Output \"Attempting to create Performance monitor Data Collector Set ${DataCollectorSetName}......\"",
            "    $DataCollectorSet.DisplayName = $DataCollectorSetName",
            "    $DataCollectorSet.Segment = $false",
            "    $DataCollectorSet.SubdirectoryFormat = 0",
            "    $DataCollectorSet.Duration = $DurationInSecond",
            "    $DataCollectorSet.RootPath = \"$BasePath\"",
            "    $ReportingSchemaXML = [string]@\"",
            "        <Report name=\"systemPerformance\" version=\"1\" threshold=\"100\">",
            "            <Import file=\"%systemroot%\\pla\\reports\\Report.System.CPU.xml\"></Import>",
            "        </Report>",
            "\"@",
            "    $Rules = [string]@\"",
            "        <Rules>",
            "            <Logging level=\"15\" file=\"rules.log\">",
            "            </Logging>",
            "            <Import file=\"%systemroot%\\pla\\rules\\Rules.System.CPU.xml\"></Import>",
            "        </Rules>",
            "\"@",
            "    $DataCollectorSet.DataManager.ReportFileName= 'report.html'",
            "    $DataCollectorSet.DataManager.RuleTargetFileName = 'report.xml'",
            "    $DataCollectorSet.DataManager.Rules = $Rules",
            "    $DataCollectorSet.DataManager.ReportSchema =$ReportingSchemaXML",
            "    $DataCollectorSet.DataManager.Enabled = $true",
            "    $DataCollector = $DataCollectorSet.DataCollectors.CreateDataCollector(0)",
            "    $DataCollector.FileName = $PerfmonOutputPrefix",
            "    $DataCollector.FileNameFormat = 0x1",
            "    $DataCollector.FileNameFormatPattern = \"HH\\-mm\\-ss\"",
            "    $DataCollector.SampleInterval = 1",
            "    $DataCollector.Name = $DataCollectorSetName",
            "",
            "    $Counters = @('\\LogicalDisk(*)\\*', '\\Memory\\*', '\\Thread(*)\\*', '\\Network Interface(*)\\*', '\\Network Adapter(*)\\*', '\\PhysicalDisk(*)\\*', '\\Process(*)\\*', '\\Server\\*', '\\System\\*', '\\Processor(*)\\*', '\\IPv4\\*', '\\IPv6\\*', '\\TCPv4\\*', '\\TCPv6\\*', '\\UDPv4\\*', '\\UDPv6\\*', '\\Processor Information(*)\\*', '\\ENA Packets Shaping(*)\\*')",
            "",
            "    $DataCollector.PerformanceCounters = $Counters",
            "    try {",
            "        $DataCollectorSet.DataCollectors.Add($DataCollector)",
            "        $DataCollectorSet.Commit(\"$DataCollectorSetName\", $null, 0x0003) | Out-Null",
            "        $DataCollectorSet.Query($DataCollectorSetName, $null)",
            "        if ($DataCollectorSet.Status -eq 0) {",
            "            Write-Output \"Data Collector Set ${DataCollectorSetName} created successfully.\"",
            "        }",
            "        Write-Output \"Attempting to start Performance monitor Data Collector Set ${DataCollectorSetName}......\"",
            "        $DataCollectorSet.Start($true)",
            "        if ($DataCollectorSet.Status -eq 1) {",
            "            Write-Output \"Data Collector Set ${DataCollectorSetName} started successfully.\"",
            "        }",
            "    }",
            "    catch {",
            "        Write-Output \"[FAILED] Failed to create Performance Counter and start the perfmon capture with error: $_\"",
            "        Exit 1",
            "    }",
            "}",
            "",
            "Try {",
            "    Checkdiskspace",
            "    # Check and stop WPR and Perfmon log capture if they are running",
            "    if (Get-Command -Name \"wpr.exe\" -ErrorAction SilentlyContinue) {",
            "        StopWpr -SkipPDBGenWPRVersion $SkipPDBGenWPRVersion -CompressWPRVersion $CompressWPRVersion -WPROutputFile $WPROutputFile",
            "    }",
            "    StopPerfmonCounter -DataCollectorSetName $DataCollectorSetName -DataCollectorSet $DataCollectorSet",
            "    # Initiate Perfmon log capture",
            "    CreateAndStartPerfmonCounter -DataCollectorSetName $DataCollectorSetName -PerfmonOutputPrefix $PerfmonOutputPrefix -BasePath $BasePath -DataCollectorSet $DataCollectorSet",
            "    # Initiate WPR log capture if not both CPU and memory usage are over 95%",
            "    $CPU = [math]::Round((Get-Counter -Counter \"\\Processor(_Total)\\% Processor Time\" -SampleInterval 1 -MaxSamples 1 | Select-Object -ExpandProperty countersamples | Select-Object -ExpandProperty cookedvalue | Measure-Object -Average).average,2)",
            "    $ComputerMemory = Get-CimInstance -ClassName win32_operatingsystem",
            "    $Memory = [math]::Round((($ComputerMemory.TotalVisibleMemorySize - $ComputerMemory.FreePhysicalMemory)*100)/ $ComputerMemory.TotalVisibleMemorySize,2)",
            "    ",
            "    Write-Output \"Current CPU usage is '$CPU'% and Memory usage is '$Memory'%\"",
            "    if ($CPU -gt 95 -and $Memory -gt 95)",
            "    {",
            "        Write-Output \"Both CPU and Memory usage are over 95%, will skip capturing WPR logs to avoid system overload and will continue with Perfmon.\"",
            "        Start-Sleep -Seconds $DurationInSecond",
            "    }",
            "    else {",
            "        Write-Output \"Not both CPU and Memory usage are over 95% at this moment hence continue to capture WPR log.\"",
            "        if (Get-Command -Name \"wpr.exe\" -ErrorAction SilentlyContinue) {",
            "            StartWpr",
            "            Start-Sleep -Seconds $DurationInSecond",
            "            StopWpr -SkipPDBGenWPRVersion $SkipPDBGenWPRVersion -CompressWPRVersion $CompressWPRVersion -WPROutputFile $WPROutputFile",
            "        }",
            "        else {",
            "            Write-Output \"Windows Performance Recorder (WPR) not found. WBR Log capture skipped.\"",
            "        }",
            "    }",
            "    # Stop and Delete Performance monitor log collection",
            "    StopPerfmonCounter -DataCollectorSetName $DataCollectorSetName -DataCollectorSet $DataCollectorSet",
            "    DeletePerfmonCounter -DataCollectorSetName $DataCollectorSetName -DataCollectorSet $DataCollectorSet",
            "    # Gather other informations from the instance",
            "    tasklist /v | Out-File \"$BasePath\\tasklist.txt\"",
            "    tasklist /svc | Out-File \"$BasePath\\tasklist_svc.txt\"",
            "    systeminfo | Out-File \"$BasePath\\sysinfo.txt\"",
            "    netsh interface ipv4 show tcpstats | Out-File \"$BasePath\\netsh_ipv4_tcpstats.txt\"",
            "    netsh interface ipv6 show tcpstats | Out-File \"$BasePath\\netsh_ipv6_tcpstats.txt\"",
            "    netsh interface ipv4 show ipstats | Out-File \"$BasePath\\netsh_ipv4_ipstats.txt\"",
            "    netsh interface ipv6 show ipstats | Out-File \"$BasePath\\netsh_ipv6_ipstats.txt\"",
            "    netsh interface ipv4 show tcpconnections | Out-File \"$BasePath\\netsh_ipv4_tcpconnections.txt\"",
            "    Write-Output \"`n[PASSED] Performance logs are captured successfully inside the folder: $BasePath `nThe captured log files will not be deleted by this automation, please manually delete it after analysis.\"",
            "    Exit 0",
            "}",
            "catch {",
            "    Write-Output \"[FAILED] Failed step with error: $_\"",
            "    Exit 1",
            "}"
          ]
        }
      },
      "isCritical": true,
      "nextStep": "SummarizePerformanceLogs"
    },
    {
      "name": "CleanUpLogsOnFailure",
      "action": "aws:runCommand",
      "timeoutSeconds": 300,
      "onFailure": "Abort",
      "description": "Deletes the collected logs if the previous `CapturePerformanceLogs` step fails.",
      "maxAttempts": 3,
      "isEnd": true,
      "inputs": {
        "InstanceIds": [
          "{{ InstanceId }}"
        ],
        "DocumentName": "AWS-RunPowerShellScript",
        "Parameters": {
          "commands": [
            "# Copyright 2024 Amazon.com, Inc. or its affiliates. All Rights Reserved.",
            "# SPDX-License-Identifier: LicenseRef-.amazon.com.-AmznSL-1.0",
            "# Licensed under the Amazon Software License  http://aws.amazon.com/asl/",
            "",
            "$ExecutionId = \"{{automation:EXECUTION_ID}}\"",
            "$BasePath = \"$env:ProgramData\\Amazon\\SSM\\TroubleshootWindowsPerformance\\$ExecutionId\"",
            "$DataCollectorSet = New-Object -ComObject Pla.DataCollectorSet",
            "$DataCollectorSetName = \"TroubleshootWindowsPerformance_$ExecutionId\"",
            "",
            "function CleanUpFiles {",
            "    if (Test-Path $BasePath -PathType Container) {",
            "        # Check if the basepath contains any .dmp dump files",
            "        if (Get-ChildItem $BasePath -Filter *.dmp | Select-Object -First 1) {",
            "            # Delete all files except dump in the directory",
            "            Get-ChildItem $BasePath | Where-Object { $_.Extension -ne \".dmp\" } | Remove-Item -Force",
            "            Write-Output \"Log files under $BasePath deleted except the process dump file.\"",
            "        }",
            "        else {",
            "            Remove-Item $BasePath -Recurse -Force",
            "            Write-Output \"Log files under $BasePath deleted.\"",
            "        }",
            "    }",
            "    else {",
            "        Write-Output \"$BasePath directory doesn't exist hence no need to delete logs.\"",
            "    }",
            "}",
            "",
            "try {",
            "    ",
            "    if (Get-Command -Name \"wpr.exe\" -ErrorAction SilentlyContinue) {",
            "        $wprCommand = (Get-Command -Name \"wpr.exe\")[0]",
            "        Start-Process -FilePath $wprCommand.source -ArgumentList \"-cancel\"",
            "    }",
            "",
            "    $DataCollectorSet.Commit(\"$DataCollectorSetName\", $null, 0x1000) | Out-Null",
            "    if ($null -eq $DataCollectorSet.Status) {",
            "        CleanUpFiles",
            "    }",
            "    elseif ($DataCollectorSet.Status -eq 0) {",
            "        $DataCollectorSet.Delete()",
            "        CleanUpFiles",
            "    }",
            "    else {",
            "        Stop-SMPerformanceCollector -CollectorName $DataCollectorSetName | Out-Null",
            "        $DataCollectorSet.Delete()",
            "        CleanUpFiles",
            "    }",
            "}",
            "catch {",
            "    Write-Output \"[FAILED] Failed to delete log files, please manually delete the logs under folder: $BasePath $($_.Exception.Message)\"",
            "    Exit 1",
            "}"
          ]
        }
      },
      "isCritical": false
    },
    {
      "name": "SummarizePerformanceLogs",
      "action": "aws:runCommand",
      "timeoutSeconds": 7200,
      "description": "Summarizes the performance logs captured by the automation.",
      "onFailure": "Continue",
      "inputs": {
        "InstanceIds": [
          "{{ InstanceId }}"
        ],
        "DocumentName": "AWS-RunPowerShellScript",
        "Parameters": {
          "commands": [
            "# Copyright 2024 Amazon.com, Inc. or its affiliates. All Rights Reserved.",
            "# SPDX-License-Identifier: LicenseRef-.amazon.com.-AmznSL-1.0",
            "# Licensed under the Amazon Software License  http://aws.amazon.com/asl/",
            "",
            "$ExecutionId = \"{{ automation:EXECUTION_ID }}\"",
            "$BasePath = \"$env:ProgramData\\Amazon\\SSM\\TroubleshootWindowsPerformance\\$ExecutionId\"",
            "$XMLFilePath = \"$BasePath\\report.xml\"",
            "$XMLContent = [xml](Get-Content $XMLFilePath)",
            "$OutputFilePath = \"$BasePath\\analysis_output.log\"",
            "",
            "function WriteLog {",
            "    param(",
            "        [string] $message",
            "    )",
            "    Add-Content -Path $OutputFilePath -Value \"$message\"",
            "}",
            "function PerfmonDataAnalysis {",
            "    param (",
            "        [System.Xml.XmlNodeList]$Counters = $null,",
            "        [string]$CounterType",
            "    )",
            "",
            "    $Counters | ForEach-Object {",
            "        [PSCustomObject]@{",
            "            Counter = $_.SelectSingleNode(\"Data[@name='counter']\").InnerText",
            "            Instance = $_.SelectSingleNode(\"Data[@name='instance']\").InnerText",
            "            Min = [double]$_.SelectSingleNode(\"Data[@name='min']\").InnerText",
            "            Max = [double]$_.SelectSingleNode(\"Data[@name='max']\").InnerText",
            "            Avg = [double]$_.SelectSingleNode(\"Data[@name='mean']\").InnerText",
            "            CounterType = $CounterType",
            "            }",
            "    } | Sort-Object { [double]$_.Max } -Descending",
            "}",
            "function DisplayPerformanceAnalysis {",
            "    param (",
            "        [xml]$XMLContent,",
            "        [string]$CounterType,",
            "        [string]$CounterName",
            "    )",
            "",
            "    if ($CounterType -eq 'Processor') {",
            "        $Counters = $XMLContent.SelectNodes(\"//Table[@name='Process']/Item[Data[@name='displayName' and . = '$CounterName']]\")",
            "        $SortedCounters = PerfmonDataAnalysis -XMLContent $XMLContent -Counters $Counters -CounterType $CounterType",
            "        Write-Output \"Top 5 Processes which consumed most CPU in percentage as below. If you see a percentage higher than 100 that means the process is using more than one CPU core.\"",
            "        WriteLog -message \"Top 5 Processes which consumed most CPU in percentage as below. If you see a percentage higher than 100 that means the process is using more than one CPU core.\"",
            "        Write-Output (\"{0,-25} {1,-15} {2,-15:F2} {3,-15:F2} {4,-15:F2}\" -f \"Process\", \"Counter\", \"Min %\", \"Max %\", \"Avg %\")",
            "        WriteLog -message  (\"{0,-25} {1,-15} {2,-15:F2} {3,-15:F2} {4,-15:F2}\" -f \"Process\", \"Counter\", \"Min %\", \"Max %\", \"Avg %\")",
            "",
            "        foreach ($Counter in $SortedCounters | Select-Object -First 7) {",
            "            if ($Counter.Instance -ne '_Total' -and $Counter.Instance -ne 'Idle') {",
            "                # Display the formatted data",
            "                Write-Output (\"{0,-25} {1,-15} {2,-15:F2} {3,-15:F2} {4,-15:F2}\" -f $Counter.Instance, $Counter.CounterType, $Counter.Min, $Counter.Max, $Counter.Avg)",
            "                WriteLog -message  (\"{0,-25} {1,-15} {2,-15:F2} {3,-15:F2} {4,-15:F2}\" -f $Counter.Instance, $Counter.CounterType, $Counter.Min, $Counter.Max, $Counter.Avg)",
            "            }",
            "        }",
            "    }",
            "    elseif($CounterType -eq 'WorkingSet'){",
            "        $Counters = $XMLContent.SelectNodes(\"//Table[@name='Process']/Item[Data[@name='counter' and . = '$CounterName']]\")",
            "        Write-Output \"`nTop 5 Processes which consumed most WorkingSet64 memory as below (in MB):\"",
            "        WriteLog -message \"`nTop 5 Processes which consumed most WorkingSet64 memory as below (in MB):\"",
            "        $SortedCounters = PerfmonDataAnalysis -XMLContent $XMLContent -Counters $Counters -CounterType $CounterType",
            "        Write-Output (\"{0,-25} {1,-15} {2,-15:F2} {3,-15:F2} {4,-15:F2}\" -f \"Process\", \"Counter\", \"Min MB\", \"Max MB\", \"Avg MB\")",
            "        WriteLog -message  (\"{0,-25} {1,-15} {2,-15:F2} {3,-15:F2} {4,-15:F2}\" -f \"Process\", \"Counter\", \"Min MB\", \"Max MB\", \"Avg MB\")",
            "        foreach ($Counter in $SortedCounters | Select-Object -First 6) {",
            "            if ($Counter.Instance -ne '_Total'){",
            "                $Min = [Math]::Ceiling($Counter.Min / 1MB)",
            "                $Max= [Math]::Ceiling($Counter.Max / 1MB)",
            "                $Avg = [Math]::Ceiling($Counter.Avg / 1MB)",
            "                # Display the formatted data",
            "                Write-Output (\"{0,-25} {1,-15} {2,-15:F2} {3,-15:F2} {4,-15:F2}\" -f $Counter.Instance, $Counter.CounterType, $Min, $Max, $Avg)",
            "                WriteLog -message (\"{0,-25} {1,-15} {2,-15:F2} {3,-15:F2} {4,-15:F2}\" -f $Counter.Instance, $Counter.CounterType, $Min, $Max, $Avg)",
            "            }",
            "        }",
            "    }",
            "    elseif($CounterType -eq 'LogicalDisk'){",
            "        $CounterType = 'LogicalDisk'",
            "        $Counters = $XMLContent.SelectNodes(\"//Table[@name='$CounterType']/Item\")",
            "        $SortedCounters = PerfmonDataAnalysis -XMLContent $XMLContent -Counters $Counters -CounterType $CounterType",
            "        # Display the sorted Counters summary with custom formatting",
            "        WriteLog -message \"`nDisk usage metrics:\"",
            "        WriteLog -message (\"{0,-15} {1,-30} {2,-15} {3,-15} {4,-15}\" -f \"Device\", \"Counter\", \"Min\", \"Max\", \"Avg\")",
            "        foreach ($Counter in $SortedCounters | Where-Object {$_.counter -eq 'Disk Transfers/sec' -or $_.counter -eq 'Disk Reads/sec' -or $_.counter -eq 'Disk Writes/sec' -or $_.counter -eq 'Disk Bytes/sec' -or $_.counter -eq 'Disk Read Bytes/sec' -or $_.counter -eq 'Disk Write Bytes/sec' -or $_.counter -eq 'Current Disk Queue Length' -or $_.counter -eq 'Avg. Disk Read Queue Length' -or $_.counter -eq 'Avg. Disk Write Queue Length'} | Sort-Object { $_.Instance,$_.counter }) {",
            "            if ($Counter.Instance -eq '_Total') {",
            "                $Counter.Instance = 'Total'",
            "            }",
            "            else {",
            "                $Counter.Instance = 'Disk ' + $Counter.Instance",
            "            }",
            "            # Display the formatted data",
            "            WriteLog -message (\"{0,-15} {1,-30} {2,-15} {3,-15} {4,-15}\" -f $Counter.Instance, $Counter.counter, $Counter.Min, $Counter.Max, $Counter.Avg)",
            "        }",
            "    }",
            "    else{",
            "        $Counters = $XMLContent.SelectNodes(\"//Table[@name='$CounterName']/Item\")",
            "        $SortedCounters = PerfmonDataAnalysis -XMLContent $XMLContent -CounterName $CounterName -Counters $Counters",
            "        # Display the sorted Counters summary with custom formatting",
            "        WriteLog -message \"`n$CounterType Usage for the OS:\"",
            "",
            "        if ($SortedCounters | Where-Object { $_.Instance }) {",
            "            WriteLog -message (\"{0,-35} {1,-40} {2,-15} {3,-15} {4,-15}\" -f \"Interface\", \"Counter\", \"Min\", \"Max\", \"Avg\")",
            "        } else {",
            "            WriteLog -message (\"{0,-40} {1,-25} {2,-15} {3,-15}\" -f \"Counter\", \"Min\", \"Max\", \"Avg\")",
            "        }",
            "",
            "        foreach ($Counter in $SortedCounters | Sort-Object { $_.Instance,$_.counter }) {",
            "            if ($Counter.Instance) {",
            "                WriteLog -message (\"{0,-35} {1,-40} {2,-15} {3,-15} {4,-15}\" -f $Counter.Instance, $Counter.Counter, $Counter.Min, $Counter.Max, $Counter.Avg)",
            "            } else {",
            "                WriteLog -message (\"{0,-40} {1,-25:F2} {2,-15:F2} {3,-15:F2}\" -f $Counter.Counter, $Counter.Min, $Counter.Max, $Counter.Avg)",
            "            }",
            "        }",
            "    }",
            "}",
            "if (!(Test-Path -Path $XMLFilePath -PathType Leaf)) {",
            "    Write-Output \"[FAILED] Failed to find the captured XML file. Aborting the log summary and will continue with other steps.\"",
            "    WriteLog -message \"`n[FAILED] Failed to find the captured XML file. Aborting the log summary and will continue with other steps.\"",
            "    Exit 1",
            "} else {",
            "    DisplayPerformanceAnalysis -XMLContent $XMLContent -CounterType 'Processor' -CounterName '% Processor Time'",
            "    DisplayPerformanceAnalysis -XMLContent $XMLContent -CounterType 'WorkingSet' -CounterName 'Working Set'",
            "    DisplayPerformanceAnalysis -XMLContent $XMLContent -CounterType 'LogicalDisk' -CounterName 'Disk'",
            "    DisplayPerformanceAnalysis -XMLContent $XMLContent -CounterType 'Network Interface' -CounterName 'Network Interface'",
            "    DisplayPerformanceAnalysis -XMLContent $XMLContent -CounterType 'Memory' -CounterName 'Memory'",
            "    DisplayPerformanceAnalysis -XMLContent $XMLContent -CounterType 'TCPv4' -CounterName 'TCPv4'",
            "    DisplayPerformanceAnalysis -XMLContent $XMLContent -CounterType 'IPv4' -CounterName 'IPv4'",
            "    DisplayPerformanceAnalysis -XMLContent $XMLContent -CounterType 'UDPv4' -CounterName 'UDPv4'",
            "",
            "    Write-Output \"`n[PASSED] Performance logs summary completed.\"",
            "    Write-output \"For detailed analysis of other metrics such as Disk, Memory, Network Interface, TCPV4, IPV4 and UDPV4, please check the file $OutputFilePath `nYou can also analyze the captured Windows Performance Recorder logs as well as Windows Performance monitor logs captured in the same directory.\"",
            "    Write-output \"The analysis_output.log file will not be deleted by this automation, please manually delete it after analysis.\"",
            "    Exit 0",
            "}"
          ]
        }
      },
      "isCritical": true,
      "nextStep": "BranchOnInstallEC2Rescue"
    },
    {
      "name": "BranchOnInstallEC2Rescue",
      "action": "aws:branch",
      "description": "Branches on based on the value of the input parameter `InstallEC2RescueTool`.",
      "onFailure": "Abort",
      "isEnd": true,
      "isCritical": true,
      "inputs": {
        "Choices": [
          {
            "Variable": "{{ InstallEC2RescueTool }}",
            "StringEquals": "Yes",
            "NextStep": "InstallEC2RescueTool"
          }
        ],
        "Default": "BranchOnIfS3BucketProvided"
      }
    },
    {
      "name": "InstallEC2RescueTool",
      "description": "Installs the latest version of the EC2Rescue tool using `AWS-ConfigureAWSPackage`.",
      "action": "aws:runCommand",
      "onFailure": "step:BranchOnIfS3BucketProvided",
      "maxAttempts": 3,
      "timeoutSeconds": 3600,
      "isCritical": true,
      "inputs": {
        "DocumentName": "AWS-ConfigureAWSPackage",
        "InstanceIds": [
          "{{ InstanceId }}"
        ],
        "Parameters": {
          "action": "Install",
          "name": "AWSSupport-EC2Rescue",
          "version": "latest"
        }
      },
      "nextStep": "RunEC2RescueTool"
    },
    {
      "name": "RunEC2RescueTool",
      "action": "aws:runCommand",
      "timeoutSeconds": 3600,
      "description": "Collects EC2Rescue logs.",
      "onFailure": "Continue",
      "inputs": {
        "InstanceIds": [
          "{{ InstanceId }}"
        ],
        "DocumentName": "AWS-RunPowerShellScript",
        "Parameters": {
          "commands": [
            "# Copyright 2024 Amazon.com, Inc. or its affiliates. All Rights Reserved.",
            "# SPDX-License-Identifier: LicenseRef-.amazon.com.-AmznSL-1.0",
            "# Licensed under the Amazon Software License  http://aws.amazon.com/asl/",
            "",
            "$ExecutionId = \"{{ automation:EXECUTION_ID }}\"",
            "$BasePath = \"$env:ProgramData\\Amazon\\SSM\\TroubleshootWindowsPerformance\\$ExecutionId\"",
            "$InstanceId = \"{{InstanceId}}\"",
            "$EC2RescueLocation = \"${env:PROGRAMFILES}\\Amazon\\EC2Rescue\\EC2RescueCmd.exe\"",
            "",
            "if (Test-Path -Path $EC2RescueLocation -PathType Leaf) {",
            "    $DataCollectionItems = \"memory-dump.Mini Dump Files,eventlog,ssm-agent.Log Files,system-info,gpresult,registry,ec2config.Log Files,ec2launch.Logs,boot-config\"",
            "    $TempLogFile = \"$BasePath\\\" + $InstanceId + \"_EC2Rescue_\" + (Get-Date).ToString(\"HH-mm-ss\") + \".zip\"",
            "    $OutputLog = & \"$EC2RescueLocation\" /accepteula /online /collect:$DataCollectionItems /output:$TempLogFile",
            "    Write-Verbose $OutputLog.ToString()",
            "    Write-output \"`n[PASSED] EC2Rescue log collection is completed. Log saved in folder: '$TempLogFile'. `nThe latest EC2Rescue tool is installed by this automation and please manually remove it if you don't need it. Its installed path is $EC2RescueLocation.\"",
            "    Exit 0",
            "}",
            "else {",
            "    Write-Output \"[FAILED] Failed step with error: EC2Rescue is not installed. Aborting the EC2Rescue log collection and will continue with other steps.\"",
            "    Exit 1",
            "}"
          ]
        }
      },
      "isCritical": true,
      "nextStep": "BranchOnIfS3BucketProvided"
    },
    {
      "name": "BranchOnIfS3BucketProvided",
      "action": "aws:branch",
      "description": "Branches on whether the `LogUploadBucketName` input parameter was provided or not. If no bucket was provided, the automation ends.",
      "inputs": {
        "Choices": [
          {
            "Not": {
              "Variable": "{{ LogUploadBucketName }}",
              "StringEquals": ""
            },
            "NextStep": "GetS3BucketPublicStatus"
          }
        ]
      },
      "onFailure": "Continue",
      "isCritical": false,
      "isEnd": true
    },
    {
      "name": "GetS3BucketPublicStatus",
      "description": "Checks if the Amazon S3 bucket specified in `LogUploadBucketName` is configured with server-side encryption (SSE), and if it allows anonymous, or public read or write access permissions.",
      "action": "aws:executeScript",
      "timeoutSeconds": 600,
      "onFailure": "Abort",
      "inputs": {
        "InputPayload": {
          "Bucket": "{{ LogUploadBucketName }}"
        },
        "Handler": "s3_bucket_public_status.check_bucket_public_status",
        "Runtime": "python3.8",
        "Attachment": "check_bucket_public_status.zip"
      },
      "outputs": [
        {
          "Name": "BucketLocation",
          "Selector": "$.Payload.location",
          "Type": "String"
        }
      ],
      "isCritical": true,
      "nextStep": "UploadLogResult"
    },
    {
      "name": "UploadLogResult",
      "description": "Uploads the logs to the Amazon S3 bucket specified in the `LogDestination` parameter.",
      "action": "aws:runCommand",
      "onFailure": "Abort",
      "maxAttempts": 1,
      "timeoutSeconds": 2400,
      "inputs": {
        "DocumentName": "AWS-RunPowerShellScript",
        "InstanceIds": [
          "{{ InstanceId }}"
        ],
        "Parameters": {
          "commands": [
            "# Copyright 2024 Amazon.com, Inc. or its affiliates. All Rights Reserved.",
            "# SPDX-License-Identifier: LicenseRef-.amazon.com.-AmznSL-1.0",
            "# Licensed under the Amazon Software License http://aws.amazon.com/asl/",
            "",
            "# Set AWS Tools for PowerShell environment variables",
            "$Env:AWS_RETRY_MODE=\"standard\" # Specifies the retry mode for AWS API calls",
            "$Env:AWS_MAX_ATTEMPTS=10 # Specifies the maximum retry attempts",
            "$Env:AWS_DEFAULT_REGION=\"{{ global:REGION }}\" # Sets default region",
            "",
            "$ExecutionId = \"{{ automation:EXECUTION_ID }}\"",
            "$BasePath = \"$env:ProgramData\\Amazon\\SSM\\TroubleshootWindowsPerformance\\$ExecutionId\"",
            "$S3BucketName = \"{{ LogUploadBucketName }}\"",
            "$InstanceId = \"{{ InstanceId }}\"",
            "$LogZipFilePath = \"$env:ProgramData\\Amazon\\SSM\\TroubleshootWindowsPerformance\\Zip\\$ExecutionId\"",
            "$LogZipFile = \"$LogZipFilePath\\TroubleshootWindowsPerformance_$($InstanceId)_$($ExecutionId).zip\"",
            "$BucketLocation = \"{{ GetS3BucketPublicStatus.BucketLocation }}\"",
            "",
            "try {",
            "    Import-Module AWSPowershell",
            "",
            "    if (Test-S3Bucket -BucketName $S3BucketName -Region $BucketLocation) {",
            "        try {",
            "            [System.Net.ServicePointManager]::SecurityProtocol = ([int][system.net.SecurityProtocolType]::Tls13 -bor [int][system.net.SecurityProtocolType]::Tls12)",
            "            if (Test-Path $LogZipFilePath) {",
            "                Remove-Item -Path $LogZipFilePath -Recurse -Force",
            "            }",
            "            New-Item -Path $LogZipFilePath -ItemType \"directory\" -Force | Out-Null",
            "",
            "            # Load the System.IO.Compression.FileSystem assembly",
            "            Add-Type -AssemblyName System.IO.Compression.FileSystem -ErrorAction SilentlyContinue",
            "            # Create the zip archive from the directory",
            "            [System.IO.Compression.ZipFile]::CreateFromDirectory($BasePath, $LogZipFile, [System.IO.Compression.CompressionLevel]::Optimal, $false)",
            "            Write-Output \"The log folder has been compressed to $LogZipFile. Uploading the compressed archive to the Amazon S3 bucket...\"",
            "            Write-S3Object -BucketName $S3BucketName -File $LogZipFile -Region $BucketLocation",
            "            Write-Output \"`n[PASSED] Log files uploaded to S3 bucket $S3BucketName with key $LogZipFile. `nThe captured log files are still placed in the instance, they won't be deleted by the automation and will need to be deleted manually after troubleshooting.\"",
            "            if (Test-Path $LogZipFilePath) {",
            "                Remove-Item -Path $LogZipFilePath -Recurse -Force",
            "            }",
            "            Exit 0",
            "        }",
            "        catch {",
            "            if (Test-Path $LogZipFilePath) {",
            "                Remove-Item -Path $LogZipFilePath -Recurse -Force",
            "            }",
            "            Write-Error \"[FAILED] An error occurred when trying to upload $LogZipFile $($_.Exception.Message). Please check and upload the logs manually after accessing the instance.\"",
            "            Write-Output \"Log file location: $BasePath\"",
            "            Exit 1",
            "        }",
            "    }",
            "    else {",
            "        Write-Error \"[FAILED] Couldn't find bucket $S3BucketName. Please check and upload the logs manually after accessing the instance.\"",
            "        Write-Output \"Log file location: $BasePath\"",
            "        Exit 1",
            "    }",
            "}",
            "catch {",
            "    Write-Error \"[FAILED] Error uploading files to Amazon S3 $($_.Exception.Message). Please check and upload the logs manually after accessing the instance.\"",
            "    Write-Output \"Log file location: $BasePath (also check for $LogZipFilePath if exists)\"",
            "    Exit 1",
            "}"
          ]
        }
      },
      "isCritical": false,
      "isEnd": true
    }
  ],
  "outputs": [
    "VerifyPrerequisites.Output",
    "CaptureProcessDump.Output",
    "CapturePerformanceLogs.Output",
    "CleanUpLogsOnFailure.Output",
    "SummarizePerformanceLogs.Output",
    "RunEC2RescueTool.Output",
    "UploadLogResult.Output"
  ],
  "files": {
    "check_concurrency.zip": {
      "checksums": {
        "SHA256": "ce966c740fd8a381d8103a68634c6cc360758a3e269bb6047851ac95fd913f06"
      }
    },
    "check_bucket_public_status.zip": {
      "checksums": {
        "SHA256": "be0dee25ffdfeedf7e18bce29ddb6093ea8999b87510499d8e141fcf2c9d721b"
      }
    }
  }
}
