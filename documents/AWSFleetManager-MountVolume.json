{
  "schemaVersion": "2.2",
  "description": "Mounts specified EBS volume by initializing the volume disk and creating a partition to make it useable.",
  "parameters": {
    "PerformAction": {
      "type": "String",
      "description": "(Optional) Set this to \"Yes\" to perform the action.",
      "default": "No",
      "allowedValues": [
        "No",
        "Yes"
      ]
    },
    "VolumeId": {
      "type": "String",
      "description": "(Required) Volume ID for the volume to mount.",
      "default": "",
      "allowedPattern": "^vol-[a-z0-9]{8,17}$"
    },
    "MountPoint": {
      "type": "String",
      "description": "(Optional) Drive letter that will be assigned to new volume. For example, D.",
      "default": "",
      "allowedPattern": "^$|^[a-zA-Z]{1}$"
    },
    "FileSystem": {
      "type": "String",
      "description": "(Required) File system in which the volume will be formatted. For example, NTFS.",
      "default": "NTFS",
      "allowedValues": [
        "exFAT",
        "FAT",
        "FAT32",
        "NTFS",
        "ReFS"
      ]
    },
    "VolumeLabel": {
      "type": "String",
      "description": "(Optional) Name used to identify the volume.",
      "default": "",
      "allowedPattern": "^$|^[^\"'\\/\\\\\\[\\]:;|=,+*?<>@\\r\\n]+$"
    },
    "PartitionStyle": {
      "type": "String",
      "description": "(Required) Partition type for the volume being mounted.",
      "default": "GPT",
      "allowedValues": [
        "MBR",
        "GPT"
      ]
    }
  },
  "mainSteps": [
    {
      "precondition": {
        "StringEquals": [
          "platformType",
          "Windows"
        ]
      },
      "action": "aws:runPowerShellScript",
      "name": "InvokeWindowsScript",
      "inputs": {
        "runCommand": [
          "$ErrorActionPreference = 'Stop'\n\nFunction ParseInputParameter {\n    param (\n        [string]$Name,\n        [string]$Value,\n        [string]$Regex\n    )\n\n    $ValidParameterRegex = '^--%[ +{|{].*}( +)?$'\n    if ($Value -notmatch $ValidParameterRegex) {\n        ExitWithFailureMessage -Message \"Invalid syntax for the parameter $Name\"\n    }\n    $parameterValue = $Value.Substring(3)\n\n    $trimmedParameterValue = $parameterValue.TrimStart().TrimEnd()\n    $trimmedParameterValue = $trimmedParameterValue.Substring(1)\n    $trimmedParameterValue = $trimmedParameterValue.Substring(0, $trimmedParameterValue.Length - 1)\n\n    if ($Regex -and $trimmedParameterValue -notmatch $Regex) {\n        ExitWithFailureMessage -Message \"Invalid syntax for the parameter $Name\"\n    } else {\n        $trimmedParameterValue\n    }\n}\n\nfunction ExitWithFailureMessage {\n    param (\n        [string]$Message,\n        [string]$ExceptionMessage,\n        [Switch]$PrintJson\n    )\n    if ([string]::IsNullOrWhitespace($ExceptionMessage)) {\n        $errorMessage = $Message\n    } else {\n        $errorMessage = '{0} {1}' -f $Message, $ExceptionMessage\n    }\n    if ($PrintJson) {ConvertTo-Json -InputObject @{error = $errorMessage} -Compress}\n    WriteStandardError -Message $errorMessage\n    [System.Environment]::Exit(1)\n}\n\nfunction ExitWithFailureMessageAndExitCode {\n    param (\n        [string]$Message,\n        [string]$ExceptionMessage,\n        [int]$ExitCode,\n        [Switch]$PrintJson\n    )\n    if ([string]::IsNullOrWhitespace($ExceptionMessage)) {\n        $errorMessage = $Message\n    } else {\n        $errorMessage = '{0} {1}' -f $Message, $ExceptionMessage\n    }\n    if ($PSBoundParameters.ContainsKey('ExitCode') -eq $true) {\n        $exitCode = $ExitCode\n    } else {\n        $exitCode = 1\n    }\n    if ($PrintJson) {\n        $ErrorObject = @{\n            error = $errorMessage\n            exitCode = $exitCode\n        }\n        ConvertTo-Json -InputObject $ErrorObject -Compress\n    }\n    WriteStandardError -Message $errorMessage\n    [System.Environment]::Exit($exitCode)\n}\n\nfunction ExitWithSuccessMessage {\n    param (\n        [string]$Message\n    )\n    Write-Host $Message\n    [System.Environment]::Exit(0)\n}\n\nfunction WriteStandardError {\n    param (\n        [string]$Message\n    )\n    $Host.UI.WriteErrorLine($Message)\n}\n\nfunction TestPerformAction {\n    param ( [string]$PerformAction )\n    if ($PerformAction -ne 'Yes') {\n        ExitWithFailureMessage -Message \"No action was taken because the PerformAction parameter is set to $PerformAction. To make the desired change, set this parameter to Yes.\"\n    }\n}\n\n$script:ResultProperty = 'results'\n$script:DataProperty = 'data'\n$script:NextTokenProperty = 'nextToken'\n\nfunction ConvertBase64ToString {\n    param (\n        [string]$Base64\n    )\n    $bytes = [System.Convert]::FromBase64String($Base64)\n    [System.Text.Encoding]::UTF8.GetString($bytes)\n}\n\nfunction ConvertStringToBase64 {\n    param (\n        [string]$String\n    )\n    $bytes = [System.Text.Encoding]::UTF8.GetBytes($String)\n    [System.Convert]::ToBase64String($bytes)\n}\n\nfunction GetCompressionBoolean {\n    param (\n        [ValidateSet('No','Yes')]\n        [string]$CompressOutput\n    )\n    if ($CompressOutput -eq 'Yes') {\n        $true\n    } else {\n        $false\n    }\n}\n\nfunction GetJson {\n    param ($InputObject)\n    ConvertTo-Json -InputObject $InputObject -Compress -Depth 5\n}\n\nfunction GetBase64EncodedGzipString {\n    param ($InputString)\n\n    $inputBytes = [System.Text.Encoding]::UTF8.GetBytes($InputString)\n\n    try {\n        $memoryStream = New-Object -TypeName 'System.IO.MemoryStream'\n        $compressionMode = [System.IO.Compression.CompressionMode]::Compress\n        $gzipStream = New-Object -TypeName 'System.IO.Compression.GzipStream' -ArgumentList @($memoryStream, $compressionMode)\n\n        $gzipStream.Write($inputBytes, 0, $inputBytes.Length)\n        $gzipStream.Close()\n        $memoryStream.Close()\n\n        [System.Convert]::ToBase64String($memoryStream.ToArray())\n    } finally {\n        $gzipStream.Dispose()\n        $memoryStream.Dispose()\n    }\n}\n\nfunction GetResultAsString {\n    param (\n        [PSObject]$Object,\n        [bool]$Completed,\n        [switch]$ConvertNextTokenToBase64,\n        [bool]$EnableCompression,\n        [bool]$ForceEmptyNextToken,\n        [string]$NextToken,\n        [string]$PaginationProperty,\n        [array]$StringReplacementRegex\n    )\n\n    if ([string]::IsNullOrWhiteSpace($NextToken)) {\n        if ($Completed -eq $false -and $Object.Count -ge 1 -and $ForceEmptyNextToken -ne $true) {\n            if ($PaginationProperty -eq '.') {\n                $NextToken = $Object[-1]\n            } else {\n                $NextToken = $Object[-1].$PaginationProperty\n            }\n        }\n    }\n\n    if ($ForceEmptyNextToken) {\n        $NextToken = [string]::Empty\n    } elseif ($ConvertNextTokenToBase64) {\n        $NextToken = ConvertStringToBase64 -String $NextToken\n    }\n\n    $data = @{\n        $script:ResultProperty    = $Object\n        $script:NextTokenProperty = $NextToken\n    }\n\n    if ($EnableCompression -eq $true) {\n        $string = GetJson -InputObject $data\n\n        if ($StringReplacementRegex.Count -eq 2) {\n            $string = $string -replace $StringReplacementRegex\n        }\n\n        $data = GetBase64EncodedGzipString -InputString $string\n    }\n\n    $output = GetJson -InputObject @{\n        $script:DataProperty = $data\n    }\n    if ($StringReplacementRegex.Count -eq 2) {\n        $output -replace $StringReplacementRegex\n    } else {\n        $output\n    }\n}\n\nfunction GetMaximumOutputBytes {\n    param (\n        $AllowTruncatedOutput,\n        [int]$MaximumOutputSize = 2500\n    )\n    if ($AllowTruncatedOutput -eq 'Yes') {\n        0\n    } else {\n        $padding = (GetResultAsString -Object @() -Completed $false -EnableCompression $false).length\n        $MaximumOutputSize - $padding\n    }\n}\n\nfunction ProcessItems {\n    param (\n        [scriptblock]$ScriptBlock,\n        [switch]$ConvertNextTokenToBase64,\n        [int]$ChunksPerLoop = 1,\n        [bool]$EnableCompression,\n        [int]$MaximumOutputBytes,\n        [string]$PaginationProperty,\n        [string]$PropertyToRemove,\n        [string]$NextToken,\n        [switch]$SetNextTokenBeforeAdding,\n        [array]$StringReplacementRegex\n    )\n\n    $chunkedOutputArray = New-Object -TypeName 'System.Collections.ArrayList'\n\n    $outputResult = [string]::Empty\n\n    $outputTooBig = $false\n    $counter = 0\n\n    $getResultString = @{\n        EnableCompression = $EnableCompression\n        PaginationProperty = $PaginationProperty\n        StringReplacementRegex = $StringReplacementRegex\n    }\n\n    foreach ($item in (& $ScriptBlock)) {\n        if ($outputTooBig -eq $true) { break }\n\n        if ($NextToken -ne '*') {\n            if ($PaginationProperty -eq '.' -and $item -le $NextToken) {\n                continue\n            } elseif ($PaginationProperty -ne '.' -and $item.$PaginationProperty -le $NextToken) {\n                continue\n            }\n        }\n\n        if ($SetNextTokenBeforeAdding) {\n            if ($PaginationProperty -eq '.') {\n                $newNextToken = $item\n            } else {\n                $newNextToken = $item.$PaginationProperty\n            }\n        }\n\n        if ($PropertyToRemove) {\n            $item.PSObject.properties.remove($PropertyToRemove)\n        }\n\n        $null = $chunkedOutputArray.Add($item)\n\n        if ($counter -lt $ChunksPerLoop) {\n            $counter++\n            continue\n        }\n\n        $counter = 0\n\n        $properties = @{\n            Object = $chunkedOutputArray\n            Completed = $outputTooBig\n        }\n        if ($ConvertNextTokenToBase64) {\n            $properties.Add('ConvertNextTokenToBase64', $ConvertNextTokenToBase64)\n        }\n        if ($SetNextTokenBeforeAdding) {\n            $properties.Add('NextToken', $newNextToken)\n        }\n        $tempResult = GetResultAsString @properties @getResultString\n\n        if ($MaximumOutputBytes -eq 0 -or $tempResult.Length -le $MaximumOutputBytes) {\n            $outputResult = $tempResult\n        } else {\n            $outputTooBig = $true\n            break\n        }\n    }\n\n    # Processing remaining items if the output isn't too big yet\n    if ($outputTooBig -eq $false) {\n        $properties = @{\n            Object = $chunkedOutputArray\n            Completed = $outputTooBig\n            ForceEmptyNextToken = $true\n        }\n        if ($ConvertNextTokenToBase64) {\n            $properties.Add('ConvertNextTokenToBase64', $ConvertNextTokenToBase64)\n        }\n        if ($SetNextTokenBeforeAdding) {\n            $properties.Add('NextToken', $newNextToken)\n        }\n        $tempResult = GetResultAsString @getResultString @properties\n        if ($MaximumOutputBytes -eq 0 -or $tempResult.Length -le $MaximumOutputBytes) {\n            $outputResult = $tempResult\n        }\n    }\n\n    $outputResult\n}\n\n$VolumeId = Write-Output --%{{{ VolumeId }}}\n$VolumeId = ParseInputParameter -Name 'VolumeId' -Value $VolumeId\n\n$MountPoint = Write-Output --%{{{MountPoint}}}\n$MountPoint = ParseInputParameter -Name 'MountPoint' -Value $MountPoint\n\n$FileSystem = Write-Output --%{{{FileSystem}}}\n$FileSystem = ParseInputParameter -Name 'FileSystem' -Value $FileSystem\n\n$VolumeLabel = Write-Output --%{{{VolumeLabel}}}\n$VolumeLabel = ParseInputParameter -Name 'VolumeLabel' -Value $VolumeLabel\n\n$PartitionStyle = Write-Output --%{{{PartitionStyle}}}\n$PartitionStyle = ParseInputParameter -Name 'PartitionStyle' -Value $PartitionStyle\n\n$PerformAction = Write-Output --%{{{ PerformAction }}}\n$PerformAction = ParseInputParameter -Name 'PerformAction' -Value $PerformAction -Regex '(Yes|No)'\nTestPerformAction -PerformAction $PerformAction\n\n$DEVICE_NAME_PATTERN = '^(xvd[a-z])|(\\/dev\\/sda1)|(vol\\.)|(AWS\\.)'\n\nfunction TestValidVolumeId {\n    param([string]$VolumeId)\n    if ($VolumeId -match $DEVICE_NAME_PATTERN) {\n        return $true\n    }\n    if ($VolumeId.StartsWith('AWS') -or $VolumeId.StartsWith('vol')) {\n        return $true\n    }\n    return $false\n}\n\n# Determines if the disk is empty before any actions are performed on the volume\n# This does not clean if the disk is initialized, or if partitions exist on volume\n$Global:WasEmpty = $false\nfunction IsEmpty {\n    param (\n        $Disk,\n        $VolumeId\n    )\n    $partition = Get-Partition -Disk $Disk\n    if (($Disk.PartitionStyle -eq 'RAW') -and ($null -eq $partition)) {\n        $Global:WasEmpty = $true\n        $Global:WasEmpty\n    } else {\n        ExitWithFailureMessage -Message \"There is currently existing data on $VolumeId. Please choose an empty volume or remove existing data from this one.\" -PrintJson\n    }\n}\n\n# Cleans the volume in case of any failures throughout execution as long as the WasEmpty function returns true.\n# This ensure the customer does not need to re-initialize disk in case of failure.\nfunction FailureCleanup {\n    param(\n        $Disk,\n        $VolumeId\n    )\n    if ($Global:WasEmpty) {\n        try {\n            Clear-Disk -Number $Disk.DiskNumber -Confirm:$false -RemoveData:$true\n        } catch {\n            $ErrorMessage = $_.Exception.Message\n            ExitWithFailureMessage -Message \"Failed to clean ${VolumeId}: $ErrorMessage\" -PrintJson\n        }\n    } else {\n        ExitWithFailureMessage -Message \"The volume was not empty before 'MountVolume' attempt, will not attempt to clean\" -PrintJson\n    }\n}\n\n# Initilizes the EBS volume using the designated partition style\nfunction InitializeVolume {\n    param (\n        $Disk,\n        $PartitionType,\n        $VolumeId\n    )\n\n    Try {\n        Initialize-Disk -InputObject $Disk -PartitionStyle $PartitionType\n        $partition = Get-Partition -DiskNumber $Disk.DiskNumber -ErrorAction SilentlyContinue | Where-Object { $_.Type -EQ 'Reserved' }\n        # Since these are additional disks that do not hold system information, we are removing the reserved partition on the disk.\n        if (($null -ne $partition) -and ($Disk.IsSystem -ne $true)) {\n            Remove-Partition -DiskNumber $Disk.DiskNumber -PartitionNumber $partition.PartitionNumber -Confirm:$false -ErrorAction SilentlyContinue\n        }\n    } Catch {\n        $ErrorMessage = $_.Exception.Message\n        FailureCleanup -Disk $Disk -VolumeId $VolumeId\n        ExitWithFailureMessage -Message \"Failed to initialize disk on ${VolumeId}: $ErrorMessage\" -PrintJson\n    }\n}\n\n# Creates the initial partition on the volume selected using the maximum size of the disk\nfunction CreatePartition {\n    param (\n        $Disk,\n        $MountPoint,\n        $VolumeId\n    )\n    Try {\n        # Since the MountPoint parameter is optional, we are handling the creation of\n        # the partition with, or without, the mount point\n        if ([string]::IsNullOrWhiteSpace($MountPoint)) {\n            New-Partition -DiskNumber $Disk.DiskNumber -UseMaximumSize\n        } else {\n            New-Partition -DiskNumber $Disk.DiskNumber -DriveLetter $MountPoint -UseMaximumSize\n        }\n    } Catch {\n        $ErrorMessage = $_.Exception.Message\n        FailureCleanup -Disk $Disk -VolumeId $VolumeId\n        ExitWithFailureMessage -Message \"Failed to create new partition on ${VolumeId}: $ErrorMessage\"  -PrintJson\n    }\n}\n\n# Formats the volume selected\nfunction FormatVolume {\n    param (\n        $FileSystem,\n        $Partition,\n        $Label,\n        $VolumeId\n    )\n\n    try {\n        # Since the VolumeLabel parameter is optional, we are handling the creation of\n        # the partition with, or without, the volume label\n        if ([string]::IsNullOrWhiteSpace($Label)) {\n            Format-Volume -Partition $Partition -FileSystem $FileSystem\n        } else {\n            Format-Volume -Partition $Partition -FileSystem $FileSystem -NewFileSystemLabel $Label\n        }\n    } catch {\n        $ErrorMessage = $_.Exception.Message\n        FailureCleanup -Disk $disk -VolumeId $VolumeId\n        ExitWithFailureMessage -Message \"Failed for format volume on ${VolumeId}: $ErrorMessage\"\n    }\n}\n\n# Determines if the VolumeId is valid, converts it into the correct format to match volume serial number,\n# and then selects the correct physical disk to be used later.\nif ($VolumeId) {\n    if ((TestValidVolumeId -VolumeId $VolumeId) -eq $false) {\n        ExitWithFailureMessage -Message \"Volume name $VolumeId is invalid\" -PrintJson\n    }\n    if ($VolumeId.StartsWith('vol-')) {\n        $newVolumeId = \"$($VolumeId.Substring(0, 3))$($VolumeId.Substring(4))\"\n        $physicalDisk = Get-PhysicalDisk | Where-Object { $_.SerialNumber.StartsWith($newVolumeId) }\n    } else {\n        $physicalDisk = Get-PhysicalDisk -UniqueId $newVolumeId -ErrorAction SilentlyContinue\n    }\n    if (-not $physicalDisk) {\n        ExitWithFailureMessage -Message \"No Physical Disk exists matching the name '$newVolumeId'.\" -PrintJson\n    }\n}\n\n$deviceId = $physicalDisk | Select-Object -ExpandProperty DeviceId\n$disk = Get-Disk -Number $deviceId\n\n# Ensures the volume is empty and then mounts the volume using previously defined functions\nif (IsEmpty -Disk $disk -VolumeId $VolumeId) {\n    try {\n        InitializeVolume -Disk $disk -PartitionType $PartitionStyle -VolumeId $VolumeId\n        $partition = CreatePartition -Disk $disk -MountPoint $MountPoint -VolumeId $VolumeId\n        $Properties = @(\n            'DriveLetter'\n            'FriendlyName'\n            'FileSystemType'\n            'DriveType'\n            'HealthStatus'\n            'OperationalStatus'\n            'SizeRemaining'\n            'Size'\n        )\n        FormatVolume -Partition $partition -FileSystem $FileSystem -Label $VolumeLabel -VolumeId $VolumeId | Select-Object $Properties | ConvertTo-Json\n    } catch {\n        FailureCleanup -Disk $disk -VolumeId $VolumeId\n        ExitWithFailureMessage -Message \"An unknown error has occured while trying mount the volume as $PartitionStyle\"\n    }\n}\n"
        ]
      }
    }
  ]
}
