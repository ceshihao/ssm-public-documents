{
  "description": "This document will collect ECS logs from a specified ECS instance and upload it to a specified S3 bucket.",
  "schemaVersion": "0.3",
  "assumeRole": "{{ AutomationAssumeRole }}",
  "parameters": {
    "ECSInstanceId": {
      "type": "String",
      "allowedPattern": "^[i|mi]-[a-z0-9]{8,17}$",
      "description": "(Required) The ID of the ECS EC2 instance you want to collect logs from."
    },
    "LogDestination": {
      "type": "String",
      "description": "(Optional) The Amazon Simple Storage Service (S3) bucket in your account to upload the logs to. Please make sure the bucket policy does not grant unnecessary read/write permissions to parties that do not need access to the collected logs.",
      "allowedPattern": "^$|^(?!(^(([0-9]{1,3}[.]){3}[0-9]{1,3}$)))^((?!xn--)(?!.*-s3alias))[a-z0-9][-.a-z0-9]{1,61}[a-z0-9]$",
      "default": ""
    },
    "AutomationAssumeRole": {
      "type": "String",
      "description": "(Optional) The ARN of the role that allows Automation to perform the actions on your behalf. If no role is specified, Systems Manager Automation uses the permissions of the user that runs this document.",
      "default": ""
    }
  },
  "mainSteps": [
    {
      "name": "assertInstanceIsManaged",
      "action": "aws:assertAwsResourceProperty",
      "onFailure": "Abort",
      "inputs": {
        "Service": "ssm",
        "Api": "DescribeInstanceInformation",
        "Filters": [
          {
            "Key": "InstanceIds",
            "Values": [
              "{{ ECSInstanceId }}"
            ]
          }
        ],
        "PropertySelector": "$.InstanceInformationList[0].PingStatus",
        "DesiredValues": [
          "Online"
        ]
      },
      "isCritical": "true",
      "nextStep": "getInstancePlatform"
    },
    {
      "name": "getInstancePlatform",
      "action": "aws:executeAwsApi",
      "onFailure": "Abort",
      "inputs": {
        "Service": "ssm",
        "Api": "DescribeInstanceInformation",
        "Filters": [
          {
            "Key": "InstanceIds",
            "Values": [
              "{{ECSInstanceId}}"
            ]
          }
        ]
      },
      "outputs": [
        {
          "Name": "platformType",
          "Selector": "$.InstanceInformationList[0].PlatformType",
          "Type": "String"
        }
      ],
      "isCritical": "true",
      "nextStep": "verifyInstancePlatform"
    },
    {
      "name": "verifyInstancePlatform",
      "action": "aws:branch",
      "inputs": {
        "Choices": [
          {
            "NextStep": "runLogCollectionScriptOnWindows",
            "Variable": "{{getInstancePlatform.platformType}}",
            "StringEquals": "Windows"
          },
          {
            "NextStep": "runLogCollectionScriptOnLinux",
            "Variable": "{{getInstancePlatform.platformType}}",
            "StringEquals": "Linux"
          }
        ]
      }
    },
    {
      "name": "runLogCollectionScriptOnLinux",
      "action": "aws:runCommand",
      "onFailure": "Abort",
      "inputs": {
        "DocumentName": "AWS-RunShellScript",
        "InstanceIds": [
          "{{ECSInstanceId}}"
        ],
        "Parameters": {
          "commands": [
            "#!/usr/bin/env bash",
            "#",
            "# Copyright 2016-2018 Amazon.com, Inc. or its affiliates.",
            "# All Rights Reserved.",
            "#",
            "# Licensed under the Apache License, Version 2.0 (the \"License\").",
            "# You may not use this file except in compliance with the License.",
            "# A copy of the License is located at",
            "#",
            "#    http://aws.amazon.com/apache2.0/",
            "#",
            "# or in the \"license\" file accompanying this file.",
            "# This file is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR",
            "# CONDITIONS OF ANY KIND, either express or implied. See the License for the",
            "# specific language governing permissions and limitations under the License.",
            "#",
            "#",
            "# - Collects Docker daemon and Amazon ECS Container Agent logs on Amazon Linux,",
            "#   Redhat 7, Debian 8.",
            "# - Collects general operating system logs.",
            "# - For usage information, see --help.",
            "",
            "export LANG=\"C\"",
            "export LC_ALL=\"C\"",
            "",
            "# Collection configuration",
            "# collectdir is where all collected informaton is placed under. This",
            "# services as the top level for this script's operation.",
            "readonly collectdir=\"/var/log/collectECSlogs_{{ECSInstanceId}}\"",
            "readonly collectdirpath=\"/var/log/\"",
            "readonly logdir=\"/var/log/collectECSlogs\"",
            "",
            "# Shared check variables",
            "",
            "# info_system is where the checks' data is placed.",
            "info_system=\"${collectdir}/system\"",
            "# pkgtype is the detected packaging system used on the host (eg: yum, deb)",
            "pkgtype=''  # defined in get_pkgtype",
            "# init_type is the operating system type used for casing check behavior.",
            "init_type=''  # defined in get_init_type",
            "progname='' # defined in parse_options",
            "",
            "# Script run defaults",
            "",
            "mode='brief' # defined in parse_options",
            "",
            "# Common functions",
            "# ---------------------------------------------------------------------------------------",
            "",
            "help() {",
            "  echo \"USAGE: ${progname} [--mode=[brief]]\"",
            "  echo \"       ${progname} --help\"",
            "  echo \"\"",
            "  echo \"OPTIONS:\"",
            "  echo \"     --mode  Sets the desired mode of the script. For more information,\"",
            "  echo \"             see the MODES section.\"",
            "  echo \"     --help  Show this help message.\"",
            "  echo \"\"",
            "  echo \"MODES:\"",
            "  echo \"     brief         Gathers basic operating system, Docker daemon, and Amazon\"",
            "  echo \"                   ECS Container Agent logs. This is the default mode.\"",
            "}",
            "",
            "parse_options() {",
            "  local count=\"$#\"",
            "",
            "  progname=\"$0\"",
            "",
            "  for i in $(seq \"$count\"); do",
            "    eval arg=\\$\"$i\"",
            "    # shellcheck disable=SC2154",
            "    param=\"$(echo \"$arg\" | awk -F '=' '{print $1}' | sed -e 's|--||')\"",
            "    val=\"$(echo \"$arg\" | awk -F '=' '{print $2}')\"",
            "",
            "    case \"${param}\" in",
            "      mode)",
            "        eval \"$param\"=\"${val}\"",
            "        ;;",
            "      help)",
            "        help && exit 0",
            "        ;;",
            "      *)",
            "        echo \"Parameter not found: '$param'\"",
            "        help && exit 1",
            "        ;;",
            "    esac",
            "  done",
            "}",
            "",
            "ok() {",
            "  echo \"ok\"",
            "}",
            "",
            "info() {",
            "  echo \"$*\"",
            "}",
            "",
            "try() {",
            "  local action=$*",
            "  echo -n \"Trying to $action ... \"",
            "}",
            "",
            "warning() {",
            "  local reason=$*",
            "  echo \"warning: $reason\"",
            "}",
            "",
            "failed() {",
            "  local reason=$*",
            "  echo \"failed: $reason\"",
            "}",
            "",
            "die() {",
            "  echo \"ERROR: $*\"",
            "  exit 1",
            "}",
            "",
            "is_root() {",
            "  try \"check if the script is running as root\"",
            "",
            "  if [[ \"$(id -u)\" != \"0\" ]]; then",
            "    die \"this script must be run as root!\"",
            "",
            "  fi",
            "",
            "  ok",
            "}",
            "",
            "cleanup() {",
            "  if [[ \"${collectdir}\" == \"/var/log/collectECSlogs_{{ECSInstanceId}}\" ]]; then",
            "    rm -rf \"$collectdir\" >/dev/null 2>&1",
            "  else",
            "    echo -e \"Unable to cleanup $collectdir, Please cleanup manually!\"",
            "  fi",
            "}",
            "",
            "init() {",
            "  is_root",
            "  get_init_type",
            "  get_pkgtype",
            "}",
            "",
            "collect_brief() {",
            "  init",
            "  is_diskfull",
            "  get_common_logs",
            "  get_kernel_logs",
            "  get_mounts_info",
            "  get_selinux_info",
            "  get_iptables_info",
            "  get_pkglist",
            "  get_system_services",
            "  get_docker_info",
            "  get_docker_containers_info",
            "  get_docker_logs",
            "  get_docker_systemd_config",
            "  get_docker_sysconfig",
            "  get_docker_daemon_json",
            "  get_ecs_agent_logs",
            "  get_ecs_agent_info",
            "  get_open_files",
            "}",
            "",
            "# Routines",
            "# ---------------------------------------------------------------------------------------",
            "",
            "get_init_type() {",
            "  try \"collect system information\"",
            "",
            "  case \"$(cat /proc/1/comm)\" in",
            "    systemd)",
            "      init_type=\"systemd\"",
            "    ;;",
            "    *)",
            "      init_type=\"other\"",
            "    ;;",
            "  esac",
            "",
            "  ok",
            "}",
            "",
            "get_pkgtype() {",
            "  if [[ -n \"$(command -v rpm)\" ]]; then",
            "    pkgtype=\"rpm\"",
            "  elif [[ -n \"$(command -v dpkg)\" ]]; then",
            "    pkgtype=\"dpkg\"",
            "  else",
            "    pkgtype=\"unknown\"",
            "  fi",
            "}",
            "",
            "pack() {",
            "  try \"archive gathered log information\"",
            "  if [ ! -f $logdir ]; then",
            "    mkdir -p $logdir",
            "  fi",
            "",
            "  local tar_bin",
            "  tar_bin=\"$(command -v tar 2>/dev/null)\"",
            "  [ -z \"${tar_bin}\" ] && warning \"TAR archiver not found, please install a TAR archiver to create the collection archive. You can still view the logs in the collect folder.\"",
            "",
            "  cd \"$collectdirpath\" || { echo \"cd failed.\"; exit 1; }",
            "",
            "  ${tar_bin} -cvzf \"$logdir\"/ecs_{{ECSInstanceId}}_{{automation:EXECUTION_ID}}.tgz collectECSlogs_{{ECSInstanceId}} > /dev/null 2>&1",
            "",
            "  ok",
            "}",
            "",
            "is_diskfull() {",
            "  try \"check disk space usage\"",
            "",
            "  threshold=70",
            "  i=2",
            "  result=$(df -kh | grep -ve \"Filesystem\" -ve \"loop\" | awk '{ print $5 }' | sed 's/%//g')",
            "  exceeded=0",
            "",
            "  for percent in ${result}; do",
            "    if [[ \"${percent}\" -gt \"${threshold}\" ]]; then",
            "      partition=$(df -kh | head -$i | tail -1| awk '{print $1}')",
            "      echo",
            "      warning \"${partition} is ${percent}% full, please ensure adequate disk space to collect and store the log files.\"",
            "      : $((exceeded++))",
            "    fi",
            "    i=$((i+1))",
            "  done",
            "",
            "  if [ \"$exceeded\" -gt 0 ]; then",
            "    return 1",
            "  else",
            "    ok",
            "  fi",
            "}",
            "",
            "get_mounts_info() {",
            "  try \"get mount points and volume information\"",
            "",
            "  mkdir -p \"$info_system\"",
            "  mount > \"$info_system\"/mounts.txt",
            "  echo \"\" >> \"$info_system\"/mounts.txt",
            "  df -h >> \"$info_system\"/mounts.txt",
            "",
            "  if command -v lvdisplay > /dev/null; then",
            "    lvdisplay > \"$info_system\"/lvdisplay.txt",
            "    vgdisplay > \"$info_system\"/vgdisplay.txt",
            "    pvdisplay > \"$info_system\"/pvdisplay.txt",
            "  fi",
            "",
            "  ok",
            "}",
            "",
            "get_selinux_info() {",
            "  try \"check SELinux status\"",
            "",
            "  enforced=\"$(getenforce 2>/dev/null)\"",
            "",
            "  { [ \"${pkgtype}\" != \"rpm\" ] || [ -z \"${enforced}\" ]; } \\",
            "    && info \"not installed\" \\",
            "    && return",
            "",
            "  mkdir -p \"$info_system\"",
            "  echo -e \"SELinux mode:\\\\n    ${enforced}\" >  \"$info_system\"/selinux.txt",
            "",
            "  ok",
            "}",
            "",
            "get_iptables_info() {",
            "  try \"get iptables list\"",
            "",
            "  mkdir -p \"$info_system\"",
            "  iptables -nvL -t filter > \"$info_system\"/iptables-filter.txt",
            "  iptables -nvL -t nat  > \"$info_system\"/iptables-nat.txt",
            "",
            "  ok",
            "}",
            "",
            "get_open_files() {",
            "  try \"get open files list\"",
            "",
            "  mkdir -p \"$info_system\"",
            "  for d in /proc/*/fd; do echo \"$d\"; find \"$d\" -maxdepth 1 | wc -l; done > \"$info_system\"/open-file-counts.txt",
            "  ls -l /proc/*/fd > \"$info_system\"/open-file-details.txt",
            "",
            "  ok",
            "}",
            "",
            "get_common_logs() {",
            "  try \"collect common operating system logs\"",
            "",
            "  dstdir=\"${info_system}/var_log\"",
            "  mkdir -p \"$dstdir\"",
            "",
            "  for entry in syslog messages; do",
            "    [ -e \"/var/log/${entry}\" ] && cp -f /var/log/${entry} \"$dstdir\"/",
            "  done",
            "",
            "  ok",
            "}",
            "",
            "get_kernel_logs() {",
            "  try \"collect kernel logs\"",
            "",
            "  dstdir=\"${info_system}/kernel\"",
            "  mkdir -p \"$dstdir\"",
            "  if [ -e \"/var/log/dmesg\" ]; then",
            "    cp -f /var/log/dmesg \"$dstdir/dmesg.boot\"",
            "  fi",
            "  dmesg > \"$dstdir/dmesg.current\"",
            "  dmesg --ctime > \"$dstdir/dmesg.human.current\"",
            "  ok",
            "}",
            "",
            "get_docker_logs() {",
            "  try \"collect Docker and containerd daemon logs\"",
            "",
            "  dstdir=\"${info_system}/docker_log\"",
            "  mkdir -p \"$dstdir\"",
            "  case \"${init_type}\" in",
            "    systemd)",
            "      journalctl -u docker > \"${dstdir}\"/docker",
            "      journalctl -u containerd > \"${info_system}\"/containerd.log",
            "      ;;",
            "    other)",
            "      for entry in docker upstart/docker; do",
            "        if [[ -e \"/var/log/${entry}\" ]]; then",
            "          cp -f /var/log/\"${entry}\" \"${dstdir}\"/docker",
            "        fi",
            "      done",
            "      ;;",
            "    *)",
            "      warning \"the current operating system is not supported.\"",
            "      return 1",
            "      ;;",
            "  esac",
            "",
            "  ok",
            "}",
            "",
            "get_ecs_agent_logs() {",
            "  try \"collect Amazon ECS Container Agent logs\"",
            "",
            "  dstdir=\"${info_system}/ecs_agent_logs\"",
            "",
            "  if [ ! -d /var/log/ecs ]; then",
            "    failed \"ECS log directory does not exist\"",
            "    return 1",
            "  fi",
            "",
            "  mkdir -p \"$dstdir\"",
            "",
            "  cp -f /var/log/ecs/* \"$dstdir\"/",
            "",
            "  ok",
            "}",
            "",
            "get_pkglist() {",
            "  try \"detect installed packages\"",
            "",
            "  mkdir -p \"$info_system\"",
            "  case \"${pkgtype}\" in",
            "    rpm)",
            "      rpm -qa >\"$info_system\"/pkglist.txt 2>&1",
            "      ;;",
            "    dpkg)",
            "      dpkg --list > \"$info_system\"/pkglist.txt 2>&1",
            "      ;;",
            "    *)",
            "      warning \"unknown package type.\"",
            "      return 1",
            "      ;;",
            "  esac",
            "",
            "  ok",
            "}",
            "",
            "get_system_services() {",
            "  try \"detect active system services list\"",
            "",
            "  mkdir -p \"$info_system\"",
            "  case \"${init_type}\" in",
            "    systemd)",
            "      systemctl list-units > \"$info_system\"/services.txt 2>&1",
            "      ;;",
            "    other)",
            "      service --status-all >> \"$info_system\"/services.txt 2>&1",
            "      ;;",
            "    *)",
            "      warning \"unable to determine active services.\"",
            "      return 1",
            "      ;;",
            "  esac",
            "",
            "  top -b -n 1 > \"$info_system\"/top.txt 2>&1",
            "  ps fauxwww > \"$info_system\"/ps.txt 2>&1",
            "  netstat -plant > \"$info_system\"/netstat.txt 2>&1",
            "",
            "  ok",
            "}",
            "",
            "get_docker_info() {",
            "  try \"gather Docker daemon information\"",
            "",
            "  mkdir -p \"$info_system\"/docker",
            "",
            "  if pgrep dockerd > /dev/null ; then",
            "",
            "    timeout 20 docker info > \"$info_system\"/docker/docker-info.txt 2>&1 || echo \"Timed out, ignoring \\\"docker info output \\\" \"",
            "    timeout 20 docker ps --all --no-trunc > \"$info_system\"/docker/docker-ps.txt 2>&1 || echo \"Timed out, ignoring \\\"docker ps --all --no-trunc output \\\" \"",
            "    timeout 20 docker images > \"$info_system\"/docker/docker-images.txt 2>&1 || echo \"Timed out, ignoring \\\"docker images output \\\" \"",
            "    timeout 20 docker version > \"$info_system\"/docker/docker-version.txt 2>&1 || echo \"Timed out, ignoring \\\"docker version output \\\" \"",
            "    timeout 60 docker stats --all --no-trunc --no-stream > \"$info_system\"/docker/docker-stats.txt 2>&1 || echo \"Timed out, ignoring \\\"docker stats\\\" output\"",
            "",
            "    ok",
            "  else",
            "    warning \"the Docker daemon is not running.\" | tee \"$info_system\"/docker/docker-not-running.txt",
            "  fi",
            "}",
            "",
            "get_ecs_agent_info() {",
            "  try \"collect Amazon ECS Container Agent state and config\"",
            "",
            "  mkdir -p \"$info_system\"/ecs-agent",
            "  if [ -e /var/lib/ecs/data/ecs_agent_data.json ]; then",
            "    python -mjson.tool < /var/lib/ecs/data/ecs_agent_data.json > \"$info_system\"/ecs-agent/ecs_agent_data.txt 2>&1",
            "  fi",
            "",
            "  if [ -e /var/lib/ecs/data/agent.db ]; then",
            "    cp -f /var/lib/ecs/data/agent.db \"$info_system\"/ecs-agent/agent.db 2>&1",
            "    chmod +r \"$info_system\"/ecs-agent/agent.db",
            "  fi",
            "",
            "  if [ -e /etc/ecs/ecs.config ]; then",
            "    cp -f /etc/ecs/ecs.config \"$info_system\"/ecs-agent/ 2>&1",
            "    if grep --quiet \"ECS_ENGINE_AUTH_DATA\" \"$info_system\"/ecs-agent/ecs.config; then",
            "      sed -i 's/ECS_ENGINE_AUTH_DATA=.*/ECS_ENGINE_AUTH_DATA=/g' \"$info_system\"/ecs-agent/ecs.config",
            "    fi",
            "  fi",
            "  ok",
            "",
            "  try \"collect Amazon ECS Container Agent engine data\"",
            "",
            "  if pgrep agent > /dev/null ; then",
            "    if command -v curl >/dev/null; then",
            "      if curl --max-time 3 -s http://localhost:51678/v1/tasks | python -mjson.tool > \"$info_system\"/ecs-agent/agent-running-info.txt 2>&1; then",
            "          ok",
            "      else",
            "          warning \"failed to get agent data\"",
            "      fi",
            "    else",
            "      warning \"curl is unavailable for probing ECS Container Agent introspection endpoint\"",
            "    fi",
            "  else",
            "    warning \"The Amazon ECS Container Agent is not running\" | tee \"$info_system\"/ecs-agent/ecs-agent-not-running.txt",
            "    return 1",
            "  fi",
            "}",
            "",
            "get_docker_containers_info() {",
            "  try \"inspect all Docker containers\"",
            "",
            "  mkdir -p \"$info_system\"/docker",
            "",
            "  if pgrep dockerd > /dev/null ; then",
            "    for i in $(docker ps -a -q); do",
            "      timeout 10 docker inspect \"$i\" > \"$info_system\"/docker/container-\"$i\".txt 2>&1",
            "      if [ $? -eq 124 ]; then",
            "        touch \"$info_system\"/docker/container-inspect-timed-out.txt",
            "        failed \"'docker inspect' timed out, not gathering containers\"",
            "        return 1",
            "      fi",
            "",
            "      if grep --quiet \"ECS_ENGINE_AUTH_DATA\" \"$info_system\"/docker/container-\"$i\".txt; then",
            "        sed -i 's/ECS_ENGINE_AUTH_DATA=.*/ECS_ENGINE_AUTH_DATA=/g' \"$info_system\"/docker/container-\"$i\".txt",
            "      fi",
            "    done",
            "  else",
            "    warning \"the Docker daemon is not running.\" | tee \"$info_system\"/docker/docker-not-running.txt",
            "    return 1",
            "  fi",
            "  ok",
            "}",
            "",
            "get_docker_sysconfig() {",
            "  try \"collect Docker sysconfig\"",
            "",
            "  if [ -e /etc/sysconfig/docker ]; then",
            "    mkdir -p \"${info_system}\"/docker",
            "    cp /etc/sysconfig/docker \"${info_system}\"/docker/sysconfig-docker",
            "    ok",
            "  else",
            "    info \"/etc/sysconfig/docker not found\"",
            "  fi",
            "",
            " try \"collect Docker storage sysconfig\"",
            "",
            "  if [ -e /etc/sysconfig/docker-storage ]; then",
            "    mkdir -p \"${info_system}\"/docker",
            "    cp /etc/sysconfig/docker-storage \"${info_system}\"/docker/sysconfig-docker-storage",
            "    ok",
            "  else",
            "    info \"/etc/sysconfig/docker-storage not found\"",
            "  fi",
            "}",
            "",
            "",
            "get_docker_daemon_json(){",
            "  try \"collect Docker daemon.json\"",
            "",
            "  if [ -e /etc/docker/daemon.json ]; then",
            "    mkdir -p \"${info_system}\"/docker",
            "    cp /etc/docker/daemon.json \"${info_system}\"/docker/daemon.json",
            "    ok",
            "  else",
            "    info \"/etc/docker/daemon.json not found\"",
            "  fi",
            "}",
            "",
            "get_docker_systemd_config(){",
            "",
            "  if [[ \"$init_type\" != \"systemd\" ]]; then",
            "    return 0",
            "  fi",
            "",
            "  try \"collect Docker systemd unit file\"",
            "",
            "  mkdir -p \"${info_system}\"/docker",
            "  if systemctl cat docker.service > \"${info_system}\"/docker/docker.service 2>/dev/null; then",
            "   ok",
            "  else",
            "    rm -f \"$info_system/docker/docker.service\"",
            "    warning \"docker.service not found\"",
            "  fi",
            "",
            "  try \"collect containerd systemd unit file\"",
            "  if systemctl cat containerd.service > \"${info_system}\"/docker/containerd.service 2>/dev/null; then",
            "   ok",
            "  else",
            "    rm -f \"$info_system/docker/containerd.service\"",
            "    warning \"containerd.service not found\"",
            "  fi",
            "}",
            "",
            "finished()",
            "{",
            "  if [ -z {{LogDestination}} ]; then",
            "    echo -e \"\\nDone... your bundled logs are located in $logdir/ecs_{{ECSInstanceId}}_{{automation:EXECUTION_ID}}.tgz.\\n\"",
            "  fi",
            "}",
            "# --------------------------------------------------------------------------------------------",
            "",
            "parse_options \"$@\"",
            "",
            "collect_brief",
            "pack",
            "cleanup",
            "finished"
          ]
        }
      },
      "description": "Run the Log collection script on the provided ECS Linux instance",
      "isCritical": "true",
      "nextStep": "verifyIfS3BucketProvided"
    },
    {
      "name": "runLogCollectionScriptOnWindows",
      "action": "aws:runCommand",
      "onFailure": "Abort",
      "inputs": {
        "DocumentName": "AWS-RunPowerShellScript",
        "InstanceIds": [
          "{{ECSInstanceId}}"
        ],
        "Parameters": {
          "commands": [
            "<# ",
            "    Copyright 2017 Amazon.com, Inc. or its affiliates. All Rights Reserved.",
            "    Licensed under the Apache License, Version 2.0 (the \"License\"). You may not use this file except in compliance with the License. A copy of the License is located at",
            "",
            "        http://aws.amazon.com/apache2.0/",
            "",
            "    or in the \"license\" file accompanying this file. ",
            "    This file is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.",
            "",
            ".SYNOPSIS ",
            "    Collects ECS Agent Logs",
            ".DESCRIPTION ",
            "    Run the script to collect ECS Logs",
            "    Run without parameters to Gather basic operating system, Docker daemon, and Amazon ECS container agent logs. ",
            "    Default script RunMode is Brief mode.",
            ".NOTES",
            "    You need to run this script with Elevated permissions to allow for the collection of the installed applications list",
            ".EXAMPLE ",
            "    ecs-log-collector.ps1",
            "    Gathers basic OS System, Docker daemon and Amazon ECS container agent logs",
            "#>",
            "",
            "param(",
            "    [Parameter(Mandatory=$False)][string]$RunMode = \"Brief\"   ",
            "    )",
            "",
            "# Common options",
            "$basepath = \"C:\\ProgramData\"",
            "$infodir=\"$basepath\\collectECSlogs_{{ECSInstanceId}}\"",
            "$logdir=\"$basepath\\collectECSlogs\"",
            "$info_system=\"$infodir\\system\"",
            "$s3BucketName = \"{{ LogDestination }}\"",
            "",
            "# Common functions",
            "# ---------------------------------------------------------------------------------------",
            "",
            "Function is_elevated{",
            "    If (-NOT ([Security.Principal.WindowsPrincipal] [Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole(`",
            "    [Security.Principal.WindowsBuiltInRole] \"Administrator\")) {",
            "        Write-warning \"This script requires elevated privileges to copy registry keys to the ECS logs collector folder.\"",
            "        Write-Host \"Please re-launch as Administrator.\" -foreground \"red\" -background \"black\"",
            "        break",
            "    }",
            "}",
            "",
            "",
            "Function create_working_dir{",
            "    try {",
            "        Write-Host \"Creating temporary directory\"",
            "        New-Item -type directory -path $info_system -Force >$null",
            "        New-Item -type directory -path $info_system\\docker -Force >$null",
            "        New-Item -type directory -path $info_system\\firewall -Force >$null",
            "        New-Item -type directory -path $info_system\\ecs -Force >$null",
            "        New-Item -type directory -path $info_system\\docker_log -Force >$null",
            "        Write-Host \"OK\" -ForegroundColor \"green\"",
            "    }",
            "    catch {",
            "        Write-Host \"Unable to create temporary directory\"",
            "        Write-Host \"Please ensure you have enough permissions to create directories\"",
            "        Write-Error \"Failed to create temporary directory\"",
            "        Break",
            "    }",
            "}",
            "",
            "Function get_sysinfo{",
            "    try {",
            "        Write-Host \"Collecting System information\"",
            "        systeminfo.exe > $info_system\\sysinfo",
            "        Write-Host \"OK\" -ForegroundColor \"green\"",
            "    }",
            "    catch {",
            "        Write-Error \"Unable to collect system information\" ",
            "        Break",
            "    }  ",
            "        ",
            "}",
            "",
            "Function is_diskfull{",
            "    $threshold = 30",
            "    try {",
            "        Write-Host \"Checking free disk space\"",
            "        $drive = Get-WmiObject Win32_LogicalDisk -Filter \"DeviceID='C:'\"",
            "        $percent = ([math]::round($drive.FreeSpace/1GB, 0) / ([math]::round($drive.Size/1GB, 0)) * 100)",
            "        Write-Host \"C: drive has $percent% free space\"",
            "        Write-Host \"OK\" -ForegroundColor \"green\"",
            "    }",
            "    catch {",
            "        Write-Error \"Unable to Determine Free Disk Space\" ",
            "        Break",
            "    }",
            "    if ($percent -lt $threshold){",
            "        Write-Error \"C: drive only has $percent% free space, please ensure there is at least $threshold% free disk space to collect and store the log files\" ",
            "        Break",
            "    }",
            "}",
            "",
            "Function get_system_logs{",
            "    try {",
            "        Write-Host \"Collecting System Logs\"",
            "        Get-WinEvent -LogName System | Select-Object timecreated,leveldisplayname,machinename,message | export-csv -Path $info_system\\system-eventlogs.csv",
            "        Write-Host \"OK\" -foregroundcolor \"green\"",
            "    }",
            "    catch {",
            "        Write-Error \"Unable to Collect System Logs\"",
            "        break",
            "    }",
            "}",
            "",
            "Function get_application_logs{",
            "    try {",
            "        Write-Host \"Collecting Application Logs\"",
            "        Get-WinEvent -LogName Application | Select-Object timecreated,leveldisplayname,machinename,message | export-csv -Path $info_system\\application-eventlogs.csv",
            "        Write-Host \"OK\" -foregroundcolor \"green\"",
            "    }",
            "    catch {",
            "        Write-Error \"Unable to Collect Application Logs\"",
            "        break",
            "    }",
            "}",
            "",
            "Function get_volumes_info{",
            "    try {",
            "        Write-Host \"Collecting Volume info\"",
            "        Get-psdrive -PSProvider 'FileSystem' | Out-file $info_system\\volumes",
            "        Write-Host \"OK\" -foregroundcolor \"green\"",
            "    }",
            "    catch {",
            "        Write-Error \"Unable to Collect Volume information\"",
            "        break",
            "    }",
            "}",
            "",
            "Function get_firewall_info{",
            "    try {",
            "        Write-Host \"Collecting Windows Firewall info\"",
            "        $fw = Get-NetFirewallProfile",
            "        foreach ($f in $fw){",
            "            if ($f.Enabled -eq \"True\"){",
            "                $file = $f.name",
            "                Write-Host \"Collecting Rules for\" $f.name \"profile\"",
            "                Get-NetFirewallProfile -Name $f.name | Get-NetFirewallRule | Out-file $info_system\\firewall\\firewall-$file",
            "                }",
            "            }",
            "        Write-Host \"OK\" -foregroundcolor \"green\"",
            "    }",
            "    catch {",
            "        Write-Error \"Unable to Collect Windows Firewall information\"",
            "        break",
            "    }",
            "}",
            "",
            "Function get_softwarelist{",
            "    try {",
            "        Write-Host \"Collecting installed applications list\"",
            "        gp HKLM:\\Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\* |Select DisplayName, DisplayVersion, Publisher, InstallDate, HelpLink, UninstallString | out-file $info_system\\installed-64bit-apps.txt",
            "        gp HKLM:\\Software\\Wow6432Node\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\* |Select DisplayName, DisplayVersion, Publisher, InstallDate, HelpLink, UninstallString | out-file $info_system\\installed-32bit-apps.txt",
            "        Write-Host \"OK\" -foregroundcolor \"green\"",
            "    }",
            "    catch {",
            "        Write-Error \"Unable to collect installed applications list\"",
            "        break",
            "    }",
            "}",
            "",
            "Function get_system_services{",
            "    try {",
            "        Write-Host \"Collecting Services list\"",
            "        get-service | fl | out-file $info_system\\services",
            "        Write-Host \"OK\" -foregroundcolor \"green\"",
            "    }",
            "    catch {",
            "        Write-Error \"Unable to collect Services list\"",
            "        break",
            "    }",
            "}",
            "",
            "Function get_docker_info{",
            "    try {",
            "        Write-Host \"Collecting Docker daemon information\"",
            "        docker info > $info_system\\docker\\docker-info.txt 2>&1",
            "        docker ps --all --no-trunc > $info_system\\docker\\docker-ps.txt 2>&1",
            "        docker images > $info_system\\docker\\docker-images.txt 2>&1",
            "        docker version > $info_system\\docker\\docker-version.txt 2>&1",
            "        Write-Host \"OK\" -foregroundcolor \"green\"",
            "    }",
            "    catch{",
            "        Write-Error \"Unable to collect Docker daemon information\"",
            "        Break",
            "    }",
            "}",
            "",
            "Function get_ecs_agent_logs{",
            "    try {",
            "        Write-Host \"Collecting ECS Agent logs\"",
            "        copy C:\\programdata\\amazon\\ecs\\log\\* $info_system\\ecs\\",
            "        Write-Host \"OK\" -foregroundcolor \"green\"",
            "    }",
            "    catch{",
            "        Write-Error \"Unable to collect ECS Agent logs\"",
            "        Break",
            "    }",
            "}",
            "",
            "Function get_containers_info{",
            "    try {",
            "        Write-Host \"Inspect running Docker containers and gather Amazon ECS container agent data\"",
            "        $containers = docker ps -q",
            "        foreach ($c in $containers){",
            "            docker inspect $c > $info_system/docker/container-$c.txt",
            "            if (Get-Content $info_system/docker/container-$c.txt |where-object {$_ -like 'ECS_ENGINE_AUTH_DATA'} ) {",
            "                (Get-Content $info_system/docker/container-$c.txt) | ForEach-Object {$_ -replace 'ECS_ENGINE_AUTH_DATA*.+$', 'ECS_ENGINE_AUTH_DATA: OBFUSCATED'} | Set-Content $info_system/docker/container-$c.txt",
            "            }",
            "        }",
            "        Write-Host \"OK\" -foregroundcolor \"green\"",
            "    }",
            "    catch {",
            "        Write-Error \"Unable to collect Docker containers data\"",
            "        Break",
            "    }",
            "}",
            "",
            "Function get_docker_logs{",
            "    try {",
            "        Write-Host \"Collecting Docker daemon logs\"",
            "        Get-EventLog -LogName Application -Source Docker | Sort-Object Time | Export-CSV $info_system/docker_log/docker-daemon.csv",
            "        Write-Host \"OK\" -foregroundcolor \"green\"",
            "    }",
            "    catch {",
            "        Write-Error \"Unable to collect Docker daemon logs\"",
            "        Break",
            "    }",
            "}",
            "",
            "Function cleanup{",
            "    if ( $infodir -eq \"$basepath\\collectECSlogs_{{ECSInstanceId}}\" )",
            "    {",
            "        Remove-Item -Recurse -Force $infodir -ErrorAction Ignore",
            "    }",
            "    else {",
            "        Write-Error \"Unable to cleanup $infodir, Please cleanup manually!\" ",
            "        Break",
            "    }",
            "    ",
            "}",
            "",
            "Function create_log_dir{",
            "    if (!(Test-Path $logdir))",
            "    {",
            "        try{",
            "            Write-Host \"Creating log directory\"",
            "            New-Item -type directory -path $logdir -Force >$null",
            "            Write-Host \"OK\" -ForegroundColor \"green\"",
            "        }",
            "        catch{",
            "            Write-Host \"Unable to create log directory\"",
            "            Write-Host \"Please ensure you have enough permissions to create directories\"",
            "            Write-Error \"Failed to create log directory\"",
            "            Break",
            "        }",
            "    }",
            "}",
            "",
            "Function pack{",
            "    try {",
            "        Write-Host \"Archiving gathered data\"",
            "        create_log_dir",
            "        Compress-Archive -Path $infodir -CompressionLevel Optimal -DestinationPath $logdir\\ecs_{{ECSInstanceId}}_{{automation:EXECUTION_ID}}.zip",
            "        Write-Host \"OK\" -foregroundcolor \"green\"",
            "    }",
            "    catch {",
            "        Write-Error \"Unable to archive data\"",
            "        Break",
            "    }",
            "}",
            "",
            "Function init{",
            "    is_elevated",
            "    create_working_dir",
            "    get_sysinfo",
            "}",
            "    ",
            "",
            "Function collect_brief{",
            "    init",
            "    is_diskfull",
            "    get_system_logs",
            "    get_application_logs",
            "    get_volumes_info",
            "    get_firewall_info",
            "    get_softwarelist",
            "    get_system_services",
            "    get_docker_info",
            "    get_ecs_agent_logs",
            "    get_containers_info",
            "    get_docker_logs",
            "}  ",
            "",
            "Function finished{",
            "    If (-Not $s3BucketName)",
            "    {",
            "        Write-Host \"`nDone... your bundled logs are located in $logdir\\ecs_{{ECSInstanceId}}_{{automation:EXECUTION_ID}}.zip`n\"",
            "    }",
            "}",
            "    ",
            "collect_brief",
            "pack ",
            "cleanup",
            "finished"
          ]
        }
      },
      "description": "Run the Log collection script on the provided ECS Windows instance",
      "isCritical": "true",
      "nextStep": "verifyIfS3BucketProvided"
    },
    {
      "name": "verifyIfS3BucketProvided",
      "action": "aws:branch",
      "inputs": {
        "Choices": [
          {
            "Not": {
              "Variable": "{{LogDestination}}",
              "StringEquals": ""
            },
            "NextStep": "runUploadScript"
          }
        ]
      },
      "description": "Checks if S3 bucket was provided in the invocation to upload the logs",
      "onFailure": "Abort",
      "isCritical": true,
      "isEnd": true
    },
    {
      "name": "runUploadScript",
      "action": "aws:branch",
      "inputs": {
        "Choices": [
          {
            "NextStep": "runUploadScriptOnWindows",
            "Variable": "{{getInstancePlatform.platformType}}",
            "StringEquals": "Windows"
          },
          {
            "NextStep": "runUploadScriptOnLinux",
            "Variable": "{{getInstancePlatform.platformType}}",
            "StringEquals": "Linux"
          }
        ]
      }
    },
    {
      "name": "runUploadScriptOnLinux",
      "action": "aws:runCommand",
      "onFailure": "Abort",
      "inputs": {
        "DocumentName": "AWS-RunShellScript",
        "InstanceIds": [
          "{{ECSInstanceId}}"
        ],
        "Parameters": {
          "commands": [
            "logfile=\"ecs_{{ECSInstanceId}}_{{automation:EXECUTION_ID}}.tgz\"",
            "bucketStatus=True",
            "accountId=\"{{ global:ACCOUNT_ID }}\"",
            "filepath=\"/var/log/collectECSlogs/${logfile}\"",
            "",
            "function cleanup()",
            "{",
            "if [ -f $filepath ]; then",
            "    rm $filepath",
            "fi",
            "}",
            "",
            "function eval_bucket_policy(){",
            "    policy_status=$($awspath s3api get-bucket-policy-status --bucket {{LogDestination}} --query PolicyStatus.IsPublic --output text 2>&1)",
            "    command_status=$?",
            "    if [ $command_status -eq 0 ] ; then",
            "        if [ \"$policy_status\" = \"False\" ] ; then",
            "            bucketStatus=False    ",
            "        else",
            "            echo \"Verifying bucket policy: Bucket is public, cannot Upload to a public bucket!\"",
            "        fi",
            "    elif [[ $(echo \"$policy_status\" | grep NoSuchBucketPolicy) ]]; then",
            "        bucketStatus=False",
            "    else",
            "        echo \"There was an error while verifying S3 bucket policy, $policy_status\"",
            "        bucketStatus=True",
            "    fi",
            "}",
            "",
            "function eval_bucket_acl(){",
            "    PUBLIC_ACL_INDICATOR='http://acs.amazonaws.com/groups/global/AllUsers'",
            "    acl_status=$($awspath s3api get-bucket-acl --output text --bucket {{LogDestination}} 2>&1)",
            "    command_status=$?",
            "    if [ $command_status -eq 0 ] ; then",
            "        if `echo $acl_status | grep -A1 'READ\\|WRITE' | grep -q \"${PUBLIC_ACL_INDICATOR}\"`",
            "        then",
            "            bucketStatus=True",
            "            echo \"Verifying bucket ACL: Bucket is public, cannot Upload to a public bucket!\"",
            "        else",
            "            bucketStatus=False",
            "        fi",
            "    else",
            "        echo \"There was an error while verifying S3 bucket ACL, $acl_status\"",
            "        bucketStatus=True",
            "    fi",
            "}",
            "",
            "echo \"Uploading ECS logs collected. Checking if AWS CLI is installed.\"",
            "if command -v aws &> /dev/null",
            "then",
            "    echo \"AWS CLI is Installed..\" ",
            "    awspath=$(command -v aws)",
            "    ${awspath} s3api head-bucket --bucket {{LogDestination}} --expected-bucket-owner $accountId &>/dev/null",
            "    if [ $? -ne 0 ];",
            "    then",
            "        echo \"No S3 bucket called {{LogDestination}} found in the current AWS account, or access denied. Please specify a S3 bucket you own and this instance has access to.\"",
            "        cleanup",
            "        exit 1",
            "    else",
            "        echo \"Checking if bucket {{LogDestination}} is public or not.\"",
            "        eval_bucket_policy  ",
            "        if [ \"$bucketStatus\" = \"False\" ]",
            "        then ",
            "            eval_bucket_acl ",
            "            if [ \"$bucketStatus\" = \"False\" ]",
            "            then",
            "                echo \"Bucket {{LogDestination}} is not public. Starting log upload..\"",
            "                if [ -f $filepath ]; then",
            "                    ${awspath} s3 cp $filepath s3://{{LogDestination}} --no-progress",
            "                    if [ $? -eq 0 ];",
            "                    then",
            "                        echo \"Log file $logfile uploaded to S3 bucket {{LogDestination}}.\"",
            "                    else ",
            "                        echo \"Failed to upload log file to S3 bucket {{LogDestination}}.\"",
            "                        cleanup",
            "                        exit 1",
            "                    fi",
            "                else",
            "                    echo \"Log file $filepath doesn't exist, Failed to upload the logs to S3 bucket {{LogDestination}}.\"",
            "                    cleanup",
            "                    exit 1",
            "                fi",
            "            else",
            "                echo \"The operation to upload logs has been cancelled. Exiting!\"",
            "                cleanup",
            "                exit 1",
            "            fi   ",
            "            cleanup",
            "        else",
            "            echo \"The operation to upload logs has been cancelled. Exiting!\"",
            "            cleanup",
            "            exit 1",
            "        fi",
            "fi",
            "else",
            "    echo \"AWS CLI Not Installed. Quitting Upload WorkFlow.\"",
            "    cleanup",
            "    exit 1",
            "fi"
          ]
        }
      },
      "isCritical": "true",
      "isEnd": true,
      "description": "Upload logs to S3"
    },
    {
      "name": "runUploadScriptOnWindows",
      "action": "aws:runCommand",
      "onFailure": "Abort",
      "inputs": {
        "DocumentName": "AWS-RunPowerShellScript",
        "InstanceIds": [
          "{{ECSInstanceId}}"
        ],
        "Parameters": {
          "commands": [
            "$s3BucketName = \"{{ LogDestination }}\"",
            "$curdir = (Get-Item -Path \".\\\" -Verbose).FullName",
            "$basepath = \"C:\\ProgramData\"",
            "$logFile = \"ecs_{{ECSInstanceId}}_{{ automation:EXECUTION_ID }}.zip\"",
            "$logdir=\"$basepath\\collectECSlogs\"",
            "$filepath = \"$logdir\\$logfile\"",
            "$accountId = \"{{ global:ACCOUNT_ID }}\"",
            "",
            "",
            "Function cleanup{",
            "    if (Test-Path $filepath -PathType leaf)",
            "    {",
            "    Remove-Item $filepath",
            "    }",
            "}",
            "",
            "Function evalBucketPolicy{",
            "    try {",
            "        $bucketPolicy = Get-S3BucketPolicyStatus -BucketName $S3bucketName -ExpectedBucketOwner $accountId",
            "    } ",
            "    catch {",
            "        if($_.Exception.Message -eq \"The bucket policy does not exist\") {",
            "            return $False",
            "        }",
            "        else",
            "        {",
            "            Write-Host \"There was an error while verifying S3 bucket policy:\" $_.Exception.Message",
            "            return $True",
            "        }",
            "    }",
            "    if($bucketPolicy.IsPublic) {",
            "        Write-Host \"Verifying bucket Policy: Bucket is public, cannot Upload to a public bucket!\"",
            "        return $True",
            "        }",
            "    return $False",
            "}",
            "",
            "Function evalBucketAcl{",
            "    try{",
            "        $bucketAcl = Get-S3ACL -Bucketname $s3BucketName",
            "        foreach ($grant in $bucketAcl.Grants)",
            "        {",
            "            if ($grant.Grantee.URI -eq \"http://acs.amazonaws.com/groups/global/AllUsers\")",
            "            {",
            "                Write-Host \"Verifying bucket ACL: Bucket is public, cannot Upload to a public bucket!\"",
            "                return $True",
            "            }",
            "        }",
            "    }catch{",
            "            Write-Host \"There was an error while verifying S3 bucket ACL:\" $_.Exception.Message",
            "            return $True",
            "    }",
            "    return $False",
            "}",
            "",
            "try{",
            "    if(Get-Module -ListAvailable -Name AWSPowershell){",
            "        Import-Module AWSPowershell",
            "        if(Test-S3Bucket -BucketName $s3BucketName){",
            "            Write-Host \"Checking if bucket $s3BucketName is public or not.\"",
            "            if((evalBucketPolicy) -or (evalBucketAcl)){",
            "                cleanup",
            "                throw \"The operation to upload logs has been cancelled. Exiting!\"",
            "            }else{",
            "                Write-Host \"Bucket $s3BucketName is not public. Starting log upload..\"",
            "                if (Test-Path $filepath -PathType leaf)",
            "                {",
            "                    try{",
            "                        Write-S3Object  -BucketName $s3BucketName -File $filepath",
            "                        Write-Host \"Log file $logfile uploaded to S3 bucket $s3BucketName.\"",
            "                    }",
            "                    catch{",
            "                        Write-Host \"Failed to upload Log file to S3 bucket $s3BucketName.\"",
            "                        cleanup",
            "                        Exit 1",
            "                    }",
            "                }",
            "                else",
            "                {",
            "                    Write-Host \"Log file $filepath doesn't exist, Failed to upload the logs to S3 bucket $s3BucketName.\"",
            "                    cleanup",
            "                    Exit 1",
            "                }",
            "                cleanup          ",
            "            }    ",
            "        }else{",
            "            cleanup",
            "            throw (\"No S3 bucket called \" + $s3BucketName + \" found in the current AWS account, or access denied. Please specify a S3 bucket you own and this instance has access to.\")",
            "        }",
            "    }else{",
            "        Write-Host \"AWS Tools for Windows PowerShell not installed. Please install the latest version of the AWS Tools for Windows PowerShell and try again.\"",
            "        Write-Host \"Download location: https://aws.amazon.com/powershell/\"",
            "        cleanup",
            "        Exit 255",
            "    }",
            "}catch{",
            "    Write-Host $_.Exception.Message",
            "    Exit 1",
            "}"
          ]
        }
      },
      "isCritical": "true",
      "isEnd": true,
      "description": "Upload logs to S3"
    }
  ]
}
