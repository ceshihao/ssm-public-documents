{
  "description": "The **AWSSupport-CollectECSInstanceLogs** runbook collects operating system and Amazon Elastic Container Service (Amazon ECS) related log files from an Amazon Elastic Compute Cloud (Amazon EC2) instance to help you troubleshoot common Amazon ECS issues. While the automation is collecting the associated log files, changes are made to the file system. These changes include the creation of temporary directories and a log directory, the copying of log files to these directories, and compressing the log files into an archive.\n\nIf you specify a value for the `LogDestination` parameter, the automation evaluates the policy status of the Amazon Simple Storage Service (Amazon S3) bucket you specify. To help with the security of the logs gathered from your Amazon EC2 instance, if the policy status isPublic is set to true , or if the access control list (ACL) grants READ|WRITE permissions to the All Users Amazon S3 predefined group, the logs are not uploaded. Additionaly, if the provided bucket is not available in your account, the logs are not uploaded. For more information about Amazon S3 predefined groups, see [Amazon S3 predefined groups](https://docs.aws.amazon.com/AmazonS3/latest/dev/acl-overview.html#specifying-grantee-predefined-groups) in the *Amazon Simple Storage Service User Guide*.",
  "schemaVersion": "0.3",
  "assumeRole": "{{ AutomationAssumeRole }}",
  "parameters": {
    "ECSInstanceId": {
      "type": "AWS::EC2::Instance::Id",
      "description": "(Required) The ID of the instance you want to collect logs from. The instance you specify must be managed by Systems Manager."
    },
    "LogDestination": {
      "type": "AWS::S3::Bucket::Name",
      "description": "(Optional) The Amazon S3 bucket in your AWS account to upload the archived logs to. Please make sure the bucket policy does not grant unnecessary read/write permissions to parties that do not need access to the collected logs.",
      "default": ""
    },
    "AutomationAssumeRole": {
      "type": "AWS::IAM::Role::Arn",
      "description": "(Optional) The Amazon Resource Name (ARN) of the AWS Identity and Access Management (IAM) role that allows Systems Manager Automation to perform the actions on your behalf. If no role is specified, Systems Manager Automation uses the permissions of the user that starts this runbook.",
      "default": ""
    }
  },
  "mainSteps": [
    {
      "name": "AssertInstanceIsManaged",
      "description": "Verifies whether the instance you specify in the `ECSInstanceId` parameter is managed by Systems Manager.",
      "action": "aws:assertAwsResourceProperty",
      "onFailure": "Abort",
      "maxAttempts": 3,
      "timeoutSeconds": 120,
      "inputs": {
        "Service": "ssm",
        "Api": "DescribeInstanceInformation",
        "Filters": [
          {
            "Key": "InstanceIds",
            "Values": [
              "{{ ECSInstanceId }}"
            ]
          }
        ],
        "PropertySelector": "$.InstanceInformationList[0].PingStatus",
        "DesiredValues": [
          "Online"
        ]
      },
      "isCritical": true,
      "nextStep": "GetInstancePlatform"
    },
    {
      "name": "GetInstancePlatform",
      "action": "aws:executeAwsApi",
      "description": "Gets information about the operating system (OS) platform of the instance specified in the `ECSInstanceId` parameter.",
      "onFailure": "Abort",
      "maxAttempts": 3,
      "timeoutSeconds": 120,
      "inputs": {
        "Service": "ssm",
        "Api": "DescribeInstanceInformation",
        "Filters": [
          {
            "Key": "InstanceIds",
            "Values": [
              "{{ ECSInstanceId }}"
            ]
          }
        ]
      },
      "outputs": [
        {
          "Name": "platformType",
          "Selector": "$.InstanceInformationList[0].PlatformType",
          "Type": "String"
        }
      ],
      "isCritical": true,
      "nextStep": "BranchOnInstancePlatformForLogCollection"
    },
    {
      "name": "BranchOnInstancePlatformForLogCollection",
      "action": "aws:branch",
      "description": "Branches the automation step based on the OS platform.",
      "isEnd": true,
      "inputs": {
        "Choices": [
          {
            "NextStep": "RunLogCollectionScriptOnWindows",
            "Variable": "{{ GetInstancePlatform.platformType }}",
            "StringEquals": "Windows"
          },
          {
            "NextStep": "RunLogCollectionScriptOnLinux",
            "Variable": "{{ GetInstancePlatform.platformType }}",
            "StringEquals": "Linux"
          }
        ]
      }
    },
    {
      "name": "RunLogCollectionScriptOnLinux",
      "action": "aws:runCommand",
      "onFailure": "Abort",
      "maxAttempts": 1,
      "timeoutSeconds": 600,
      "inputs": {
        "DocumentName": "AWS-RunShellScript",
        "InstanceIds": [
          "{{ ECSInstanceId }}"
        ],
        "Parameters": {
          "commands": [
            "#!/usr/bin/env bash",
            "#",
            "# Copyright 2016-2018 Amazon.com, Inc. or its affiliates.",
            "# All Rights Reserved.",
            "#",
            "# Licensed under the Apache License, Version 2.0 (the \"License\").",
            "# You may not use this file except in compliance with the License.",
            "# A copy of the License is located at",
            "#",
            "#    http://aws.amazon.com/apache2.0/",
            "#",
            "# or in the \"license\" file accompanying this file.",
            "# This file is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR",
            "# CONDITIONS OF ANY KIND, either express or implied. See the License for the",
            "# specific language governing permissions and limitations under the License.",
            "#",
            "#",
            "# - Collects Docker daemon and Amazon ECS Container Agent logs on Amazon Linux,",
            "#   Redhat 7, Debian 8.",
            "# - Collects general operating system logs.",
            "# - For usage information, see --help.",
            "",
            "export LANG=\"C\"",
            "export LC_ALL=\"C\"",
            "",
            "# Collection configuration",
            "# collectdir is where all collected informaton is placed under. This",
            "# services as the top level for this script's operation.",
            "readonly collectdir=\"/var/log/collectECSlogs_{{ECSInstanceId}}\"",
            "readonly collectdirpath=\"/var/log/\"",
            "readonly logdir=\"/var/log/collectECSlogs\"",
            "",
            "# Shared check variables",
            "",
            "# info_system is where the checks' data is placed.",
            "info_system=\"${collectdir}/system\"",
            "# pkgtype is the detected packaging system used on the host (eg: yum, deb)",
            "pkgtype=''  # defined in get_pkgtype",
            "# init_type is the operating system type used for casing check behavior.",
            "init_type=''  # defined in get_init_type",
            "progname='' # defined in parse_options",
            "",
            "# Script run defaults",
            "",
            "mode='brief' # defined in parse_options",
            "",
            "# Common functions",
            "# ---------------------------------------------------------------------------------------",
            "",
            "help() {",
            "  echo \"USAGE: ${progname} [--mode=[brief]]\"",
            "  echo \"       ${progname} --help\"",
            "  echo \"\"",
            "  echo \"OPTIONS:\"",
            "  echo \"     --mode  Sets the desired mode of the script. For more information,\"",
            "  echo \"             see the MODES section.\"",
            "  echo \"     --help  Show this help message.\"",
            "  echo \"\"",
            "  echo \"MODES:\"",
            "  echo \"     brief         Gathers basic operating system, Docker daemon, and Amazon\"",
            "  echo \"                   ECS Container Agent logs. This is the default mode.\"",
            "}",
            "",
            "parse_options() {",
            "  local count=\"$#\"",
            "",
            "  progname=\"$0\"",
            "",
            "  for i in $(seq \"$count\"); do",
            "    eval arg=\\$\"$i\"",
            "    # shellcheck disable=SC2154",
            "    param=\"$(echo \"$arg\" | awk -F '=' '{print $1}' | sed -e 's|--||')\"",
            "    val=\"$(echo \"$arg\" | awk -F '=' '{print $2}')\"",
            "",
            "    case \"${param}\" in",
            "      mode)",
            "        eval \"$param\"=\"${val}\"",
            "        ;;",
            "      help)",
            "        help && exit 0",
            "        ;;",
            "      *)",
            "        echo \"Parameter not found: '$param'\"",
            "        help && exit 1",
            "        ;;",
            "    esac",
            "  done",
            "}",
            "",
            "ok() {",
            "  echo \"ok\"",
            "}",
            "",
            "info() {",
            "  echo \"$*\"",
            "}",
            "",
            "try() {",
            "  local action=$*",
            "  echo -n \"Trying to $action ... \"",
            "}",
            "",
            "warning() {",
            "  local reason=$*",
            "  echo \"warning: $reason\"",
            "}",
            "",
            "failed() {",
            "  local reason=$*",
            "  echo \"failed: $reason\"",
            "}",
            "",
            "die() {",
            "  echo \"ERROR: $*\"",
            "  exit 1",
            "}",
            "",
            "is_root() {",
            "  try \"check if the script is running as root\"",
            "",
            "  if [[ \"$(id -u)\" != \"0\" ]]; then",
            "    die \"this script must be run as root!\"",
            "",
            "  fi",
            "",
            "  ok",
            "}",
            "",
            "cleanup() {",
            "  if [[ \"${collectdir}\" == \"/var/log/collectECSlogs_{{ECSInstanceId}}\" ]]; then",
            "    rm -rf \"$collectdir\" >/dev/null 2>&1",
            "  else",
            "    echo -e \"Unable to cleanup $collectdir, Please cleanup manually!\"",
            "  fi",
            "}",
            "",
            "init() {",
            "  is_root",
            "  get_init_type",
            "  get_pkgtype",
            "}",
            "",
            "collect_brief() {",
            "  init",
            "  is_diskfull",
            "  get_common_logs",
            "  get_kernel_logs",
            "  get_mounts_info",
            "  get_selinux_info",
            "  get_iptables_info",
            "  get_pkglist",
            "  get_system_services",
            "  get_docker_info",
            "  get_docker_containers_info",
            "  get_docker_logs",
            "  get_docker_systemd_config",
            "  get_docker_sysconfig",
            "  get_docker_daemon_json",
            "  get_ecs_agent_logs",
            "  get_ecs_agent_info",
            "  get_open_files",
            "}",
            "",
            "# Routines",
            "# ---------------------------------------------------------------------------------------",
            "",
            "get_init_type() {",
            "  try \"collect system information\"",
            "",
            "  case \"$(cat /proc/1/comm)\" in",
            "    systemd)",
            "      init_type=\"systemd\"",
            "    ;;",
            "    *)",
            "      init_type=\"other\"",
            "    ;;",
            "  esac",
            "",
            "  ok",
            "}",
            "",
            "get_pkgtype() {",
            "  if [[ -n \"$(command -v rpm)\" ]]; then",
            "    pkgtype=\"rpm\"",
            "  elif [[ -n \"$(command -v dpkg)\" ]]; then",
            "    pkgtype=\"dpkg\"",
            "  else",
            "    pkgtype=\"unknown\"",
            "  fi",
            "}",
            "",
            "pack() {",
            "  try \"archive gathered log information\"",
            "",
            "  if [ ! -d \"$logdir\" ]; then",
            "    mkdir -p \"$logdir\" || { echo \"Failed to create log directory $logdir\"; exit 1; }",
            "  fi",
            "",
            "  local tar_bin",
            "  tar_bin=\"$(command -v tar 2>/dev/null)\"",
            "  if [ -z \"${tar_bin}\" ]; then",
            "    warning \"TAR archiver not found, please install a TAR archiver to create the collection archive. You can still view the logs in the collect folder.\"",
            "  else",
            "    cd \"$collectdirpath\" || { echo \"Failed to change directory to $collectdirpath\"; exit 1; }",
            "",
            "    ${tar_bin} -cvzf \"$logdir/ecs_{{ECSInstanceId}}_{{automation:EXECUTION_ID}}.tgz\" \"collectECSlogs_{{ECSInstanceId}}\" || { echo \"Failed to create tar archive\"; exit 1; }",
            "  fi",
            "",
            "  ok",
            "}",
            "",
            "is_diskfull() {",
            "  try \"check disk space usage\"",
            "",
            "  threshold=70",
            "  i=2",
            "  result=$(df -kh | grep -ve \"Filesystem\" -ve \"loop\" | awk '{ print $5 }' | sed 's/%//g')",
            "  exceeded=0",
            "",
            "  for percent in ${result}; do",
            "    if [[ \"${percent}\" -gt \"${threshold}\" ]]; then",
            "      partition=$(df -kh | head -$i | tail -1| awk '{print $1}')",
            "      echo",
            "      warning \"${partition} is ${percent}% full, please ensure adequate disk space to collect and store the log files.\"",
            "      : $((exceeded++))",
            "    fi",
            "    i=$((i+1))",
            "  done",
            "",
            "  if [ \"$exceeded\" -gt 0 ]; then",
            "    return 1",
            "  else",
            "    ok",
            "  fi",
            "}",
            "",
            "get_mounts_info() {",
            "  try \"get mount points and volume information\"",
            "",
            "  mkdir -p \"$info_system\"",
            "  mount > \"$info_system\"/mounts.txt",
            "  echo \"\" >> \"$info_system\"/mounts.txt",
            "  df -h >> \"$info_system\"/mounts.txt",
            "",
            "  if command -v lvdisplay > /dev/null; then",
            "    lvdisplay > \"$info_system\"/lvdisplay.txt",
            "    vgdisplay > \"$info_system\"/vgdisplay.txt",
            "    pvdisplay > \"$info_system\"/pvdisplay.txt",
            "  fi",
            "",
            "  ok",
            "}",
            "",
            "get_selinux_info() {",
            "  try \"check SELinux status\"",
            "",
            "  enforced=\"$(getenforce 2>/dev/null)\"",
            "",
            "  { [ \"${pkgtype}\" != \"rpm\" ] || [ -z \"${enforced}\" ]; } \\",
            "    && info \"not installed\" \\",
            "    && return",
            "",
            "  mkdir -p \"$info_system\"",
            "  echo -e \"SELinux mode:\\\\n    ${enforced}\" >  \"$info_system\"/selinux.txt",
            "",
            "  ok",
            "}",
            "",
            "get_iptables_info() {",
            "  try \"get iptables list\"",
            "",
            "  mkdir -p \"$info_system\"",
            "  iptables -nvL -t filter > \"$info_system\"/iptables-filter.txt",
            "  iptables -nvL -t nat  > \"$info_system\"/iptables-nat.txt",
            "",
            "  ok",
            "}",
            "",
            "get_open_files() {",
            "  try \"get open files list\"",
            "",
            "  mkdir -p \"$info_system\"",
            "  for d in /proc/*/fd; do echo \"$d\"; find \"$d\" -maxdepth 1 | wc -l; done > \"$info_system\"/open-file-counts.txt",
            "  ls -l /proc/*/fd > \"$info_system\"/open-file-details.txt",
            "",
            "  ok",
            "}",
            "",
            "get_common_logs() {",
            "  try \"collect common operating system logs\"",
            "",
            "  dstdir=\"${info_system}/var_log\"",
            "  mkdir -p \"$dstdir\"",
            "",
            "  for entry in syslog messages; do",
            "    [ -e \"/var/log/${entry}\" ] && cp -f /var/log/${entry} \"$dstdir\"/",
            "  done",
            "",
            "  ok",
            "}",
            "",
            "get_kernel_logs() {",
            "  try \"collect kernel logs\"",
            "",
            "  dstdir=\"${info_system}/kernel\"",
            "  mkdir -p \"$dstdir\"",
            "  if [ -e \"/var/log/dmesg\" ]; then",
            "    cp -f /var/log/dmesg \"$dstdir/dmesg.boot\"",
            "  fi",
            "  dmesg > \"$dstdir/dmesg.current\"",
            "  dmesg --ctime > \"$dstdir/dmesg.human.current\"",
            "  ok",
            "}",
            "",
            "get_docker_logs() {",
            "  try \"collect Docker and containerd daemon logs\"",
            "",
            "  dstdir=\"${info_system}/docker_log\"",
            "  mkdir -p \"$dstdir\"",
            "  case \"${init_type}\" in",
            "    systemd)",
            "      journalctl -u docker > \"${dstdir}\"/docker",
            "      journalctl -u containerd > \"${info_system}\"/containerd.log",
            "      ;;",
            "    other)",
            "      for entry in docker upstart/docker; do",
            "        if [[ -e \"/var/log/${entry}\" ]]; then",
            "          cp -f /var/log/\"${entry}\" \"${dstdir}\"/docker",
            "        fi",
            "      done",
            "      ;;",
            "    *)",
            "      warning \"the current operating system is not supported.\"",
            "      return 1",
            "      ;;",
            "  esac",
            "",
            "  ok",
            "}",
            "",
            "get_ecs_agent_logs() {",
            "  try \"collect Amazon ECS Container Agent logs\"",
            "",
            "  dstdir=\"${info_system}/ecs_agent_logs\"",
            "",
            "  if [ ! -d /var/log/ecs ]; then",
            "    failed \"ECS log directory does not exist\"",
            "    return 1",
            "  fi",
            "",
            "  mkdir -p \"$dstdir\"",
            "",
            "  cp -f /var/log/ecs/* \"$dstdir\"/",
            "",
            "  ok",
            "}",
            "",
            "get_pkglist() {",
            "  try \"detect installed packages\"",
            "",
            "  mkdir -p \"$info_system\"",
            "  case \"${pkgtype}\" in",
            "    rpm)",
            "      rpm -qa >\"$info_system\"/pkglist.txt 2>&1",
            "      ;;",
            "    dpkg)",
            "      dpkg --list > \"$info_system\"/pkglist.txt 2>&1",
            "      ;;",
            "    *)",
            "      warning \"unknown package type.\"",
            "      return 1",
            "      ;;",
            "  esac",
            "",
            "  ok",
            "}",
            "",
            "get_system_services() {",
            "  try \"detect active system services list\"",
            "",
            "  mkdir -p \"$info_system\"",
            "  case \"${init_type}\" in",
            "    systemd)",
            "      systemctl list-units > \"$info_system\"/services.txt 2>&1",
            "      ;;",
            "    other)",
            "      service --status-all >> \"$info_system\"/services.txt 2>&1",
            "      ;;",
            "    *)",
            "      warning \"unable to determine active services.\"",
            "      return 1",
            "      ;;",
            "  esac",
            "",
            "  top -b -n 1 > \"$info_system\"/top.txt 2>&1",
            "  ps fauxwww > \"$info_system\"/ps.txt 2>&1",
            "  netstat -plant > \"$info_system\"/netstat.txt 2>&1",
            "",
            "  ok",
            "}",
            "",
            "get_docker_info() {",
            "  try \"gather Docker daemon information\"",
            "",
            "  mkdir -p \"$info_system\"/docker",
            "",
            "  if pgrep dockerd > /dev/null ; then",
            "",
            "    timeout 20 docker info > \"$info_system\"/docker/docker-info.txt 2>&1 || echo \"Timed out, ignoring \\\"docker info output \\\" \"",
            "    timeout 20 docker ps --all --no-trunc > \"$info_system\"/docker/docker-ps.txt 2>&1 || echo \"Timed out, ignoring \\\"docker ps --all --no-trunc output \\\" \"",
            "    timeout 20 docker images > \"$info_system\"/docker/docker-images.txt 2>&1 || echo \"Timed out, ignoring \\\"docker images output \\\" \"",
            "    timeout 20 docker version > \"$info_system\"/docker/docker-version.txt 2>&1 || echo \"Timed out, ignoring \\\"docker version output \\\" \"",
            "    timeout 60 docker stats --all --no-trunc --no-stream > \"$info_system\"/docker/docker-stats.txt 2>&1 || echo \"Timed out, ignoring \\\"docker stats\\\" output\"",
            "",
            "    ok",
            "  else",
            "    warning \"the Docker daemon is not running.\" | tee \"$info_system\"/docker/docker-not-running.txt",
            "  fi",
            "}",
            "",
            "get_ecs_agent_info() {",
            "  try \"collect Amazon ECS Container Agent state and config\"",
            "",
            "  mkdir -p \"$info_system\"/ecs-agent",
            "  if [ -e /var/lib/ecs/data/ecs_agent_data.json ]; then",
            "    python -mjson.tool < /var/lib/ecs/data/ecs_agent_data.json > \"$info_system\"/ecs-agent/ecs_agent_data.txt 2>&1",
            "  fi",
            "",
            "  if [ -e /var/lib/ecs/data/agent.db ]; then",
            "    cp -f /var/lib/ecs/data/agent.db \"$info_system\"/ecs-agent/agent.db 2>&1",
            "    chmod +r \"$info_system\"/ecs-agent/agent.db",
            "  fi",
            "",
            "  if [ -e /etc/ecs/ecs.config ]; then",
            "    cp -f /etc/ecs/ecs.config \"$info_system\"/ecs-agent/ 2>&1",
            "    if grep --quiet \"ECS_ENGINE_AUTH_DATA\" \"$info_system\"/ecs-agent/ecs.config; then",
            "      sed -i 's/ECS_ENGINE_AUTH_DATA=.*/ECS_ENGINE_AUTH_DATA=/g' \"$info_system\"/ecs-agent/ecs.config",
            "    fi",
            "  fi",
            "  ok",
            "",
            "  try \"collect Amazon ECS Container Agent engine data\"",
            "",
            "  if pgrep agent > /dev/null ; then",
            "    if command -v curl >/dev/null; then",
            "      if curl --max-time 3 -s http://localhost:51678/v1/tasks | python -mjson.tool > \"$info_system\"/ecs-agent/agent-running-info.txt 2>&1; then",
            "          ok",
            "      else",
            "          warning \"failed to get agent data\"",
            "      fi",
            "    else",
            "      warning \"curl is unavailable for probing ECS Container Agent introspection endpoint\"",
            "    fi",
            "  else",
            "    warning \"The Amazon ECS Container Agent is not running\" | tee \"$info_system\"/ecs-agent/ecs-agent-not-running.txt",
            "    return 1",
            "  fi",
            "}",
            "",
            "get_docker_containers_info() {",
            "  try \"inspect all Docker containers\"",
            "",
            "  mkdir -p \"$info_system\"/docker",
            "",
            "  if pgrep dockerd > /dev/null ; then",
            "    for i in $(docker ps -a -q); do",
            "      timeout 10 docker inspect \"$i\" > \"$info_system\"/docker/container-\"$i\".txt 2>&1",
            "      if [ $? -eq 124 ]; then",
            "        touch \"$info_system\"/docker/container-inspect-timed-out.txt",
            "        failed \"'docker inspect' timed out, not gathering containers\"",
            "        return 1",
            "      fi",
            "",
            "      if grep --quiet \"ECS_ENGINE_AUTH_DATA\" \"$info_system\"/docker/container-\"$i\".txt; then",
            "        sed -i 's/ECS_ENGINE_AUTH_DATA=.*/ECS_ENGINE_AUTH_DATA=/g' \"$info_system\"/docker/container-\"$i\".txt",
            "      fi",
            "    done",
            "  else",
            "    warning \"the Docker daemon is not running.\" | tee \"$info_system\"/docker/docker-not-running.txt",
            "    return 1",
            "  fi",
            "  ok",
            "}",
            "",
            "get_docker_sysconfig() {",
            "  try \"collect Docker sysconfig\"",
            "",
            "  if [ -e /etc/sysconfig/docker ]; then",
            "    mkdir -p \"${info_system}\"/docker",
            "    cp /etc/sysconfig/docker \"${info_system}\"/docker/sysconfig-docker",
            "    ok",
            "  else",
            "    info \"/etc/sysconfig/docker not found\"",
            "  fi",
            "",
            " try \"collect Docker storage sysconfig\"",
            "",
            "  if [ -e /etc/sysconfig/docker-storage ]; then",
            "    mkdir -p \"${info_system}\"/docker",
            "    cp /etc/sysconfig/docker-storage \"${info_system}\"/docker/sysconfig-docker-storage",
            "    ok",
            "  else",
            "    info \"/etc/sysconfig/docker-storage not found\"",
            "  fi",
            "}",
            "",
            "",
            "get_docker_daemon_json(){",
            "  try \"collect Docker daemon.json\"",
            "",
            "  if [ -e /etc/docker/daemon.json ]; then",
            "    mkdir -p \"${info_system}\"/docker",
            "    cp /etc/docker/daemon.json \"${info_system}\"/docker/daemon.json",
            "    ok",
            "  else",
            "    info \"/etc/docker/daemon.json not found\"",
            "  fi",
            "}",
            "",
            "get_docker_systemd_config(){",
            "",
            "  if [[ \"$init_type\" != \"systemd\" ]]; then",
            "    return 0",
            "  fi",
            "",
            "  try \"collect Docker systemd unit file\"",
            "",
            "  mkdir -p \"${info_system}\"/docker",
            "  if systemctl cat docker.service > \"${info_system}\"/docker/docker.service 2>/dev/null; then",
            "   ok",
            "  else",
            "    rm -f \"$info_system/docker/docker.service\"",
            "    warning \"docker.service not found\"",
            "  fi",
            "",
            "  try \"collect containerd systemd unit file\"",
            "  if systemctl cat containerd.service > \"${info_system}\"/docker/containerd.service 2>/dev/null; then",
            "   ok",
            "  else",
            "    rm -f \"$info_system/docker/containerd.service\"",
            "    warning \"containerd.service not found\"",
            "  fi",
            "}",
            "",
            "finished()",
            "{",
            "  log_destination=\"{{LogDestination}}\"",
            "  if [ -z $log_destination ]; then",
            "    echo -e \"\\nDone... your bundled logs are located in $logdir/ecs_{{ECSInstanceId}}_{{automation:EXECUTION_ID}}.tgz.\\n\"",
            "  fi",
            "}",
            "# --------------------------------------------------------------------------------------------",
            "",
            "parse_options \"$@\"",
            "",
            "collect_brief",
            "pack",
            "cleanup",
            "finished"
          ]
        }
      },
      "description": "Gathers operating system and Amazon ECS related log files on Linux instances and creates an archive file in the `/var/log/collectECSlogs` directory.",
      "isCritical": true,
      "nextStep": "BranchOnIfS3BucketProvided"
    },
    {
      "name": "RunLogCollectionScriptOnWindows",
      "action": "aws:runCommand",
      "onFailure": "Abort",
      "maxAttempts": 1,
      "timeoutSeconds": 600,
      "inputs": {
        "DocumentName": "AWS-RunPowerShellScript",
        "InstanceIds": [
          "{{ ECSInstanceId }}"
        ],
        "Parameters": {
          "commands": [
            "<# ",
            "    Copyright 2024 Amazon.com, Inc. or its affiliates. All Rights Reserved.",
            "    Licensed under the Apache License, Version 2.0 (the \"License\"). You may not use this file except in compliance with the License. A copy of the License is located at",
            "",
            "        http://aws.amazon.com/apache2.0/",
            "",
            "    or in the \"license\" file accompanying this file. ",
            "    This file is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.",
            "",
            ".SYNOPSIS ",
            "    Collects ECS Agent Logs",
            ".DESCRIPTION ",
            "    Run the script to collect ECS Logs",
            "    Run without parameters to Gather basic operating system, Docker daemon, and Amazon ECS container agent logs. ",
            "    Default script RunMode is Brief mode.",
            ".NOTES",
            "    You need to run this script with Elevated permissions to allow for the collection of the installed applications list",
            ".EXAMPLE ",
            "    ecs-log-collector.ps1",
            "    Gathers basic OS System, Docker daemon and Amazon ECS container agent logs",
            "#>",
            "",
            "param(",
            "    [Parameter(Mandatory=$False)][string]$RunMode = \"Brief\"   ",
            "    )",
            "",
            "# Common options",
            "$basepath = $env:ProgramData",
            "$infodir=\"$basepath\\collectECSlogs_{{ ECSInstanceId }}\"",
            "$logdir=\"$basepath\\collectECSlogs\"",
            "$info_system=\"$infodir\\system\"",
            "$s3BucketName = \"{{ LogDestination }}\"",
            "",
            "$ErrorActionPreference = \"Continue\"",
            "# Common functions",
            "# ---------------------------------------------------------------------------------------",
            "",
            "Function is_elevated{",
            "    If (-NOT ([Security.Principal.WindowsPrincipal] [Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole(`",
            "    [Security.Principal.WindowsBuiltInRole] \"Administrator\")) {",
            "        Write-warning \"This script requires elevated privileges to copy registry keys to the ECS logs collector folder.\"",
            "        Write-Host \"Please re-launch as Administrator.\" -foreground \"red\" -background \"black\"",
            "        break",
            "    }",
            "}",
            "",
            "",
            "Function create_working_dir{",
            "    try {",
            "        Write-Host \"Creating temporary directory\"",
            "        New-Item -type directory -path $info_system -Force >$null",
            "        New-Item -type directory -path $info_system\\docker -Force >$null",
            "        New-Item -type directory -path $info_system\\firewall -Force >$null",
            "        New-Item -type directory -path $info_system\\ecs -Force >$null",
            "        New-Item -type directory -path $info_system\\docker_log -Force >$null",
            "        Write-Host \"OK\" -ForegroundColor \"green\"",
            "    }",
            "    catch {",
            "        Write-Host \"Unable to create temporary directory\"",
            "        Write-Host \"Please ensure you have enough permissions to create directories\"",
            "        Write-Error \"Failed to create temporary directory\"",
            "        Break",
            "    }",
            "}",
            "",
            "Function get_sysinfo{",
            "    try {",
            "        Write-Host \"Collecting System information\"",
            "        systeminfo.exe > $info_system\\sysinfo",
            "        Write-Host \"OK\" -ForegroundColor \"green\"",
            "    }",
            "    catch {",
            "        Write-Error \"Unable to collect system information\" ",
            "        $_.Exception | Out-File $info_system\\log-collector.log -Append",
            "    }  ",
            "        ",
            "}",
            "",
            "Function is_diskfull{",
            "    $threshold = 30",
            "    try {",
            "        Write-Host \"Checking free disk space\"",
            "        $drive = Get-WmiObject Win32_LogicalDisk -Filter \"DeviceID='C:'\"",
            "        $percent = ([math]::round($drive.FreeSpace/1GB, 0) / ([math]::round($drive.Size/1GB, 0)) * 100)",
            "        Write-Host \"C: drive has $percent% free space\"",
            "        Write-Host \"OK\" -ForegroundColor \"green\"",
            "    }",
            "    catch {",
            "        Write-Error \"Unable to Determine Free Disk Space\" ",
            "        $_.Exception | Out-File $info_system\\log-collector.log -Append",
            "    }",
            "    if ($percent -lt $threshold){",
            "        Write-Error \"C: drive only has $percent% free space, please ensure there is at least $threshold% free disk space to collect and store the log files\" ",
            "        $_.Exception | Out-File $info_system\\log-collector.log -Append",
            "    }",
            "}",
            "",
            "Function get_system_logs{",
            "    try {",
            "        Write-Host \"Collecting System Logs\"",
            "        Get-WinEvent -LogName System | Select-Object timecreated,leveldisplayname,machinename,message | export-csv -Path $info_system\\system-eventlogs.csv",
            "        Write-Host \"OK\" -foregroundcolor \"green\"",
            "    }",
            "    catch {",
            "        Write-Error \"Unable to Collect System Logs\"",
            "        $_.Exception | Out-File $info_system\\log-collector.log -Append",
            "    }",
            "}",
            "",
            "Function get_application_logs{",
            "    try {",
            "        Write-Host \"Collecting Application Logs\"",
            "        Get-WinEvent -LogName Application | Select-Object timecreated,leveldisplayname,machinename,message | export-csv -Path $info_system\\application-eventlogs.csv",
            "        Write-Host \"OK\" -foregroundcolor \"green\"",
            "    }",
            "    catch {",
            "        Write-Error \"Unable to Collect Application Logs\"",
            "        $_.Exception | Out-File $info_system\\log-collector.log -Append",
            "    }",
            "}",
            "",
            "Function get_volumes_info{",
            "    try {",
            "        Write-Host \"Collecting Volume info\"",
            "        Get-psdrive -PSProvider 'FileSystem' | Out-file $info_system\\volumes",
            "        Write-Host \"OK\" -foregroundcolor \"green\"",
            "    }",
            "    catch {",
            "        Write-Error \"Unable to Collect Volume information\"",
            "        $_.Exception | Out-File $info_system\\log-collector.log -Append",
            "    }",
            "}",
            "",
            "Function get_firewall_info{",
            "    try {",
            "        Write-Host \"Collecting Windows Firewall info\"",
            "        $fw = Get-NetFirewallProfile",
            "        foreach ($f in $fw){",
            "            if ($f.Enabled -eq \"True\"){",
            "                $file = $f.name",
            "                Write-Host \"Collecting Rules for\" $f.name \"profile\"",
            "                Get-NetFirewallProfile -Name $f.name | Get-NetFirewallRule | Out-file $info_system\\firewall\\firewall-$file",
            "                }",
            "            }",
            "        Write-Host \"OK\" -foregroundcolor \"green\"",
            "    }",
            "    catch {",
            "        Write-Error \"Unable to Collect Windows Firewall information\"",
            "        $_.Exception | Out-File $info_system\\log-collector.log -Append",
            "    }",
            "}",
            "",
            "Function get_softwarelist{",
            "    try {",
            "        Write-Host \"Collecting installed applications list\"",
            "        gp HKLM:\\Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\* |Select DisplayName, DisplayVersion, Publisher, InstallDate, HelpLink, UninstallString | out-file $info_system\\installed-64bit-apps.txt",
            "        gp HKLM:\\Software\\Wow6432Node\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\* |Select DisplayName, DisplayVersion, Publisher, InstallDate, HelpLink, UninstallString | out-file $info_system\\installed-32bit-apps.txt",
            "        Write-Host \"OK\" -foregroundcolor \"green\"",
            "    }",
            "    catch {",
            "        Write-Error \"Unable to collect installed applications list\"",
            "        $_.Exception | Out-File $info_system\\log-collector.log -Append",
            "    }",
            "}",
            "",
            "Function get_system_services{",
            "    try {",
            "        Write-Host \"Collecting Services list\"",
            "        get-service | fl | out-file $info_system\\services",
            "        Write-Host \"OK\" -foregroundcolor \"green\"",
            "    }",
            "    catch {",
            "        Write-Error \"Unable to collect Services list\"",
            "        $_.Exception | Out-File $info_system\\log-collector.log -Append",
            "    }",
            "}",
            "",
            "Function get_docker_info{",
            "    try {",
            "        Write-Host \"Collecting Docker daemon information\"",
            "",
            "        $scriptBlock = {",
            "            docker info > \"$($args[0])\\docker\\docker-info.txt\" 2>&1",
            "            docker ps --all --no-trunc > \"$($args[0])\\docker\\docker-ps.txt\" 2>&1",
            "            docker images > \"$($args[0])\\docker\\docker-images.txt\" 2>&1",
            "            docker version > \"$($args[0])\\docker\\docker-version.txt\" 2>&1",
            "            Write-Host \"OK\" -foregroundcolor \"green\"",
            "        }",
            "",
            "        $job = Start-Job -ScriptBlock $scriptBlock -ArgumentList $info_system",
            "        ",
            "        # Wait for the job to complete or timeout",
            "        $timeout = 200  # Timeout value in seconds",
            "        $jobCompleted = Wait-Job $job -Timeout $timeout -ErrorAction SilentlyContinue",
            "",
            "        # Check if the job completed within the timeout",
            "        if ($jobCompleted) {",
            "            # Job completed within the timeout",
            "            Write-Host \"OK\" -ForegroundColor \"green\"",
            "        } else {",
            "            # Job did not complete within the timeout",
            "            $timeoutMessage = \"Timeout: Unable to collect Docker daemon information within $timeout seconds.\"",
            "            Write-Error $timeoutMessage",
            "            $timeoutMessage | Out-File $info_system\\log-collector.log -Append",
            "        }",
            "",
            "        # Save the output of the job",
            "        Receive-Job -Job $job  | Out-File $info_system\\log-collector.log -Append",
            "",
            "        # Remove the job",
            "        Remove-Job $job",
            "    }",
            "    catch{",
            "        Write-Error \"Unable to collect Docker daemon information\"",
            "        $_.Exception | Out-File $info_system\\log-collector.log -Append",
            "    }",
            "}",
            "",
            "Function get_ecs_agent_logs{",
            "    try {",
            "        # https://docs.aws.amazon.com/AmazonECS/latest/developerguide/logs.html",
            "        Write-Host \"Collecting ECS Agent logs\"",
            "        copy $env:ProgramData\\Amazon\\ECS\\log\\* $info_system\\ecs\\",
            "        Write-Host \"OK\" -foregroundcolor \"green\"",
            "    }",
            "    catch{",
            "        Write-Error \"Unable to collect ECS Agent logs\"",
            "        $_.Exception | Out-File $info_system\\log-collector.log -Append",
            "    }",
            "}",
            "",
            "Function get_containers_info{",
            "    try {",
            "        Write-Host \"Inspect running Docker containers and gather Amazon ECS container agent data\"",
            "        ",
            "        $scriptBlock = {",
            "            $containers = docker ps -q",
            "            foreach ($c in $containers){",
            "                docker inspect $c > \"$($args[0])/docker/container-$c.txt\"",
            "                if (Get-Content \"$($args[0])/docker/container-$c.txt\" |where-object {$_ -like 'ECS_ENGINE_AUTH_DATA'} ) {",
            "                    (Get-Content \"$($args[0])/docker/container-$c.txt\") | ForEach-Object {$_ -replace 'ECS_ENGINE_AUTH_DATA*.+$', 'ECS_ENGINE_AUTH_DATA: OBFUSCATED'} | Set-Content \"$($args[0])/docker/container-$c.txt\"",
            "                }",
            "            }",
            "        }",
            "        $job = Start-Job -ScriptBlock $scriptBlock -ArgumentList $info_system",
            "        # Wait for the job to complete or timeout",
            "        $timeout = 300  # Timeout value in seconds",
            "        $jobCompleted = Wait-Job $job -Timeout $timeout -ErrorAction SilentlyContinue",
            "",
            "        # Check if the job completed within the timeout",
            "        if ($jobCompleted) {",
            "            # Job completed within the timeout",
            "            Write-Host \"OK\" -ForegroundColor \"green\"",
            "        } else {",
            "            # Job did not complete within the timeout",
            "            $timeoutMessage = \"Timeout: Unable to gather Amazon ECS container agent data within $timeout seconds.\"",
            "            Write-Error $timeoutMessage",
            "            $timeoutMessage | Out-File $info_system\\log-collector.log -Append",
            "        }",
            "",
            "        # Save the output of the job",
            "        Receive-Job -Job $job  | Out-File $info_system\\log-collector.log -Append",
            "",
            "        # Remove the job",
            "        Remove-Job $job",
            "    }",
            "    catch {",
            "        Write-Error \"Unable to collect Docker containers data\"",
            "        $_.Exception | Out-File $info_system\\log-collector.log -Append",
            "    }",
            "}",
            "",
            "Function get_docker_logs{",
            "    try {",
            "        Write-Host \"Collecting Docker daemon logs\"",
            "        Get-EventLog -LogName Application -Source Docker | Sort-Object Time | Export-CSV $info_system/docker_log/docker-daemon.csv",
            "        Write-Host \"OK\" -foregroundcolor \"green\"",
            "    }",
            "    catch {",
            "        Write-Error \"Unable to collect Docker daemon logs\"",
            "        $_.Exception | Out-File $info_system\\log-collector.log -Append",
            "    }",
            "}",
            "",
            "Function cleanup{",
            "    if ( $infodir -eq \"$basepath\\collectECSlogs_{{ECSInstanceId}}\" )",
            "    {",
            "        Remove-Item -Recurse -Force $infodir -ErrorAction Ignore",
            "    }",
            "    else {",
            "        Write-Error \"Unable to cleanup $infodir, Please cleanup manually!\" ",
            "        $_.Exception | Out-File $info_system\\log-collector.log -Append",
            "    }",
            "    ",
            "}",
            "",
            "Function create_log_dir{",
            "    if (!(Test-Path $logdir))",
            "    {",
            "        try{",
            "            Write-Host \"Creating log directory\"",
            "            New-Item -type directory -path $logdir -Force >$null",
            "            Write-Host \"OK\" -ForegroundColor \"green\"",
            "        }",
            "        catch{",
            "            Write-Host \"Unable to create log directory\"",
            "            Write-Host \"Please ensure you have enough permissions to create directories\"",
            "            Write-Error \"Failed to create log directory\"",
            "            $_.Exception | Out-File $info_system\\log-collector.log -Append",
            "        }",
            "    }",
            "}",
            "",
            "Function pack{",
            "    try {",
            "        Write-Host \"Archiving gathered data\"",
            "        create_log_dir",
            "        Compress-Archive -Path $infodir -CompressionLevel Optimal -DestinationPath $logdir\\ecs_{{ ECSInstanceId }}_{{ automation:EXECUTION_ID }}.zip",
            "        Write-Host \"OK\" -foregroundcolor \"green\"",
            "    }",
            "    catch {",
            "        Write-Error \"Unable to archive data\"",
            "        Break",
            "    }",
            "}",
            "",
            "Function init{",
            "    is_elevated",
            "    create_working_dir",
            "    get_sysinfo",
            "}",
            "    ",
            "",
            "Function collect_brief{",
            "    init",
            "    is_diskfull",
            "    get_system_logs",
            "    get_application_logs",
            "    get_volumes_info",
            "    get_firewall_info",
            "    get_softwarelist",
            "    get_system_services",
            "    get_docker_info",
            "    get_ecs_agent_logs",
            "    get_containers_info",
            "    get_docker_logs",
            "}  ",
            "",
            "Function finished{",
            "    If (-Not $s3BucketName)",
            "    {",
            "        Write-Host \"`nDone... your bundled logs are located in $logdir\\ecs_{{ECSInstanceId}}_{{automation:EXECUTION_ID}}.zip`n\"",
            "    }",
            "}",
            "    ",
            "collect_brief",
            "pack ",
            "cleanup",
            "finished"
          ]
        }
      },
      "description": "Gathers operating system and Amazon ECS related log files on Windows instances and creates an archive file in the `%ProgramData%\\collectECSlogs` directory.",
      "isCritical": true,
      "nextStep": "BranchOnIfS3BucketProvided"
    },
    {
      "name": "BranchOnIfS3BucketProvided",
      "action": "aws:branch",
      "description": "Branch on whether the `LogDestination` input parameter was provided or not.",
      "inputs": {
        "Choices": [
          {
            "Not": {
              "Variable": "{{ LogDestination }}",
              "StringEquals": ""
            },
            "NextStep": "GetS3BucketPublicStatus"
          }
        ]
      },
      "onFailure": "Abort",
      "isCritical": true,
      "isEnd": true
    },
    {
      "name": "GetS3BucketPublicStatus",
      "description": "Checks if the Amazon S3 bucket specified in the \"LogDestination\" allows anonymous, or public read or write access permissions.",
      "action": "aws:executeScript",
      "onFailure": "Abort",
      "inputs": {
        "InputPayload": {
          "S3BucketName": "{{ LogDestination }}"
        },
        "Handler": "get_bucket_public_status.is_bucket_public",
        "Runtime": "python3.8",
        "Attachment": "artifact.zip"
      },
      "outputs": [
        {
          "Name": "S3BucketLocation",
          "Selector": "$.Payload.location",
          "Type": "String"
        }
      ],
      "nextStep": "BranchOnInstancePlatformForUpload",
      "isCritical": true
    },
    {
      "name": "BranchOnInstancePlatformForUpload",
      "action": "aws:branch",
      "isEnd": true,
      "description": "Branches the automation step based on the OS platform.",
      "inputs": {
        "Choices": [
          {
            "NextStep": "RunUploadScriptOnWindows",
            "Variable": "{{ GetInstancePlatform.platformType }}",
            "StringEquals": "Windows"
          },
          {
            "NextStep": "RunUploadScriptOnLinux",
            "Variable": "{{ GetInstancePlatform.platformType }}",
            "StringEquals": "Linux"
          }
        ]
      }
    },
    {
      "name": "RunUploadScriptOnLinux",
      "action": "aws:runCommand",
      "maxAttempts": 1,
      "timeoutSeconds": 600,
      "onFailure": "Abort",
      "inputs": {
        "DocumentName": "AWS-RunShellScript",
        "InstanceIds": [
          "{{ ECSInstanceId }}"
        ],
        "Parameters": {
          "commands": [
            "#!/bin/bash",
            "# Copyright 2023 Amazon.com, Inc. or its affiliates. All Rights Reserved.",
            "# SPDX-License-Identifier: LicenseRef-.amazon.com.-AmznSL-1.0",
            "# Licensed under the Amazon Software License  http://aws.amazon.com/asl/",
            "",
            "logfile=\"ecs_{{ECSInstanceId}}_{{automation:EXECUTION_ID}}.tgz\"",
            "accountId=\"{{ global:ACCOUNT_ID }}\"",
            "filepath=\"/var/log/collectECSlogs/${logfile}\"",
            "log_destination_bucket=\"{{LogDestination}}\"",
            "bucket_location=\"{{GetS3BucketPublicStatus.S3BucketLocation}}\"",
            "",
            "function cleanup()",
            "{",
            "if [ -f $filepath ]; then",
            "    rm $filepath",
            "fi",
            "}",
            "",
            "echo \"Uploading ECS logs collected. Checking if AWS CLI is installed.\"",
            "if command -v aws &> /dev/null",
            "then",
            "    echo \"AWS CLI is Installed..\" ",
            "    awspath=$(command -v aws)",
            "    echo \"Bucket name $log_destination_bucket\" ",
            "    echo \"Bucket location $bucket_location\" ",
            "    if ! (${awspath} s3api head-bucket --bucket \"$log_destination_bucket\" --region \"$bucket_location\" --expected-bucket-owner \"$accountId\");",
            "    then",
            "        echo \"No S3 bucket called $log_destination_bucket found in the current AWS account, or access denied.\"",
            "        echo \"Please specify a S3 bucket you own and this instance has access to.\"",
            "        cleanup",
            "        exit 1",
            "    else",
            "        echo \"Starting log upload to $log_destination_bucket...\"",
            "        if [ -f $filepath ]; then",
            "            ${awspath} s3 cp $filepath s3://$log_destination_bucket --region \"$bucket_location\" --no-progress --only-show-errors;",
            "            cleanup",
            "        else",
            "            echo \"Log file $filepath doesn't exist, Failed to upload the logs to S3 bucket $log_destination_bucket.\"",
            "            cleanup",
            "            exit 1",
            "        fi",
            "    fi",
            "else",
            "    echo \"AWS CLI Not Installed. Quitting Upload WorkFlow.\"",
            "    cleanup",
            "    exit 1",
            "fi"
          ]
        }
      },
      "isCritical": true,
      "isEnd": true,
      "description": "Uploads the log archive to the Amazon S3 bucket specified in the `LogDestination` parameter and deletes the archived log file from OS."
    },
    {
      "name": "RunUploadScriptOnWindows",
      "action": "aws:runCommand",
      "onFailure": "Abort",
      "maxAttempts": 1,
      "timeoutSeconds": 600,
      "inputs": {
        "DocumentName": "AWS-RunPowerShellScript",
        "InstanceIds": [
          "{{ ECSInstanceId }}"
        ],
        "Parameters": {
          "commands": [
            "$s3BucketName = \"{{ LogDestination }}\"",
            "$curdir = (Get-Item -Path \".\\\" -Verbose).FullName",
            "$basepath = $env:ProgramData",
            "$logFile = \"ecs_{{ ECSInstanceId }}_{{ automation:EXECUTION_ID }}.zip\"",
            "$logdir = \"$basepath\\collectECSlogs\"",
            "$filepath = \"$logdir\\$logfile\"",
            "$accountId = \"{{ global:ACCOUNT_ID }}\"",
            "",
            "",
            "Function CleanupFolder{",
            "    if (Test-Path $filepath -PathType leaf)",
            "    {",
            "    Remove-Item $filepath",
            "    }",
            "}",
            "",
            "try{",
            "    if(Get-Module -ListAvailable -Name AWSPowershell){",
            "        Import-Module AWSPowershell",
            "        if(Test-S3Bucket -BucketName $s3BucketName){",
            "            if (Test-Path $filepath -PathType leaf)",
            "            {",
            "                try{",
            "                    Write-S3Object -BucketName $s3BucketName -File $filepath",
            "                    Write-Host \"Log file $logfile uploaded to S3 bucket $s3BucketName.\"",
            "                }",
            "                catch{",
            "                    Write-Host \"Failed to upload Log file to S3 bucket $s3BucketName.\"",
            "                    CleanupFolder",
            "                    Exit 1",
            "                }",
            "            }",
            "            else",
            "            {",
            "                Write-Host \"Log file $filepath doesn't exist, Failed to upload the logs to S3 bucket $s3BucketName.\"",
            "                CleanupFolder",
            "                Exit 1",
            "            }",
            "            CleanupFolder",
            "        }else{",
            "            CleanupFolder",
            "            throw (\"No S3 bucket called \" + $s3BucketName + \" found in the current AWS account, or access denied. Please specify a S3 bucket you own and this instance has access to.\")",
            "        }",
            "    }else{",
            "        Write-Host \"AWS Tools for Windows PowerShell not installed. Please install the latest version of the AWS Tools for Windows PowerShell and try again.\"",
            "        Write-Host \"Download location: https://aws.amazon.com/powershell/\"",
            "        CleanupFolder",
            "        Exit 255",
            "    }",
            "}catch{",
            "    Write-Host $_.Exception.Message",
            "    Exit 1",
            "}"
          ]
        }
      },
      "isCritical": true,
      "isEnd": true,
      "description": "Uploads the log archive to the Amazon S3 bucket specified in the `LogDestination` parameter and deletes the archived log file from OS."
    }
  ],
  "files": {
    "artifact.zip": {
      "checksums": {
        "SHA256": "319e0be3f3c19e5ef7e6943b2da170887632128fa6e8a56f2d2af12cc3b2cb2a"
      }
    }
  }
}
