{
  "description": "The **AWSSupport-TroubleshootADConnectorConnectivity** runbook verifies the following prerequisites for an AD Connector:\n\n1. Checks if the required traffic is allowed by the security group and network access control list (ACL) rules associated with your AD Connector.\n1. Checks if the AWS Systems Manager, AWS Security Token Service, and Amazon CloudWatch interface VPC endpoints exist in the same virtual private cloud (VPC) as the AD Connector.\n\nWhen the prerequisite checks complete successfully, the runbook launches two Amazon Elastic Compute Cloud (Amazon EC2) Linux t2.micro instances in the same subnets as your AD Connector. Network connectivity tests are then performed using the ```netcat``` and ```nslookup``` utilities.\n\n## Important:\n\nUsing this runbook might incur extra charges to your AWS account for the Amazon EC2 instances, Amazon Elastic Block Store volumes and Amazon Machine Image (AMI) created during the automation. For more information, see [Amazon Elastic Compute Cloud Pricing](https://aws.amazon.com/ec2/pricing/) and [Amazon Elastic Block Store Pricing](https://aws.amazon.com/ebs/pricing/).\nIf the ```aws:deletestack``` step fails, go to the AWS CloudFormation console to manually delete the stack. The stack name created by this runbook begins with ```AWSSupport-TroubleshootADConnectorConnectivity```. For information about deleting AWS CloudFormation stacks, see [Deleting a stack](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/cfn-console-delete-stack.html) in the AWS CloudFormation User Guide. ",
  "schemaVersion": "0.3",
  "assumeRole": "{{ AutomationAssumeRole }}",
  "outputs": [
    "evalDirectorySecurityGroup.output",
    "runConnectivityTestOnHelperInstance1.output",
    "evalAclEntries.output",
    "runConnectivityTestOnHelperInstance2.output",
    "checkVPCEndpoints.output",
    "handleDeleteStackFailure.output"
  ],
  "parameters": {
    "DirectoryId": {
      "type": "String",
      "description": "(Required) The ID of the AD Connector directory you want to troubleshoot connectivity to.",
      "allowedPattern": "^d-[a-z0-9]{10}$"
    },
    "Ec2InstanceProfile": {
      "type": "String",
      "description": "(Required) The name of the instance profile you want to assign to the instances that are launched to perform connectivity tests. The instance profile you specify must have the AmazonSSMManagedInstanceCore policy or equivalent permissions attached.",
      "allowedPattern": "[\\w+=,.@-]+",
      "maxChars": 128
    },
    "AutomationAssumeRole": {
      "type": "AWS::IAM::Role::Arn",
      "description": "(Optional) The Amazon Resource Name (ARN) of the AWS Identity and Access Management (IAM) role that allows Systems Manager Automation to perform the actions on your behalf. If no role is specified, Systems Manager Automation uses the permissions of the user that starts this runbook.",
      "default": ""
    }
  },
  "mainSteps": [
    {
      "name": "assertDirectoryType",
      "action": "aws:assertAwsResourceProperty",
      "description": "Confirms the directory specified in the DirectoryId parameter is an AD Connector.",
      "onFailure": "Abort",
      "maxAttempts": 3,
      "timeoutSeconds": 120,
      "inputs": {
        "Service": "ds",
        "Api": "DescribeDirectories",
        "DirectoryIds": [
          "{{ DirectoryId }}"
        ],
        "PropertySelector": "$.DirectoryDescriptions[0].Type",
        "DesiredValues": [
          "ADConnector"
        ]
      },
      "isCritical": "true"
    },
    {
      "name": "getDirectoryInfo",
      "action": "aws:executeAwsApi",
      "description": "Gathers information about the AD Connector: DnsIpAddrs, VpcId, SecurityGroupId, SubnetIds, ConnectIps, and Name.",
      "onFailure": "Abort",
      "maxAttempts": 3,
      "timeoutSeconds": 120,
      "inputs": {
        "Service": "ds",
        "Api": "DescribeDirectories",
        "DirectoryIds": [
          "{{ DirectoryId }}"
        ]
      },
      "outputs": [
        {
          "Name": "onPremDnsIpAddrs",
          "Selector": "$.DirectoryDescriptions[0].DnsIpAddrs",
          "Type": "StringList"
        },
        {
          "Name": "directoryVpcId",
          "Selector": "$.DirectoryDescriptions[0].ConnectSettings.VpcId",
          "Type": "String"
        },
        {
          "Name": "directorySecurityGroupId",
          "Selector": "$.DirectoryDescriptions[0].ConnectSettings.SecurityGroupId",
          "Type": "String"
        },
        {
          "Name": "directorySubnets",
          "Selector": "$.DirectoryDescriptions[0].ConnectSettings.SubnetIds",
          "Type": "StringList"
        },
        {
          "Name": "directoryDnsIpAddrs",
          "Selector": "$.DirectoryDescriptions[0].ConnectSettings.ConnectIps",
          "Type": "StringList"
        },
        {
          "Name": "directoryName",
          "Selector": "$.DirectoryDescriptions[0].Name",
          "Type": "String"
        }
      ],
      "nextStep": "getDirectorySubnetCidrs"
    },
    {
      "name": "getDirectorySubnetCidrs",
      "action": "aws:executeAwsApi",
      "description": "Gathers information about the subnets that are associated with the AD Connector.",
      "onFailure": "Abort",
      "maxAttempts": 3,
      "timeoutSeconds": 120,
      "inputs": {
        "Service": "ec2",
        "Api": "DescribeSubnets",
        "SubnetIds": [
          "{{ getDirectoryInfo.directorySubnets }}"
        ]
      },
      "outputs": [
        {
          "Name": "directorySubnetCidrs",
          "Selector": "$.Subnets..CidrBlock",
          "Type": "StringList"
        }
      ],
      "nextStep": "getDirectorySecurityGroup"
    },
    {
      "name": "getDirectorySecurityGroup",
      "action": "aws:executeAwsApi",
      "description": "Gathers information about the security groups that are associated with the AD Connector.",
      "onFailure": "Abort",
      "maxAttempts": 3,
      "timeoutSeconds": 120,
      "inputs": {
        "Service": "ec2",
        "Api": "DescribeSecurityGroups",
        "GroupIds": [
          "{{ getDirectoryInfo.directorySecurityGroupId }}"
        ]
      },
      "outputs": [
        {
          "Name": "directorySecurityGroups",
          "Selector": "$.SecurityGroups",
          "Type": "MapList"
        }
      ],
      "nextStep": "getDirectoryAcl"
    },
    {
      "name": "getDirectoryAcl",
      "action": "aws:executeAwsApi",
      "description": "Gathers information about the  network ACL rules that are associated with the AD Connector.",
      "onFailure": "Abort",
      "maxAttempts": 3,
      "timeoutSeconds": 120,
      "inputs": {
        "Service": "ec2",
        "Api": "DescribeNetworkAcls",
        "Filters": [
          {
            "Name": "association.subnet-id",
            "Values": "{{ getDirectoryInfo.directorySubnets }}"
          }
        ]
      },
      "outputs": [
        {
          "Name": "directoryAcls",
          "Selector": "$.NetworkAcls",
          "Type": "MapList"
        }
      ],
      "nextStep": "evalDirectorySecurityGroup"
    },
    {
      "name": "evalDirectorySecurityGroup",
      "action": "aws:executeScript",
      "description": "Evalutes the AD Connector security group rules to verify that the required outbound traffic is allowed.",
      "maxAttempts": 3,
      "timeoutSeconds": 45,
      "onFailure": "Continue",
      "inputs": {
        "Runtime": "python3.8",
        "Handler": "evalDirectorySecurityGroup",
        "InputPayload": {
          "remoteCidrs": "{{ getDirectoryInfo.onPremDnsIpAddrs }}",
          "directorySecurityGroups": "{{ getDirectorySecurityGroup.directorySecurityGroups }}",
          "requiredTraffic": "{\"outbound\":{\"-1\":[[0,65535]]}}"
        },
        "Script": "def evalDirectorySecurityGroup(events,context):\n    import json \n    \n    directorySecurityGroups = events['directorySecurityGroups']\n    inputCidrs = events['remoteCidrs']\n    remoteCidrs = []\n    finalOutput = []\n    for inputCidr in inputCidrs:\n        remoteCidr = inputCidr.replace(inputCidr, inputCidr + \"/32\")\n        remoteCidrs.append(remoteCidr)\n    requiredTraffic = json.loads(events['requiredTraffic'])\n#    print('RequiredTraffic',requiredTraffic)\n    \n    err = False\n    sourceCidr = {'network-cidrs':remoteCidrs,'security-groups':[]} \n    err = eval_security_groups_traffic(directorySecurityGroups, sourceCidr, requiredTraffic)\n    \n    if err:\n        finalOutput.append({ 'Error': 'Required traffic is not allowed in Security Groups. See ExecutionLog for Step 6. Please refer to the following article for more information regarding AD connector Prerequisites https://docs.aws.amazon.com/directoryservice/latest/admin-guide/prereq_connector.html' })\n        return finalOutput\n    else:\n        finalOutput.append({ 'Success': 'Required traffic is allowed in Security Groups' })\n        return finalOutput\n\ndef eval_security_groups_traffic(sgs, sourceCidr, traffic):\n    from ipaddress import ip_network\n    try:\n        err = False\n        for sg in sgs:\n            for protocol, ranges in traffic.get('outbound',[]).items():\n                for range in ranges:\n                    allowed = False\n                    for r in sg.get('IpPermissionsEgress', []):\n                        if r['IpProtocol'] in (protocol,'-1'): \n                            if (not 'FromPort' in r and not 'ToPort' in r) or (r['FromPort'] <= range[0] and r['ToPort'] >= range[1]): # \"Rule allows port %s\" % r['fromPort']\n                                for user_id_group_pair in r.get('UserIdGroupPairs',[]):\n                                    for group_id in sourceCidr.get('security-groups', []):\n                                        if user_id_group_pair['GroupId'] == group_id:\n                                            allowed = True\n                                            break\n                                for ip_range in r['IpRanges']:\n                                    for network_cidr in sourceCidr.get('network-cidrs', []):\n                                        if (ip_network(ip_range['CidrIp'], strict=False).overlaps(ip_network(network_cidr, strict=False))):\n                                            allowed = True\n                                            break\n                    if (not allowed):\n                        print('No outbound Security Group rule in', sg['GroupId'],'allows connectivity for',protocol.replace(\"-1\", \"all\").upper(),'in range:',range)\n                        err = True\n        return err\n\n    except Exception as e:\n        print('Failed to evaluate Security Groups.', str(e))\n        return True\n"
      },
      "outputs": [
        {
          "Name": "output",
          "Selector": "$.Payload",
          "Type": "MapList"
        },
        {
          "Name": "error",
          "Selector": "$.Payload.err",
          "Type": "Boolean"
        }
      ],
      "nextStep": "evalAclEntries"
    },
    {
      "name": "evalAclEntries",
      "action": "aws:executeScript",
      "description": "Evalutes the AD Connector network ACL rules to verify that the required outbound and inbound network traffic is allowed.",
      "maxAttempts": 3,
      "timeoutSeconds": 45,
      "onFailure": "Continue",
      "inputs": {
        "Runtime": "python3.8",
        "Handler": "evalAclEntries",
        "InputPayload": {
          "remoteCidrs": "{{ getDirectoryInfo.onPremDnsIpAddrs }}",
          "directoryAcl": "{{ getDirectoryAcl.directoryAcls }}",
          "requiredTraffic": "{\"inbound\":{\"tcp\":[[53,53],[88,88],[389,389],[1024,65535]],\"udp\":[[53,53],[88,88],[389,389]],\"icmp\":[[-1,-1]]},\"outbound\":{\"-1\":[[0,65535]]}}"
        },
        "Script": "def evalAclEntries(events,context):\n    from ipaddress import ip_network\n    import json\n    err = False\n    directoryNetworkAcls = events['directoryAcl']\n    inputCidrs = events['remoteCidrs']\n    remoteCidrs = []\n    finalOutput = []\n    for inputCidr in inputCidrs:\n        remoteCidr = inputCidr.replace(inputCidr, inputCidr + \"/32\")\n        remoteCidrs.append(remoteCidr)\n    requiredTraffic = json.loads(events['requiredTraffic'])\n    \n    sourceCidr = {'network-cidrs':remoteCidrs,'security-groups':[]} \n    allowRules = eval_acl_rules(directoryNetworkAcls, sourceCidr, requiredTraffic)\n    err = check_allowed(allowRules, requiredTraffic)\n\n    if err:\n        finalOutput.append({ 'Error': 'Required traffic is not allowed in Network ACLs. See ExecutionLog for Step 7. Please refer to the following article for more information regarding AD connector Prerequisites https://docs.aws.amazon.com/directoryservice/latest/admin-guide/prereq_connector.html' })\n        return finalOutput\n    else:\n        finalOutput.append({ 'Success': 'Required traffic is allowed in Network ACLs' })\n        return finalOutput\n\ndef print_allowed(allowRules):\n    for nacl_id, nacl in allowRules.items():\n        print('NetworkAclId', nacl_id, 'Inbound:', list(nacl[0].items()), ' <> Outbound:', list(nacl[1].items()))\n\ndef eval_acl_rules(rules, sourceCidr, traffic): \n    from collections import defaultdict\n    from ipaddress import ip_network\n\n    in_allow = defaultdict(list)\n    out_allow = defaultdict(list)\n    allowRules = defaultdict(list)\n    \n    try:\n        for nacl in rules:\n                for r in sorted(nacl['Entries'], key=lambda k: k['RuleNumber'], reverse=True):\n                        for network_cidr in sourceCidr.get('network-cidrs', []):\n                            protocol = get_std_protocol(r['Protocol'])\n                            if (ip_network(r['CidrBlock'], strict=False).overlaps(ip_network(network_cidr, strict=False))):\n                                if not 'PortRange' in r:\n                                    f=0\n                                    t=65535\n                                else:\n                                    f=r['PortRange']['From']\n                                    t=r['PortRange']['To']\n\n                                if not r['Egress']:\n                                    if r['RuleAction'] == 'allow':\n                                        in_allow[protocol] = range_add([f,t],in_allow[protocol])\n                                    else:\n                                        in_allow[protocol] = range_diff([f,t],in_allow[protocol])\n                                else:\n                                    if r['RuleAction'] == 'allow':\n\n                                        out_allow[protocol] = range_add([f,t],out_allow[protocol])\n                                    else:\n                                        out_allow[protocol] = range_diff([f,t],out_allow[protocol])\n                \n                allowRules[nacl['NetworkAclId']].append(in_allow.copy())#[0]\n                allowRules[nacl['NetworkAclId']].append(out_allow.copy())#[1]\n                in_allow.clear()\n                out_allow.clear()\n\n        return allowRules\n    \n    except Exception as e:\n        print('Failed to evaluate Network ACLs.', str(e))\n        return allowRules\n\ndef get_std_protocol(acl_protocol):\n    # defined at https://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml\n    customprotocol = {\"-1\":\"-1\",\"hopopt\":\"0\",\"icmp\":\"1\",\"igmp\":\"2\",\"ggp\":\"3\",\"ipv4\":\"4\",\"st\":\"5\",\"tcp\":\"6\",\"cbt\":\"7\",\"egp\":\"8\",\"igp\":\"9\",\"bbn-rcc-mon\":\"10\",\"nvp-ii\":\"11\",\"pup\":\"12\",\"argus\":\"13\",\"emcon\":\"14\",\"xnet\":\"15\",\"chaos\":\"16\",\"udp\":\"17\",\"mux\":\"18\",\"dcn-meas\":\"19\",\"hmp\":\"20\",\"prm\":\"21\",\"xns-idp\":\"22\",\"trunk-1\":\"23\",\"trunk-2\":\"24\",\"leaf-1\":\"25\",\"leaf-2\":\"26\",\"rdp\":\"27\",\"irtp\":\"28\",\"iso-tp4\":\"29\",\"netblt\":\"30\",\"mfe-nsp\":\"31\",\"merit-inp\":\"32\",\"dccp\":\"33\",\"3pc\":\"34\",\"idpr\":\"35\",\"xtp\":\"36\",\"ddp\":\"37\",\"idpr-cmtp\":\"38\",\"tp++\":\"39\",\"il\":\"40\",\"ipv6\":\"41\",\"sdrp\":\"42\",\"ipv6-route\":\"43\",\"ipv6-frag\":\"44\",\"idrp\":\"45\",\"rsvp\":\"46\",\"gre\":\"47\",\"dsr\":\"48\",\"bna\":\"49\",\"esp\":\"50\",\"ah\":\"51\",\"i-nlsp\":\"52\",\"swipe\":\"53\",\"narp\":\"54\",\"mobile\":\"55\",\"tlsp\":\"56\",\"ipv6-icmp\":\"58\",\"ipv6-nonxt\":\"59\",\"ipv6-opts\":\"60\",\"61\":\"61\",\"cftp\":\"62\",\"63\":\"63\",\"sat-expak\":\"64\",\"kryptolan\":\"65\",\"rvd\":\"66\",\"ippc\":\"67\",\"68\":\"68\",\"sat-mon\":\"69\",\"visa\":\"70\",\"ipcv\":\"71\",\"cpnx\":\"72\",\"cphb\":\"73\",\"wsn\":\"74\",\"pvp\":\"75\",\"br-sat-mon\":\"76\",\"sun-nd\":\"77\",\"wb-mon\":\"78\",\"wb-expak\":\"79\",\"iso-ip\":\"80\",\"vmtp\":\"81\",\"secure-vmtp\":\"82\",\"vines\":\"83\",\"ttp\":\"84\",\"nsfnet-igp\":\"85\",\"dgp\":\"86\",\"tcf\":\"87\",\"eigrp\":\"88\",\"ospfigp\":\"89\",\"sprite-rpc\":\"90\",\"larp\":\"91\",\"mtp\":\"92\",\"ax.25\":\"93\",\"ipip\":\"94\",\"micp\":\"95\",\"scc-sp\":\"96\",\"etherip\":\"97\",\"encap\":\"98\",\"99\":\"99\",\"gmtp\":\"100\",\"ifmp\":\"101\",\"pnni\":\"102\",\"pim\":\"103\",\"aris\":\"104\",\"scps\":\"105\",\"qnx\":\"106\",\"a/n\":\"107\",\"ipcomp\":\"108\",\"snp\":\"109\",\"compaq-peer\":\"110\",\"ipx-in-ip\":\"111\",\"vrrp\":\"112\",\"pgm\":\"113\",\"114\":\"114\",\"l2tp\":\"115\",\"dd\":\"116\",\"iatp\":\"117\",\"stp\":\"118\",\"srp\":\"119\",\"uti\":\"120\",\"smp\":\"121\",\"sm\":\"122\",\"ptp\":\"123\",\"isis-over-ipv4\":\"124\",\"fire\":\"125\",\"crtp\":\"126\",\"crudp\":\"127\",\"sscopmce\":\"128\",\"iplt\":\"129\",\"sps\":\"130\",\"pipe\":\"131\",\"sctp\":\"132\",\"fc\":\"133\",\"rsvp-e2e-ignore\":\"134\",\"mobility-header\":\"135\",\"udplite\":\"136\",\"mpls-in-ip\":\"137\",\"manet\":\"138\",\"hip\":\"139\",\"shim6\":\"140\",\"wesp\":\"141\",\"rohc\":\"142\",\"253\":\"253\",\"254\":\"254\"}\n    inv_map = {v: k for k, v in customprotocol.items()}\n    return inv_map.get(acl_protocol)\n\ndef range_add(new,interv):\n    interv.append(new)\n    interv = [x for x in interv if x != [] and len(x) == 2 and all(isinstance(val, int) for val in x)]\n    interv.sort()\n    res=[]\n    while(len(interv)>0):\n        if len(interv)==1:\n            res.append(interv[0])\n            interv.pop(0)\n            continue\n        if interv[0][1]>=interv[1][0]:\n            tmp=[interv[0][0],max(interv[0][1],interv[1][1])]\n            interv[0]=tmp\n            interv.pop(1)\n            continue\n        res.append(interv[0])\n        interv.pop(0)\n    return res\n\ndef range_diff(new,interv):\n    interv = range_add([],interv)\n    if len(new)==0:\n        new = [0,0]\n    interv = [x for x in interv if x != [] and len(x) == 2 and all(isinstance(val, int) for val in x)]\n    interv.sort()\n    res=[]\n    for t in interv:\n        s1, e1 = t\n        s2, e2 = new\n        s = sorted((s1, s2, e1, e2))\n        if s[0] == s1 and s[0] != s[1]:\n            v = s[1] if e1 < s2 else s[1]-1 \n            res.append([s[0],v])\n        if s[3] == e1 and s[2] != s[3]:\n            v = s[2] if e2 < s1 else s[2]+1\n            res.append([v,s[3]])\n    if len(res)==0:\n        res = [[0,0]]\n    return res\n\ndef check_allowed(allowRules, traffic):\n    err = False\n    for nacl_id, nacl in allowRules.items():\n        for protocol, ranges in traffic.get('inbound',[]).items():\n            for range in ranges:\n                allowed = False\n                for r in nacl[0].get('-1', []):\n                    if r[0] <= range[0] and r[1] >= range[1]:\n                        allowed = True\n                        break\n                for r in nacl[0].get(protocol, []):\n                    if r[0] <= range[0] and r[1] >= range[1]:\n                        allowed = True\n                        break\n            if (not allowed):\n                print('Error: No inbound ACL rule in',nacl_id,'allows connectivity for',protocol.replace(\"-1\", \"all\").upper(),'in range:',range)\n                err = True\n            else:\n                break\n\n        for protocol, ranges in traffic.get('outbound',[]).items():\n            for range in ranges:\n                allowed = False\n                for r in nacl[1].get('-1', []):\n                    if r[0] <= range[0] and r[1] >= range[1]:\n                        allowed = True\n                        break\n                for r in nacl[1].get(protocol, []):\n                    if r[0] <= range[0] and r[1] >= range[1]:\n                        allowed = True\n                        break\n            if (not allowed):\n                print('Error: No outbound ACL rule in',nacl_id,'allows connectivity for',protocol.replace(\"-1\", \"all\").upper(),'in range:',range)\n                err = True\n            else:\n                break\n            \n    return err\n"
      },
      "outputs": [
        {
          "Name": "output",
          "Selector": "$.Payload",
          "Type": "MapList"
        },
        {
          "Name": "error",
          "Selector": "$.Payload.err",
          "Type": "Boolean"
        }
      ],
      "nextStep": "checkVPCEndpoints"
    },
    {
      "name": "checkVPCEndpoints",
      "action": "aws:executeScript",
      "description": "Checks if the AWS Systems Manager, AWS Security Token Service and Amazon CloudWatch interface VPC endpoints exist in the same VPC as the AD Connector.",
      "maxAttempts": 3,
      "timeoutSeconds": 45,
      "onFailure": "Continue",
      "inputs": {
        "Runtime": "python3.8",
        "Handler": "checkVPCEndpoints",
        "InputPayload": {
          "directoryVPC": "{{ getDirectoryInfo.directoryVpcId }}"
        },
        "Script": "def checkVPCEndpoints(events,context):\n    import boto3\n    from botocore.exceptions import ClientError,ParamValidationError\n\n    client = boto3.client('ec2')\n\n    # Getting current region\n    current_session = boto3.session.Session()\n    current_region = current_session.region_name\n\n    # Setting Variables for VPC endpoints\n    ssmUrl = 'com.amazonaws.' + current_region + '.ssm'\n    stsUrl = 'com.amazonaws.' + current_region + '.sts'\n    cwUrl = 'com.amazonaws.' + current_region + '.monitoring'\n    vpcId = events['directoryVPC']\n\n\n    try:\n        # Checking SSM Enpoint\n        ssmResponse = client.describe_vpc_endpoints(Filters=[{'Name':'service-name','Values':[ssmUrl]},{'Name': 'vpc-id','Values': [vpcId]}])\n        if ssmResponse['VpcEndpoints']:\n            ssmOutput = { 'Error': 'VPC endpoint for AWS Systems Manager found for the same VPC as of the directory. Please remove the endpoint to fix the directory impairment. VPC Endpoint ID: ' + ssmResponse['VpcEndpoints'][0]['VpcEndpointId']}\n        else:\n            ssmOutput= { 'Success': 'VPC endpoint for AWS Systems Manager not found for the same VPC as of the directory. No Action Required.'}\n        \n        # Checking STS Endpoint\n        stsResponse = client.describe_vpc_endpoints(Filters=[{'Name':'service-name','Values':[stsUrl]},{'Name': 'vpc-id','Values': [vpcId]}])\n        if stsResponse['VpcEndpoints']:\n            stsOutput = { 'Error': 'VPC endpoint for AWS Security Token Service (AWS STS) found for the same VPC as of the directory. Please remove the endpoint to fix the directory impairment. VPC Endpoint ID: ' + stsResponse['VpcEndpoints'][0]['VpcEndpointId']}\n        else:\n            stsOutput = { 'Success': 'VPC endpoint for AWS Security Token Service (AWS STS) not found for the same VPC as of the directory. No Action Required.'}\n\n        # Checking CloudWatch Endpoint\n        cwResponse = client.describe_vpc_endpoints(Filters=[{'Name':'service-name','Values':[cwUrl]},{'Name': 'vpc-id','Values': [vpcId]}])\n        if cwResponse['VpcEndpoints']:\n            cwOutput = { 'Error': 'VPC endpoint for Amazon CloudWatch found for the same VPC as of the directory. Please remove the endpoint to fix the directory impairment. VPC Endpoint ID: ' + cwResponse['VpcEndpoints'][0]['VpcEndpointId']}\n        else:\n            cwOutput = { 'Success': 'VPC endpoint for Amazon CloudWatch not found for the same VPC as of the directory. No Action Required.'}\n        \n        return ssmOutput,stsOutput,cwOutput\n\n    except ClientError as e:\n        raise Exception (\"[ERROR]\",e)\n"
      },
      "outputs": [
        {
          "Name": "output",
          "Selector": "$.Payload",
          "Type": "MapList"
        }
      ],
      "nextStep": "compilePrerequistesTestsOutput"
    },
    {
      "name": "compilePrerequistesTestsOutput",
      "action": "aws:executeScript",
      "description": "Compiles the outputs of the checks performed in the previous steps.",
      "maxAttempts": 3,
      "timeoutSeconds": 45,
      "onFailure": "Abort",
      "inputs": {
        "Runtime": "python3.8",
        "Handler": "compilePrerequistesTestsOutput",
        "InputPayload": {
          "securityGroupOutput": "{{ evalDirectorySecurityGroup.output }}",
          "aclOutput": "{{ evalAclEntries.output }}",
          "vpceOutput": "{{ checkVPCEndpoints.output }}",
          "Subnets": [
            "{{ getDirectoryInfo.directorySubnets }}"
          ],
          "DNS": [
            "{{ getDirectoryInfo.onPremDnsIpAddrs }}"
          ]
        },
        "Script": "def compilePrerequistesTestsOutput(events,context):\n    import json\n    \n    # Setting Variables for VPC endpoints\n    directorySecurityGroup = events['securityGroupOutput']\n    directoryAclOutput = events['aclOutput']\n    directoryEndpoint = events['vpceOutput']\n\n    # Convert Outputs to string\n    subnetList = events['Subnets']\n    dnsIps = events['DNS']\n    joinIps = ' '.join(dnsIps)\n    newIps = '\"' + joinIps + '\"'\n    newdirectorySecurityGroup = json.dumps(directorySecurityGroup)\n    newDirectoryAcloutput = json.dumps(directoryAclOutput)\n    newdirectoryEndpoint = json.dumps(directoryEndpoint)\n    finalOutPut = newdirectorySecurityGroup + newDirectoryAcloutput + newdirectoryEndpoint\n    return {'finalOutPut': finalOutPut, 'finalIps':newIps, 'subnet1': subnetList[0], 'subnet2': subnetList[1]}\n"
      },
      "outputs": [
        {
          "Name": "output",
          "Selector": "$.Payload.finalOutPut",
          "Type": "String"
        },
        {
          "Name": "firstSubnet",
          "Selector": "$.Payload.subnet1",
          "Type": "String"
        },
        {
          "Name": "secondSubnet",
          "Selector": "$.Payload.subnet2",
          "Type": "String"
        },
        {
          "Name": "dnsServerIps",
          "Selector": "$.Payload.finalIps",
          "Type": "String"
        }
      ],
      "nextStep": "checkPrerequisites"
    },
    {
      "name": "checkPrerequisites",
      "action": "aws:branch",
      "description": "Branches the automation depending on the output of previous steps. The automation stops here if the required outbound and inbound rules are missing for the security groups and network ACLs.",
      "maxAttempts": 3,
      "timeoutSeconds": 120,
      "isEnd": true,
      "inputs": {
        "Choices": [
          {
            "NextStep": "createHelperEC2InstancesStack",
            "Not": {
              "Variable": "{{compilePrerequistesTestsOutput.output}}",
              "Contains": "Error"
            }
          }
        ]
      }
    },
    {
      "name": "createHelperEC2InstancesStack",
      "action": "aws:createStack",
      "description": "Creates an AWS CloudFormation stack to launch Amazon EC2 instances to perform connectivity tests.",
      "maxAttempts": 1,
      "timeoutSeconds": 500,
      "onFailure": "step:deleteStack",
      "inputs": {
        "Capabilities": [
          "CAPABILITY_IAM",
          "CAPABILITY_NAMED_IAM"
        ],
        "StackName": "AWSSupport-TroubleshootADConnectorConnectivity-{{ automation:EXECUTION_ID }}",
        "TemplateBody": "AWSTemplateFormatVersion: '2010-09-09'\nDescription: 'This step create a CloudFormation template to launch resources required to collect logs. CloudFormation template created 2 Helper Instances: 1 in each subnet of AD connector.'\nParameters:\n  LINUXAMI:\n    Type: AWS::SSM::Parameter::Value<AWS::EC2::Image::Id>\n    Default: \"/aws/service/ami-amazon-linux-latest/amzn2-ami-hvm-x86_64-gp2\"\n  InstanceProfile:\n    Type: String\n    Default: \"{{ Ec2InstanceProfile }}\"\nResources:\n  HelperEC2Instance1:\n    Type: AWS::EC2::Instance\n    Properties:\n      IamInstanceProfile:\n        Ref: InstanceProfile\n      ImageId:\n        Ref: LINUXAMI\n      InstanceType: t3.micro\n      SecurityGroupIds:\n      - \"{{ getDirectoryInfo.directorySecurityGroupId }}\"\n      SubnetId: \"{{ compilePrerequistesTestsOutput.firstSubnet }}\"\n      Tags:\n      - Key: Name\n        Value: awssupport-{{ automation:EXECUTION_ID }}-ec2\n  HelperEC2Instance2:\n    Type: AWS::EC2::Instance\n    Properties:\n      IamInstanceProfile:\n        Ref: InstanceProfile\n      ImageId:\n        Ref: LINUXAMI\n      InstanceType: t3.micro\n      SecurityGroupIds:\n      - \"{{ getDirectoryInfo.directorySecurityGroupId }}\"\n      SubnetId: \"{{ compilePrerequistesTestsOutput.secondSubnet }}\"\n      Tags:\n      - Key: Name\n        Value: awssupport-{{ automation:EXECUTION_ID }}-ec2\nOutputs:\n  firstInstance:\n    Value:\n      Ref: HelperEC2Instance1\n  secondInstance:\n    Value:\n      Ref: HelperEC2Instance2\n",
        "TimeoutInMinutes": 15
      },
      "outputs": [
        {
          "Name": "stackId",
          "Selector": "$.StackId",
          "Type": "String"
        }
      ],
      "nextStep": "getStackInfo"
    },
    {
      "name": "getStackInfo",
      "action": "aws:executeAwsApi",
      "description": "Gathers the IDs of newly launched Amazon EC2 instances.",
      "onFailure": "step:deleteStack",
      "maxAttempts": 3,
      "timeoutSeconds": 120,
      "inputs": {
        "Service": "cloudformation",
        "Api": "ListStackResources",
        "StackName": "{{ createHelperEC2InstancesStack.stackId }}"
      },
      "outputs": [
        {
          "Name": "firstHelperEC2InstanceId",
          "Selector": "$.StackResourceSummaries[0].PhysicalResourceId",
          "Type": "String"
        },
        {
          "Name": "secondHelperEC2InstanceId",
          "Selector": "$.StackResourceSummaries[1].PhysicalResourceId",
          "Type": "String"
        }
      ],
      "nextStep": "verifySSMConnectivityOnHelperInstance1"
    },
    {
      "name": "verifySSMConnectivityOnHelperInstance1",
      "action": "aws:waitForAwsResourceProperty",
      "description": "Waits for the first newly launched Amazon EC2 instance to report as managed by AWS Systems Manager.",
      "onFailure": "step:stopEc2HelperInstances",
      "maxAttempts": 3,
      "timeoutSeconds": 120,
      "isCritical": "true",
      "inputs": {
        "Service": "ssm",
        "Api": "DescribeInstanceInformation",
        "InstanceInformationFilterList": [
          {
            "key": "InstanceIds",
            "valueSet": [
              "{{ getStackInfo.firstHelperEC2InstanceId }}"
            ]
          }
        ],
        "PropertySelector": "$.InstanceInformationList[0].PingStatus",
        "DesiredValues": [
          "Online"
        ]
      },
      "nextStep": "verifySSMConnectivityOnHelperInstance2"
    },
    {
      "name": "verifySSMConnectivityOnHelperInstance2",
      "action": "aws:waitForAwsResourceProperty",
      "description": "Waits for the second newly launched Amazon EC2 instance to report as managed by AWS Systems Manager.",
      "onFailure": "step:stopEc2HelperInstances",
      "maxAttempts": 3,
      "timeoutSeconds": 120,
      "isCritical": "true",
      "inputs": {
        "Service": "ssm",
        "Api": "DescribeInstanceInformation",
        "InstanceInformationFilterList": [
          {
            "key": "InstanceIds",
            "valueSet": [
              "{{ getStackInfo.secondHelperEC2InstanceId }}"
            ]
          }
        ],
        "PropertySelector": "$.InstanceInformationList[0].PingStatus",
        "DesiredValues": [
          "Online"
        ]
      },
      "nextStep": "runConnectivityTestOnHelperInstance1"
    },
    {
      "name": "runConnectivityTestOnHelperInstance1",
      "action": "aws:runCommand",
      "description": "Performs network connectivity tests to the on-premises DNS server IP addresses from the first Amazon EC2 instance.",
      "maxAttempts": 1,
      "timeoutSeconds": 180,
      "onFailure": "step:stopEc2HelperInstances",
      "inputs": {
        "DocumentName": "AWS-RunShellScript",
        "InstanceIds": [
          "{{ getStackInfo.firstHelperEC2InstanceId }}"
        ],
        "TimeoutSeconds": "180",
        "Parameters": {
          "commands": [
            "dnsIp={{ compilePrerequistesTestsOutput.dnsServerIps }}",
            "sleep 5",
            "sudo yum install nc -y -q 2>/dev/null",
            "echo '********************************************************************\\nRunning Connectivity Test from subnet: {{ compilePrerequistesTestsOutput.firstSubnet }}\\n********************************************************************'",
            "echo '\\n''===================================================='",
            "echo '1) Performing name resolution and srv records test:\\n===================================================='",
            "for ipAddress in $dnsIp",
            "do",
            "if nslookup {{ getDirectoryInfo.directoryName }} $ipAddress &>/dev/null; then echo 'Checking domain {{ getDirectoryInfo.directoryName }} name resolution against DNS server '$ipAddress': PASSED'; else echo 'Checking domain {{ getDirectoryInfo.directoryName }} name resolution against DNS server '$ipAddress': FAILED'; fi",
            "if nslookup -type=srv _ldap._tcp.{{ getDirectoryInfo.directoryName }} $ipAddress &>/dev/null; then echo 'Checking domain {{ getDirectoryInfo.directoryName }} LDAP SRV records resolution against DNS server '$ipAddress': PASSED'; else echo 'Checking domain {{ getDirectoryInfo.directoryName }} LDAP SRV records resolution against DNS server '$ipAddress': FAILED'; fi",
            "if nslookup -type=srv _kerberos._tcp.{{ getDirectoryInfo.directoryName }} $ipAddress &>/dev/null; then echo 'Checking domain {{ getDirectoryInfo.directoryName }} Kerberos SRV records resolution against DNS server '$ipAddress': PASSED'; else echo 'Checking domain {{ getDirectoryInfo.directoryName }} Kerberos SRV records resolution against DNS server '$ipAddress': FAILED\\n'; fi",
            "done",
            "stepNumber='2'",
            "for ipAddress in $dnsIp",
            "do",
            "echo '\\n''================================================'",
            "echo ''$stepNumber') Testing required TCP ports on '$ipAddress':\\n================================================'",
            "if nc -vzw1 $ipAddress 389 2>/dev/null; then echo 'Checking TCP port 389: PASSED'; else echo 'Checking TCP port 389: FAILED'; fi",
            "if nc -vzw1 $ipAddress 88 2>/dev/null; then echo 'Checking TCP port 88: PASSED'; else echo 'Checking TCP port 88: FAILED'; fi",
            "if nc -vzw1 $ipAddress 53 2>/dev/null; then echo 'Checking TCP port 53: PASSED'; else echo 'Checking TCP port 53: FAILED'; fi",
            "((stepNumber=stepNumber+1))",
            "echo '\\n''================================================'",
            "echo ''$stepNumber') Testing required UDP ports on '$ipAddress':\\n================================================'",
            "if nc -vzw1 -u $ipAddress 389 2>/dev/null; then echo 'Checking UDP port 389: PASSED'; else echo 'Checking UDP port 389: FAILED'; fi",
            "if nc -vzw1 -u $ipAddress 88 2>/dev/null; then echo 'Checking UDP port 88: PASSED'; else echo 'Checking UDP port 88: FAILED'; fi",
            "if nc -vzw1 -u $ipAddress 53 2>/dev/null; then echo 'Checking UDP port 53: PASSED'; else echo 'Checking UDP port 53: FAILED'; fi",
            "((stepNumber=stepNumber+1))",
            "done"
          ]
        }
      },
      "outputs": [
        {
          "Name": "output",
          "Selector": "$.Output"
        },
        {
          "Name": "error",
          "Selector": "$.Payload.err",
          "Type": "Boolean"
        }
      ],
      "nextStep": "runConnectivityTestOnHelperInstance2"
    },
    {
      "name": "runConnectivityTestOnHelperInstance2",
      "action": "aws:runCommand",
      "description": "Performs network connectivity tests to the on-premises DNS server IP addresses from the second Amazon EC2 instance.",
      "maxAttempts": 1,
      "timeoutSeconds": 180,
      "onFailure": "Continue",
      "inputs": {
        "DocumentName": "AWS-RunShellScript",
        "InstanceIds": [
          "{{ getStackInfo.secondHelperEC2InstanceId }}"
        ],
        "TimeoutSeconds": "180",
        "Parameters": {
          "commands": [
            "dnsIp={{ compilePrerequistesTestsOutput.dnsServerIps }}",
            "sleep 5",
            "sudo yum install nc -y -q 2>/dev/null",
            "echo '********************************************************************\\nRunning Connectivity Test from subnet: {{ compilePrerequistesTestsOutput.secondSubnet }}\\n********************************************************************'",
            "echo '\\n''===================================================='",
            "echo '1) Performing name resolution and srv records test:\\n===================================================='",
            "for ipAddress in $dnsIp",
            "do",
            "if nslookup {{ getDirectoryInfo.directoryName }} $ipAddress &>/dev/null; then echo 'Checking domain {{ getDirectoryInfo.directoryName }} name resolution against DNS server '$ipAddress': PASSED'; else echo 'Checking domain {{ getDirectoryInfo.directoryName }} name resolution against DNS server '$ipAddress': FAILED'; fi",
            "if nslookup -type=srv _ldap._tcp.{{ getDirectoryInfo.directoryName }} $ipAddress &>/dev/null; then echo 'Checking domain {{ getDirectoryInfo.directoryName }} LDAP SRV records resolution against DNS server '$ipAddress': PASSED'; else echo 'Checking domain {{ getDirectoryInfo.directoryName }} LDAP SRV records resolution against DNS server '$ipAddress': FAILED'; fi",
            "if nslookup -type=srv _kerberos._tcp.{{ getDirectoryInfo.directoryName }} $ipAddress &>/dev/null; then echo 'Checking domain {{ getDirectoryInfo.directoryName }} Kerberos SRV records resolution against DNS server '$ipAddress': PASSED'; else echo 'Checking domain {{ getDirectoryInfo.directoryName }} Kerberos SRV records resolution against DNS server '$ipAddress': FAILED\\n'; fi",
            "done",
            "stepNumber='2'",
            "for ipAddress in $dnsIp",
            "do",
            "echo '\\n''================================================'",
            "echo ''$stepNumber') Testing required TCP ports on '$ipAddress':\\n================================================'",
            "if nc -vzw1 $ipAddress 389 2>/dev/null; then echo 'Checking TCP port 389: PASSED'; else echo 'Checking TCP port 389: FAILED'; fi",
            "if nc -vzw1 $ipAddress 88 2>/dev/null; then echo 'Checking TCP port 88: PASSED'; else echo 'Checking TCP port 88: FAILED'; fi",
            "if nc -vzw1 $ipAddress 53 2>/dev/null; then echo 'Checking TCP port 53: PASSED'; else echo 'Checking TCP port 53: FAILED'; fi",
            "((stepNumber=stepNumber+1))",
            "echo '\\n''================================================'",
            "echo ''$stepNumber') Testing required UDP ports on '$ipAddress':\\n================================================'",
            "if nc -vzw1 -u $ipAddress 389 2>/dev/null; then echo 'Checking UDP port 389: PASSED'; else echo 'Checking UDP port 389: FAILED'; fi",
            "if nc -vzw1 -u $ipAddress 88 2>/dev/null; then echo 'Checking UDP port 88: PASSED'; else echo 'Checking UDP port 88: FAILED'; fi",
            "if nc -vzw1 -u $ipAddress 53 2>/dev/null; then echo 'Checking UDP port 53: PASSED'; else echo 'Checking UDP port 53: FAILED'; fi",
            "((stepNumber=stepNumber+1))",
            "done"
          ]
        }
      },
      "outputs": [
        {
          "Name": "output",
          "Selector": "$.Output"
        },
        {
          "Name": "error",
          "Selector": "$.Payload.err",
          "Type": "Boolean"
        }
      ],
      "nextStep": "stopEc2HelperInstances"
    },
    {
      "name": "stopEc2HelperInstances",
      "action": "aws:changeInstanceState",
      "description": "Stops the Amazon EC2 instances used for the connectivity tests.",
      "onFailure": "Continue",
      "maxAttempts": 3,
      "timeoutSeconds": 300,
      "inputs": {
        "InstanceIds": [
          "{{ getStackInfo.firstHelperEC2InstanceId }}",
          "{{ getStackInfo.secondHelperEC2InstanceId }}"
        ],
        "CheckStateOnly": false,
        "DesiredState": "stopped"
      },
      "nextStep": "deleteStack"
    },
    {
      "name": "deleteStack",
      "action": "aws:deleteStack",
      "description": "Deletes the AWS CloudFormation stack.",
      "maxAttempts": 3,
      "timeoutSeconds": 500,
      "isCritical": "true",
      "onFailure": "step:handleDeleteStackFailure",
      "inputs": {
        "StackName": "{{ createHelperEC2InstancesStack.stackId }}"
      },
      "isEnd": true
    },
    {
      "name": "handleDeleteStackFailure",
      "action": "aws:executeScript",
      "description": "Outputs instructions about how to manually delete the AWS CloudFormation stack if the automation fails to delete the stack.",
      "maxAttempts": 3,
      "timeoutSeconds": 120,
      "isCritical": "false",
      "onFailure": "Continue",
      "inputs": {
        "Runtime": "python3.8",
        "Handler": "handleDeleteStackFailure_handler",
        "InputPayload": {
          "stackId": "{{ createHelperEC2InstancesStack.stackId }}"
        },
        "Script": "def handleDeleteStackFailure_handler(events, context):\n\n    import boto3\n    from botocore.exceptions import ClientError,ParamValidationError\n\n    #Capturing the stack ID from the event.\n    stackIdArn = events['stackId']\n\n    #Constructing boto3 client and getting stack name\n    client = boto3.client('cloudformation')\n    try:\n        response = client.describe_stacks(StackName=stackIdArn)\n        stackName = response['Stacks'][0]['StackName']\n    except ClientError as e:\n        raise Exception (\"[ERROR]\",e)\n\n    Message = (\"\\n**[WARNING]** The deleteStack step has failed. To manually delete the stack: \\n\\n\"  \n    \"1. Open the AWS CloudFormation console at https://console.aws.amazon.com/cloudformation. \\n\"\n    \"2. On the Stacks page in the CloudFormation console, select the stack: \") + stackName + \"\\n3. In the stack details pane, choose Delete. \"\n\n    Docs = (\"\\n\\nFor more information on how to delete the stack, follow : https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/cfn-console-delete-stack.html\")\n\n    Result = Message + Docs\n\n    return Result\n"
      },
      "outputs": [
        {
          "Name": "output",
          "Selector": "$.Payload",
          "Type": "String"
        }
      ],
      "isEnd": true
    }
  ]
}
