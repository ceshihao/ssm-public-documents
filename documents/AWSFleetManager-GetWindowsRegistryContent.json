{
  "schemaVersion": "2.2",
  "description": "Performs Windows Registry browse and navigation related operations. Uses default Windows Registry View.",
  "parameters": {
    "Action": {
      "type": "String",
      "description": "(Optional) The action to perform",
      "default": "GetRegistryContent",
      "allowedValues": [
        "GetRegistryContent"
      ]
    },
    "Path": {
      "type": "String",
      "description": "Registry key path relative to the selected Registry Hive. The format for this parameter is \"HIVE:\\Path\", for example \"HKLM:\\SOFTWARE\".",
      "allowedPattern": "^((HKEY_LOCAL_MACHINE|HKLM|HKEY_CURRENT_CONFIG|HKCC|HKEY_CURRENT_USER|HKCU|HKEY_USERS|HKU|HKEY_CLASSES_ROOT|HKCR)+:\\\\)(()|([a-zA-Z0-9\\s_@\\-\\^!#.\\:\\/\\$%&+={}\\[\\]\\\\*]))+$"
    },
    "NextToken": {
      "type": "String",
      "description": "(Optional) Used for the pagination of data. To return all results, specify a value of *. When used with the ListKeys action, set this value to the last key name returned from the previous execution. When used with the ListValues action, set this value to the last value name returned from the previous execution.",
      "default": "*",
      "allowedPattern": "^\\*$|^([A-Za-z0-9-_\\/+]{4})*([A-Za-z0-9-_\\/+]{4}|[A-Za-z0-9-_\\/+]{3}=|[A-Za-z0-9-_\\/+]{2}==)$",
      "minChars": 1,
      "maxChars": 255
    },
    "AllowTruncatedOutput": {
      "type": "String",
      "description": "(Optional) Specifies whether the standard output can be truncated or not. If set to 'No', the standard output size will be limited to stay with Systems Manager API limits. If set to 'Yes', the standard output will not be limited.",
      "default": "Yes",
      "allowedValues": [
        "No",
        "Yes"
      ]
    },
    "CompressOutput": {
      "type": "String",
      "description": "(Optional) Defines whether output is compressed. If set to \"No\", the output will be a JSON string. If set to \"Yes\", the output will be a JSON string, that is gzipped and BASE64 encoded.",
      "default": "No",
      "allowedValues": [
        "No",
        "Yes"
      ]
    }
  },
  "mainSteps": [
    {
      "precondition": {
        "StringEquals": [
          "platformType",
          "Windows"
        ]
      },
      "action": "aws:runPowerShellScript",
      "name": "InvokeWindowsScript",
      "inputs": {
        "runCommand": [
          "$ErrorActionPreference = 'Stop'\n\nFunction ParseInputParameter {\n    param (\n        [string]$Name,\n        [string]$Value,\n        [string]$Regex\n    )\n\n    $ValidParameterRegex = '^--%[ +{|{].*}( +)?$'\n    if ($Value -notmatch $ValidParameterRegex) {\n        ExitWithFailureMessage -Message \"Invalid syntax for the parameter $Name\"\n    }\n    $parameterValue = $Value.Substring(3)\n\n    $trimmedParameterValue = $parameterValue.TrimStart().TrimEnd()\n    $trimmedParameterValue = $trimmedParameterValue.Substring(1)\n    $trimmedParameterValue = $trimmedParameterValue.Substring(0, $trimmedParameterValue.Length - 1)\n\n    if ($Regex -and $trimmedParameterValue -notmatch $Regex) {\n        ExitWithFailureMessage -Message \"Invalid syntax for the parameter $Name\"\n    } else {\n        $trimmedParameterValue\n    }\n}\n\nfunction ExitWithFailureMessage {\n    param (\n        [string]$Message,\n        [string]$ExceptionMessage,\n        [Switch]$PrintJson\n    )\n    if ([string]::IsNullOrWhitespace($ExceptionMessage)) {\n        $errorMessage = $Message\n    } else {\n        $errorMessage = '{0} {1}' -f $Message, $ExceptionMessage\n    }\n    if ($PrintJson) {ConvertTo-Json -InputObject @{error = $errorMessage} -Compress}\n    WriteStandardError -Message $errorMessage\n    [System.Environment]::Exit(1)\n}\n\nfunction ExitWithFailureMessageAndExitCode {\n    param (\n        [string]$Message,\n        [string]$ExceptionMessage,\n        [int]$ExitCode,\n        [Switch]$PrintJson\n    )\n    if ([string]::IsNullOrWhitespace($ExceptionMessage)) {\n        $errorMessage = $Message\n    } else {\n        $errorMessage = '{0} {1}' -f $Message, $ExceptionMessage\n    }\n    if ($PSBoundParameters.ContainsKey('ExitCode') -eq $true) {\n        $exitCode = $ExitCode\n    } else {\n        $exitCode = 1\n    }\n    if ($PrintJson) {\n        $ErrorObject = @{\n            error = $errorMessage\n            exitCode = $exitCode\n        }\n        ConvertTo-Json -InputObject $ErrorObject -Compress\n    }\n    WriteStandardError -Message $errorMessage\n    [System.Environment]::Exit($exitCode)\n}\n\nfunction ExitWithSuccessMessage {\n    param (\n        [string]$Message\n    )\n    Write-Host $Message\n    [System.Environment]::Exit(0)\n}\n\nfunction WriteStandardError {\n    param (\n        [string]$Message\n    )\n    $Host.UI.WriteErrorLine($Message)\n}\n\n$script:ResultProperty = 'results'\n$script:DataProperty = 'data'\n$script:NextTokenProperty = 'nextToken'\n\nfunction ConvertBase64ToString {\n    param (\n        [string]$Base64\n    )\n    $bytes = [System.Convert]::FromBase64String($Base64)\n    [System.Text.Encoding]::UTF8.GetString($bytes)\n}\n\nfunction ConvertStringToBase64 {\n    param (\n        [string]$String\n    )\n    $bytes = [System.Text.Encoding]::UTF8.GetBytes($String)\n    [System.Convert]::ToBase64String($bytes)\n}\n\nfunction GetCompressionBoolean {\n    param (\n        [ValidateSet('No','Yes')]\n        [string]$CompressOutput\n    )\n    if ($CompressOutput -eq 'Yes') {\n        $true\n    } else {\n        $false\n    }\n}\n\nfunction GetJson {\n    param ($InputObject)\n    ConvertTo-Json -InputObject $InputObject -Compress -Depth 5\n}\n\nfunction GetBase64EncodedGzipString {\n    param ($InputString)\n\n    $inputBytes = [System.Text.Encoding]::UTF8.GetBytes($InputString)\n\n    try {\n        $memoryStream = New-Object -TypeName 'System.IO.MemoryStream'\n        $compressionMode = [System.IO.Compression.CompressionMode]::Compress\n        $gzipStream = New-Object -TypeName 'System.IO.Compression.GzipStream' -ArgumentList @($memoryStream, $compressionMode)\n\n        $gzipStream.Write($inputBytes, 0, $inputBytes.Length)\n        $gzipStream.Close()\n        $memoryStream.Close()\n\n        [System.Convert]::ToBase64String($memoryStream.ToArray())\n    } finally {\n        $gzipStream.Dispose()\n        $memoryStream.Dispose()\n    }\n}\n\nfunction GetResultAsString {\n    param (\n        [PSObject]$Object,\n        [bool]$Completed,\n        [switch]$ConvertNextTokenToBase64,\n        [bool]$EnableCompression,\n        [bool]$ForceEmptyNextToken,\n        [string]$NextToken,\n        [string]$PaginationProperty,\n        [array]$StringReplacementRegex\n    )\n\n    if ([string]::IsNullOrWhiteSpace($NextToken)) {\n        if ($Completed -eq $false -and $Object.Count -ge 1 -and $ForceEmptyNextToken -ne $true) {\n            if ($PaginationProperty -eq '.') {\n                $NextToken = $Object[-1]\n            } else {\n                $NextToken = $Object[-1].$PaginationProperty\n            }\n        }\n    }\n\n    if ($ForceEmptyNextToken) {\n        $NextToken = [string]::Empty\n    } elseif ($ConvertNextTokenToBase64) {\n        $NextToken = ConvertStringToBase64 -String $NextToken\n    }\n\n    $data = @{\n        $script:ResultProperty    = $Object\n        $script:NextTokenProperty = $NextToken\n    }\n\n    if ($EnableCompression -eq $true) {\n        $string = GetJson -InputObject $data\n\n        if ($StringReplacementRegex.Count -eq 2) {\n            $string = $string -replace $StringReplacementRegex\n        }\n\n        $data = GetBase64EncodedGzipString -InputString $string\n    }\n\n    $output = GetJson -InputObject @{\n        $script:DataProperty = $data\n    }\n    if ($StringReplacementRegex.Count -eq 2) {\n        $output -replace $StringReplacementRegex\n    } else {\n        $output\n    }\n}\n\nfunction GetMaximumOutputBytes {\n    param (\n        $AllowTruncatedOutput,\n        [int]$MaximumOutputSize = 2500\n    )\n    if ($AllowTruncatedOutput -eq 'Yes') {\n        0\n    } else {\n        $padding = (GetResultAsString -Object @() -Completed $false -EnableCompression $false).length\n        $MaximumOutputSize - $padding\n    }\n}\n\nfunction ProcessItems {\n    param (\n        [scriptblock]$ScriptBlock,\n        [switch]$ConvertNextTokenToBase64,\n        [int]$ChunksPerLoop = 1,\n        [bool]$EnableCompression,\n        [int]$MaximumOutputBytes,\n        [string]$PaginationProperty,\n        [string]$PropertyToRemove,\n        [string]$NextToken,\n        [switch]$SetNextTokenBeforeAdding,\n        [array]$StringReplacementRegex\n    )\n\n    $chunkedOutputArray = New-Object -TypeName 'System.Collections.ArrayList'\n\n    $outputResult = [string]::Empty\n\n    $outputTooBig = $false\n    $counter = 0\n\n    $getResultString = @{\n        EnableCompression = $EnableCompression\n        PaginationProperty = $PaginationProperty\n        StringReplacementRegex = $StringReplacementRegex\n    }\n\n    foreach ($item in (& $ScriptBlock)) {\n        if ($outputTooBig -eq $true) { break }\n\n        if ($NextToken -ne '*') {\n            if ($PaginationProperty -eq '.' -and $item -le $NextToken) {\n                continue\n            } elseif ($PaginationProperty -ne '.' -and $item.$PaginationProperty -le $NextToken) {\n                continue\n            }\n        }\n\n        if ($SetNextTokenBeforeAdding) {\n            if ($PaginationProperty -eq '.') {\n                $newNextToken = $item\n            } else {\n                $newNextToken = $item.$PaginationProperty\n            }\n        }\n\n        if ($PropertyToRemove) {\n            $item.PSObject.properties.remove($PropertyToRemove)\n        }\n\n        $null = $chunkedOutputArray.Add($item)\n\n        if ($counter -lt $ChunksPerLoop) {\n            $counter++\n            continue\n        }\n\n        $counter = 0\n\n        $properties = @{\n            Object = $chunkedOutputArray\n            Completed = $outputTooBig\n        }\n        if ($ConvertNextTokenToBase64) {\n            $properties.Add('ConvertNextTokenToBase64', $ConvertNextTokenToBase64)\n        }\n        if ($SetNextTokenBeforeAdding) {\n            $properties.Add('NextToken', $newNextToken)\n        }\n        $tempResult = GetResultAsString @properties @getResultString\n\n        if ($MaximumOutputBytes -eq 0 -or $tempResult.Length -le $MaximumOutputBytes) {\n            $outputResult = $tempResult\n        } else {\n            $outputTooBig = $true\n            break\n        }\n    }\n\n    # Processing remaining items if the output isn't too big yet\n    if ($outputTooBig -eq $false) {\n        $properties = @{\n            Object = $chunkedOutputArray\n            Completed = $outputTooBig\n            ForceEmptyNextToken = $true\n        }\n        if ($ConvertNextTokenToBase64) {\n            $properties.Add('ConvertNextTokenToBase64', $ConvertNextTokenToBase64)\n        }\n        if ($SetNextTokenBeforeAdding) {\n            $properties.Add('NextToken', $newNextToken)\n        }\n        $tempResult = GetResultAsString @getResultString @properties\n        if ($MaximumOutputBytes -eq 0 -or $tempResult.Length -le $MaximumOutputBytes) {\n            $outputResult = $tempResult\n        }\n    }\n\n    $outputResult\n}\n\n$Action = Write-Output --%{{{ Action }}}\n$Action = ParseInputParameter -Name 'Action' -Value $Action\n\n$Path = Write-Output --%{{{ Path }}}\n$Path = ParseInputParameter -Name 'Path' -Value $Path\n\n$NextToken = Write-Output --%{{{ NextToken }}}\n$NextToken = ParseInputParameter -Name 'NextToken' -Value $NextToken\n\n$AllowTruncatedOutput = Write-Output --%{{{ AllowTruncatedOutput }}}\n$AllowTruncatedOutput = ParseInputParameter -Name 'AllowTruncatedOutput' -Value $AllowTruncatedOutput -Regex '(Yes|No)'\n\n$CompressOutput = Write-Output --%{{{ CompressOutput }}}\n$CompressOutput = ParseInputParameter -Name 'CompressOutput' -Value $CompressOutput -Regex '(Yes|No)'\n\nif ($NextToken -ne '*') {\n    try {\n        $NextToken = ConvertBase64ToString -Base64 $NextToken\n    } catch {\n        ExitWithFailureMessage -Message 'The specified NextToken is invalid.' -PrintJson\n    }\n}\n\n$enableCompression = GetCompressionBoolean -CompressOutput $CompressOutput\n$maximumOutputBytes = GetMaximumOutputBytes -AllowTruncatedOutput $AllowTruncatedOutput\n\nfunction TestRegistryKeyExists {\n    param (\n        $Query,\n        $SubKey\n    )\n\n    $registryKey = $Query.OpenSubKey($SubKey, $false)\n    if ($null -eq $registryKey) {\n        return $false\n    }\n    return $true\n}\n\nfunction TestIfValueShouldBeReturned {\n    param (\n        $Value,\n        $NextToken\n    )\n    if ($NextToken -eq '*' -or $Value -gt $NextToken) {\n        return $true\n    } else {\n        return $false\n    }\n}\n\n$Hive = ($Path.Split('\\')).GetValue(0)\n$registrySubKey = $Path.Replace($hive, [string]::Empty).TrimStart('\\')\n\n[hashtable]$hivePrefixToName = @{\n    'HKLM:'                = [Microsoft.Win32.RegistryHive]::LocalMachine\n    'HKEY_LOCAL_MACHINE:'  = [Microsoft.Win32.RegistryHive]::LocalMachine\n    'HKCU:'                = [Microsoft.Win32.RegistryHive]::CurrentUser\n    'HKEY_CURRENT_USER:'   = [Microsoft.Win32.RegistryHive]::CurrentUser\n    'HKCC:'                = [Microsoft.Win32.RegistryHive]::CurrentConfig\n    'HKEY_CURRENT_CONFIG:' = [Microsoft.Win32.RegistryHive]::CurrentConfig\n    'HKEY_USERS:'          = [Microsoft.Win32.RegistryHive]::Users\n    'HU:'                  = [Microsoft.Win32.RegistryHive]::Users\n    'HKEY_CLASSES_ROOT:'   = [Microsoft.Win32.RegistryHive]::ClassesRoot\n    'HKCR:'                = [Microsoft.Win32.RegistryHive]::ClassesRoot\n}\n$query = [Microsoft.Win32.RegistryKey]::OpenBaseKey($hivePrefixToName[$Hive], [Microsoft.Win32.RegistryView]'Default')\n\nif (-not(TestRegistryKeyExists -Query $query -SubKey $registrySubKey -Name $Name)) {\n    ExitWithFailureMessage -Message 'The specified registry key does not exist.' -PrintJson\n}\n\nif ($enableCompression) {\n    $chunksPerLoop = 15\n} else {\n    $chunksPerLoop = 1\n}\n\nswitch ($Action) {\n    'GetRegistryContent' {\n        $customSortKey = 'CustomSort'\n        [scriptblock]$scriptblock = {\n            $results = New-Object -TypeName System.Collections.ArrayList\n            $subKey = $query.OpenSubKey($registrySubKey, $false)\n\n            # Find all registry keys\n            foreach ($key in $subKey.GetSubKeyNames()) {\n                $customSort = \"k_$key\"\n                if (TestIfValueShouldBeReturned -Value $customSort -NextToken $NextToken) {\n                    $properties = [ordered]@{\n                        Name           = $key\n                        Type           = 'Key'\n                        Value          = ''\n                        $customSortKey = $customSort\n                    }\n                    $null = $results.Add((New-Object -TypeName PSCustomObject -Property $properties))\n                }\n            }\n\n            # Find all registry values\n            foreach ($valueName in ($subKey.GetValueNames())) {\n                $customSort = \"v_$valueName\"\n                if (TestIfValueShouldBeReturned -Value $customSort -NextToken $NextToken) {\n                    $properties = [ordered]@{\n                        Name           = $valueName\n                        Type           = [enum]::GetName([type][Microsoft.Win32.RegistryValueKind], $subKey.GetValueKind($valueName))\n                        Value          = $subKey.GetValue($valueName, [Microsoft.Win32.RegistryValueOptions]::None)\n                        $customSortKey = $customSort\n                    }\n                    $null = $results.Add((New-Object -TypeName PSCustomObject -Property $properties))\n                }\n            }\n\n            $results | Sort-Object -Property CustomSort\n        }\n\n        $processItems = @{\n            ScriptBlock              = $scriptblock\n            ConvertNextTokenToBase64 = $true\n            ChunksPerLoop            = $chunksPerLoop\n            EnableCompression        = $enableCompression\n            MaximumOutputBytes       = $maximumOutputBytes\n            NextToken                = $NextToken\n            PaginationProperty       = $customSortKey\n            PropertyToRemove         = $customSortKey\n            SetNextTokenBeforeAdding = $true\n        }\n    }\n}\n\nProcessItems @processItems\n"
        ]
      }
    }
  ]
}
