{
  "description": "## Id\nAWSResilienceHub-TriggerRestApiGwThrottlingTest_2020-09-21\n\n## Intent\nTest REST API Gateway behavior when hitting throttling threshold\n\n## Type\nTEST\n\n## Risk\nHigh\n\n## Requirements\n  * REST API Gateway\n  * Alarm for metric [4XXError](https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-metrics-and-dimensions.html) setup for the specified API Gateway\n  * There is constant traffic on API Gateway during test\n\n## Permissions required for AutomationAssumeRole\n  * apigateway:GET\n  * apigateway:PATCH\n  * servicequotas:GetServiceQuota\n  * cloudwatch:DescribeAlarms\n  * ssm:GetAutomationExecution\n  * ssm:StartAutomationExecution\n  * ssm:GetParameters\n  * iam:PassRole\n\n##### Permissions required to log output to CloudWatch\n  * logs:PutLogEvents\n  * logs:DescribeLogGroups\n  * logs:DescribeLogStreams\n\n## Supports Rollback\nYes, restore original throttling settings\n\n## Cancellation behavior\nRestore original throttling settings\n\n## Inputs\n### (Required) AutomationAssumeRole\n  * type: String\n  * description: ARN of the IAM role with permissions listed above\n\n### (Required) RestApiGwUsagePlanId\n  * type: String\n  * description: The ID of REST API Gateway usage plan to be modified\n\n### (Required) ApiGw4xxAlarmName\n  * type: String\n  * description: Alarm for metric [4XXError](https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-metrics-and-dimensions.html) setup for the specified API Gateway\n\n### (Optional) RestApiGwThrottlingRate\n  * type: String\n  * description: The value of throttling rate (requests per second)\n  * default: '0'\n\n### (Optional) RestApiGwThrottlingBurst\n  * type: String\n  * description: The value of throttling burst rate (requests per second)\n  * default: '0'\n\n### (Optional) RestApiGwStageName\n  * type: String\n  * description: The name of the Stage which throttling settings should be applied to. If not set, setting will be applied on the Usage Plan level\n  * default: ''\n\n### (Optional) RestApiGwId\n  * type: String\n  * description: The ID of REST API Gateway. Required if Stage name is provided. Otherwise, it will be ignored\n  * default: ''\n\n### (Optional) RestApiGwResourcePath\n  * type: String\n  * description: The Resource Path which throttling settings should be applied to (e.g. /Customers/Accounts/). Can be set to \"*\" (all resources). If `RestApiGwStageName` is not provided then this parameter is ignored\n  * default: '*'\n\n### (Optional) The HTTP method which throttling settings should be applied to (e.g. GET, POST, PUT, and etc.). Can be set to \"*\" (all http methods). If `RestApiGwStageName` is not provided then this parameter is ignored\n  * type: String\n  * description: The value of throttling rate (requests per second)\n  * default: '*'\n\n### (Optional) IsRollback\n  * type: String\n  * description: Run the rollback steps of the document. True or False. If True, the parameter PreviousExecutionId should also be specified\n  * default: false\n\n### (Optional) PreviousExecutionId\n  * type: String\n  * description: SSM execution ID of the previous execution of this document for which resources need to be cleaned up\n\n## Details\nThe document injects failure by setting both throttling rate and trottling burst of the specified REST\nAPI Gateway to 0. If provided, throttling is injected only for the specified stage, path and method. Alarm\nfor metric [4XXError](https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-metrics-and-dimensions.html)\nshould be trigger by traffic on the gateway. In case of issues users should manually restore original\nthrottling settings from backup.\n\n## Steps executed in normal flow\n  * CheckIsRollback\n  * AssertAlarmToBeGreenBeforeTest\n  * BackupThrottlingConfiguration\n  * SetThrottlingConfiguration\n  * AssertAlarmToBeRed\n  * RollbackCurrentExecution\n  * AssertAlarmToBeGreen\n\n## Steps executed in rollback flow\n  * CheckIsRollback\n  * GetInputsFromPreviousExecution\n  * AssertInputsFromPreviousExecution\n  * PrepareRollbackOfPreviousExecution\n  * RollbackPreviousExecution\n\n## Outputs\nNone",
  "schemaVersion": "0.3",
  "assumeRole": "{{ AutomationAssumeRole }}",
  "parameters": {
    "AutomationAssumeRole": {
      "type": "String",
      "description": "(Required) The ARN of the role that allows Automation to perform the actions on your behalf."
    },
    "ApiGw4xxAlarmName": {
      "type": "String",
      "description": "(Required) Alarm for metric `4XXError` setup for the specified"
    },
    "RestApiGwUsagePlanId": {
      "type": "String",
      "description": "(Required) The ID of REST API Gateway usage plan to be modified"
    },
    "RestApiGwThrottlingRate": {
      "type": "String",
      "description": "(Optional) The value of throttling rate (requests per second)",
      "default": "0"
    },
    "RestApiGwThrottlingBurst": {
      "type": "String",
      "description": "(Optional) The value of throttling burst rate (requests per second)",
      "default": "0"
    },
    "RestApiGwStageName": {
      "type": "String",
      "description": "(Optional) The name of the Stage which throttling settings should be applied to. If not set, setting will be applied on the Usage Plan level",
      "default": ""
    },
    "RestApiGwId": {
      "type": "String",
      "description": "(Optional) The ID of REST API Gateway. Required if Stage name is provided. Otherwise, it will be ignored",
      "default": ""
    },
    "RestApiGwResourcePath": {
      "type": "String",
      "description": "(Optional) The Resource Path which throttling settings should be applied to (e.g. /Customers/Accounts/). Can be set to \"*\" (all resources). If RestApiGwStageName is not provided then this parameter is ignored",
      "default": "*"
    },
    "RestApiGwHttpMethod": {
      "type": "String",
      "description": "(Optional) The HTTP method which throttling settings should be applied to (e.g. GET, POST, PUT, and etc.). Can be set to \"*\" (all http methods). If RestApiGwStageName is not provided then this parameter is ignored",
      "default": "*"
    },
    "IsRollback": {
      "type": "Boolean",
      "description": "(Optional) Run rollback step of the given previous execution (parameter `PreviousExecutionId`). Can be either true or false.",
      "default": false
    },
    "PreviousExecutionId": {
      "type": "String",
      "description": "(Optional) Previous execution id for which resources need to be cleaned up.",
      "default": ""
    }
  },
  "mainSteps": [
    {
      "name": "CheckIsRollback",
      "description": "Check if document should be executed in rollback mode",
      "action": "aws:branch",
      "inputs": {
        "Choices": [
          {
            "NextStep": "GetInputsFromPreviousExecution",
            "Variable": "{{IsRollback}}",
            "BooleanEquals": true
          }
        ],
        "Default": "AssertAlarmToBeGreenBeforeTest"
      }
    },
    {
      "name": "GetInputsFromPreviousExecution",
      "description": "Get input from previous execution. This will be used to validate that rollback is executed with the same input",
      "action": "aws:executeScript",
      "outputs": [
        {
          "Name": "RestApiGwUsagePlanId",
          "Selector": "$.Payload.RestApiGwUsagePlanId[0]",
          "Type": "String"
        },
        {
          "Name": "RestApiGwId",
          "Selector": "$.Payload.RestApiGwId[0]",
          "Type": "String"
        },
        {
          "Name": "RestApiGwStageName",
          "Selector": "$.Payload.RestApiGwStageName[0]",
          "Type": "String"
        },
        {
          "Name": "RestApiGwResourcePath",
          "Selector": "$.Payload.RestApiGwResourcePath[0]",
          "Type": "String"
        },
        {
          "Name": "RestApiGwHttpMethod",
          "Selector": "$.Payload.RestApiGwHttpMethod[0]",
          "Type": "String"
        }
      ],
      "inputs": {
        "Runtime": "python3.7",
        "Handler": "get_inputs_from_ssm_execution",
        "InputPayload": {
          "ExecutionId": "{{ PreviousExecutionId }}"
        },
        "Script": "import json\nimport boto3\nfrom botocore.config import Config\n\n\n\n\ndef get_inputs_from_ssm_execution(events, context):\n    output = {}\n    config = Config(retries={'max_attempts': 20, 'mode': 'standard'})\n    ssm = boto3.client('ssm', config=config)\n\n    if 'ExecutionId' not in events:\n        raise KeyError('Requires ExecutionId')\n\n    if not events['ExecutionId']:\n        raise KeyError('Requires not empty ExecutionId')\n\n    response = ssm.get_automation_execution(AutomationExecutionId=events['ExecutionId'])\n    response_parameters = response['AutomationExecution']['Parameters']\n    # TODO DIG-853\n    for parameter in response_parameters:\n        output[parameter] = response_parameters[parameter]\n\n    return output"
      }
    },
    {
      "name": "AssertInputsFromPreviousExecution",
      "description": "Validate that rollback is executed with the same input",
      "action": "aws:executeScript",
      "inputs": {
        "Runtime": "python3.7",
        "Handler": "assert_inputs_before_throttling_rollback",
        "InputPayload": {
          "RestApiGwUsagePlanId": "{{ RestApiGwUsagePlanId }}",
          "RestApiGwId": "{{ RestApiGwId }}",
          "RestApiGwStageName": "{{ RestApiGwStageName }}",
          "RestApiGwResourcePath": "{{ RestApiGwResourcePath }}",
          "RestApiGwHttpMethod": "{{ RestApiGwHttpMethod }}",
          "OriginalRestApiGwUsagePlanId": "{{ GetInputsFromPreviousExecution.RestApiGwUsagePlanId }}",
          "OriginalRestApiGwId": "{{ GetInputsFromPreviousExecution.RestApiGwId }}",
          "OriginalRestApiGwStageName": "{{ GetInputsFromPreviousExecution.RestApiGwStageName }}",
          "OriginalRestApiGwResourcePath": "{{ GetInputsFromPreviousExecution.RestApiGwResourcePath }}",
          "OriginalRestApiGwHttpMethod": "{{ GetInputsFromPreviousExecution.RestApiGwHttpMethod }}"
        },
        "Script": "import json\nimport logging\nimport time\nfrom random import uniform\nfrom typing import Any, Callable\n\nimport boto3\nfrom botocore.config import Config\nfrom botocore.exceptions import ClientError\n\nlog = logging.getLogger()\nlog.setLevel(logging.INFO)\n\n\n\ndef assert_inputs_before_throttling_rollback(events: dict, context: dict) -> None:\n    usage_plan_id: str = events['RestApiGwUsagePlanId']\n    gateway_id: str = events.get('RestApiGwId')\n    stage_name: str = events.get('RestApiGwStageName')\n    resource_path: str = events.get('RestApiGwResourcePath', '*')\n    http_method: str = events.get('RestApiGwHttpMethod', '*')\n\n    original_usage_plan_id: str = events['OriginalRestApiGwUsagePlanId']\n    original_gateway_id: str = events.get('OriginalRestApiGwId')\n    original_stage_name: str = events.get('OriginalRestApiGwStageName')\n    original_resource_path: str = events.get('OriginalRestApiGwResourcePath', '*')\n    original_http_method: str = events.get('OriginalRestApiGwHttpMethod', '*')\n\n    # Need to have it here to overcame issue DIG-853 during rollback case\n    if original_stage_name.startswith('{{') and original_gateway_id.startswith('{{'):\n        original_stage_name = original_gateway_id = ''\n\n    if original_resource_path.startswith('{{'):\n        original_resource_path = '*'\n\n    if original_http_method.startswith('{{'):\n        original_http_method = '*'\n\n    assert usage_plan_id == original_usage_plan_id, f'Provided RestApiGwUsagePlanId: {usage_plan_id} is not equal to ' \\\n                                                    f'original RestApiGwUsagePlanId: {original_usage_plan_id}'\n\n    assert gateway_id == original_gateway_id, f'Provided RestApiGwId: {gateway_id} is not equal to ' \\\n                                              f'original RestApiGwId: {original_gateway_id}'\n\n    assert stage_name == original_stage_name, f'Provided RestApiGwStageName: {stage_name} is not equal to ' \\\n                                              f'original RestApiGwStageName: {original_stage_name}'\n\n    assert resource_path == original_resource_path, f'Provided RestApiGwResourcePath: {resource_path} is not equal to' \\\n                                                    f' original RestApiGwResourcePath: {original_resource_path}'\n\n    assert http_method == original_http_method, f'Provided RestApiGwHttpMethod: {http_method} is not equal to ' \\\n                                                f'original RestApiGwHttpMethod: {original_http_method}'"
      }
    },
    {
      "name": "PrepareRollbackOfPreviousExecution",
      "description": "Get original throttling settings for rollback",
      "action": "aws:executeScript",
      "outputs": [
        {
          "Name": "RestApiGwThrottlingRateOriginalValue",
          "Selector": "$.Payload.RestApiGwThrottlingRateOriginalValue[0]",
          "Type": "String"
        },
        {
          "Name": "RestApiGwThrottlingBurstOriginalValue",
          "Selector": "$.Payload.RestApiGwThrottlingBurstOriginalValue[0]",
          "Type": "String"
        }
      ],
      "inputs": {
        "Runtime": "python3.7",
        "Handler": "get_output_from_ssm_step_execution",
        "InputPayload": {
          "ExecutionId": "{{ PreviousExecutionId }}",
          "StepName": "BackupThrottlingConfiguration",
          "ResponseField": "RestApiGwThrottlingRateOriginalValue,RestApiGwThrottlingBurstOriginalValue"
        },
        "Script": "import json\nimport boto3\nfrom botocore.config import Config\n\n\n\n\ndef get_output_from_ssm_step_execution(events, context):\n    config = Config(retries={'max_attempts': 20, 'mode': 'standard'})\n    ssm = boto3.client('ssm', config=config)\n\n    if 'ExecutionId' not in events or 'StepName' not in events or 'ResponseField' not in events:\n        raise KeyError('Requires ExecutionId, StepName and ResponseField in events')\n\n    ssm_response = ssm.get_automation_execution(AutomationExecutionId=events['ExecutionId'])\n    for step in ssm_response['AutomationExecution']['StepExecutions']:\n        if step['StepName'] == events['StepName']:\n            response_fields = events['ResponseField'].split(',')\n            output = {}\n            for response_field in response_fields:\n                if response_field in step['Outputs']:\n                    output[response_field] = step['Outputs'][response_field]\n                else:\n                    \"\"\"\n                    By default SSM ignores empty values when encodes API outputs to JSON. It may result in\n                    a situation when an empty value is a valid value but step output completely misses it.\n                    Usually happens with SQS queue policies, default policy is returned by API as an empty value\n                    and executeApi step output ignores it. As a result, further steps in rollback execution will fail.\n                    Instead of ignoring this value we should use a default empty value in rollback, i.e. empty string\n                    represents a default sqs policy\n                    \"\"\"\n                    output[response_field] = ['']\n            return output\n\n    # Could not find step name\n    raise Exception('Can not find step name % in ssm execution response', events['StepName'])"
      }
    },
    {
      "name": "RollbackPreviousExecution",
      "description": "Restore original throttling configuratiuon for the REST API Gateway from previous execution",
      "action": "aws:executeScript",
      "outputs": [
        {
          "Name": "RestApiGwThrottlingRateRestoredValue",
          "Selector": "$.Payload.RateLimit",
          "Type": "Integer"
        },
        {
          "Name": "RestApiGwThrottlingBurstRestoredValue",
          "Selector": "$.Payload.BurstLimit",
          "Type": "Integer"
        }
      ],
      "inputs": {
        "Runtime": "python3.7",
        "Handler": "set_throttling_config",
        "InputPayload": {
          "RestApiGwUsagePlanId": "{{ GetInputsFromPreviousExecution.RestApiGwUsagePlanId }}",
          "RestApiGwId": "{{ GetInputsFromPreviousExecution.RestApiGwId }}",
          "RestApiGwStageName": "{{ GetInputsFromPreviousExecution.RestApiGwStageName }}",
          "RestApiGwResourcePath": "{{ GetInputsFromPreviousExecution.RestApiGwResourcePath }}",
          "RestApiGwHttpMethod": "{{ GetInputsFromPreviousExecution.RestApiGwHttpMethod }}",
          "RestApiGwThrottlingRate": "{{ PrepareRollbackOfPreviousExecution.RestApiGwThrottlingRateOriginalValue }}",
          "RestApiGwThrottlingBurst": "{{ PrepareRollbackOfPreviousExecution.RestApiGwThrottlingBurstOriginalValue }}",
          "ValidateQuotaLimits": false
        },
        "Script": "import json\nimport logging\nimport time\nfrom random import uniform\nfrom typing import Any, Callable\n\nimport boto3\nfrom botocore.config import Config\nfrom botocore.exceptions import ClientError\n\nlog = logging.getLogger()\nlog.setLevel(logging.INFO)\n\n\n\ndef assert_https_status_code_200(response: dict, error_message: str) -> None:\n    if response['ResponseMetadata']['HTTPStatusCode'] != 200:\n        raise ValueError(f'{error_message} Response is: {response}')\n\n\n\ndef execute_boto3_with_backoff(delegate: Callable[[Any], dict], **kwargs) -> dict:\n    \"\"\"\n    Executes the given delegate with apigateway client parameter, handles TooManyRequestsException using\n    exponential backoff algorithm with random jitter\n    :param delegate: The delegate to execute (with boto3 function)\n    :keyword args:\n        retries: Number of maximum backoff retries\n        max_interval: Maximum backoff interval in seconds\n        base_time: Backoff base time\n    :return: The output of the given function\n    \"\"\"\n    backoff_retries: int = kwargs.get('retries', 15)\n    backoff_max_interval: int = kwargs.get('max_interval', 64)\n    backoff_base_time: int = kwargs.get('base_time', 2)\n    apigw_client = boto3.client('apigateway')\n\n    count = 1\n    while count <= backoff_retries:\n        try:\n            log.debug(f'Making an API call, attempt: {count} ...')\n            response = delegate(apigw_client)\n            assert_https_status_code_200(response, 'Failed to perform API call')\n            log.debug('API call performed successfully.')\n            return response\n        except ClientError as error:\n            if error.response['Error']['Code'] == 'TooManyRequestsException':\n                interval: float = min(backoff_base_time * 2 ** count + round(uniform(-2, 2), 2), backoff_max_interval)\n                log.warning(f'TooManyRequestsException, slow it down with delay {interval} seconds ...')\n                time.sleep(interval)\n                count += 1\n            else:\n                log.error(error)\n                raise error\n\n    raise Exception(f'Failed to perform API call successfully for {count - 1} times.')\n\n\n\ndef get_service_quota(config: object, service_code: str, quota_code: str) -> dict:\n    client = boto3.client('service-quotas', config=config)\n    response = client.get_service_quota(ServiceCode=service_code, QuotaCode=quota_code)\n    assert_https_status_code_200(response, f'Failed to perform get_service_quota with '\n                                           f'ServiceCode: {service_code} and QuotaCode: {quota_code}')\n    return response\n\n\n\ndef update_usage_plan(usage_plan_id: str, patch_operations: list, retries: int = 15) -> dict:\n    return execute_boto3_with_backoff(\n        delegate=lambda x: x.update_usage_plan(\n            usagePlanId=usage_plan_id,\n            patchOperations=patch_operations\n        ),\n        retries=retries\n    )\n\n\n\ndef wait_throttling_config_updated(events: dict, context: dict) -> None:\n    expected_rate_limit: int = int(events['RestApiGwThrottlingRate'])\n    expected_burst_limit: int = int(events['RestApiGwThrottlingBurst'])\n    max_retries: int = events.get('MaxRetries', 40)\n    timeout: int = events.get('Timeout', 15)\n    while max_retries > 0:\n        actual_throttling_config = get_throttling_config(events, None)\n        actual_rate_limit = actual_throttling_config['RateLimit']\n        actual_burst_limit = actual_throttling_config['BurstLimit']\n        if actual_rate_limit == expected_rate_limit and actual_burst_limit == expected_burst_limit:\n            return\n        log.info(f'Waiting for expected values: [RateLimit: {expected_rate_limit}, BurstLimit: {expected_burst_limit}],'\n                 f' actual values: [RateLimit: {actual_rate_limit}, BurstLimit: {actual_burst_limit}]')\n        max_retries -= 1\n        time.sleep(timeout)\n\n    raise TimeoutError('Error to wait for throttling config update. Maximum timeout exceeded!')\n\n\n\ndef get_throttling_config(events: dict, context: dict) -> dict:\n    if 'RestApiGwUsagePlanId' not in events:\n        raise KeyError('Requires RestApiGwUsagePlanId in events')\n\n    if 'RestApiGwStageName' in events and events['RestApiGwStageName']:\n        if 'RestApiGwId' not in events:\n            raise KeyError('Requires RestApiGwId in events')\n        if not events['RestApiGwId']:\n            raise KeyError('RestApiGwId should not be empty')\n\n    usage_plan_id: str = events['RestApiGwUsagePlanId']\n    gateway_id: str = events.get('RestApiGwId')\n    stage_name: str = events.get('RestApiGwStageName')\n    resource_path: str = events.get('RestApiGwResourcePath', '*')\n    http_method: str = events.get('RestApiGwHttpMethod', '*')\n\n    # Need to have it here for rollback case to overcame issue DIG-853 with get_inputs_from_ssm_execution\n    if (stage_name and stage_name.startswith('{{')) and (gateway_id and gateway_id.startswith('{{')):\n        gateway_id = stage_name = None\n    resource_path = '*' if resource_path.startswith('{{') else resource_path\n    http_method = '*' if http_method.startswith('{{') else http_method\n\n    config: object = Config(retries={'max_attempts': 20, 'mode': 'standard'})\n    client = boto3.client('apigateway', config=config)\n    usage_plan = client.get_usage_plan(usagePlanId=usage_plan_id)\n    assert_https_status_code_200(usage_plan, f'Failed to get usage plan with id {usage_plan_id}')\n\n    if stage_name:\n        stage_found = False\n        for stage in usage_plan['apiStages']:\n            if stage['apiId'] == gateway_id and stage['stage'] == stage_name:\n                stage_found = True\n                if 'throttle' in stage and f'{resource_path}/{http_method}' in stage['throttle']:\n                    rate_limit: float = stage['throttle'][f'{resource_path}/{http_method}']['rateLimit']\n                    burst_limit: int = stage['throttle'][f'{resource_path}/{http_method}']['burstLimit']\n                else:\n                    rate_limit: float = usage_plan['throttle']['rateLimit']\n                    burst_limit: int = usage_plan['throttle']['burstLimit']\n        if not stage_found:\n            raise KeyError(f'Stage name {stage_name} not found in get_usage_plan response: {usage_plan}')\n    else:\n        rate_limit: float = usage_plan['throttle']['rateLimit']\n        burst_limit: int = usage_plan['throttle']['burstLimit']\n\n    return {'RateLimit': int(rate_limit),\n            'BurstLimit': burst_limit,\n            'QuotaLimit': usage_plan['quota']['limit'],\n            'QuotaPeriod': usage_plan['quota']['period']}\n\n\n\ndef set_throttling_config(events: dict, context: dict) -> dict:\n    if 'RestApiGwUsagePlanId' not in events:\n        raise KeyError('Requires RestApiGwUsagePlanId in events')\n\n    if 'RestApiGwThrottlingRate' not in events:\n        raise KeyError('Requires RestApiGwThrottlingRate in events')\n\n    if 'RestApiGwThrottlingBurst' not in events:\n        raise KeyError('Requires RestApiGwThrottlingBurst in events')\n\n    if 'RestApiGwStageName' in events and events['RestApiGwStageName']:\n        if 'RestApiGwId' not in events:\n            raise KeyError('Requires RestApiGwId in events')\n        if not events['RestApiGwId']:\n            raise KeyError('RestApiGwId should not be empty')\n\n    usage_plan_id: str = events['RestApiGwUsagePlanId']\n    new_rate_limit: float = float(events['RestApiGwThrottlingRate'])\n    new_burst_limit: int = int(events['RestApiGwThrottlingBurst'])\n    gateway_id: str = events.get('RestApiGwId')\n    stage_name: str = events.get('RestApiGwStageName')\n    resource_path: str = events.get('RestApiGwResourcePath', '*')\n    http_method: str = events.get('RestApiGwHttpMethod', '*')\n    validate_quota_limits: bool = events.get('ValidateQuotaLimits', True)\n\n    output: dict = {}\n    quota_rate_limit_code: str = 'L-8A5B8E43'\n    quota_burst_limit_code: str = 'L-CDF5615A'\n    patch_operations: list = [\n        {\n            'op': 'replace',\n            'path': '/throttle/rateLimit',\n            'value': str(new_rate_limit)\n        },\n        {\n            'op': 'replace',\n            'path': '/throttle/burstLimit',\n            'value': str(new_burst_limit)\n        }\n    ]\n\n    # Need to have it here for rollback case to overcame issue DIG-853 with get_inputs_from_ssm_execution\n    if (stage_name and stage_name.startswith('{{')) and (gateway_id and gateway_id.startswith('{{')):\n        gateway_id = stage_name = None\n    resource_path = '*' if resource_path.startswith('{{') else resource_path\n    http_method = '*' if http_method.startswith('{{') else http_method\n\n    boto3_config: object = Config(retries={'max_attempts': 20, 'mode': 'standard'})\n\n    if validate_quota_limits:\n        quota_rate_limit: float = get_service_quota(\n            boto3_config, 'apigateway', quota_rate_limit_code)['Quota']['Value']\n        quota_burst_limit: float = get_service_quota(\n            boto3_config, 'apigateway', quota_burst_limit_code)['Quota']['Value']\n\n        if new_rate_limit > quota_rate_limit:\n            raise ValueError(f'Given value of RestApiGwThrottlingRate: {new_rate_limit}, can not be more than '\n                             f'service quota Throttle rate: {quota_rate_limit}')\n\n        if new_burst_limit > quota_burst_limit:\n            raise ValueError(f'Given value of RestApiGwThrottlingBurst: {new_burst_limit}, can not be more than '\n                             f'service quota Throttle burst rate: {quota_burst_limit}')\n    if stage_name:\n        path: str = f'/apiStages/{gateway_id}:{stage_name}/throttle/{resource_path}/{http_method}'\n        patch_operations[0]['path'], patch_operations[1]['path'] = f'{path}/rateLimit', f'{path}/burstLimit'\n        updated_usage_plan = update_usage_plan(usage_plan_id, patch_operations)\n\n        for stage in updated_usage_plan['apiStages']:\n            if stage['apiId'] == gateway_id and stage['stage'] == stage_name:\n                output['RateLimit'] = stage['throttle'][f'{resource_path}/{http_method}']['rateLimit']\n                output['BurstLimit'] = stage['throttle'][f'{resource_path}/{http_method}']['burstLimit']\n    else:\n        updated_usage_plan = update_usage_plan(usage_plan_id, patch_operations)\n        output['RateLimit'] = updated_usage_plan['throttle']['rateLimit']\n        output['BurstLimit'] = updated_usage_plan['throttle']['burstLimit']\n\n    output['RateLimit'] = int(output['RateLimit'])\n    wait_throttling_config_updated(events, None)\n\n    return output"
      },
      "isEnd": true
    },
    {
      "name": "AssertAlarmToBeGreenBeforeTest",
      "description": "Ensure alarm is green before starting test. Fail if alarm is not green within expected time.",
      "action": "aws:waitForAwsResourceProperty",
      "maxAttempts": 1,
      "timeoutSeconds": 1200,
      "inputs": {
        "Service": "cloudwatch",
        "Api": "DescribeAlarms",
        "AlarmNames": [
          "{{ApiGw4xxAlarmName}}"
        ],
        "PropertySelector": "$.MetricAlarms[0].StateValue",
        "DesiredValues": [
          "OK"
        ]
      }
    },
    {
      "name": "BackupThrottlingConfiguration",
      "description": "Backup original throttling settings for rollback",
      "action": "aws:executeScript",
      "outputs": [
        {
          "Name": "RestApiGwThrottlingRateOriginalValue",
          "Selector": "$.Payload.RateLimit",
          "Type": "Integer"
        },
        {
          "Name": "RestApiGwThrottlingBurstOriginalValue",
          "Selector": "$.Payload.BurstLimit",
          "Type": "Integer"
        }
      ],
      "inputs": {
        "Runtime": "python3.7",
        "Handler": "get_throttling_config",
        "InputPayload": {
          "RestApiGwUsagePlanId": "{{ RestApiGwUsagePlanId }}",
          "RestApiGwId": "{{ RestApiGwId }}",
          "RestApiGwStageName": "{{ RestApiGwStageName }}",
          "RestApiGwResourcePath": "{{ RestApiGwResourcePath }}",
          "RestApiGwHttpMethod": "{{ RestApiGwHttpMethod }}"
        },
        "Script": "import json\nimport logging\nimport time\nfrom random import uniform\nfrom typing import Any, Callable\n\nimport boto3\nfrom botocore.config import Config\nfrom botocore.exceptions import ClientError\n\nlog = logging.getLogger()\nlog.setLevel(logging.INFO)\n\n\n\ndef assert_https_status_code_200(response: dict, error_message: str) -> None:\n    if response['ResponseMetadata']['HTTPStatusCode'] != 200:\n        raise ValueError(f'{error_message} Response is: {response}')\n\n\n\ndef get_throttling_config(events: dict, context: dict) -> dict:\n    if 'RestApiGwUsagePlanId' not in events:\n        raise KeyError('Requires RestApiGwUsagePlanId in events')\n\n    if 'RestApiGwStageName' in events and events['RestApiGwStageName']:\n        if 'RestApiGwId' not in events:\n            raise KeyError('Requires RestApiGwId in events')\n        if not events['RestApiGwId']:\n            raise KeyError('RestApiGwId should not be empty')\n\n    usage_plan_id: str = events['RestApiGwUsagePlanId']\n    gateway_id: str = events.get('RestApiGwId')\n    stage_name: str = events.get('RestApiGwStageName')\n    resource_path: str = events.get('RestApiGwResourcePath', '*')\n    http_method: str = events.get('RestApiGwHttpMethod', '*')\n\n    # Need to have it here for rollback case to overcame issue DIG-853 with get_inputs_from_ssm_execution\n    if (stage_name and stage_name.startswith('{{')) and (gateway_id and gateway_id.startswith('{{')):\n        gateway_id = stage_name = None\n    resource_path = '*' if resource_path.startswith('{{') else resource_path\n    http_method = '*' if http_method.startswith('{{') else http_method\n\n    config: object = Config(retries={'max_attempts': 20, 'mode': 'standard'})\n    client = boto3.client('apigateway', config=config)\n    usage_plan = client.get_usage_plan(usagePlanId=usage_plan_id)\n    assert_https_status_code_200(usage_plan, f'Failed to get usage plan with id {usage_plan_id}')\n\n    if stage_name:\n        stage_found = False\n        for stage in usage_plan['apiStages']:\n            if stage['apiId'] == gateway_id and stage['stage'] == stage_name:\n                stage_found = True\n                if 'throttle' in stage and f'{resource_path}/{http_method}' in stage['throttle']:\n                    rate_limit: float = stage['throttle'][f'{resource_path}/{http_method}']['rateLimit']\n                    burst_limit: int = stage['throttle'][f'{resource_path}/{http_method}']['burstLimit']\n                else:\n                    rate_limit: float = usage_plan['throttle']['rateLimit']\n                    burst_limit: int = usage_plan['throttle']['burstLimit']\n        if not stage_found:\n            raise KeyError(f'Stage name {stage_name} not found in get_usage_plan response: {usage_plan}')\n    else:\n        rate_limit: float = usage_plan['throttle']['rateLimit']\n        burst_limit: int = usage_plan['throttle']['burstLimit']\n\n    return {'RateLimit': int(rate_limit),\n            'BurstLimit': burst_limit,\n            'QuotaLimit': usage_plan['quota']['limit'],\n            'QuotaPeriod': usage_plan['quota']['period']}"
      }
    },
    {
      "name": "SetThrottlingConfiguration",
      "description": "Update throttling configuratiuon for REST API Gateway. If provided, settings are updated only for the\nspecified stage, path and method",
      "onFailure": "step:RollbackCurrentExecution",
      "onCancel": "step:TriggerRollback",
      "action": "aws:executeScript",
      "outputs": [
        {
          "Name": "RestApiGwThrottlingRateNewValue",
          "Selector": "$.Payload.RateLimit",
          "Type": "Integer"
        },
        {
          "Name": "RestApiGwThrottlingBurstNewValue",
          "Selector": "$.Payload.BurstLimit",
          "Type": "Integer"
        }
      ],
      "inputs": {
        "Runtime": "python3.7",
        "Handler": "set_throttling_config",
        "InputPayload": {
          "RestApiGwUsagePlanId": "{{ RestApiGwUsagePlanId }}",
          "RestApiGwId": "{{ RestApiGwId }}",
          "RestApiGwStageName": "{{ RestApiGwStageName }}",
          "RestApiGwResourcePath": "{{ RestApiGwResourcePath }}",
          "RestApiGwHttpMethod": "{{ RestApiGwHttpMethod }}",
          "RestApiGwThrottlingRate": "{{ RestApiGwThrottlingRate }}",
          "RestApiGwThrottlingBurst": "{{ RestApiGwThrottlingBurst }}",
          "ValidateQuotaLimits": false
        },
        "Script": "import json\nimport logging\nimport time\nfrom random import uniform\nfrom typing import Any, Callable\n\nimport boto3\nfrom botocore.config import Config\nfrom botocore.exceptions import ClientError\n\nlog = logging.getLogger()\nlog.setLevel(logging.INFO)\n\n\n\ndef assert_https_status_code_200(response: dict, error_message: str) -> None:\n    if response['ResponseMetadata']['HTTPStatusCode'] != 200:\n        raise ValueError(f'{error_message} Response is: {response}')\n\n\n\ndef execute_boto3_with_backoff(delegate: Callable[[Any], dict], **kwargs) -> dict:\n    \"\"\"\n    Executes the given delegate with apigateway client parameter, handles TooManyRequestsException using\n    exponential backoff algorithm with random jitter\n    :param delegate: The delegate to execute (with boto3 function)\n    :keyword args:\n        retries: Number of maximum backoff retries\n        max_interval: Maximum backoff interval in seconds\n        base_time: Backoff base time\n    :return: The output of the given function\n    \"\"\"\n    backoff_retries: int = kwargs.get('retries', 15)\n    backoff_max_interval: int = kwargs.get('max_interval', 64)\n    backoff_base_time: int = kwargs.get('base_time', 2)\n    apigw_client = boto3.client('apigateway')\n\n    count = 1\n    while count <= backoff_retries:\n        try:\n            log.debug(f'Making an API call, attempt: {count} ...')\n            response = delegate(apigw_client)\n            assert_https_status_code_200(response, 'Failed to perform API call')\n            log.debug('API call performed successfully.')\n            return response\n        except ClientError as error:\n            if error.response['Error']['Code'] == 'TooManyRequestsException':\n                interval: float = min(backoff_base_time * 2 ** count + round(uniform(-2, 2), 2), backoff_max_interval)\n                log.warning(f'TooManyRequestsException, slow it down with delay {interval} seconds ...')\n                time.sleep(interval)\n                count += 1\n            else:\n                log.error(error)\n                raise error\n\n    raise Exception(f'Failed to perform API call successfully for {count - 1} times.')\n\n\n\ndef get_service_quota(config: object, service_code: str, quota_code: str) -> dict:\n    client = boto3.client('service-quotas', config=config)\n    response = client.get_service_quota(ServiceCode=service_code, QuotaCode=quota_code)\n    assert_https_status_code_200(response, f'Failed to perform get_service_quota with '\n                                           f'ServiceCode: {service_code} and QuotaCode: {quota_code}')\n    return response\n\n\n\ndef update_usage_plan(usage_plan_id: str, patch_operations: list, retries: int = 15) -> dict:\n    return execute_boto3_with_backoff(\n        delegate=lambda x: x.update_usage_plan(\n            usagePlanId=usage_plan_id,\n            patchOperations=patch_operations\n        ),\n        retries=retries\n    )\n\n\n\ndef wait_throttling_config_updated(events: dict, context: dict) -> None:\n    expected_rate_limit: int = int(events['RestApiGwThrottlingRate'])\n    expected_burst_limit: int = int(events['RestApiGwThrottlingBurst'])\n    max_retries: int = events.get('MaxRetries', 40)\n    timeout: int = events.get('Timeout', 15)\n    while max_retries > 0:\n        actual_throttling_config = get_throttling_config(events, None)\n        actual_rate_limit = actual_throttling_config['RateLimit']\n        actual_burst_limit = actual_throttling_config['BurstLimit']\n        if actual_rate_limit == expected_rate_limit and actual_burst_limit == expected_burst_limit:\n            return\n        log.info(f'Waiting for expected values: [RateLimit: {expected_rate_limit}, BurstLimit: {expected_burst_limit}],'\n                 f' actual values: [RateLimit: {actual_rate_limit}, BurstLimit: {actual_burst_limit}]')\n        max_retries -= 1\n        time.sleep(timeout)\n\n    raise TimeoutError('Error to wait for throttling config update. Maximum timeout exceeded!')\n\n\n\ndef get_throttling_config(events: dict, context: dict) -> dict:\n    if 'RestApiGwUsagePlanId' not in events:\n        raise KeyError('Requires RestApiGwUsagePlanId in events')\n\n    if 'RestApiGwStageName' in events and events['RestApiGwStageName']:\n        if 'RestApiGwId' not in events:\n            raise KeyError('Requires RestApiGwId in events')\n        if not events['RestApiGwId']:\n            raise KeyError('RestApiGwId should not be empty')\n\n    usage_plan_id: str = events['RestApiGwUsagePlanId']\n    gateway_id: str = events.get('RestApiGwId')\n    stage_name: str = events.get('RestApiGwStageName')\n    resource_path: str = events.get('RestApiGwResourcePath', '*')\n    http_method: str = events.get('RestApiGwHttpMethod', '*')\n\n    # Need to have it here for rollback case to overcame issue DIG-853 with get_inputs_from_ssm_execution\n    if (stage_name and stage_name.startswith('{{')) and (gateway_id and gateway_id.startswith('{{')):\n        gateway_id = stage_name = None\n    resource_path = '*' if resource_path.startswith('{{') else resource_path\n    http_method = '*' if http_method.startswith('{{') else http_method\n\n    config: object = Config(retries={'max_attempts': 20, 'mode': 'standard'})\n    client = boto3.client('apigateway', config=config)\n    usage_plan = client.get_usage_plan(usagePlanId=usage_plan_id)\n    assert_https_status_code_200(usage_plan, f'Failed to get usage plan with id {usage_plan_id}')\n\n    if stage_name:\n        stage_found = False\n        for stage in usage_plan['apiStages']:\n            if stage['apiId'] == gateway_id and stage['stage'] == stage_name:\n                stage_found = True\n                if 'throttle' in stage and f'{resource_path}/{http_method}' in stage['throttle']:\n                    rate_limit: float = stage['throttle'][f'{resource_path}/{http_method}']['rateLimit']\n                    burst_limit: int = stage['throttle'][f'{resource_path}/{http_method}']['burstLimit']\n                else:\n                    rate_limit: float = usage_plan['throttle']['rateLimit']\n                    burst_limit: int = usage_plan['throttle']['burstLimit']\n        if not stage_found:\n            raise KeyError(f'Stage name {stage_name} not found in get_usage_plan response: {usage_plan}')\n    else:\n        rate_limit: float = usage_plan['throttle']['rateLimit']\n        burst_limit: int = usage_plan['throttle']['burstLimit']\n\n    return {'RateLimit': int(rate_limit),\n            'BurstLimit': burst_limit,\n            'QuotaLimit': usage_plan['quota']['limit'],\n            'QuotaPeriod': usage_plan['quota']['period']}\n\n\n\ndef set_throttling_config(events: dict, context: dict) -> dict:\n    if 'RestApiGwUsagePlanId' not in events:\n        raise KeyError('Requires RestApiGwUsagePlanId in events')\n\n    if 'RestApiGwThrottlingRate' not in events:\n        raise KeyError('Requires RestApiGwThrottlingRate in events')\n\n    if 'RestApiGwThrottlingBurst' not in events:\n        raise KeyError('Requires RestApiGwThrottlingBurst in events')\n\n    if 'RestApiGwStageName' in events and events['RestApiGwStageName']:\n        if 'RestApiGwId' not in events:\n            raise KeyError('Requires RestApiGwId in events')\n        if not events['RestApiGwId']:\n            raise KeyError('RestApiGwId should not be empty')\n\n    usage_plan_id: str = events['RestApiGwUsagePlanId']\n    new_rate_limit: float = float(events['RestApiGwThrottlingRate'])\n    new_burst_limit: int = int(events['RestApiGwThrottlingBurst'])\n    gateway_id: str = events.get('RestApiGwId')\n    stage_name: str = events.get('RestApiGwStageName')\n    resource_path: str = events.get('RestApiGwResourcePath', '*')\n    http_method: str = events.get('RestApiGwHttpMethod', '*')\n    validate_quota_limits: bool = events.get('ValidateQuotaLimits', True)\n\n    output: dict = {}\n    quota_rate_limit_code: str = 'L-8A5B8E43'\n    quota_burst_limit_code: str = 'L-CDF5615A'\n    patch_operations: list = [\n        {\n            'op': 'replace',\n            'path': '/throttle/rateLimit',\n            'value': str(new_rate_limit)\n        },\n        {\n            'op': 'replace',\n            'path': '/throttle/burstLimit',\n            'value': str(new_burst_limit)\n        }\n    ]\n\n    # Need to have it here for rollback case to overcame issue DIG-853 with get_inputs_from_ssm_execution\n    if (stage_name and stage_name.startswith('{{')) and (gateway_id and gateway_id.startswith('{{')):\n        gateway_id = stage_name = None\n    resource_path = '*' if resource_path.startswith('{{') else resource_path\n    http_method = '*' if http_method.startswith('{{') else http_method\n\n    boto3_config: object = Config(retries={'max_attempts': 20, 'mode': 'standard'})\n\n    if validate_quota_limits:\n        quota_rate_limit: float = get_service_quota(\n            boto3_config, 'apigateway', quota_rate_limit_code)['Quota']['Value']\n        quota_burst_limit: float = get_service_quota(\n            boto3_config, 'apigateway', quota_burst_limit_code)['Quota']['Value']\n\n        if new_rate_limit > quota_rate_limit:\n            raise ValueError(f'Given value of RestApiGwThrottlingRate: {new_rate_limit}, can not be more than '\n                             f'service quota Throttle rate: {quota_rate_limit}')\n\n        if new_burst_limit > quota_burst_limit:\n            raise ValueError(f'Given value of RestApiGwThrottlingBurst: {new_burst_limit}, can not be more than '\n                             f'service quota Throttle burst rate: {quota_burst_limit}')\n    if stage_name:\n        path: str = f'/apiStages/{gateway_id}:{stage_name}/throttle/{resource_path}/{http_method}'\n        patch_operations[0]['path'], patch_operations[1]['path'] = f'{path}/rateLimit', f'{path}/burstLimit'\n        updated_usage_plan = update_usage_plan(usage_plan_id, patch_operations)\n\n        for stage in updated_usage_plan['apiStages']:\n            if stage['apiId'] == gateway_id and stage['stage'] == stage_name:\n                output['RateLimit'] = stage['throttle'][f'{resource_path}/{http_method}']['rateLimit']\n                output['BurstLimit'] = stage['throttle'][f'{resource_path}/{http_method}']['burstLimit']\n    else:\n        updated_usage_plan = update_usage_plan(usage_plan_id, patch_operations)\n        output['RateLimit'] = updated_usage_plan['throttle']['rateLimit']\n        output['BurstLimit'] = updated_usage_plan['throttle']['burstLimit']\n\n    output['RateLimit'] = int(output['RateLimit'])\n    wait_throttling_config_updated(events, None)\n\n    return output"
      }
    },
    {
      "name": "AssertAlarmToBeRed",
      "description": "Wait for expected alarm to be red after failure is injected",
      "action": "aws:waitForAwsResourceProperty",
      "maxAttempts": 1,
      "timeoutSeconds": 1200,
      "onFailure": "step:RollbackCurrentExecution",
      "onCancel": "step:TriggerRollback",
      "inputs": {
        "Service": "cloudwatch",
        "Api": "DescribeAlarms",
        "AlarmNames": [
          "{{ApiGw4xxAlarmName}}"
        ],
        "PropertySelector": "$.MetricAlarms[0].StateValue",
        "DesiredValues": [
          "ALARM"
        ]
      }
    },
    {
      "name": "RollbackCurrentExecution",
      "description": "Restore original throttling configuratiuon for the REST API Gateway",
      "maxAttempts": 5,
      "onCancel": "step:TriggerRollback",
      "action": "aws:executeScript",
      "outputs": [
        {
          "Name": "RestApiGwThrottlingRateRestoredValue",
          "Selector": "$.Payload.RateLimit",
          "Type": "Integer"
        },
        {
          "Name": "RestApiGwThrottlingBurstRestoredValue",
          "Selector": "$.Payload.BurstLimit",
          "Type": "Integer"
        }
      ],
      "inputs": {
        "Runtime": "python3.7",
        "Handler": "set_throttling_config",
        "InputPayload": {
          "RestApiGwUsagePlanId": "{{ RestApiGwUsagePlanId }}",
          "RestApiGwId": "{{ RestApiGwId }}",
          "RestApiGwStageName": "{{ RestApiGwStageName }}",
          "RestApiGwResourcePath": "{{ RestApiGwResourcePath }}",
          "RestApiGwHttpMethod": "{{ RestApiGwHttpMethod }}",
          "RestApiGwThrottlingRate": "{{ BackupThrottlingConfiguration.RestApiGwThrottlingRateOriginalValue }}",
          "RestApiGwThrottlingBurst": "{{ BackupThrottlingConfiguration.RestApiGwThrottlingBurstOriginalValue }}",
          "ValidateQuotaLimits": false
        },
        "Script": "import json\nimport logging\nimport time\nfrom random import uniform\nfrom typing import Any, Callable\n\nimport boto3\nfrom botocore.config import Config\nfrom botocore.exceptions import ClientError\n\nlog = logging.getLogger()\nlog.setLevel(logging.INFO)\n\n\n\ndef assert_https_status_code_200(response: dict, error_message: str) -> None:\n    if response['ResponseMetadata']['HTTPStatusCode'] != 200:\n        raise ValueError(f'{error_message} Response is: {response}')\n\n\n\ndef execute_boto3_with_backoff(delegate: Callable[[Any], dict], **kwargs) -> dict:\n    \"\"\"\n    Executes the given delegate with apigateway client parameter, handles TooManyRequestsException using\n    exponential backoff algorithm with random jitter\n    :param delegate: The delegate to execute (with boto3 function)\n    :keyword args:\n        retries: Number of maximum backoff retries\n        max_interval: Maximum backoff interval in seconds\n        base_time: Backoff base time\n    :return: The output of the given function\n    \"\"\"\n    backoff_retries: int = kwargs.get('retries', 15)\n    backoff_max_interval: int = kwargs.get('max_interval', 64)\n    backoff_base_time: int = kwargs.get('base_time', 2)\n    apigw_client = boto3.client('apigateway')\n\n    count = 1\n    while count <= backoff_retries:\n        try:\n            log.debug(f'Making an API call, attempt: {count} ...')\n            response = delegate(apigw_client)\n            assert_https_status_code_200(response, 'Failed to perform API call')\n            log.debug('API call performed successfully.')\n            return response\n        except ClientError as error:\n            if error.response['Error']['Code'] == 'TooManyRequestsException':\n                interval: float = min(backoff_base_time * 2 ** count + round(uniform(-2, 2), 2), backoff_max_interval)\n                log.warning(f'TooManyRequestsException, slow it down with delay {interval} seconds ...')\n                time.sleep(interval)\n                count += 1\n            else:\n                log.error(error)\n                raise error\n\n    raise Exception(f'Failed to perform API call successfully for {count - 1} times.')\n\n\n\ndef get_service_quota(config: object, service_code: str, quota_code: str) -> dict:\n    client = boto3.client('service-quotas', config=config)\n    response = client.get_service_quota(ServiceCode=service_code, QuotaCode=quota_code)\n    assert_https_status_code_200(response, f'Failed to perform get_service_quota with '\n                                           f'ServiceCode: {service_code} and QuotaCode: {quota_code}')\n    return response\n\n\n\ndef update_usage_plan(usage_plan_id: str, patch_operations: list, retries: int = 15) -> dict:\n    return execute_boto3_with_backoff(\n        delegate=lambda x: x.update_usage_plan(\n            usagePlanId=usage_plan_id,\n            patchOperations=patch_operations\n        ),\n        retries=retries\n    )\n\n\n\ndef wait_throttling_config_updated(events: dict, context: dict) -> None:\n    expected_rate_limit: int = int(events['RestApiGwThrottlingRate'])\n    expected_burst_limit: int = int(events['RestApiGwThrottlingBurst'])\n    max_retries: int = events.get('MaxRetries', 40)\n    timeout: int = events.get('Timeout', 15)\n    while max_retries > 0:\n        actual_throttling_config = get_throttling_config(events, None)\n        actual_rate_limit = actual_throttling_config['RateLimit']\n        actual_burst_limit = actual_throttling_config['BurstLimit']\n        if actual_rate_limit == expected_rate_limit and actual_burst_limit == expected_burst_limit:\n            return\n        log.info(f'Waiting for expected values: [RateLimit: {expected_rate_limit}, BurstLimit: {expected_burst_limit}],'\n                 f' actual values: [RateLimit: {actual_rate_limit}, BurstLimit: {actual_burst_limit}]')\n        max_retries -= 1\n        time.sleep(timeout)\n\n    raise TimeoutError('Error to wait for throttling config update. Maximum timeout exceeded!')\n\n\n\ndef get_throttling_config(events: dict, context: dict) -> dict:\n    if 'RestApiGwUsagePlanId' not in events:\n        raise KeyError('Requires RestApiGwUsagePlanId in events')\n\n    if 'RestApiGwStageName' in events and events['RestApiGwStageName']:\n        if 'RestApiGwId' not in events:\n            raise KeyError('Requires RestApiGwId in events')\n        if not events['RestApiGwId']:\n            raise KeyError('RestApiGwId should not be empty')\n\n    usage_plan_id: str = events['RestApiGwUsagePlanId']\n    gateway_id: str = events.get('RestApiGwId')\n    stage_name: str = events.get('RestApiGwStageName')\n    resource_path: str = events.get('RestApiGwResourcePath', '*')\n    http_method: str = events.get('RestApiGwHttpMethod', '*')\n\n    # Need to have it here for rollback case to overcame issue DIG-853 with get_inputs_from_ssm_execution\n    if (stage_name and stage_name.startswith('{{')) and (gateway_id and gateway_id.startswith('{{')):\n        gateway_id = stage_name = None\n    resource_path = '*' if resource_path.startswith('{{') else resource_path\n    http_method = '*' if http_method.startswith('{{') else http_method\n\n    config: object = Config(retries={'max_attempts': 20, 'mode': 'standard'})\n    client = boto3.client('apigateway', config=config)\n    usage_plan = client.get_usage_plan(usagePlanId=usage_plan_id)\n    assert_https_status_code_200(usage_plan, f'Failed to get usage plan with id {usage_plan_id}')\n\n    if stage_name:\n        stage_found = False\n        for stage in usage_plan['apiStages']:\n            if stage['apiId'] == gateway_id and stage['stage'] == stage_name:\n                stage_found = True\n                if 'throttle' in stage and f'{resource_path}/{http_method}' in stage['throttle']:\n                    rate_limit: float = stage['throttle'][f'{resource_path}/{http_method}']['rateLimit']\n                    burst_limit: int = stage['throttle'][f'{resource_path}/{http_method}']['burstLimit']\n                else:\n                    rate_limit: float = usage_plan['throttle']['rateLimit']\n                    burst_limit: int = usage_plan['throttle']['burstLimit']\n        if not stage_found:\n            raise KeyError(f'Stage name {stage_name} not found in get_usage_plan response: {usage_plan}')\n    else:\n        rate_limit: float = usage_plan['throttle']['rateLimit']\n        burst_limit: int = usage_plan['throttle']['burstLimit']\n\n    return {'RateLimit': int(rate_limit),\n            'BurstLimit': burst_limit,\n            'QuotaLimit': usage_plan['quota']['limit'],\n            'QuotaPeriod': usage_plan['quota']['period']}\n\n\n\ndef set_throttling_config(events: dict, context: dict) -> dict:\n    if 'RestApiGwUsagePlanId' not in events:\n        raise KeyError('Requires RestApiGwUsagePlanId in events')\n\n    if 'RestApiGwThrottlingRate' not in events:\n        raise KeyError('Requires RestApiGwThrottlingRate in events')\n\n    if 'RestApiGwThrottlingBurst' not in events:\n        raise KeyError('Requires RestApiGwThrottlingBurst in events')\n\n    if 'RestApiGwStageName' in events and events['RestApiGwStageName']:\n        if 'RestApiGwId' not in events:\n            raise KeyError('Requires RestApiGwId in events')\n        if not events['RestApiGwId']:\n            raise KeyError('RestApiGwId should not be empty')\n\n    usage_plan_id: str = events['RestApiGwUsagePlanId']\n    new_rate_limit: float = float(events['RestApiGwThrottlingRate'])\n    new_burst_limit: int = int(events['RestApiGwThrottlingBurst'])\n    gateway_id: str = events.get('RestApiGwId')\n    stage_name: str = events.get('RestApiGwStageName')\n    resource_path: str = events.get('RestApiGwResourcePath', '*')\n    http_method: str = events.get('RestApiGwHttpMethod', '*')\n    validate_quota_limits: bool = events.get('ValidateQuotaLimits', True)\n\n    output: dict = {}\n    quota_rate_limit_code: str = 'L-8A5B8E43'\n    quota_burst_limit_code: str = 'L-CDF5615A'\n    patch_operations: list = [\n        {\n            'op': 'replace',\n            'path': '/throttle/rateLimit',\n            'value': str(new_rate_limit)\n        },\n        {\n            'op': 'replace',\n            'path': '/throttle/burstLimit',\n            'value': str(new_burst_limit)\n        }\n    ]\n\n    # Need to have it here for rollback case to overcame issue DIG-853 with get_inputs_from_ssm_execution\n    if (stage_name and stage_name.startswith('{{')) and (gateway_id and gateway_id.startswith('{{')):\n        gateway_id = stage_name = None\n    resource_path = '*' if resource_path.startswith('{{') else resource_path\n    http_method = '*' if http_method.startswith('{{') else http_method\n\n    boto3_config: object = Config(retries={'max_attempts': 20, 'mode': 'standard'})\n\n    if validate_quota_limits:\n        quota_rate_limit: float = get_service_quota(\n            boto3_config, 'apigateway', quota_rate_limit_code)['Quota']['Value']\n        quota_burst_limit: float = get_service_quota(\n            boto3_config, 'apigateway', quota_burst_limit_code)['Quota']['Value']\n\n        if new_rate_limit > quota_rate_limit:\n            raise ValueError(f'Given value of RestApiGwThrottlingRate: {new_rate_limit}, can not be more than '\n                             f'service quota Throttle rate: {quota_rate_limit}')\n\n        if new_burst_limit > quota_burst_limit:\n            raise ValueError(f'Given value of RestApiGwThrottlingBurst: {new_burst_limit}, can not be more than '\n                             f'service quota Throttle burst rate: {quota_burst_limit}')\n    if stage_name:\n        path: str = f'/apiStages/{gateway_id}:{stage_name}/throttle/{resource_path}/{http_method}'\n        patch_operations[0]['path'], patch_operations[1]['path'] = f'{path}/rateLimit', f'{path}/burstLimit'\n        updated_usage_plan = update_usage_plan(usage_plan_id, patch_operations)\n\n        for stage in updated_usage_plan['apiStages']:\n            if stage['apiId'] == gateway_id and stage['stage'] == stage_name:\n                output['RateLimit'] = stage['throttle'][f'{resource_path}/{http_method}']['rateLimit']\n                output['BurstLimit'] = stage['throttle'][f'{resource_path}/{http_method}']['burstLimit']\n    else:\n        updated_usage_plan = update_usage_plan(usage_plan_id, patch_operations)\n        output['RateLimit'] = updated_usage_plan['throttle']['rateLimit']\n        output['BurstLimit'] = updated_usage_plan['throttle']['burstLimit']\n\n    output['RateLimit'] = int(output['RateLimit'])\n    wait_throttling_config_updated(events, None)\n\n    return output"
      }
    },
    {
      "name": "AssertAlarmToBeGreen",
      "description": "Wait for the alarm to be green after test is complete",
      "action": "aws:waitForAwsResourceProperty",
      "maxAttempts": 1,
      "timeoutSeconds": 1200,
      "inputs": {
        "Service": "cloudwatch",
        "Api": "DescribeAlarms",
        "AlarmNames": [
          "{{ApiGw4xxAlarmName}}"
        ],
        "PropertySelector": "$.MetricAlarms[0].StateValue",
        "DesiredValues": [
          "OK"
        ]
      },
      "isEnd": true
    },
    {
      "name": "TriggerRollback",
      "description": "This step is executed when ssm document is cancelled while it was in progress. This step starts a new execution of document in rollback mode to rollback the changes made as part of normal execution",
      "action": "aws:executeScript",
      "onFailure": "Abort",
      "outputs": [
        {
          "Name": "RollbackExecutionId",
          "Selector": "$.Payload.RollbackExecutionId",
          "Type": "String"
        }
      ],
      "inputs": {
        "Runtime": "python3.7",
        "Handler": "start_rollback_execution",
        "InputPayload": {
          "ExecutionId": "{{automation:EXECUTION_ID}}"
        },
        "Script": "import json\nimport boto3\nfrom botocore.config import Config\n\n\n\n\ndef start_rollback_execution(events, context):\n    output = {}\n    config = Config(retries={'max_attempts': 20, 'mode': 'standard'})\n    ssm = boto3.client('ssm', config=config)\n\n    if 'ExecutionId' not in events or not events['ExecutionId']:\n        raise KeyError('Requires not empty ExecutionId')\n\n    response = ssm.get_automation_execution(AutomationExecutionId=events['ExecutionId'])\n\n    # Get parameters for current execution and add IsRollback and PreviousExecutionId\n    response_parameters = response['AutomationExecution']['Parameters']\n    response_parameters['IsRollback'] = ['true']\n    response_parameters['PreviousExecutionId'] = [events['ExecutionId']]\n\n    rollback_execution_response = ssm.start_automation_execution(\n        DocumentName=response['AutomationExecution']['DocumentName'],\n        DocumentVersion=response['AutomationExecution']['DocumentVersion'],\n        Parameters=response_parameters\n    )\n    output['RollbackExecutionId'] = rollback_execution_response['AutomationExecutionId']\n    return output"
      },
      "isEnd": true
    }
  ]
}
