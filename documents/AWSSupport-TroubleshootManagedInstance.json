{
  "description": "The **AWSSupport-TroubleshootManagedInstance** runbook helps you to determine why an Amazon Elastic Compute Cloud (Amazon EC2) instance does not report as managed by AWS Systems Manager. This runbook reviews the Amazon Virtual Private Cloud (Amazon VPC) configuration for the instance including security group rules, VPC endpoints, network access control list (ACL) rules, and route tables. It also confirms that an AWS Identity and Access Management (IAM) instance profile that contains the required permissions is attached to the instance.",
  "schemaVersion": "0.3",
  "outputs": [
    "FinalOutput.output",
    "InstanceisOnline.output"
  ],
  "assumeRole": "{{ AutomationAssumeRole }}",
  "parameters": {
    "InstanceId": {
      "type": "AWS::EC2::Instance::Id",
      "description": "(Required) The ID of the Amazon EC2 instance."
    },
    "AutomationAssumeRole": {
      "type": "AWS::IAM::Role::Arn",
      "description": "(Optional) The Amazon Resource Name (ARN) of the AWS Identity and Access Management (IAM) role that allows Systems Manager Automation to perform the actions on your behalf. If no role is specified, Systems Manager Automation uses the permissions of the user that starts this runbook.",
      "default": ""
    }
  },
  "mainSteps": [
    {
      "name": "GetPingStatus",
      "description": "Gathers the connection status of SSM Agent.",
      "action": "aws:executeAwsApi",
      "onFailure": "Abort",
      "nextStep": "IsInstanceAlreadyOnline",
      "inputs": {
        "Service": "ssm",
        "Api": "DescribeInstanceInformation",
        "Filters": [
          {
            "Key": "InstanceIds",
            "Values": [
              "{{ InstanceId }}"
            ]
          }
        ]
      },
      "outputs": [
        {
          "Name": "pingstatus",
          "Selector": "$.InstanceInformationList[0].PingStatus",
          "Type": "String"
        }
      ]
    },
    {
      "name": "IsInstanceAlreadyOnline",
      "description": "Branches based on whether the instance is already reporting as managed by Systems Manager.",
      "action": "aws:branch",
      "onFailure": "Abort",
      "isCritical": "true",
      "inputs": {
        "Choices": [
          {
            "NextStep": "GetEC2InstanceProperties",
            "Not": {
              "Variable": "{{ GetPingStatus.pingstatus }}",
              "StringEquals": "Online"
            }
          }
        ],
        "Default": "InstanceisOnline"
      }
    },
    {
      "name": "GetEC2InstanceProperties",
      "description": "Gathers details about the instance including the VPC configuration.",
      "action": "aws:executeAwsApi",
      "maxAttempts": 2,
      "onFailure": "Abort",
      "inputs": {
        "Service": "ec2",
        "Api": "DescribeInstances",
        "InstanceIds": [
          "{{ InstanceId }}"
        ]
      },
      "outputs": [
        {
          "Name": "SecurityGroupIds",
          "Selector": "$.Reservations[0].Instances[0].SecurityGroups..GroupId",
          "Type": "StringList"
        },
        {
          "Name": "SubnetId",
          "Selector": "$.Reservations[0].Instances[0].SubnetId",
          "Type": "String"
        },
        {
          "Name": "VpcId",
          "Selector": "$.Reservations[0].Instances[0].VpcId",
          "Type": "String"
        },
        {
          "Name": "PrivateIpAddress",
          "Selector": "$.Reservations[0].Instances[0].NetworkInterfaces[0].PrivateIpAddresses[0].PrivateIpAddress",
          "Type": "String"
        },
        {
          "Name": "InstanceProfile",
          "Selector": "$.Reservations[0].Instances[0].IamInstanceProfile.Arn",
          "Type": "String"
        },
        {
          "Name": "platform",
          "Selector": "$.Reservations[0].Instances[0].Platform",
          "Type": "String"
        }
      ],
      "nextStep": "CheckVpcEndpoint"
    },
    {
      "name": "CheckVpcEndpoint",
      "description": "If applicable, gathers additional details related to VPC endpoints that have been deployed to use with Systems Manager, and confirms the security groups attached to the VPC endpoint allow inbound traffic on TCP port 443 from the instance.",
      "action": "aws:executeScript",
      "onFailure": "Abort",
      "nextStep": "CheckRouteTable",
      "inputs": {
        "Runtime": "python3.8",
        "Handler": "script_handler",
        "InputPayload": {
          "GetInstance": "{{InstanceId}}",
          "InstanceSGList": "{{GetEC2InstanceProperties.SecurityGroupIds}}",
          "EC2InstanceIPs": "{{ GetEC2InstanceProperties.PrivateIpAddress }}",
          "EC2InstanceSubnet": "{{ GetEC2InstanceProperties.SubnetId }}",
          "EC2VPC": "{{ GetEC2InstanceProperties.VpcId}}"
        },
        "Script": "# Copyright 2023 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n# SPDX-License-Identifier: LicenseRef-.amazon.com.-AmznSL-1.0\n# Licensed under the Amazon Software License  http://aws.amazon.com/asl/\n\ndef script_handler(events, context):\n    import boto3\n    import ipaddress\n    from ipaddress import ip_network\n    from botocore.exceptions import ClientError\n    \n    #Getting current region\n    current_session = boto3.session.Session()\n    current_region = current_session.region_name\n    ssm_url = 'com.amazonaws.' + current_region + '.ssm'\n    \n    #Getting Instance Information#\n    Instance = events['GetInstance']\n    instance_security_groups = events['InstanceSGList']\n    subnetdetails = events['EC2InstanceSubnet']\n    instance_priv_ip = events['EC2InstanceIPs']\n    VPCdetails = events['EC2VPC']\n\n    https_port = 443\n    Results = \"\"\n    AWS_SG_DOC = '\\n For reference please see: Working with security groups - https://docs.aws.amazon.com/vpc/latest/userguide/VPC_SecurityGroups.html#WorkingWithSecurityGroups\\n\\n'\n    AWS_VPCE_DOC = '\\n For reference please see: Modifying an interface endpoint -  https://docs.aws.amazon.com/vpc/latest/userguide/vpce-interface.html#create-interface-endpoint\\n\\n'\n\n    \n    vpce_security_groups = []\n    ec2 = boto3.client('ec2')\n    try:\n       results = ec2.describe_vpc_endpoints(Filters=[{'Name':'service-name','Values':[ssm_url]},{'Name':'vpc-id','Values':[VPCdetails]}])\n       if not results['VpcEndpoints']:\n        return {'output': '1. Checking for VPC Endpoints for SSM: \\n\\n' + ' No VPC endpoints for Systems Manager found for the same VPC as of the EC2 instance: ' + VPCdetails + '. Instance can still connect to Systems Manager Endoints if correct routes and NACL rules are configured to reach the Systems Manager endpoints.\\n\\n', 'vpceid': \"Absent\" }\n       else:\n        print('\\nVPC endpoint exist for the Systems Manager service. Checking details of the VPC endpoint.')\n        for items in results['VpcEndpoints']:\n         vpce_id = items['VpcEndpointId']\n         vpce_subnet = items['SubnetIds']\n         vpce_priv_dns = items['PrivateDnsEnabled']\n         allsg = items['Groups']\n         for vpcesg in allsg:\n          VpceSecurityGroupsdetails = vpcesg['GroupId']\n          vpce_security_groups.append(VpceSecurityGroupsdetails)\n    except ClientError as e:\n        raise Exception (f\"[ERROR] Failed to describe VPC endpoints for {VPCdetails} {str(e)}\")\n        \n    list_vpce_security_groups = ','.join(vpce_security_groups)\n    list_vpce_subnet = ','.join(vpce_subnet)\n    \n    \n    Heading = '1. Checking for VPC Endpoints: \\n\\n'\n    Found = ' VPC endpoint for Systems Manager Found: ' + vpce_id\n    vpcesubnets = '\\n  a. Subnets configured for the VPC endpoint found:' + list_vpce_subnet\n    vpcedns = '\\n  b. PrivateDNS is set as True or False? Answer: ' + str(vpce_priv_dns) + '. (Recommended to set as True.)'\n    vpcesg = '\\n  c. Security group attached to the VPC endpoints ' + list_vpce_security_groups\n    \n    if subnetdetails in vpce_subnet:\n        print('Subnet configured for VPC endpoint matches that of the instance. Systems Manager agent on the instance will communicate to Systems Manager endpoints via VPC endpoints network interfaces. Ensure PrivateDNS parameter is enabled.\\n')\n        print('Checking the security group rules attached to the VPC endpoint\\n')\n        print('...Results...')\n        for vpc_security_group in vpce_security_groups:\n            try:\n               response = ec2.describe_security_groups(GroupIds=[vpc_security_group])\n               for sg in response['SecurityGroups']:\n                   for rule in sg['IpPermissions']:\n                       if ((rule.get('IpProtocol') == '-1') or (rule.get('FromPort') == -1 and rule.get('ToPort') == -1) or (https_port in range(rule.get('FromPort'), rule.get('ToPort') +1))):\n                           for cidr in rule['IpRanges']:\n                               if ipaddress.ip_address(instance_priv_ip) in ip_network(cidr['CidrIp'], strict=False):\n                                   Results = '\\n\\n PASSED: VPC endpoint for Systems Manager Exist: ' + vpce_id + ' . Ingress rules on Security groups of VPC endpoints allow traffic on port 443 from the Instance IP.\\n\\n'                            \n                                   print(Results)\n                                   finalresults = Heading + Found + vpcesubnets + vpcedns + vpcesg +  Results\n                                   return {'output': finalresults, 'vpceid': \"Present\" }\n                           for group in rule['UserIdGroupPairs']:\n                               if any(sg in group['GroupId'] for sg in instance_security_groups):\n                                   Results = '\\n\\n PASSED: VPC endpoint for Systems Manager Exist: ' + vpce_id + ' . Ingress rules on Security groups of VPC endpoints allow traffic on port 443 from the Instances Security group.\\n\\n'\n                                   print(Results)\n                                   finalresults = Heading + Found + vpcesubnets + vpcedns + vpcesg +  Results\n                                   return {'output': finalresults, 'vpceid': \"Present\" }\n            except ClientError as e:\n               raise Exception (f\"[ERROR] Failed to describe security group {vpc_security_group} {str(e)}\")\n        if not Results.strip():\n            FailedResults = '\\n\\n FAILED: VPC Endpoints for Systems Manager exist, ' + vpce_id + ' but Ingress rules on Security groups of VPC endpoints do not allow traffic on port 443 from the Instance.' + AWS_SG_DOC\n            print(FailedResults)\n            finalresultsfailed = Heading + Found + vpcesubnets + vpcedns + vpcesg +  FailedResults\n            return{'output': finalresultsfailed, 'vpceid': \"Present\"}\n    else:\n       print('...Results...')\n       FailedSubnetResults = '\\n\\n Warning : VPC endpoint for Systems Manager exist, ' + vpce_id + ' but subnets associated with the VPC Endpoint does not include the subnet of instance. This can still work if the NACL rules are correct to allow traffic between the subnets on port 443. Or alternatively, you can add the Instance subnet ' + subnetdetails + ' to the VPC endpoint.' + AWS_VPCE_DOC\n       print(FailedSubnetResults)\n       finalresultssubnet = Heading + Found + vpcesubnets + vpcedns + vpcesg +  FailedSubnetResults\n       return {'output': finalresultssubnet, 'vpceid': \"Absent\" }\n"
      },
      "outputs": [
        {
          "Name": "output",
          "Selector": "$.Payload.output",
          "Type": "String"
        },
        {
          "Name": "vpceid",
          "Selector": "$.Payload.vpceid",
          "Type": "String"
        }
      ]
    },
    {
      "name": "CheckRouteTable",
      "description": "Checks whether the route table allows traffic to the VPC endpoint or public Systems Manager endpoints.",
      "action": "aws:executeScript",
      "onFailure": "Abort",
      "nextStep": "CheckNacl",
      "inputs": {
        "Runtime": "python3.8",
        "Handler": "script_handler",
        "InputPayload": {
          "GetInstance": "{{InstanceId}}",
          "EC2InstanceSubnet": "{{ GetEC2InstanceProperties.SubnetId }}",
          "EC2VPC": "{{ GetEC2InstanceProperties.VpcId}}"
        },
        "Script": "# Copyright 2023 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n# SPDX-License-Identifier: LicenseRef-.amazon.com.-AmznSL-1.0\n# Licensed under the Amazon Software License  http://aws.amazon.com/asl/\n\ndef script_handler(events, context):\n   import boto3\n   from botocore.exceptions import ClientError\n   \n   #Getting Instance Information#\n   Instance = events['GetInstance']\n   subnetdetails = events['EC2InstanceSubnet']\n   vpc_id = events['EC2VPC']\n\n   def get_publicIP(instanceid):\n      try:\n         ec2 = boto3.client('ec2')\n         publicIP = 'None'\n         result = ec2.describe_instances(InstanceIds=[instanceid])\n         instance = result['Reservations'][0][\"Instances\"][0]\n         publicIP = instance.get(\"PublicIpAddress\", \"None\")\n         return publicIP\n      except ClientError as e:\n         raise Exception (f\"[ERROR] Failed to describe instance {instanceid} {str(e)}\")\n\n   ## Starts here:\n   ec2 = boto3.client('ec2')\n   try:\n      result = ec2.describe_route_tables(Filters=[{'Name':'association.subnet-id','Values':[subnetdetails]}])\n      if not result['RouteTables']:\n        result = ec2.describe_route_tables(Filters=[{'Name':'association.main','Values':[\"true\"]}, {'Name':'vpc-id','Values':[vpc_id]} ])\n   except ClientError as e:\n      raise Exception (f\"[ERROR] Failed to describe subnet {subnetdetails} route tables {str(e)}\")     \n\n   internet_route_list = []\n   cidr_for_local_list = []\n\n   for items in result['RouteTables']:\n    route_table_id = items['RouteTableId']\n    print('Route table found: ' + route_table_id)\n    AllRouteRules_list = items['Routes']\n\n    for routes_dict in AllRouteRules_list:\n      for element_id in ['GatewayId', 'NatGatewayId', 'TransitGatewayId', 'NetworkInterfaceId', 'VpcPeeringConnectionId']:\n         if element_id in routes_dict and 'DestinationCidrBlock' in routes_dict and routes_dict['DestinationCidrBlock'] == '0.0.0.0/0':\n            internet_route = routes_dict[element_id]\n            internet_route_list.append(internet_route)\n\n     # Local Route \n      if 'GatewayId' in routes_dict and 'DestinationIpv6CidrBlock' not in routes_dict and routes_dict['GatewayId'] == 'local':\n         cidr_for_local = routes_dict['DestinationCidrBlock']\n         cidr_for_local_list.append(cidr_for_local)\n         \n   print(f'\\nAnalysing route table entries for the instance subnet {subnetdetails}\\n')\n   print('...Results...')\n   cidrforlocallist = ''.join(cidr_for_local_list)\n   LocalRoutes = ' PASSED: Local route available for ' + cidrforlocallist + '. If VPC endpoint for Systems Manager is present, then the Local route is used to communicate with the VPC endpoint interface.'\n\n   if not internet_route_list:\n    AllOtherRoutes = ' WARNING : No route found for 0.0.0.0/0. If the VPC endpoint is present, then this warning can be ignored as Local route will be used to communicate with the VPC endpoints interface. If a VPC endpoint is not present, then your network configuration must have open internet access so that AWS Systems Manager endpoints is reachable.'\n   else:\n    for items in internet_route_list:\n     if 'igw' in items:\n      pubip = get_publicIP(Instance)\n      if pubip == 'None':\n         OtherRoutes = ' WARNING : Internet gateway ' + items + ' is present and routing traffic to 0.0.0.0/0. However, there is no Public IP or Elastic IP address present on eth0. Hence, Internet connectivity through Internet Gateway is unavailable.'\n      else:\n         OtherRoutes = ' PASSED: Internet gateway ' + items + ' is present and routing traffic to 0.0.0.0/0. Hence, Internet availability is present on the Instance and AWS Systems Manager endpoints should be accesible.'\n      AllOtherRoutes = ''.join(OtherRoutes)\n     elif 'nat' in items:\n      OtherRoutes = ' PASSED: NAT gateway ' + items + ' is present and routing traffic to 0.0.0.0/0. If Internet is not working, Check if the NACLs/security Groups associated with ' + items + ' are configured correctly for Internet access.'\n      AllOtherRoutes = ''.join(OtherRoutes)\n     elif 'eni-' in items:\n      OtherRoutes = ' WARNING : ENI ' + items + ' is present and routing traffic to 0.0.0.0. This could be working as NAT Instance. If Internet is not working, Check if the NACLs/security Groups associated with ' + items + ' are configured correctly for Internet access.'\n      AllOtherRoutes = ''.join(OtherRoutes)\n     elif 'vgw' in items:\n      OtherRoutes = ' WARNING : 0.0.0.0/0 traffic is routed through the VPN connection ' + items +'. VPN routes must be configured for connectivity to AWS Systems Manager endpoints. Alternatively, you can use VPC endpoints for AWS Systems Manager.'\n      AllOtherRoutes = ''.join(OtherRoutes)\n     elif 'tgw' in items:\n      OtherRoutes = ' WARNING : 0.0.0.0/0 traffic is routed through the transit gateway ' + items + '. Transit Gateway routes must be configured for connectivity to AWS Systems Manager endpoints. Alternatively, you can use VPC endpoints for AWS Systems Manager.'\n      AllOtherRoutes = ''.join(OtherRoutes)\n     elif 'pcx' in items:\n      OtherRoutes = ' WARNING : 0.0.0.0/0 traffic is routed through the VPC peering instead ' + items + '. This may not have connectivity to AWS Systems Manager endpoints. Your network configuration must have open Internet access or you must have custom VPC endpoints for AWS Systems Manager configured.'\n      AllOtherRoutes = ''.join(OtherRoutes)\n     elif 'vpce' in items:\n      OtherRoutes = ' WARNING : 0.0.0.0/0 traffic is routed through the VPCe Gateway Load Balancer ' + items + '. This may not have connectivity to AWS Systems Manager endpoints. Your network configuration must have open Internet access or you must have custom VPC Endpoints for AWS Systems Manager configured.'\n      AllOtherRoutes = ''.join(OtherRoutes)\n\n   Heading = \"2. Checking VPC Route Table entries of the instance\\'s subnet : \\n\\n\"\n\n   Results = Heading + LocalRoutes + '\\n' + AllOtherRoutes + '\\n\\n'\n   return {'output': Results}\n"
      },
      "outputs": [
        {
          "Name": "output",
          "Selector": "$.Payload.output",
          "Type": "String"
        }
      ]
    },
    {
      "name": "CheckNacl",
      "description": "Checks whether the network ACL rules allow traffic to the VPC endpoint or public Systems Manager endpoints.",
      "action": "aws:executeScript",
      "onFailure": "Abort",
      "nextStep": "CheckInstanceSG",
      "inputs": {
        "Runtime": "python3.8",
        "Handler": "script_handler",
        "InputPayload": {
          "GetInstance": "{{InstanceId}}",
          "isVpceIdPresent": "{{CheckVpcEndpoint.vpceid}}",
          "EC2InstanceSubnet": "{{ GetEC2InstanceProperties.SubnetId }}"
        },
        "Script": "# Copyright 2023 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n# SPDX-License-Identifier: LicenseRef-.amazon.com.-AmznSL-1.0\n# Licensed under the Amazon Software License  http://aws.amazon.com/asl/\n\ndef script_handler(events, context):\n  import boto3\n  from botocore.exceptions import ClientError\n\n  #assigning variables\n  src_port_from = 1024\n  src_port_to = 65536\n  https_port = 443  \n  vpceid = events['isVpceIdPresent']\n  subnetdetails = events['EC2InstanceSubnet']\n  Heading = \"3. Checking NACL rules of the instance subnet: \\n\\n\"\n\n  if vpceid == 'Present':\n   print(\"VPC Endpoint for Systems Manager found: \" + vpceid)\n   Results = Heading + ' SKIPPED: VPC endpoint for Systems Manager is present. Skipping this test..\\n \\n'\n   return {'output': Results }\n  else:\n   print(\"A VPC Endpoint for Systems Manager was not found.\")  \n   \n  #Get Instance NACL entries/rules\n  ec2 = boto3.client('ec2')\n  try:\n     results = ec2.describe_network_acls(Filters=[{'Name':'association.subnet-id','Values':[subnetdetails]}])\n  except ClientError as e:\n     raise Exception (f\"[ERROR] Failed to describe the network ACLs for subnet {subnetdetails} {str(e)}\")\n     \n  for rt in results['NetworkAcls']:\n   entries_list = rt['Entries']\n\n  egress_acls = [acl for acl in entries_list if acl['Egress']]\n  ingress_acls = [acl for acl in entries_list if not acl['Egress']]\n  \n  #Sorting the rules as per Rule number.\n  \n  sorted_egress_acls=sorted(egress_acls, key = lambda i: i['RuleNumber'])\n  sorted_ingress_acls=sorted(ingress_acls, key = lambda i: i['RuleNumber'])\n  \n  print(f'\\nEvaluating the NACL rules for the EC2 instance subnet {subnetdetails}\\n')\n  print('...Results...')  \n  \n  #Check if the Port range provided is in the range of the NACL rule\n  def is_in_range(src_port_from, src_port_to,acl):\n    if ((acl.get('Protocol') == '-1') or (src_port_from  in range(acl['PortRange']['From'], acl['PortRange']['To'])) or (src_port_to in  range(acl['PortRange']['From'], acl['PortRange']['To']+1))):\n        return acl['RuleAction']\n        \n  \n  for acl in sorted_egress_acls:\n    if acl.get('CidrBlock') == '0.0.0.0/0': #Checking only for Anywhere Destination\n      rule_action = is_in_range(https_port,https_port,acl)\n      if rule_action is not None:\n          Egress_Access = rule_action\n          print(\"Egress rule for TCP port 443 is \" + rule_action)\n          break\n\n\n  for acl in sorted_ingress_acls:\n    if acl.get('CidrBlock') == '0.0.0.0/0': #Checking only for Anywhere source\n      rule_action = is_in_range(src_port_from,src_port_to,acl)\n      if rule_action is not None:\n          Ingress_Access = rule_action\n          print(\"Ingress rule for ephemeral ports \" + rule_action)\n          break\n\n\n  # For Egress\n  if Egress_Access == 'allow':\n    egress_result = ' PASSED: Network ACL egress rules ALLOW outbound traffic on port 443 to 0.0.0.0/0.'  \n  else:\n   egress_result = ' FAILED: Network ACL egress rules DO NOT ALLOW outbound traffic on port 443 to 0.0.0.0/0'\n\n\n  # For Ingress\n  if Ingress_Access == 'allow':\n   ingress_result = ' PASSED: Network ACL ingress rules ALLOW inbound traffic on ephemeral ports from 0.0.0.0/0'\n  else:\n   ingress_result = ' FAILED: Network ACL ingress rules DO NOT ALLOW inbound traffic on ephemeral ports from 0.0.0.0/0'\n  \n  Results = Heading + egress_result + '\\n' + ingress_result + '\\n \\n'\n  return {'output': Results}\n"
      },
      "outputs": [
        {
          "Name": "output",
          "Selector": "$.Payload.output",
          "Type": "String"
        }
      ]
    },
    {
      "name": "CheckInstanceSG",
      "description": "Checks whether outbound traffic to the VPC endpoint or public Systems Manager endpoints is allowed by the security group associated with the instance.",
      "action": "aws:executeScript",
      "onFailure": "Abort",
      "nextStep": "CheckInstanceIAM",
      "inputs": {
        "Runtime": "python3.8",
        "Handler": "script_handler",
        "InputPayload": {
          "GetInstance": "{{InstanceId}}",
          "InstanceSGList": "{{GetEC2InstanceProperties.SecurityGroupIds}}"
        },
        "Script": "# Copyright 2023 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n# SPDX-License-Identifier: LicenseRef-.amazon.com.-AmznSL-1.0\n# Licensed under the Amazon Software License  http://aws.amazon.com/asl/\n\ndef script_handler(events, context):\n    import boto3\n    from botocore.exceptions import ClientError\n    \n    #Assigning static variables#\n    Instance = events['GetInstance']\n    list_instance_sg = events['InstanceSGList'] \n    https_port = 443\n    allowed_ip = []\n    Heading = \"4. Checking Security Groups of the EC2 instance for port 443 outbound rule: \\n\\n\"\n    ec2 = boto3.client('ec2')\n\n    for security_group in list_instance_sg:\n        try:\n           response = ec2.describe_security_groups(GroupIds=[security_group])\n           for sg in response['SecurityGroups']:\n               for rule in sg['IpPermissionsEgress']:\n                   if ((rule.get('IpProtocol') == '-1') or (rule.get('FromPort') == -1 and rule.get('ToPort') == -1) or (https_port in range(rule.get('FromPort'), rule.get('ToPort') +1))):\n                       for cidr in rule['IpRanges']:\n                           if cidr['CidrIp'] == '0.0.0.0/0':\n                               SGResults = \" PASSED: Found outbound rule for TCP 443 to 0.0.0.0/0\\n\\n\"\n                               Results = Heading + SGResults \n                               return {'output': Results }\n           \n                   #if no rule found for 0.0.0.0/0, check further.\n           \n                   if ((rule.get('IpProtocol') == '-1') or (rule.get('FromPort') == -1 and rule.get('ToPort') == -1) or (https_port in range(rule.get('FromPort'), rule.get('ToPort') +1))):\n                       for cidr in rule['IpRanges']:\n                           if cidr['CidrIp'] != '0.0.0.0/0':\n                               cidr_ip = str(cidr['CidrIp'])\n                               allowed_ip.append(cidr_ip)\n        except ClientError as e:\n           raise Exception (f\"[ERROR] Failed to describe security group {security_group} {str(e)}\")        \n\n    if  allowed_ip:\n        SGResults = \" Warning: Restricted outbound rule for TCP 443 found to \" + str(allowed_ip) + '\\n\\n'\n        Results = Heading + SGResults     \n        return {'output': Results } \n    else:\n        SGResults = \" FAILED: No outbound rule for TCP 443 found.\\n\\n\"\n        Results = Heading + SGResults \n        return {'output': Results }\n\n                            \n"
      },
      "outputs": [
        {
          "Name": "output",
          "Selector": "$.Payload.output",
          "Type": "String"
        }
      ]
    },
    {
      "name": "CheckInstanceIAM",
      "description": "Checks if the IAM instance profile attached to the instance includes a managed policy that provides the required permissions. Additionally, checks the Default Host Management Configuration status of the account.",
      "action": "aws:executeScript",
      "onFailure": "Abort",
      "nextStep": "FinalOutput",
      "inputs": {
        "Runtime": "python3.8",
        "Handler": "script_handler",
        "InputPayload": {
          "GetInstance": "{{InstanceId}}",
          "EC2InstanceProfile": "{{GetEC2InstanceProperties.InstanceProfile}}"
        },
        "Script": "# Copyright 2023 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n# SPDX-License-Identifier: LicenseRef-.amazon.com.-AmznSL-1.0\n# Licensed under the Amazon Software License  http://aws.amazon.com/asl/\n\ndef script_handler(events, context):\n  \n  import boto3\n  from botocore.exceptions import ClientError\n  \n  def initialize_client(service):\n    try:\n       global client\n       client = boto3.client(service)\n    except ClientError as e:\n       raise Exception (f\"[ERROR] Failed to initialize boto3 client for service {service} {str(e)}\")\n  \n  def check_dhmc_status(dhmc_setting_id):\n    initialize_client('ssm')\n    try:\n       response = client.get_service_setting(SettingId=dhmc_setting_id)\n       if response['ServiceSetting']['SettingValue'] == '$None':\n             return \"Disabled\"\n       else:\n             return response['ServiceSetting']['SettingValue']    \n    except ClientError as e:\n       return \"NoAccess\"\n  \n  def check_inline_policy(rolename):\n    initialize_client('iam')\n    try:\n       response = client.list_role_policies(RoleName=rolename)\n       if len(response.get('PolicyNames')) == 0:\n          return \"False\"\n       else:\n          return \"True\"\n    except ClientError as e:\n       raise Exception (f\"[ERROR] Failed to list IAM role policies for {rolename} {str(e)}\")            \n\n  \n  def get_iam_role(Name):\n    initialize_client('iam')\n    try:\n       response = client.get_instance_profile(InstanceProfileName=Name)\n       InstanceProfile_in_response = response.get('InstanceProfile')\n       for values in InstanceProfile_in_response['Roles']:\n           rolename = values['RoleName']\n           return rolename            \n    except ClientError as e:\n       raise Exception (f\"[ERROR] Failed to get IAM role for {Name} {str(e)}\")\n       \n  def generate_response_for_dhmc(result):\n    if result == 'Disabled':\n       return \" WARNING: Default Host Management Configuration is Disabled for this account.\\n\"\n    elif result == 'NoAccess':\n       return \" SKIPPED: Unable to determine Default Host Management Configuration status of the account. Please check if required permissions of ssm:GetServiceSetting is present to the user/role executing this runbook.\\n\"\n    else:\n       return \" PASSED: Default Host Management Configuration is Enabled for this account with \" + result  + \"\\n\"\n  \n  def get_list_policy(ec2profile):\n    if ec2profile:\n      ec2profile_name = ec2profile.split(\"/\")[1]\n    else:\n      failed_result = f\" FAILED: No instance profile is attached to the EC2 instance: {Instance}.\"\n      failed_result += \" For more information please see https://aws.amazon.com/blogs/mt/applying-managed-instance-policy-best-practices/\\n\"\n      return failed_result\n    AWS_SSM_IAM_DOC = '\\n For more information please see: https://docs.aws.amazon.com/systems-manager/latest/userguide/setup-instance-profile.html\\n'\n    Role = get_iam_role(ec2profile_name)   \n    try:\n       response = client.list_attached_role_policies(RoleName=Role)\n       managed_policy_text = \". However, the automation couldn't find an AWS manage policy that enables the specific Systems Manager features attached to it.\\n\"\n       managed_policy_text += \"Ensure existing attached policies have required Systems Manager permissions. The minimum permissions for Systems Manager can be \"\n       managed_policy_text += \"referenced from the AWS managed policy: AmazonSSMManagedInstanceCore.\\n\"\n       managed_policy_text += \" For more information please see https://aws.amazon.com/blogs/mt/applying-managed-instance-policy-best-practices/\\n\"\n       IAMResults = \"\"\n       if len(response['AttachedPolicies']) == 0:\n         inline_policy_found = check_inline_policy(Role)\n         if inline_policy_found == \"True\":\n           IAMResults = \" WARNING: Found Instance profile attached to the EC2 instance with inline policies attached\" + managed_policy_text\n         else:\n           IAMResults = f\" FAILED: No Policy is attached to the EC2 instance profile: {ec2profile}.\"\n           IAMResults += \"The instance profile should have policies attached with the required Systems Manager permissions. \"\n           IAMResults += \"The minimum permissions for Systems Manager can be referenced from the AWS managed policy: AmazonSSMManagedInstanceCore.\\n\"\n\n       for policy in response['AttachedPolicies']:\n          if policy['PolicyName'] in ['AmazonSSMManagedInstanceCore', 'AmazonSSMFullAccess', 'AdministratorAccess', 'AmazonEC2RoleforSSM','AmazonSSMManagedEC2InstanceDefaultPolicy']:\n             found_policy = policy['PolicyName']\n             IAMResults = \" PASSED: Found EC2 instance profile attached to the instance: \" + ec2profile + \". AWS managed policy,\" + found_policy + \" is attached to the EC2 instance profile.\\n\"\n             IAMResults += \" SKIPPED: Skipped to check Default Host Management Configuration status as required permissions are found in the EC2 instance profile.\\n\"\n             break\n          else:            \n             IAMResults = \" WARNING: Found EC2 instance profile attached to the instance \" + Instance + \" is \" + ec2profile + managed_policy_text\n  \n       if ('WARNING:' in IAMResults) or ('FAILED:' in IAMResults):\n          dhmcstatus = check_dhmc_status(servicesetting)\n          response_dhmcstatus = generate_response_for_dhmc(dhmcstatus)\n          return IAMResults + response_dhmcstatus + AWS_SSM_IAM_DOC\n       else:\n          return IAMResults + AWS_SSM_IAM_DOC\n    except ClientError as e:\n       raise Exception (f\"[ERROR] Failed to list attached role policies for {Role} {str(e)}\")\n  \n  \n  #Starts here:\n  \n  Instance = events['GetInstance']\n  InstanceProfile = events['EC2InstanceProfile']\n  substring = 'GetEC2InstanceProperties'\n  servicesetting = \"/ssm/managed-instance/default-ec2-instance-management-role\"\n  \n  AWS_SSM_IAM_DOC = '\\n For reference, follow the steps provided here: https://docs.aws.amazon.com/systems-manager/latest/userguide/setup-instance-profile.html\\n'\n  \n  if substring in InstanceProfile:\n             NoInstanceprofile = f\" FAILED: No Instance Profile is attached to the instance {Instance}\"\n             IAMResults = NoInstanceprofile + \". Instance profile must be attached on the Instance with required Systems Manager permissions. The minimum permissions for Systems Manager can be referenced from the AWS managed policy AmazonSSMManagedInstanceCore.\\n\"\n             IAMResults += \"For more information please see https://aws.amazon.com/blogs/mt/applying-managed-instance-policy-best-practices/\\n\"\n             dhmcstatus = check_dhmc_status(servicesetting)\n             response_dhmcstatus = generate_response_for_dhmc(dhmcstatus)\n             return {'output': IAMResults + response_dhmcstatus + AWS_SSM_IAM_DOC}  \n  else:\n    IAMResults = get_list_policy(InstanceProfile)\n       \n  Heading = \"5. Checking if the EC2 instance profile is attached : \\n\\n\"\n  Results = Heading + IAMResults\n  return {'output': Results}\n"
      },
      "outputs": [
        {
          "Name": "output",
          "Selector": "$.Payload.output",
          "Type": "String"
        }
      ]
    },
    {
      "name": "FinalOutput",
      "description": "Generates final output for the automation.",
      "action": "aws:executeScript",
      "onFailure": "Abort",
      "isEnd": "true",
      "inputs": {
        "Runtime": "python3.8",
        "Handler": "script_handler",
        "InputPayload": {
          "Vpce": "{{CheckVpcEndpoint.output}}",
          "routetable": "{{CheckRouteTable.output}}",
          "nacl": "{{CheckNacl.output}}",
          "sg": "{{CheckInstanceSG.output}}",
          "iam": "{{CheckInstanceIAM.output}}"
        },
        "Script": "# Copyright 2023 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n# SPDX-License-Identifier: LicenseRef-.amazon.com.-AmznSL-1.0\n# Licensed under the Amazon Software License  http://aws.amazon.com/asl/\n\ndef script_handler(events, context):\n   # Capturing other steps output.\n   \n   heading = \"Total Number of Tests: 5\\n\\n\"\n   vpceoutput = events['Vpce']\n   routetableoutput = events['routetable']\n   nacloutput = events['nacl']\n   sgoutput = events['sg']\n   iamoutput = events['iam']\n\n   further_investigation = (\n   \"\\nFor Further Investigation:\\n\"\n   \"\\nStarting with the SSM Agent version 3.1.501.0, you can use the ssm-cli tool to diagnose issues at the operating system level. Run the following command on your EC2 instance:\"\n   \"\\nssm-cli get-diagnostics --output table\\n\"\n   \"\\nReferences:\"\n   \"\\n - https://docs.aws.amazon.com/systems-manager/latest/userguide/ssm-cli.html\"\n   \"\\n - https://repost.aws/knowledge-center/systems-manager-ec2-instance-not-appear\"\n   \"\\n - https://docs.aws.amazon.com/systems-manager/latest/userguide/troubleshooting-ssm-agent.html\"\n   ) \n\n   results = heading + vpceoutput + routetableoutput  + nacloutput  + sgoutput  + iamoutput  + further_investigation\n       \n   return {'output': results}\n\n\n\n\n\n"
      },
      "outputs": [
        {
          "Name": "output",
          "Selector": "$.Payload.output",
          "Type": "String"
        }
      ]
    },
    {
      "name": "InstanceisOnline",
      "description": "If the PingStatus of the instance is Online, returns that the instance is already managed by AWS Systems Manager.",
      "action": "aws:executeScript",
      "onFailure": "Abort",
      "isEnd": "true",
      "inputs": {
        "Runtime": "python3.8",
        "Handler": "script_handler",
        "Script": "# Copyright 2023 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n# SPDX-License-Identifier: LicenseRef-.amazon.com.-AmznSL-1.0\n# Licensed under the Amazon Software License  http://aws.amazon.com/asl/\n\ndef script_handler(events, context):\n    \n    Info = \"Instance is already managed by AWS Systems Manager\"\n    return {'output' : Info}\n\n\n"
      },
      "outputs": [
        {
          "Name": "output",
          "Selector": "$.Payload.output",
          "Type": "String"
        }
      ]
    }
  ]
}
