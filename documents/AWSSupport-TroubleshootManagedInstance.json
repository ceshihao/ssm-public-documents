{
  "description": "The **AWSSupport-TroubleshootManagedInstance** runbook helps troubleshoot why an Amazon Elastic Compute Cloud (Amazon EC2) instance does not report as managed by AWS Systems Manager. This runbook reviews the Amazon Virtual Private Cloud (Amazon VPC) configuration for the instance including security group rules, VPC endpoints, network access control list (ACL) rules, and route tables. It also checks that the AWS Identity and Access Management (IAM) instance profile associated with the instance contains the required permissions or the account has enabled [Default Host Management Configuration](https://docs.aws.amazon.com/systems-manager/latest/userguide/managed-instances-default-host-management.html).",
  "schemaVersion": "0.3",
  "outputs": [
    "FinalOutput.Message"
  ],
  "assumeRole": "{{ AutomationAssumeRole }}",
  "parameters": {
    "InstanceId": {
      "type": "AWS::EC2::Instance::Id",
      "description": "(Required) The ID of the Amazon EC2 instance.",
      "allowedPattern": "^i-[a-z0-9]{8,17}$"
    },
    "AutomationAssumeRole": {
      "type": "AWS::IAM::Role::Arn",
      "description": "(Optional) The Amazon Resource Name (ARN) of the AWS Identity and Access Management (IAM) role that allows Systems Manager Automation to perform the actions on your behalf. If no role is specified, Systems Manager Automation uses the permissions of the user that starts this runbook.",
      "default": ""
    }
  },
  "mainSteps": [
    {
      "name": "GetPingStatus",
      "description": "Gets the connection status of SSM Agent by calling the `DescribeInstanceInformation` API.",
      "action": "aws:executeAwsApi",
      "onFailure": "Abort",
      "timeoutSeconds": 300,
      "maxAttempts": 1,
      "nextStep": "BranchOnIsInstanceAlreadyOnline",
      "inputs": {
        "Service": "ssm",
        "Api": "DescribeInstanceInformation",
        "Filters": [
          {
            "Key": "InstanceIds",
            "Values": [
              "{{ InstanceId }}"
            ]
          }
        ]
      },
      "outputs": [
        {
          "Name": "PingStatus",
          "Selector": "$.InstanceInformationList[0].PingStatus",
          "Type": "String"
        }
      ]
    },
    {
      "name": "BranchOnIsInstanceAlreadyOnline",
      "description": "Branches based on whether the instance is already reporting as managed by Systems Manager or not.",
      "action": "aws:branch",
      "onFailure": "Abort",
      "timeoutSeconds": 300,
      "maxAttempts": 1,
      "isCritical": true,
      "inputs": {
        "Choices": [
          {
            "NextStep": "GetEC2InstanceProperties",
            "Not": {
              "Variable": "{{ GetPingStatus.PingStatus }}",
              "StringEquals": "Online"
            }
          }
        ],
        "Default": "FinalOutput"
      },
      "isEnd": false
    },
    {
      "name": "GetEC2InstanceProperties",
      "description": "Gets details about the instance including the security groups, subnet Id, VPC Id, private IP address, IAM instance profile, and platform by calling the `DescribeInstances` API.",
      "action": "aws:executeAwsApi",
      "timeoutSeconds": 300,
      "maxAttempts": 2,
      "onFailure": "Abort",
      "inputs": {
        "Service": "ec2",
        "Api": "DescribeInstances",
        "InstanceIds": [
          "{{ InstanceId }}"
        ]
      },
      "outputs": [
        {
          "Name": "SecurityGroupIds",
          "Selector": "$.Reservations[0].Instances[0].SecurityGroups..GroupId",
          "Type": "StringList"
        },
        {
          "Name": "SubnetId",
          "Selector": "$.Reservations[0].Instances[0].SubnetId",
          "Type": "String"
        },
        {
          "Name": "VpcId",
          "Selector": "$.Reservations[0].Instances[0].VpcId",
          "Type": "String"
        },
        {
          "Name": "PrivateIpAddress",
          "Selector": "$.Reservations[0].Instances[0].NetworkInterfaces[0].PrivateIpAddresses[0].PrivateIpAddress",
          "Type": "String"
        },
        {
          "Name": "InstanceProfile",
          "Selector": "$.Reservations[0].Instances[0].IamInstanceProfile.Arn",
          "Type": "String"
        }
      ],
      "nextStep": "CheckVpcEndpoint"
    },
    {
      "name": "CheckVpcEndpoint",
      "description": "Checks if there is a Systems Manager VPC endpoint associated with the instance VPC. If exists, checks if the security groups associated to the endpoint allow inbound traffic on TCP port 443 from the instance's private IP address or security groups.",
      "action": "aws:executeScript",
      "onFailure": "Abort",
      "timeoutSeconds": 300,
      "maxAttempts": 2,
      "nextStep": "CheckRouteTable",
      "inputs": {
        "InputPayload": {
          "InstanceId": "{{ InstanceId }}",
          "SecurityGroupIds": "{{ GetEC2InstanceProperties.SecurityGroupIds }}",
          "PrivateIpAddress": "{{ GetEC2InstanceProperties.PrivateIpAddress }}",
          "SubnetId": "{{ GetEC2InstanceProperties.SubnetId }}",
          "VpcId": "{{ GetEC2InstanceProperties.VpcId }}"
        },
        "Script": "# Copyright 2023 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n# SPDX-License-Identifier: LicenseRef-.amazon.com.-AmznSL-1.0\n# Licensed under the Amazon Software License  http://aws.amazon.com/asl/\n\nimport ipaddress\nfrom ipaddress import ip_network\nfrom typing import Dict, List\n\nimport boto3\nfrom botocore.exceptions import ClientError\n\nec2_client = boto3.client(\"ec2\")\n\n\ndef script_handler(events, context):\n    region = context[\"global:REGION\"]\n    ssm_enpoint_name = f\"com.amazonaws.{region}.ssm\"\n\n    instance_security_groups: List[str] = events.get(\"SecurityGroupIds\", [])\n    instance_private_ip: str = events.get(\"PrivateIpAddress\")\n    vpc_id: str = events.get(\"VpcId\")\n\n    result: List[str] = [f\"1. Checks for Amazon VPC Systems Manager VPC Endpoint '{ssm_enpoint_name}':\"]\n    ssm_vpc_endpoint = get_ssm_vpc_endpoints(vpc_id, ssm_enpoint_name)\n    vpce_security_groups: List[str] = []\n    vpc_cidr_block = get_vpc_cidr_block(vpc_id)\n\n    if ssm_vpc_endpoint:\n        vpce_id: str = ssm_vpc_endpoint[\"VpcEndpointId\"]\n        vpce_subnets: List[str] = ssm_vpc_endpoint.get(\"SubnetIds\", [])\n        vpce_private_dns_enabled: bool = ssm_vpc_endpoint.get(\"PrivateDnsEnabled\", False)\n        vpce_security_group: Dict[str, str]\n        for vpce_security_group in ssm_vpc_endpoint.get(\"Groups\", []):\n            vpce_security_groups.append(vpce_security_group[\"GroupId\"])\n\n        result.append(f\"[OK] VPC endpoint '{vpce_id}' for Systems Manager found on the EC2 instance's VPC: {vpc_id}.\")\n        result.append(f\"[OK] Subnets configured for the VPC endpoint found: {', '.join(vpce_subnets)}.\")\n        if vpce_private_dns_enabled:\n            result.append(\"[OK] Private DNS is enabled on the VPC endpoint.\")\n        else:\n            result.append(\n                \"[WARNING] Private DNS is not enabled on the VPC endpoint (Enabling private DNS names is recommended).\"\n            )\n        result.append(f\"[INFO] Security groups attached to the VPC endpoints: {','.join(vpce_security_groups)}.\")\n\n        sgs_validation = validate_segurity_groups(vpce_security_groups, instance_private_ip, instance_security_groups)\n        result.append(sgs_validation)\n        return {\n            \"Message\": \"\\n- \".join(result),\n            \"VpcEndpointId\": vpce_id,\n            \"VpcEndpointSubnets\": vpce_subnets,\n            \"VpcEndpointSecurityGroupIds\": vpce_security_groups,\n            \"VpcCidrBlock\": vpc_cidr_block,\n        }\n    else:\n        result.append(f\"[INFO] No VPC endpoint for Systems Manager found on the EC2 instance VPC: {vpc_id}.\")\n        return {\n            \"Message\": \"\\n- \".join(result),\n            \"VpcEndpointId\": \"\",\n            \"VpcEndpointSubnets\": [],\n            \"VpcEndpointSecurityGroupIds\": [],\n            \"VpcCidrBlock\": vpc_cidr_block,\n        }\n\n\ndef get_vpc_cidr_block(vpc_id) -> str:\n    try:\n        response = ec2_client.describe_vpcs(VpcIds=[vpc_id])\n    except ClientError as e:\n        raise RuntimeError(f\"[ERROR] An error occurred while trying to describe the VPC {vpc_id}: {str(e)}\") from None\n\n    return response.get(\"Vpcs\", [])[0].get(\"CidrBlock\")\n\n\ndef get_ssm_vpc_endpoints(vpc_id, ssm_enpoint_name) -> dict:\n    try:\n        response = ec2_client.describe_vpc_endpoints(\n            Filters=[{\"Name\": \"vpc-id\", \"Values\": [vpc_id]}, {\"Name\": \"service-name\", \"Values\": [ssm_enpoint_name]}]\n        )\n    except ClientError as e:\n        raise RuntimeError(\n            f\"[ERROR] An error occurred while trying to describe the VPC endpoint {ssm_enpoint_name} for {vpc_id}: {str(e)}\"\n        ) from None\n\n    ssm_endpoints = response.get(\"VpcEndpoints\", [])\n    for endpoint in ssm_endpoints:\n        if endpoint[\"State\"].lower() == \"available\":\n            return endpoint\n        else:\n            print(f\"[WARNING] VPC endpoint '{endpoint['VpcEndpointId']}' is not in 'Available' state.\")\n            return {}\n    else:\n        return {}\n\n\ndef validate_segurity_groups(vpce_security_groups, instance_private_ip, instance_security_groups) -> str:\n    https_port = 443\n    for vpce_security_group in vpce_security_groups:\n        try:\n            response = ec2_client.describe_security_groups(GroupIds=[vpce_security_group])\n        except ClientError as e:\n            raise RuntimeError(\n                f\"[ERROR] An error occurred while trying to describe the security group {vpce_security_group}: {str(e)}\"\n            ) from None\n\n        for sg in response.get(\"SecurityGroups\", []):\n            for rule in sg.get(\"IpPermissions\", []):\n                if (\n                    (rule.get(\"IpProtocol\") == \"-1\")\n                    or (rule.get(\"FromPort\") == -1 and rule.get(\"ToPort\") == -1)\n                    or (https_port in range(rule.get(\"FromPort\"), rule.get(\"ToPort\") + 1))\n                ):\n                    for cidr in rule.get(\"IpRanges\", []):\n                        if ipaddress.ip_address(instance_private_ip) in ip_network(cidr[\"CidrIp\"], strict=False):\n                            return f\"[OK] VPC endpoint security group '{vpce_security_group}' allows traffic on port '{https_port}' from the instance private IP '{instance_private_ip}'.\"\n\n                    for group in rule.get(\"UserIdGroupPairs\", []):\n                        for security_group_id in instance_security_groups:\n                            if security_group_id in group[\"GroupId\"]:\n                                return f\"[OK] VPC endpoint security group '{vpce_security_group}' allows traffic on port {https_port} from the instance security group {security_group_id}.\"\n\n    # If we reach this point, it means that the security group does not allow traffic from the instance.\n    error_text = f\"[ERROR] VPC endpoint security groups '{', '.join(vpce_security_groups)}' do not allow traffic on port '{https_port}' from the instance security group(s) '{', '.join(instance_security_groups)}' or private IP '{instance_private_ip}'.\"\n    help_text = \"\\nFor more information see 'Configure an interface endpoint' in https://docs.aws.amazon.com/vpc/latest/privatelink/interface-endpoints.html.\"\n    return \"\\n\".join([error_text, help_text])\n",
        "Handler": "script_handler",
        "Runtime": "python3.11"
      },
      "outputs": [
        {
          "Name": "Message",
          "Selector": "$.Payload.Message",
          "Type": "String"
        },
        {
          "Name": "VpcEndpointId",
          "Selector": "$.Payload.VpcEndpointId",
          "Type": "String"
        },
        {
          "Name": "VpcEndpointSubnets",
          "Selector": "$.Payload.VpcEndpointSubnets",
          "Type": "StringList"
        },
        {
          "Name": "VpcEndpointSecurityGroupIds",
          "Selector": "$.Payload.VpcEndpointSecurityGroupIds",
          "Type": "StringList"
        },
        {
          "Name": "VpcCidrBlock",
          "Selector": "$.Payload.VpcCidrBlock",
          "Type": "String"
        }
      ]
    },
    {
      "name": "CheckRouteTable",
      "description": "Checks if the route table routes traffic to the VPC interface endpoint or the public Systems Manager endpoint.",
      "action": "aws:executeScript",
      "onFailure": "Abort",
      "timeoutSeconds": 300,
      "maxAttempts": 2,
      "nextStep": "CheckNacl",
      "inputs": {
        "InputPayload": {
          "InstanceId": "{{ InstanceId }}",
          "SubnetId": "{{ GetEC2InstanceProperties.SubnetId }}",
          "VpcId": "{{ GetEC2InstanceProperties.VpcId }}",
          "VpcEndpointId": "{{ CheckVpcEndpoint.VpcEndpointId }}"
        },
        "Script": "# Copyright 2023 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n# SPDX-License-Identifier: LicenseRef-.amazon.com.-AmznSL-1.0\n# Licensed under the Amazon Software License  http://aws.amazon.com/asl/\n\nimport boto3\nfrom botocore.exceptions import ClientError\n\nec2 = boto3.client(\"ec2\")\n\n\ndef script_handler(events, context):\n    instance_id: str = events[\"InstanceId\"]\n    subnet_id: str = events[\"SubnetId\"]\n    vpc_id: str = events[\"VpcId\"]\n    vpc_endpoint_id: str = events[\"VpcEndpointId\"]\n\n    public_ip = get_instance_public_ip(instance_id)\n    route_tables = describe_route_tables(subnet_id, vpc_id)\n    result = [f\"2. Checks for the VPC route table entries of the instance's subnet '{subnet_id}:'\"]\n    # List of Internet routes (GatewayId, NatGatewayId, TransitGatewayId, NetworkInterfaceId, VpcPeeringConnectionId)\n    internet_route_list = []\n    # List of local (default) routes\n    cidr_for_local_list = []\n\n    for route_table in route_tables:\n        route_table_id = route_table[\"RouteTableId\"]\n        result.append(f\"[INFO] VPC route table found: {route_table_id}.\")\n        routes = route_table[\"Routes\"]\n\n        for route_entry in routes:\n            for element_id in [\n                \"GatewayId\",\n                \"NatGatewayId\",\n                \"TransitGatewayId\",\n                \"NetworkInterfaceId\",\n                \"VpcPeeringConnectionId\",\n            ]:\n                if (\n                    element_id in route_entry\n                    and \"DestinationCidrBlock\" in route_entry\n                    and route_entry[\"DestinationCidrBlock\"] == \"0.0.0.0/0\"\n                ):\n                    # Add Internet route\n                    internet_route = route_entry[element_id]\n                    status = route_entry.get(\"State\", \"active\")\n                    internet_route_list.append((internet_route, status))\n\n            # Local Route\n            if (\n                \"GatewayId\" in route_entry\n                and \"DestinationIpv6CidrBlock\" not in route_entry\n                and route_entry[\"GatewayId\"] == \"local\"\n            ):\n                # Add local (default) route\n                cidr_for_local_list.append(route_entry[\"DestinationCidrBlock\"])\n\n    # Check if local route (default route) is used to communicate with the VPC SSM interface endpoint.\n    if cidr_for_local_list:\n        result.append(f\"[INFO] VPC local route (default route) available for {', '.join(cidr_for_local_list)}.\")\n        if vpc_endpoint_id:\n            result.append(\n                f\"[OK] The local route (default route) is used to communicate with the Systems Manager VPC endpoint interface '{vpc_endpoint_id}'.\"\n            )\n        else:\n            result.append(\"[WARNING] A local route is required to communicate with the VPC endpoint interface.\")\n\n    # Check if internet route is used to communicate with the SSM endpoint.\n    if not internet_route_list:\n        if vpc_endpoint_id:  # If the VPC has a Systems Manager VPC endpoint interface\n            result.append(\n                f\"[OK] A public route is not required to communicate with the Systems Manager VPC endpoint interface '{vpc_endpoint_id}'.\"\n            )\n        else:  # If no VPC endpoint interface is present, a public route is required\n            result.append(\n                \"[WARNING] No route found for 0.0.0.0/0. Internet access is required to connect to the public Systems Manager endpoint.\"\n            )\n\n    else:\n        # Loop through the internet routes an add information that can be used for troubleshooting connectivity.\n        for item, state in internet_route_list:\n            result.append(f\"[INFO] VPC Internet route with destination 0.0.0.0/0 found with target '{item}'.\")\n\n            if state != \"active\":\n                result.append(f\"[WARNING] VPC Internet route and is marked as '{state}'.\")\n            else:\n                if \"igw\" in item:\n                    if public_ip == \"None\":\n                        result.append(\n                            f\"[WARNING] VPC internet gateway '{item}' route associated, however the instance does not have a public IP address associated. Internet connectivity through the internet gateway is unavailable.\"\n                        )\n                    else:\n                        result.append(\n                            f\"[OK] VPC internet gateway '{item}' route associated and the instance has a public IP address ({public_ip}) associated.\"\n                        )\n\n                if \"nat\" in route_table:\n                    result.append(\n                        f\"[OK] VPC NAT gateway '{item}' present. Make sure the NAT gateway allow access to the Systems Manager endpoints.\"\n                    )\n\n                if \"eni-\" in route_table:\n                    result.append(\n                        f\"[INFO] Network interface '{item}' route associated. All traffic is automatically routed to this interface. Make sure the node associated with this network interface allow access to the Systems Manager endpoints.\"\n                    )\n\n                if \"vgw\" in route_table:\n                    result.append(\n                        f\"[INFO] Virtual private gateway '{item}' route associated. Make sure the VPN connection allow access to the Systems Manager endpoints.\"\n                    )\n\n                if \"tgw\" in route_table:\n                    result.append(\n                        f\"[INFO] Transit gateway '{item}' route associated. Make sure the Transit gateway routes are configured to allow access to the Systems Manager endpoints.\"\n                    )\n\n                if \"pcx\" in route_table:\n                    result.append(\n                        f\"[INFO] VPC peering connection '{item}' route associated. Make sure the VPC peering connection allows access to the Systems Manager endpoints.\"\n                    )\n\n                if \"vpce\" in route_table:\n                    result.append(\n                        f\"[INFO] VPCe gateway load balancer '{item}' route associated. Make sure the VPCe gateway load balancer allows access to the Systems Manager endpoints.\"\n                    )\n\n    result.append(\n        \"For more information about routing options see https://docs.aws.amazon.com/vpc/latest/userguide/route-table-options.html#route-tables-vpc-peering\"\n    )\n    result.append(\n        \"For more information about route tables see https://docs.aws.amazon.com/vpc/latest/userguide/route-table-options.html#route-tables-vpc-peering\"\n    )\n    return {\"Message\": \"\\n- \".join(result)}\n\n\ndef get_instance_public_ip(instanceid: str) -> str:\n    try:\n        result = ec2.describe_instances(InstanceIds=[instanceid])\n        instance = result[\"Reservations\"][0][\"Instances\"][0]\n        public_ip = instance.get(\"PublicIpAddress\", \"None\")\n        return public_ip\n    except ClientError as e:\n        raise RuntimeError(f\"[ERROR] An error occurred while trying to describe the EC2 instance {instanceid} {str(e)}\")\n\n\ndef describe_route_tables(subnet_id: str, vpc_id: str) -> list:\n    try:\n        # Get the EC2 instance subnet route table\n        result = ec2.describe_route_tables(Filters=[{\"Name\": \"association.subnet-id\", \"Values\": [subnet_id]}]).get(\n            \"RouteTables\", []\n        )\n\n        # If the subnet is not associated with any route table, get the main route table of the VPC.\n        if not result:\n            result = ec2.describe_route_tables(\n                Filters=[{\"Name\": \"association.main\", \"Values\": [\"true\"]}, {\"Name\": \"vpc-id\", \"Values\": [vpc_id]}]\n            ).get(\"RouteTables\", [])\n        return result\n    except ClientError as e:\n        raise RuntimeError(f\"[ERROR] Failed to describe the instance's subnet {subnet_id} route tables {str(e)}\")\n",
        "Handler": "script_handler",
        "Runtime": "python3.11"
      },
      "outputs": [
        {
          "Name": "Message",
          "Selector": "$.Payload.Message",
          "Type": "String"
        }
      ]
    },
    {
      "name": "CheckNacl",
      "description": "Checks if the network ACL rules associated to the instance's subnet allow traffic to the VPC or public Systems Manager endpoint.",
      "action": "aws:executeScript",
      "onFailure": "Abort",
      "timeoutSeconds": 300,
      "maxAttempts": 2,
      "nextStep": "CheckInstanceSecurityGroup",
      "inputs": {
        "InputPayload": {
          "InstanceId": "{{ InstanceId }}",
          "VpcEndpointId": "{{ CheckVpcEndpoint.VpcEndpointId }}",
          "SubnetId": "{{ GetEC2InstanceProperties.SubnetId }}",
          "PrivateIpAddress": "{{ GetEC2InstanceProperties.PrivateIpAddress }}",
          "VpcEndpointSubnets": "{{ CheckVpcEndpoint.VpcEndpointSubnets }}"
        },
        "Script": "# Copyright 2023 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n# SPDX-License-Identifier: LicenseRef-.amazon.com.-AmznSL-1.0\n# Licensed under the Amazon Software License  http://aws.amazon.com/asl/\n\nfrom typing import Any, Dict, List, Tuple\n\nimport boto3\nfrom botocore.exceptions import ClientError\n\nec2_client = boto3.client(\"ec2\")\n\n\ndef script_handler(events, context):\n    instance_id = events[\"InstanceId\"]\n    subnet_id = events[\"SubnetId\"]\n    vpc_endpoint_id = events[\"VpcEndpointId\"]\n    instance_private_ip = events.get(\"PrivateIpAddress\")\n    vpc_endpoint_subnets = events.get(\"VpcEndpointSubnets\", [])\n\n    result = []\n    result.append(f\"3. Checks for NACL rules of the instance subnet '{subnet_id}':\")\n\n    if vpc_endpoint_id and subnet_id in vpc_endpoint_subnets:\n        result.append(\n            \"[SKIPPED] VPC endpoint for Systems Manager is present and in the same subnet as the EC2 instance.\"\n        )\n        return {\"Message\": \"\\n- \".join(result)}\n\n    # Check requirements for instance's network ACL (ephemeral ports outbound)\n    result.append(f\"Check network ACLs requirements instance '{instance_id}' for instance subnet '{subnet_id}':\")\n    ephemeral_ports_outbound = {\"-1\": [[1024, 65535]]}\n    instance_reqs = check_nacl_traffic_requirements(subnet_id, instance_private_ip, False, ephemeral_ports_outbound)\n    result.extend(instance_reqs)\n\n    if vpc_endpoint_id:\n        for vpce_subnet_id in vpc_endpoint_subnets:\n            # Check requirements for VPC endpoint's network ACL (ephemeral ports outbound)\n            result.append(\n                f\"Check network ACLs requirements for the VPC endpoint '{vpc_endpoint_id}' subnet '{vpce_subnet_id}':\"\n            )\n            ephemeral_ports_outbound = {\"-1\": [[1024, 65535]]}\n            vpce_reqs = check_nacl_traffic_requirements(vpce_subnet_id, \"0.0.0.0/0\", False, ephemeral_ports_outbound)\n            result.extend(vpce_reqs)\n            https_inbound = {\"tcp\": [[443, 443]]}\n            vpce_reqs = check_nacl_traffic_requirements(vpce_subnet_id, instance_private_ip, True, https_inbound)\n            result.extend(vpce_reqs)\n\n    return {\"Message\": \"\\n- \".join(result)}\n\n\ndef check_nacl_traffic_requirements(\n    subnet_id: str, source: str, is_inbound: bool, required_traffic: Dict[str, List[List[int]]]\n) -> list:\n    network_acl_id, nacls = describe_network_acls(subnet_id)\n    result = [f\"Check network ACLs requirements on network ACL '{network_acl_id}':\"]\n    # Eval allowed inbound and outbound traffic from/to 0.0.0.0 and the instance private IP\n    inbound, outbound = eval_acl_rules(nacls, [source])\n\n    if is_inbound:\n        # Check if the required inbound traffic.\n        allowed_result = check_allowed(inbound, source, required_traffic, is_inbound)\n        result.extend(allowed_result)\n    else:\n        allowed_result = check_allowed(outbound, source, required_traffic, is_inbound)\n        result.extend(allowed_result)\n\n    return result\n\n\ndef check_allowed(\n    allowed_traffic: Dict[str, Dict[str, List[List[int]]]],\n    source: str,\n    required_traffic: Dict[str, List[List[int]]],\n    is_inbound: bool,\n) -> List[str]:\n    rules = allowed_traffic[source]\n    result = []\n    # Loop through the required traffic and check if it is allowed. If it is not allowed, add an error to the result.\n    # allowed_traffic: {\"0.0.0.0/0\": {\"-1\": [[0, 65535]]}, \"10.0.57.3\": {\"-1\": [[0, 65535]], \"udp: [[53,53],[10,123]]}}\n    # required_traffic: {\"tcp\": [[442, 443]], \"udp: [[53,53],[10,123]]\"}\n    for required_protocol, required_ranges in required_traffic.items():\n        str_protocol = required_protocol.replace(\"-1\", \"all\").upper()\n        for required_range in required_ranges:\n            allowed = False\n\n            # Loop through the allowed traffic and check if it is allowed. If it is not allowed, add an error to the result.\n            for allowed_protocol, allowed_ranges in rules.items():\n                for allowed_range in allowed_ranges:\n                    required_range_set = set(range(required_range[0], required_range[1] + 1))\n                    allowed_range_set = set(range(allowed_range[0], allowed_range[1] + 1))\n                    if (\n                        allowed_protocol in (\"-1\", required_protocol)  # \"-1\" matches all protocols\n                        and required_range_set\n                        and allowed_range_set\n                        and required_range_set.issubset(allowed_range_set)\n                    ):\n                        if is_inbound:\n                            result.append(\n                                f\"[OK] '{str_protocol}' inbound traffic allowed from '{source}' to '{required_range}'\"\n                            )\n                        else:\n                            result.append(\n                                f\"[OK] '{str_protocol}' outbound traffic allowed to '{source}' from '{required_range}'\"\n                            )\n                        allowed = True\n                        break\n            if not allowed:\n                if is_inbound:\n                    result.append(\n                        f\"[ERROR] '{str_protocol}' inbound traffic not allowed from '{source}' to '{required_range}'\"\n                    )\n                else:\n                    result.append(\n                        f\"[ERROR] '{str_protocol}' outbound traffic not allowed to '{source}' from '{required_range}'\"\n                    )\n            else:\n                break\n    return result\n\n\ndef eval_acl_rules(\n    entries: List[Any], source: List[str]\n) -> Tuple[Dict[str, Dict[str, List[List[int]]]], Dict[str, Dict[str, List[List[int]]]]]:\n    from ipaddress import ip_network\n\n    allows_in: Dict[str, Dict[str, List[List[int]]]] = {}\n    allows_out: Dict[str, Dict[str, List[List[int]]]] = {}\n\n    try:\n        for network_cidr in source:\n            in_allow: Dict[str, List[List[int]]] = {}\n            out_allow: Dict[str, List[List[int]]] = {}\n            for rule in sorted(entries, key=lambda k: k[\"RuleNumber\"], reverse=True):\n                protocol = get_std_protocol(rule[\"Protocol\"])\n                network_in_acl = ip_network(rule[\"CidrBlock\"], strict=False)\n                network_in_source = ip_network(network_cidr, strict=False)\n\n                if \"PortRange\" not in rule:\n                    from_port = 0\n                    to_port = 65535\n                else:\n                    from_port = rule[\"PortRange\"][\"From\"]\n                    to_port = rule[\"PortRange\"][\"To\"]\n\n                if not rule[\"Egress\"]:\n                    if rule[\"RuleAction\"] == \"allow\":\n                        if network_in_source.subnet_of(network_in_acl):  # type: ignore\n                            in_allow[protocol] = range_add([from_port, to_port], in_allow.get(protocol, []))\n                    else:\n                        if network_in_source.subnet_of(network_in_acl):  # type: ignore\n                            in_allow[protocol] = range_diff([from_port, to_port], in_allow.get(protocol, []))\n\n                else:\n                    if rule[\"RuleAction\"] == \"allow\":\n                        if network_in_source.subnet_of(network_in_acl):  # type: ignore\n                            out_allow[protocol] = range_add([from_port, to_port], out_allow.get(protocol, []))\n                    else:\n                        if network_in_source.subnet_of(network_in_acl):  # type: ignore\n                            out_allow[protocol] = range_diff([from_port, to_port], out_allow.get(protocol, []))\n\n            allows_in[network_cidr] = dict(in_allow)\n            allows_out[network_cidr] = dict(out_allow)\n\n        return dict(allows_in), dict(allows_out)\n\n    except Exception as e:\n        raise ValueError(\"Failed to evaluate Network ACLs.\", str(e))\n\n\ndef get_std_protocol(acl_protocol: str):\n    # defined at https://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml\n    customprotocol = {\n        \"-1\": \"-1\",\n        \"hopopt\": \"0\",\n        \"icmp\": \"1\",\n        \"igmp\": \"2\",\n        \"ggp\": \"3\",\n        \"ipv4\": \"4\",\n        \"st\": \"5\",\n        \"tcp\": \"6\",\n        \"cbt\": \"7\",\n        \"egp\": \"8\",\n        \"igp\": \"9\",\n        \"bbn-rcc-mon\": \"10\",\n        \"nvp-ii\": \"11\",\n        \"pup\": \"12\",\n        \"argus\": \"13\",\n        \"emcon\": \"14\",\n        \"xnet\": \"15\",\n        \"chaos\": \"16\",\n        \"udp\": \"17\",\n        \"mux\": \"18\",\n        \"dcn-meas\": \"19\",\n        \"hmp\": \"20\",\n        \"prm\": \"21\",\n        \"xns-idp\": \"22\",\n        \"trunk-1\": \"23\",\n        \"trunk-2\": \"24\",\n        \"leaf-1\": \"25\",\n        \"leaf-2\": \"26\",\n        \"rdp\": \"27\",\n        \"irtp\": \"28\",\n        \"iso-tp4\": \"29\",\n        \"netblt\": \"30\",\n        \"mfe-nsp\": \"31\",\n        \"merit-inp\": \"32\",\n        \"dccp\": \"33\",\n        \"3pc\": \"34\",\n        \"idpr\": \"35\",\n        \"xtp\": \"36\",\n        \"ddp\": \"37\",\n        \"idpr-cmtp\": \"38\",\n        \"tp++\": \"39\",\n        \"il\": \"40\",\n        \"ipv6\": \"41\",\n        \"sdrp\": \"42\",\n        \"ipv6-route\": \"43\",\n        \"ipv6-frag\": \"44\",\n        \"idrp\": \"45\",\n        \"rsvp\": \"46\",\n        \"gre\": \"47\",\n        \"dsr\": \"48\",\n        \"bna\": \"49\",\n        \"esp\": \"50\",\n        \"ah\": \"51\",\n        \"i-nlsp\": \"52\",\n        \"swipe\": \"53\",\n        \"narp\": \"54\",\n        \"mobile\": \"55\",\n        \"tlsp\": \"56\",\n        \"ipv6-icmp\": \"58\",\n        \"ipv6-nonxt\": \"59\",\n        \"ipv6-opts\": \"60\",\n        \"61\": \"61\",\n        \"cftp\": \"62\",\n        \"63\": \"63\",\n        \"sat-expak\": \"64\",\n        \"kryptolan\": \"65\",\n        \"rvd\": \"66\",\n        \"ippc\": \"67\",\n        \"68\": \"68\",\n        \"sat-mon\": \"69\",\n        \"visa\": \"70\",\n        \"ipcv\": \"71\",\n        \"cpnx\": \"72\",\n        \"cphb\": \"73\",\n        \"wsn\": \"74\",\n        \"pvp\": \"75\",\n        \"br-sat-mon\": \"76\",\n        \"sun-nd\": \"77\",\n        \"wb-mon\": \"78\",\n        \"wb-expak\": \"79\",\n        \"iso-ip\": \"80\",\n        \"vmtp\": \"81\",\n        \"secure-vmtp\": \"82\",\n        \"vines\": \"83\",\n        \"ttp\": \"84\",\n        \"nsfnet-igp\": \"85\",\n        \"dgp\": \"86\",\n        \"tcf\": \"87\",\n        \"eigrp\": \"88\",\n        \"ospfigp\": \"89\",\n        \"sprite-rpc\": \"90\",\n        \"larp\": \"91\",\n        \"mtp\": \"92\",\n        \"ax.25\": \"93\",\n        \"ipip\": \"94\",\n        \"micp\": \"95\",\n        \"scc-sp\": \"96\",\n        \"etherip\": \"97\",\n        \"encap\": \"98\",\n        \"99\": \"99\",\n        \"gmtp\": \"100\",\n        \"ifmp\": \"101\",\n        \"pnni\": \"102\",\n        \"pim\": \"103\",\n        \"aris\": \"104\",\n        \"scps\": \"105\",\n        \"qnx\": \"106\",\n        \"a/n\": \"107\",\n        \"ipcomp\": \"108\",\n        \"snp\": \"109\",\n        \"compaq-peer\": \"110\",\n        \"ipx-in-ip\": \"111\",\n        \"vrrp\": \"112\",\n        \"pgm\": \"113\",\n        \"114\": \"114\",\n        \"l2tp\": \"115\",\n        \"dd\": \"116\",\n        \"iatp\": \"117\",\n        \"stp\": \"118\",\n        \"srp\": \"119\",\n        \"uti\": \"120\",\n        \"smp\": \"121\",\n        \"sm\": \"122\",\n        \"ptp\": \"123\",\n        \"isis-over-ipv4\": \"124\",\n        \"fire\": \"125\",\n        \"crtp\": \"126\",\n        \"crudp\": \"127\",\n        \"sscopmce\": \"128\",\n        \"iplt\": \"129\",\n        \"sps\": \"130\",\n        \"pipe\": \"131\",\n        \"sctp\": \"132\",\n        \"fc\": \"133\",\n        \"rsvp-e2e-ignore\": \"134\",\n        \"mobility-header\": \"135\",\n        \"udplite\": \"136\",\n        \"mpls-in-ip\": \"137\",\n        \"manet\": \"138\",\n        \"hip\": \"139\",\n        \"shim6\": \"140\",\n        \"wesp\": \"141\",\n        \"rohc\": \"142\",\n        \"253\": \"253\",\n        \"254\": \"254\",\n    }\n    inv_map = {v: k for k, v in customprotocol.items()}\n    return inv_map.get(acl_protocol)\n\n\ndef range_add(new_port_range: List[int], interv: List[List[int]]) -> List[List[int]]:\n    # if new not in interv:\n    interv.append(new_port_range)\n    interv = [\n        port_range\n        for port_range in interv\n        if port_range != [] and len(port_range) == 2 and all(isinstance(val, int) for val in port_range)\n    ]\n    interv.sort()\n\n    new_interval = []\n    while len(interv) > 0:\n        if len(interv) == 1:\n            new_interval.append(interv[0])\n            interv.pop(0)\n            continue\n        if interv[0][1] >= interv[1][0]:\n            tmp = [interv[0][0], max(interv[0][1], interv[1][1])]\n            interv[0] = tmp\n            interv.pop(1)\n            continue\n\n        new_interval.append(interv[0])\n        interv.pop(0)\n    return new_interval\n\n\ndef range_diff(new_range: List[int], interv: List[List[int]]) -> List[List[int]]:\n    interv = range_add([], interv)\n    if len(new_range) == 0:\n        new_range = [0, 0]\n    interv = [\n        port_range\n        for port_range in interv\n        if port_range != [] and len(port_range) == 2 and all(isinstance(val, int) for val in port_range)\n    ]\n    interv.sort()\n    new_interval = []\n    for port_range in interv:\n        from_port, to_port = port_range\n        from_port_new, to_port_new = new_range\n        sorted_ports = sorted((from_port, from_port_new, to_port, to_port_new))\n        if sorted_ports[0] == from_port and sorted_ports[0] != sorted_ports[1]:\n            min_port = sorted_ports[1] if to_port < from_port_new else sorted_ports[1] - 1\n            new_interval.append([sorted_ports[0], min_port])\n        if sorted_ports[3] == to_port and sorted_ports[2] != sorted_ports[3]:\n            min_port = sorted_ports[2] if to_port_new < from_port else sorted_ports[2] + 1\n            new_interval.append([min_port, sorted_ports[3]])\n    if len(new_interval) == 0:\n        new_interval = [[0, 0]]\n    return new_interval\n\n\ndef describe_network_acls(subnet_id: str) -> Tuple[str, List[Any]]:\n    \"\"\"Analyse Network ACL rules for all traffic open from '0.0.0.0/0\"\"\"\n    try:\n        response = ec2_client.describe_network_acls(Filters=[{\"Name\": \"association.subnet-id\", \"Values\": [subnet_id]}])\n        network_acls = response.get(\"NetworkAcls\")[0].get(\"Entries\", [])\n        network_acl_id = response.get(\"NetworkAcls\")[0].get(\"NetworkAclId\")\n        return network_acl_id, network_acls\n\n    except ClientError as error:\n        raise RuntimeError(\n            f\"[ERROR] Failed to describe the instance's Network ACLs from subnet {subnet_id}: {str(error)}.\"\n        )\n",
        "Handler": "script_handler",
        "Runtime": "python3.11"
      },
      "outputs": [
        {
          "Name": "Message",
          "Selector": "$.Payload.Message",
          "Type": "String"
        }
      ]
    },
    {
      "name": "CheckInstanceSecurityGroup",
      "description": "Checks if outbound traffic to the VPC endpoint or public Systems Manager endpoints is allowed by the security group associated with the instance.",
      "action": "aws:executeScript",
      "onFailure": "Abort",
      "timeoutSeconds": 300,
      "maxAttempts": 2,
      "nextStep": "CheckInstanceIAM",
      "inputs": {
        "InputPayload": {
          "InstanceId": "{{ InstanceId }}",
          "VpcEndpointId": "{{ CheckVpcEndpoint.VpcEndpointId }}",
          "SecurityGroupIds": "{{ GetEC2InstanceProperties.SecurityGroupIds }}",
          "VpcEndpointSecurityGroupIds": "{{ CheckVpcEndpoint.VpcEndpointSecurityGroupIds }}",
          "VpcCidrBlock": "{{ CheckVpcEndpoint.VpcCidrBlock }}"
        },
        "Script": "# Copyright 2023 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n# SPDX-License-Identifier: LicenseRef-.amazon.com.-AmznSL-1.0\n# Licensed under the Amazon Software License  http://aws.amazon.com/asl/\n\nfrom ipaddress import ip_network\nfrom typing import List\n\nimport boto3\nfrom botocore.exceptions import ClientError\n\nec2_client = boto3.client(\"ec2\")\n\n\ndef script_handler(events, context):\n    instance_id = events[\"InstanceId\"]\n    vpc_endpoint_id = events[\"VpcEndpointId\"]\n    vpc_cidr_block = events.get(\"VpcCidrBlock\")\n    vpc_endpoint_security_groups = events.get(\"VpcEndpointSecurityGroupIds\", [])\n    instance_security_groups = events.get(\"SecurityGroupIds\", [])\n    result: List[str] = [f\"4. Checks EC2 instance '{instance_id}' security groups outbound traffic:\"]\n\n    result.append(\"Check outbound traffic to the public Systems Manager endpoint:\")\n    result.extend(validate_segurity_groups(instance_security_groups, [\"0.0.0.0/0\"]))\n\n    if vpc_endpoint_id:\n        # Describe the outbound traffic for describe_vpc_endpoints\n        result.append(f\"Check outbound traffic to the Systems Manager VPC interface endpoint '{vpc_endpoint_id}:\")\n        result.append(\"Check outbound traffic to '0.0.0.0/0':\")\n        result.extend(validate_segurity_groups(instance_security_groups, [\"0.0.0.0/0\"]))\n        result.append(f\"Check outbound traffic to endpoint security groups {', '.join(vpc_endpoint_security_groups)}:\")\n        result.extend(validate_segurity_groups(instance_security_groups, vpc_endpoint_security_groups))\n        result.append(f\"Check outbound traffic to the VPC CIDR block '{vpc_cidr_block}':\")\n        result.extend(validate_segurity_groups(instance_security_groups, [vpc_cidr_block]))\n\n    return {\"Message\": \"\\n- \".join(result)}\n\n\ndef validate_segurity_groups(security_groups: List[str], destination: List[str]) -> List[str]:\n    https_port = 443\n    result = []\n    for security_group in security_groups:\n        try:\n            response = ec2_client.describe_security_groups(GroupIds=[security_group])\n        except ClientError as e:\n            raise RuntimeError(\n                f\"[ERROR] An error occurred while trying to describe the security group {security_group}: {str(e)}\"\n            ) from None\n\n        sgs_access_allowed = False\n        for sg in response.get(\"SecurityGroups\", []):\n            for rule in sg.get(\"IpPermissionsEgress\", []):\n                rule_access_allowed = False\n                if (\n                    (rule.get(\"IpProtocol\") == \"-1\")\n                    or (rule.get(\"FromPort\") == -1 and rule.get(\"ToPort\") == -1)\n                    or (https_port in range(rule.get(\"FromPort\"), rule.get(\"ToPort\") + 1))\n                ):\n                    for d in destination:\n                        if d.startswith(\"sg-\"):\n                            for group in rule.get(\"UserIdGroupPairs\", []):\n                                if d in group[\"GroupId\"]:\n                                    result.append(\n                                        f\"[OK] Instance security group '{security_group}' allows outbound traffic on port '{https_port}' to '{d}'.\"\n                                    )\n                                    rule_access_allowed = True\n                                    sgs_access_allowed = True\n                                    break\n                            else:\n                                result.append(\n                                    f\"[INFO] Instance security group '{security_group}' does not allow outbound traffic on port '{https_port}' to '{d}'.\"\n                                )\n\n                        else:\n                            destination_network = ip_network(d, strict=False)\n                            for cidr in rule.get(\"IpRanges\", []):\n                                source_network = ip_network(cidr[\"CidrIp\"], strict=False)\n                                if source_network.subnet_of(destination_network):  # type: ignore\n                                    result.append(\n                                        f\"[OK] VPC endpoint security group '{security_group}' allows outbound traffic on port '{https_port}' to '{d}'.\"\n                                    )\n                                    rule_access_allowed = True\n                                    sgs_access_allowed = True\n                                    break\n                            else:\n                                result.append(\n                                    f\"[INFO] Instance security group '{security_group}' does not allow outbound traffic on port '{https_port}' to '{d}'.\"\n                                )\n\n                if rule_access_allowed:\n                    break\n            else:\n                result.append(\n                    f\"[WARNING] Instance security group '{security_group}' does not allow outbound traffic on port '{https_port}'.\"\n                )\n\n    if not sgs_access_allowed:\n        result.append(\n            f\"[ERROR] Instance security groups '{', '.join(security_groups)}' does not allow outbound traffic on port '{https_port}'.\"\n        )\n\n    return result\n",
        "Handler": "script_handler",
        "Runtime": "python3.11"
      },
      "outputs": [
        {
          "Name": "Message",
          "Selector": "$.Payload.Message",
          "Type": "String"
        }
      ]
    },
    {
      "name": "CheckInstanceIAM",
      "description": "Checks if the IAM instance profile attached to the instance includes a managed policy that provides the required permissions. Additionally, checks the Default Host Management Configuration status of the account.",
      "action": "aws:executeScript",
      "onFailure": "Abort",
      "timeoutSeconds": 300,
      "maxAttempts": 2,
      "nextStep": "FinalOutput",
      "inputs": {
        "InputPayload": {
          "InstanceId": "{{ InstanceId }}"
        },
        "Script": "# Copyright 2023 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n# SPDX-License-Identifier: LicenseRef-.amazon.com.-AmznSL-1.0\n# Licensed under the Amazon Software License  http://aws.amazon.com/asl/\n\nfrom typing import List\n\nimport boto3\nfrom botocore.exceptions import ClientError\n\nssm_client = boto3.client(\"ssm\")\nec2_client = boto3.client(\"ec2\")\niam_client = boto3.client(\"iam\")\n\n\ndef script_handler(events, context):\n    instance_id = events[\"InstanceId\"]\n    result: List[str] = [\"5. Checks EC2 instance IAM profile and required permissions:\"]\n\n    instance_profile_name = get_instance_profile(instance_id)\n\n    dhmc_setting_id = \"/ssm/managed-instance/default-ec2-instance-management-role\"\n    result.append(\"Check Default Host Management Configuration:\")\n    dhmc_status = check_dhmc_status(dhmc_setting_id)\n    result.append(f\"[INFO] Default Host Management Configuration is {dhmc_status}.\")\n\n    if not instance_profile_name:\n        result.append(f\"[ERROR] No EC2 instance IAM profile attached to the instance: '{instance_id}'.\")\n        return {\"Message\": \"\\n- \".join(result)}\n\n    role_name = get_iam_role_from_profile_name(instance_profile_name)\n    managed_policies = get_attached_managed_policies(role_name)\n\n    result.append(f\"Check for AWS managed policies attached to the instance profile '{instance_profile_name}':\")\n    required_policy_assigned = check_required_managed_policies(managed_policies)\n\n    if required_policy_assigned:\n        result.append(\n            f\"[OK] Found an AWS managed policy attached to the instance profile '{instance_profile_name}' with required permissions.\"\n        )\n        return {\"Message\": \"\\n- \".join(result)}\n    else:\n        result.append(\n            f\"[INFO] Not found an AWS managed policy attached to the instance profile '{instance_profile_name}' with required permissions.\"\n        )\n\n    result.append(f\"Check for inline policies attached to the instance profile '{instance_profile_name}':\")\n    inline_policies = get_attached_inline_policies(role_name)\n\n    if inline_policies:\n        result.append(\n            f\"[INFO] Found inline policies attached to the instance profile '{instance_profile_name}'. Make sure the policies grant the required minimum permissions.\"\n        )\n    else:\n        result.append(f\"[ERROR] No permissions found attached to the EC2 instance profile '{instance_profile_name}'.\")\n\n    result.append(\"Troubleshooting reference:\")\n    result.append(\"For more information about setup instance permissions see:\")\n    result.append(\"https://docs.aws.amazon.com/systems-manager/latest/userguide/setup-instance-permissions.html\")\n    result.append(\"The minimum permissions for Systems Manager can be referenced from the AWS managed policy:\")\n    result.append(\"https://docs.aws.amazon.com/aws-managed-policy/latest/reference/AmazonSSMManagedInstanceCore.html\")\n\n    return {\"Message\": \"\\n- \".join(result)}\n\n\ndef check_required_managed_policies(managed_policies: list) -> bool:\n    managed_policies_list = [\n        \"AmazonSSMManagedInstanceCore\",\n        \"AmazonSSMFullAccess\",\n        \"AdministratorAccess\",\n        \"AmazonEC2RoleforSSM\",\n        \"AmazonSSMManagedEC2InstanceDefaultPolicy\",\n    ]\n    for policy in managed_policies:\n        if policy[\"PolicyName\"] in managed_policies_list:\n            return True\n\n    return False\n\n\ndef get_instance_profile(instance_id: str) -> str:\n    try:\n        response = ec2_client.describe_instances(InstanceIds=[instance_id])\n        instance_profile = response[\"Reservations\"][0][\"Instances\"][0].get(\"IamInstanceProfile\")\n        if instance_profile:\n            return instance_profile[\"Arn\"].split(\"/\")[-1]\n        else:\n            return \"\"\n\n    except ClientError as e:\n        raise RuntimeError(f\"[ERROR] Failed todescribe the EC2 instance {instance_id}: {str(e)}\") from None\n\n\ndef get_attached_managed_policies(role_name: str) -> list:\n    try:\n        response = iam_client.list_attached_role_policies(RoleName=role_name)\n        return response.get(\"AttachedPolicies\", [])\n    except ClientError as e:\n        raise RuntimeError(f\"[ERROR] Failed to list attached managed policies for {role_name}: {str(e)}\")\n\n\ndef get_iam_role_from_profile_name(instance_profile_name: str) -> str:\n    try:\n        response = iam_client.get_instance_profile(InstanceProfileName=instance_profile_name)\n        instanceprofile_in_response = response.get(\"InstanceProfile\")\n        for values in instanceprofile_in_response[\"Roles\"]:\n            role_name = values[\"RoleName\"]\n            return role_name\n        return \"\"\n    except ClientError as e:\n        raise RuntimeError(f\"[ERROR] Failed to get the role name from the instance profile: {str(e)}\")\n\n\ndef get_attached_inline_policies(role_name: str) -> bool:\n    try:\n        response = iam_client.list_role_policies(RoleName=role_name)\n        print(response)\n        if len(response.get(\"PolicyNames\", [])) == 0:\n            return False\n        else:\n            return True\n    except ClientError as e:\n        raise RuntimeError(f\"[ERROR] Failed to list inline policies for {role_name}: {str(e)}\")\n\n\ndef check_dhmc_status(dhmc_setting_id: str) -> str:\n    try:\n        response = ssm_client.get_service_setting(SettingId=dhmc_setting_id)\n        return response[\"ServiceSetting\"][\"Status\"]\n    except ClientError as e:\n        raise RuntimeError(f\"[ERROR] Failed to get the Default Host Management Configuration status: {str(e)}\")\n",
        "Handler": "script_handler",
        "Runtime": "python3.11"
      },
      "outputs": [
        {
          "Name": "Message",
          "Selector": "$.Payload.Message",
          "Type": "String"
        }
      ]
    },
    {
      "name": "FinalOutput",
      "description": "Generates the final output for the automation.",
      "action": "aws:executeScript",
      "onFailure": "Abort",
      "timeoutSeconds": 300,
      "maxAttempts": 2,
      "isEnd": true,
      "inputs": {
        "InputPayload": {
          "CheckVpcEndpoint": "{{ CheckVpcEndpoint.Message }}",
          "CheckRouteTable": "{{ CheckRouteTable.Message }}",
          "CheckNacl": "{{ CheckNacl.Message }}",
          "CheckInstanceSecurityGroup": "{{ CheckInstanceSecurityGroup.Message }}",
          "CheckInstanceIAM": "{{ CheckInstanceIAM.Message }}",
          "GetPingStatus": "{{ GetPingStatus.PingStatus }}"
        },
        "Script": "# Copyright 2023 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n# SPDX-License-Identifier: LicenseRef-.amazon.com.-AmznSL-1.0\n# Licensed under the Amazon Software License  http://aws.amazon.com/asl/\n\n\ndef script_handler(events, context):\n    # Capturing other steps output.\n\n    check_vpc_endpoint = events[\"CheckVpcEndpoint\"]\n    check_route_table = events[\"CheckRouteTable\"]\n    check_nacl = events[\"CheckNacl\"]\n    check_instance_security_group = events[\"CheckInstanceSecurityGroup\"]\n    check_instance_iam_role = events[\"CheckInstanceIAM\"]\n    get_ping_status = events[\"GetPingStatus\"]\n\n    if get_ping_status.lower() == \"online\":\n        return {\"Message\": \"EC2 instance is managed by Systems Manager.\"}\n\n    more_information = \"\\n- \".join(\n        [\n            \"6. Additional Troubleshooting:\",\n            \"Starting with the SSM Agent version 3.1.501.0, you can use the 'ssm-cli' tool to diagnose issues at the operating system level.\",\n            \"Troubleshooting managed node availability using ssm-cli:\",\n            \"https://docs.aws.amazon.com/systems-manager/latest/userguide/ssm-cli.html\",\n            \"Troubleshooting reference:\",\n            \"https://repost.aws/knowledge-center/systems-manager-ec2-instance-not-appear\",\n            \"https://docs.aws.amazon.com/systems-manager/latest/userguide/troubleshooting-ssm-agent.html\",\n        ]\n    )\n\n    return {\n        \"Message\": \"\\n\\n\".join(\n            [\n                check_vpc_endpoint,\n                check_route_table,\n                check_nacl,\n                check_instance_security_group,\n                check_instance_iam_role,\n                more_information,\n            ]\n        )\n    }\n",
        "Handler": "script_handler",
        "Runtime": "python3.11"
      },
      "outputs": [
        {
          "Name": "Message",
          "Selector": "$.Payload.Message",
          "Type": "String"
        }
      ]
    }
  ]
}
