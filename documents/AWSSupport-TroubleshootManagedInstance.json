{
  "description": "# AWSSupport-TroubleshootManagedInstance\n---\nThis automation document checks if the instance meets the prerequisites for EC2 Instances to come up as SSM Managed Instances. This documents runs checks related to VPC configuration like security group rules, VPC endpoints, Network ACL configuration,Route table and if IAM role is attached or not.  At the last, it shares information about SSM Agent troubleshooting kit which can be downloaded and run on the instances to check OS level issues in related to SSM agent. Supports both Windows and Linux.\n\n---\n\n### **Parameters**\n1.  **InstanceId**:\n\nType: StringList\n\nDescription: **(Required)** Provide the Instance Id. (e.g. i-05fa91429c6cdcb49)\n\n2.  **AutomationAssumeRole**:\n\nType: String\n\nDescription: **(Optional)** The ARN of the role that allows Automation to perform the actions on your behalf. If no role is specified, this document will use the permissions of the user that executes this document.\n\n",
  "schemaVersion": "0.3",
  "outputs": [
    "FinalOutput.output",
    "InstanceisOnline.output"
  ],
  "assumeRole": "{{ AutomationAssumeRole }}",
  "parameters": {
    "InstanceId": {
      "type": "String",
      "description": "(Required) Provide the Instance Id. (e.g. i-07330aca1eb7fecc6 )",
      "allowedPattern": "^[i]{0,1}-[a-z0-9]{8,17}$"
    },
    "AutomationAssumeRole": {
      "type": "String",
      "description": "(Optional)The ARN of the role that allows Automation to perform the actions on your behalf. If no role is specified,this document will use the permissions of the user that executes this document.",
      "allowedPattern": "^$|^arn:aws:iam::[0-9]*:role/[/\\w+=,.@-]+$",
      "default": ""
    }
  },
  "mainSteps": [
    {
      "name": "GetPingStatus",
      "action": "aws:executeAwsApi",
      "onFailure": "Abort",
      "nextStep": "IsInstanceAlreadyOnline",
      "inputs": {
        "Service": "ssm",
        "Api": "DescribeInstanceInformation",
        "Filters": [
          {
            "Key": "InstanceIds",
            "Values": [
              "{{ InstanceId }}"
            ]
          }
        ]
      },
      "outputs": [
        {
          "Name": "pingstatus",
          "Selector": "$.InstanceInformationList[0].PingStatus",
          "Type": "String"
        }
      ]
    },
    {
      "name": "IsInstanceAlreadyOnline",
      "action": "aws:branch",
      "onFailure": "Abort",
      "isCritical": "true",
      "inputs": {
        "Choices": [
          {
            "NextStep": "GetEC2InstanceProperties",
            "Not": {
              "Variable": "{{ GetPingStatus.pingstatus }}",
              "StringEquals": "Online"
            }
          }
        ],
        "Default": "InstanceisOnline"
      }
    },
    {
      "name": "GetEC2InstanceProperties",
      "action": "aws:executeAwsApi",
      "maxAttempts": 2,
      "onFailure": "Abort",
      "inputs": {
        "Service": "ec2",
        "Api": "DescribeInstances",
        "InstanceIds": [
          "{{ InstanceId }}"
        ]
      },
      "outputs": [
        {
          "Name": "SecurityGroupIds",
          "Selector": "$.Reservations[0].Instances[0].SecurityGroups..GroupId",
          "Type": "StringList"
        },
        {
          "Name": "SubnetId",
          "Selector": "$.Reservations[0].Instances[0].SubnetId",
          "Type": "String"
        },
        {
          "Name": "VpcId",
          "Selector": "$.Reservations[0].Instances[0].VpcId",
          "Type": "String"
        },
        {
          "Name": "PrivateIpAddress",
          "Selector": "$.Reservations[0].Instances[0].NetworkInterfaces[0].PrivateIpAddresses[0].PrivateIpAddress",
          "Type": "String"
        },
        {
          "Name": "InstanceProfile",
          "Selector": "$.Reservations[0].Instances[0].IamInstanceProfile.Arn",
          "Type": "String"
        },
        {
          "Name": "platform",
          "Selector": "$.Reservations[0].Instances[0].Platform",
          "Type": "String"
        }
      ],
      "nextStep": "CheckVpcEndpoint"
    },
    {
      "name": "CheckVpcEndpoint",
      "action": "aws:executeScript",
      "onFailure": "Abort",
      "nextStep": "CheckRouteTable",
      "inputs": {
        "Runtime": "python3.8",
        "Handler": "script_handler",
        "InputPayload": {
          "GetInstance": "{{InstanceId}}",
          "InstanceSGList": "{{GetEC2InstanceProperties.SecurityGroupIds}}",
          "EC2InstanceIPs": "{{ GetEC2InstanceProperties.PrivateIpAddress }}",
          "EC2InstanceSubnet": "{{ GetEC2InstanceProperties.SubnetId }}",
          "EC2VPC": "{{ GetEC2InstanceProperties.VpcId}}"
        },
        "Script": "def script_handler(events, context):\n    import boto3\n    import ipaddress\n    from ipaddress import ip_network,ip_address\n    from botocore.exceptions import ClientError,ParamValidationError\n    \n    #Getting current region\n    current_session = boto3.session.Session()\n    current_region = current_session.region_name\n    ssm_url = 'com.amazonaws.' + current_region + '.ssm'\n    \n    #Getting Instance Information#\n    Instance = events['GetInstance']\n    instance_security_groups = events['InstanceSGList']\n    subnetdetails = events['EC2InstanceSubnet']\n    instance_priv_ip = events['EC2InstanceIPs']\n    VPCdetails = events['EC2VPC']\n\n    https_port = 443\n    Results = \"\"\n    AWS_SG_DOC = '\\n For reference, Working with security groups - https://docs.aws.amazon.com/vpc/latest/userguide/VPC_SecurityGroups.html#WorkingWithSecurityGroups\\n\\n'\n    AWS_VPCE_DOC = '\\n For reference, Modifying an Interface endpoint -  https://docs.aws.amazon.com/vpc/latest/userguide/vpce-interface.html#create-interface-endpoint\\n\\n'\n\n    \n    vpce_security_groups = []\n    ec2 = boto3.client('ec2')\n    try:\n       results = ec2.describe_vpc_endpoints(Filters=[{'Name':'service-name','Values':[ssm_url]},{'Name':'vpc-id','Values':[VPCdetails]}])\n       if not results['VpcEndpoints']:\n        return {'output': '1. Checking for VPC Endpoints for SSM: \\n\\n' + ' No VPC endpoints for SSM available found for the same VPC as of the Instance: ' + VPCdetails + '. Instance can still connect to SSM Endoints if correct routes and NACL rules are configured to reach the ssm endpoints.\\n\\n', 'vpceid': \"Absent\" }\n       else:\n        print(' ')\n        print('VPC endpoint exist for the SSM service. Checking details of the vpc endpoint. ')\n        for items in results['VpcEndpoints']:\n         vpce_id = items['VpcEndpointId']\n         vpce_subnet = items['SubnetIds']\n         vpce_priv_dns = items['PrivateDnsEnabled']\n         allsg = items['Groups']\n         for vpcesg in allsg:\n          VpceSecurityGroupsdetails = vpcesg['GroupId']\n          vpce_security_groups.append(VpceSecurityGroupsdetails)\n    except ClientError as e:\n        raise Exception (\"[ERROR]\",e)\n        \n    list_vpce_security_groups = ','.join(vpce_security_groups)\n    list_vpce_subnet = ','.join(vpce_subnet)\n    \n    \n    Heading = '1. Checking for VPC Endpoints: \\n\\n'\n    Found = ' VPC endpoint for SSM Found: ' + vpce_id\n    vpcesubnets = '\\n  a. Subnets configured for the vpc endpoint found:' + list_vpce_subnet\n    vpcedns = '\\n  b. PrivateDNS is set as True or False? Answer: ' + str(vpce_priv_dns) + '. (Recommended to set as True.)'\n    vpcesg = '\\n  c. Security group attached to the vpc endpoints ' + list_vpce_security_groups\n    \n    if subnetdetails in vpce_subnet:\n        print('Subnet configured for VPC endpoint matches that of the instance. SSM agent on the instance will communicate to ssm endpoints via vpc endpoints network interfaces. Ensure PrivateDNS parameter is enabled.')\n        print('Checking the security group rules attached to the VPC endpoint ')\n        print(' ')       \n        print('...Results...')\n        for vpc_security_group in vpce_security_groups:\n            try:\n               response = ec2.describe_security_groups(GroupIds=[vpc_security_group])\n               for sg in response['SecurityGroups']:\n                   for rule in sg['IpPermissions']:\n                       if ((rule.get('IpProtocol') == '-1') or (rule.get('FromPort') == -1 and rule.get('ToPort') == -1) or (https_port in range(rule.get('FromPort'), rule.get('ToPort') +1))):\n                           for cidr in rule['IpRanges']:\n                               if ipaddress.ip_address(instance_priv_ip) in ip_network(cidr['CidrIp'], strict=False):\n                                   Results = '\\n\\n PASSED : VPC endpoint for SSM Exist: ' + vpce_id + ' . Ingress rules on Security groups of VPC endpoints allow traffic on port 443 from the Instance IP.\\n\\n'                            \n                                   print(Results)\n                                   finalresults = Heading + Found + vpcesubnets + vpcedns + vpcesg +  Results\n                                   return {'output': finalresults, 'vpceid': \"Present\" }\n                           for group in rule['UserIdGroupPairs']:\n                               if any(sg in group['GroupId'] for sg in instance_security_groups):\n                                   Results = '\\n\\n PASSED : VPC endpoint for SSM Exist: ' + vpce_id + ' . Ingress rules on Security groups of VPC endpoints allow traffic on port 443 from the Instances Security group.\\n\\n'\n                                   print(Results)\n                                   finalresults = Heading + Found + vpcesubnets + vpcedns + vpcesg +  Results\n                                   return {'output': finalresults, 'vpceid': \"Present\" }\n            except ClientError as e:\n               raise Exception (\"[ERROR]\",e)\n        if not Results.strip():\n            FailedResults = '\\n\\n FAILED : VPC Endpoints for SSM exist, ' + vpce_id + ' but Ingress rules on Security groups of VPC endpoints do not allow traffic on port 443 from the Instance.' + AWS_SG_DOC\n            print(FailedResults)\n            finalresultsfailed = Heading + Found + vpcesubnets + vpcedns + vpcesg +  FailedResults\n            return{'output': finalresultsfailed, 'vpceid': \"Present\"}\n    else:\n       print('...Results...')\n       FailedSubnetResults = '\\n\\n Warning : VPC endpoint for SSM exist, ' + vpce_id + ' but subnets associated with the VPC Endpoint does not include the subnet of instance. This can still work if the NACL rules are correct to allow traffic between the subnets on port 443. Or alternatively, you can add the Instance subnet ' + subnetdetails + ' to the VPC endpoint.' + AWS_VPCE_DOC\n       print(FailedSubnetResults)\n       finalresultssubnet = Heading + Found + vpcesubnets + vpcedns + vpcesg +  FailedSubnetResults\n       return {'output': finalresultssubnet, 'vpceid': \"Absent\" }\n"
      },
      "outputs": [
        {
          "Name": "output",
          "Selector": "$.Payload.output",
          "Type": "String"
        },
        {
          "Name": "vpceid",
          "Selector": "$.Payload.vpceid",
          "Type": "String"
        }
      ]
    },
    {
      "name": "CheckRouteTable",
      "action": "aws:executeScript",
      "onFailure": "Abort",
      "nextStep": "CheckNacl",
      "inputs": {
        "Runtime": "python3.8",
        "Handler": "script_handler",
        "InputPayload": {
          "GetInstance": "{{InstanceId}}",
          "EC2InstanceSubnet": "{{ GetEC2InstanceProperties.SubnetId }}"
        },
        "Script": "def script_handler(events, context):\n   import boto3\n   import json\n   from botocore.exceptions import ClientError,ParamValidationError\n\n   #Getting Instance Information#\n   Instance = events['GetInstance']\n   subnetdetails = events['EC2InstanceSubnet']\n   \n   ec2 = boto3.client('ec2')\n   try:\n      result = ec2.describe_route_tables(Filters=[{'Name':'association.subnet-id','Values':[subnetdetails]}])\n   except ClientError as e:\n      raise Exception (\"[ERROR] Failed to initialize EC2 client\",e)     \n\n   internet_route_list = []\n   cidr_for_local_list = []\n\n   for items in result['RouteTables']:\n    route_table_id = items['RouteTableId']\n    print('Route table found: ' + route_table_id)\n    AllRouteRules_list = items['Routes']\n    for routes_dict in AllRouteRules_list:\n     # 0.0.0.0/0 Routes  \n     if 'GatewayId' in routes_dict and 'DestinationCidrBlock' in routes_dict and routes_dict['DestinationCidrBlock'] == '0.0.0.0/0':\n      internet_route = routes_dict['GatewayId']\n      internet_route_list.append(internet_route)\n     elif 'NatGatewayId' in routes_dict and 'DestinationCidrBlock' in routes_dict and routes_dict['DestinationCidrBlock'] == '0.0.0.0/0':\n      internet_route = routes_dict['NatGatewayId']\n      internet_route_list.append(internet_route)\n     elif 'TransitGatewayId' in routes_dict and 'DestinationCidrBlock' in routes_dict and routes_dict['DestinationCidrBlock'] == '0.0.0.0/0':\n      internet_route = routes_dict['TransitGatewayId']\n      internet_route_list.append(internet_route)\n     elif 'NetworkInterfaceId' in routes_dict and 'DestinationCidrBlock' in routes_dict and routes_dict['DestinationCidrBlock'] == '0.0.0.0/0':\n      internet_route = routes_dict['NetworkInterfaceId']\n      internet_route_list.append(internet_route)\n     elif 'VpcPeeringConnectionId' in routes_dict and 'DestinationCidrBlock' in routes_dict and routes_dict['DestinationCidrBlock'] == '0.0.0.0/0':\n      internet_route = routes_dict['VpcPeeringConnectionId']\n      internet_route_list.append(internet_route)      \n     # Local Route \n     if 'GatewayId' in routes_dict and 'DestinationIpv6CidrBlock' not in routes_dict and routes_dict['GatewayId'] == 'local':\n      cidr_for_local = routes_dict['DestinationCidrBlock']\n      cidr_for_local_list.append(cidr_for_local)\n   print(' ')   \n   print('Analysing Route table entries for the Instance subnet ' + subnetdetails )\n   print(' ')\n   print('...Results...')\n   cidrforlocallist = ''.join(cidr_for_local_list)\n   LocalRoutes = ' PASSED : Local route available for ' + cidrforlocallist + '. If VPC endpoint for SSM is present, then Local route is used to communicate with VPC endpoint interface.'\n\n   if not internet_route_list:\n    AllOtherRoutes = ' WARNING :  No Route found for 0.0.0.0/0. If VPC endpoint is present, then this warning can be ignored as Local route will be used to communicate with vpc endpoints interface. If VPC endpoint is not present, then your network configuration must have open internet access so that ssm endpoints is reachable.'\n   else:\n    for items in internet_route_list:\n     if 'igw' in items:\n      OtherRoutes = ' PASSED : Internet gateway ' + items + ' is present and routing traffic towards 0.0.0.0/0. Hence, Internet availability is present on the Instance and ssm endpoints should be accesible.'\n      AllOtherRoutes = ''.join(OtherRoutes)\n     elif 'nat' in items:\n      OtherRoutes = ' PASSED : NAT gateway ' + items + ' is present and routing traffic towards 0.0.0.0/0. If Internet is not working, Check the NACL/Security Groups associated with ' + items + ' are configured correctly for internet access.'\n      AllOtherRoutes = ''.join(OtherRoutes)\n     elif 'eni-' in items:\n      OtherRoutes = ' WARNING : ENI ' + items + ' is present and routing traffic towards 0.0.0.0. This could be working as NAT Instance.If Internet is not working, Check the NACL/Security Groups associated with ' + items + ' are configured correctly for internet access.'\n      AllOtherRoutes = ''.join(OtherRoutes)\n     elif 'vgw' in items:\n      OtherRoutes = ' WARNING : 0.0.0.0/0 traffic is routed through the VPN connection ' + items +'.VPN routes must be configured for connectivity to SSM endpoints. Alternatively, you can use VPC endpoints for SSM.'\n      AllOtherRoutes = ''.join(OtherRoutes)\n     elif 'tgw' in items:\n      OtherRoutes = ' WARNING : 0.0.0.0/0 traffic is routed through transit gateway ' + items + '. Transit Gatway routes must be configured for connectivity to SSM endpoints. Alternatively, you can use VPC endpoints for SSM.'\n      AllOtherRoutes = ''.join(OtherRoutes)\n     elif 'pcx' in items:\n      OtherRoutes = ' WARNING : 0.0.0.0/0 traffic is routed through VPC peering instead ' + items + '. This may not have connectivity towards ssm endpoints. Your network configuration must have open internet access or you must have custom VPC Endpoints for SSM configured.'\n      AllOtherRoutes = ''.join(OtherRoutes)\n\n   Heading = \"2. Checking Route Table entries of the instance\\'s subnet : \\n\\n\"\n\n   Results = Heading + LocalRoutes + '\\n' + AllOtherRoutes + '\\n\\n'\n   return {'output': Results}\n"
      },
      "outputs": [
        {
          "Name": "output",
          "Selector": "$.Payload.output",
          "Type": "String"
        }
      ]
    },
    {
      "name": "CheckNacl",
      "action": "aws:executeScript",
      "onFailure": "Abort",
      "nextStep": "CheckInstanceSG",
      "inputs": {
        "Runtime": "python3.8",
        "Handler": "script_handler",
        "InputPayload": {
          "GetInstance": "{{InstanceId}}",
          "isVpceIdPresent": "{{CheckVpcEndpoint.vpceid}}",
          "EC2InstanceSubnet": "{{ GetEC2InstanceProperties.SubnetId }}"
        },
        "Script": "def script_handler(events, context):\n  import boto3\n  from botocore.exceptions import ClientError,ParamValidationError\n\n  #assigning variables\n  src_port_from = 1024\n  src_port_to = 65536\n  https_port = 443  \n  Instance = events['GetInstance']\n  vpceid = events['isVpceIdPresent']\n  subnetdetails = events['EC2InstanceSubnet']\n  Heading = \"3. Checking NACL rules of the instance subnet: \\n\\n\"\n\n  if vpceid == 'Present':\n   print(\"VPC Endpoint for SSM found: \" + vpceid)\n   Results = Heading + ' Skipped : VPC Endpoint for SSM is present. Skipping this test..\\n \\n'\n   return {'output': Results }\n  else:\n   print(\"VPC Endpoint for SSM is not found/\")  \n   \n  #Get Instance NACL entries/rules\n  ec2 = boto3.client('ec2')\n  try:\n     results = ec2.describe_network_acls(Filters=[{'Name':'association.subnet-id','Values':[subnetdetails]}])\n  except ClientError as e:\n     raise Exception (\"[ERROR] Failed to initialize EC2 client\",e)\n     \n  for rt in results['NetworkAcls']:\n   entries_list = rt['Entries']\n\n  egress_acls = [acl for acl in entries_list if acl['Egress']]\n  ingress_acls = [acl for acl in entries_list if not acl['Egress']]\n  \n  #Sorting the rules as per Rule number.\n  \n  sorted_egress_acls=sorted(egress_acls, key = lambda i: i['RuleNumber'])\n  sorted_ingress_acls=sorted(ingress_acls, key = lambda i: i['RuleNumber'])\n  \n  print(' ')\n  print('Evaluating NACL rules for the Instance subnet ' + subnetdetails)\n  print(' ')\n  print('...Results...')  \n  \n  #Check if the Port range provided is in the range of the NACL rule\n  def is_in_range(src_port_from, src_port_to,acl):\n    if ((acl.get('Protocol') == '-1') or (src_port_from  in range(acl['PortRange']['From'], acl['PortRange']['To'])) or (src_port_to in  range(acl['PortRange']['From'], acl['PortRange']['To']+1))):\n        return acl['RuleAction']\n        \n  \n  for acl in sorted_egress_acls:\n    if acl.get('CidrBlock') == '0.0.0.0/0': #Checking only for Anywhere Destination\n      rule_action = is_in_range(https_port,https_port,acl)\n      if rule_action is not None:\n          Egress_Access = rule_action\n          print(\"Egress rule for Port 443 is \" + rule_action)\n          break\n\n\n  for acl in sorted_ingress_acls:\n    if acl.get('CidrBlock') == '0.0.0.0/0': #Checking only for Anywhere source\n      rule_action = is_in_range(src_port_from,src_port_to,acl)\n      if rule_action is not None:\n          Ingress_Access = rule_action\n          print(\"Ingress rule for ephemeral ports \" + rule_action)\n          break\n\n\n  # For Egress\n  if Egress_Access == 'allow':\n    EgressResult = ' PASSED : Network Acl Egress Rules ALLOWS outbound traffic on port 443 towards 0.0.0.0/0.'  \n  else:\n   EgressResult = ' FAILED : Network Acl Egress Rules do not allow outbound traffic on port 443 towards 0.0.0.0/0'\n\n\n  # For Ingress\n  if Ingress_Access == 'allow':\n   IngressResult = ' PASSED : Network Acl Ingress Rules ALLOWS inbound traffic on ephemeral ports from 0.0.0.0/0'\n  else:\n   IngressResult = ' FAILED : Network Acl Ingress Rules do not allow Inbound traffic on  ephemeral ports from  0.0.0.0/0'\n  \n  Results = Heading + EgressResult + '\\n' + IngressResult + '\\n \\n'\n  return {'output': Results}\n"
      },
      "outputs": [
        {
          "Name": "output",
          "Selector": "$.Payload.output",
          "Type": "String"
        }
      ]
    },
    {
      "name": "CheckInstanceSG",
      "action": "aws:executeScript",
      "onFailure": "Abort",
      "nextStep": "CheckInstanceIAM",
      "inputs": {
        "Runtime": "python3.8",
        "Handler": "script_handler",
        "InputPayload": {
          "GetInstance": "{{InstanceId}}",
          "InstanceSGList": "{{GetEC2InstanceProperties.SecurityGroupIds}}"
        },
        "Script": "def script_handler(events, context):\n    import boto3\n    from botocore.exceptions import ClientError,ParamValidationError\n    \n    #Assigning static variables#\n    Instance = events['GetInstance']\n    list_instance_sg = events['InstanceSGList'] \n    https_port = 443\n    allowed_ip = []\n    Heading = \"4. Checking SGs of the instance for Port 443 outbound rule: \\n\\n\"\n    ec2 = boto3.client('ec2')\n\n    for security_group in list_instance_sg:\n        try:\n           response = ec2.describe_security_groups(GroupIds=[security_group])\n           for sg in response['SecurityGroups']:\n               for rule in sg['IpPermissionsEgress']:\n                   if ((rule.get('IpProtocol') == '-1') or (rule.get('FromPort') == -1 and rule.get('ToPort') == -1) or (https_port in range(rule.get('FromPort'), rule.get('ToPort') +1))):\n                       for cidr in rule['IpRanges']:\n                           if cidr['CidrIp'] == '0.0.0.0/0':\n                               SGResults = \" PASSED : Found Outbound Rule for TCP 443 to 0.0.0.0/0\\n\\n\"\n                               Results = Heading + SGResults \n                               return {'output': Results }\n           \n                   #if no rule found for 0.0.0.0/0, check further.\n           \n                   if ((rule.get('IpProtocol') == '-1') or (rule.get('FromPort') == -1 and rule.get('ToPort') == -1) or (https_port in range(rule.get('FromPort'), rule.get('ToPort') +1))):\n                       for cidr in rule['IpRanges']:\n                           if cidr['CidrIp'] != '0.0.0.0/0':\n                               cidr_ip = str(cidr['CidrIp'])\n                               allowed_ip.append(cidr_ip)\n        except ClientError as e:\n           raise Exception (\"[ERROR]\",e)        \n\n    if  allowed_ip:\n        SGResults = \" Warning: Restricted outbound rule for TCP 443 found to \" + str(allowed_ip) + '\\n\\n'\n        Results = Heading + SGResults     \n        return {'output': Results } \n    else:\n        SGResults = \" FAILED: No outbound rule for TCP 443 found.\\n\\n\"\n        Results = Heading + SGResults \n        return {'output': Results }\n\n                            \n"
      },
      "outputs": [
        {
          "Name": "output",
          "Selector": "$.Payload.output",
          "Type": "String"
        }
      ]
    },
    {
      "name": "CheckInstanceIAM",
      "action": "aws:executeScript",
      "onFailure": "Abort",
      "nextStep": "PlatformEvaluation",
      "inputs": {
        "Runtime": "python3.8",
        "Handler": "script_handler",
        "InputPayload": {
          "GetInstance": "{{InstanceId}}",
          "EC2InstanceProfile": "{{GetEC2InstanceProperties.InstanceProfile}}"
        },
        "Script": "def script_handler(events, context):\n\n   import boto3\n   from botocore.exceptions import ClientError,ParamValidationError\n   \n   def initialize_client(service):\n      try:\n        global client\n        client = boto3.client(service)\n      except ClientError as e:\n        raise Exception (\"[ERROR] Failed to initialize\" + service + \" client\",e)\n\n        \n   def get_iam_role(Name):\n      initialize_client('iam')\n      try:\n         response = client.get_instance_profile(InstanceProfileName=Name)\n         InstanceProfile_in_response = response.get('InstanceProfile')\n         for values in InstanceProfile_in_response['Roles']:\n             rolename = values['RoleName']\n             return rolename            \n      except ClientError as e:\n         raise Exception (\"[ERROR]\",e)  \n         \n   \n   def get_list_policy(ec2profile):\n      ec2profile_name = ec2profile.split(\"/\")[1]\n      AWS_SSM_IAM_DOC = '\\n For reference, follow steps provided here : https://docs.aws.amazon.com/systems-manager/latest/userguide/setup-instance-profile.html\\n'\n      Role = get_iam_role(ec2profile_name)   \n      try:\n         response = client.list_attached_role_policies(RoleName=Role)      \n         for policy in response['AttachedPolicies']:\n            if policy['PolicyName'] in ['AmazonSSMManagedInstanceCore', 'AmazonSSMFullAccess', 'AdministratorAccess', 'AmazonEC2RoleforSSM']:\n               found_policy = policy['PolicyName']\n               IAMResults = \" PASSED: Found Instance profile attached to the Instance: \" + ec2profile + \". AWS Managed policy,\" + found_policy + \" is attached to the Instance profile.\\n\"\n               break\n            else:            \n               IAMResults = \" Warning: Found Instance profile attached to the Instance \" + Instance + \" is \" + ec2profile + \". However, couldn't find AWS Managed policies for SSM attached to it. \\n Ensure existing attached policies have required ssm permissions. The minimum permissions for ssm can be referenced from the AWS Managed Policy,AmazonSSMManagedInstanceCore.\" + AWS_SSM_IAM_DOC\n         return IAMResults\n      except ClientError as e:\n         raise Exception (\"[ERROR] Failed to initialize IAM client\",e)    \n      \n   Instance = events['GetInstance']\n   InstanceProfile = events['EC2InstanceProfile']\n   substring = 'GetEC2InstanceProperties'\n   \n   AWS_SSM_IAM_DOC = '\\n For reference, follow steps provided here : https://docs.aws.amazon.com/systems-manager/latest/userguide/setup-instance-profile.html\\n'\n   \n   if substring in InstanceProfile:\n               NoInstanceprofile = \" FAILED : No Instance Profile  is attached to the instance, \" + Instance\n               IAMResults = NoInstanceprofile + \". Instance profile must be attached on the Instance with required ssm permissions. The minimum permissions for ssm can be referenced from the AWS Managed Policy,AmazonSSMManagedInstanceCore. This is a required step.\\n\" + AWS_SSM_IAM_DOC \n    \n   else:\n      IAMResults = get_list_policy(InstanceProfile)\n\n         \n   Heading = \"5. Checking if Instance Profile is attached : \\n\\n\"\n   Results = Heading + IAMResults\n   return {'output': Results}\n"
      },
      "outputs": [
        {
          "Name": "output",
          "Selector": "$.Payload.output",
          "Type": "String"
        }
      ]
    },
    {
      "name": "PlatformEvaluation",
      "action": "aws:branch",
      "onFailure": "Abort",
      "isCritical": "true",
      "inputs": {
        "Choices": [
          {
            "NextStep": "WindowsOsTroubleshooting",
            "Variable": "{{ GetEC2InstanceProperties.platform }}",
            "StringEquals": "windows"
          }
        ],
        "Default": "LinuxOsTroubleshooting"
      }
    },
    {
      "name": "LinuxOsTroubleshooting",
      "action": "aws:executeScript",
      "onFailure": "Abort",
      "nextStep": "FinalOutput",
      "inputs": {
        "Runtime": "python3.8",
        "Handler": "script_handler",
        "Script": "def script_handler(events, context):\n    import boto3\n\n    \n    Info = (\"\\n - - - - - - - - - - - - - - - - - - - \\n\"\n    \"\\n |     For Further Investigation     | \\n\"\n    \"\\n - - - - - - - - - - - - - - - - - - - \\n\"\n    \"\\n You can use SSMAgentToolkit-Linux to troubleshoot further for Operating system level problems. The SSMAgent-Toolkit is a bash script developed to run multiple checks to determined why a Linux EC2 instance does not come online as Managed Instance.\\n\\n\"\n    \"\\n You can run the following commands on your Linux Machine. This will download the SSMAgentToolkit-Linux Script and execute it. The output will show various tests ran and its results.\\n\"\n    \"\\n wget https://raw.githubusercontent.com/awslabs/aws-support-tools/master/Systems%20Manager/SSMAGENT-TOOLKIT-LINUX/ssmagent-toolkit-Linux.sh\"\n    \"\\n bash ssmagent-toolkit-Linux.sh > AWS-SSMtroubleshooting-output.txt\"\n    \"\\n cat AWS-SSMtroubleshooting-output.txt\"\n    \"\\n\\n# Reference : \\n\"\n    \" a. https://github.com/awslabs/aws-support-tools/tree/master/Systems%20Manager/SSMAGENT-TOOLKIT-LINUX \\n\"\n    \" b. https://aws.amazon.com/premiumsupport/knowledge-center/systems-manager-ec2-instance-not-appear/ \\n\\n\"\n    )\n\n    return {'output' : Info}\n\n\n"
      },
      "outputs": [
        {
          "Name": "output",
          "Selector": "$.Payload.output",
          "Type": "String"
        }
      ]
    },
    {
      "name": "WindowsOsTroubleshooting",
      "action": "aws:executeScript",
      "onFailure": "Abort",
      "nextStep": "FinalOutput",
      "inputs": {
        "Runtime": "python3.8",
        "Handler": "script_handler",
        "Script": "def script_handler(events, context):\n    import boto3\n\n    \n    Info = (\"\\n - - - - - - - - - - - - - - - - - - - \\n\"\n    \"\\n |     For Further Investigation     | \\n\"\n    \"\\n - - - - - - - - - - - - - - - - - - - \\n\"\n    \"\\n You can use SSMAgentToolkit-Windows to troubleshoot further for Operating system level problems. The SSMAgent-Toolkit is a set of PowerShell scripts developed to run multiple checks to determined why a Windows EC2 instance does not come online as Managed Instance.\\n\"\n    \"\\n Simply download the ZIP file included in the below package and extract. \"\n    \"\\n Package location : https://github.com/awslabs/aws-support-tools/tree/master/Systems%20Manager/SSMAgent-Toolkit-Windows\\n\"\n    \"\\n Change directory to the extracted folder and Run the followings as administrator in PowerShell.\"\n    \"\\n Import-Module .\\SSMAgent-Toolkit.psm1;Invoke-SSMChecks\\n\"\n    \"\\n\\n# Reference : \\n\"\n    \" a. https://github.com/awslabs/aws-support-tools/tree/master/Systems%20Manager/SSMAGENT-TOOLKIT-LINUX \\n\"\n    \" b. https://aws.amazon.com/premiumsupport/knowledge-center/systems-manager-ec2-instance-not-appear/ \\n\\n\"\n    )\n\n    return {'output' : Info}\n\n\n"
      },
      "outputs": [
        {
          "Name": "output",
          "Selector": "$.Payload.output",
          "Type": "String"
        }
      ]
    },
    {
      "name": "FinalOutput",
      "action": "aws:executeScript",
      "onFailure": "Abort",
      "isEnd": "true",
      "inputs": {
        "Runtime": "python3.8",
        "Handler": "script_handler",
        "InputPayload": {
          "Vpce": "{{CheckVpcEndpoint.output}}",
          "routetable": "{{CheckRouteTable.output}}",
          "nacl": "{{CheckNacl.output}}",
          "sg": "{{CheckInstanceSG.output}}",
          "iam": "{{CheckInstanceIAM.output}}",
          "linuxscript": "{{LinuxOsTroubleshooting.output}}",
          "windowsscript": "{{WindowsOsTroubleshooting.output}}"
        },
        "Script": "def script_handler(events, context):\n   import boto3\n   import json\n\n   #Capturing other steps output.\n   \n   Heading = \"Total Number of Tests: 5\\n\\n\"\n   vpceoutput = events['Vpce']\n   routetableoutput = events['routetable']\n   nacloutput = events['nacl']\n   sgoutput = events['sg']\n   iamoutput = events['iam']\n   linuxscriptoutput = events['linuxscript']\n   windowsscriptoutput = events['windowsscript']\n\n \n   if 'SSMAgentToolkit-Linux' in linuxscriptoutput:\n          Results = Heading + vpceoutput + routetableoutput  + nacloutput  + sgoutput  + iamoutput  + linuxscriptoutput\n   else:\n          Results = Heading + vpceoutput + routetableoutput  + nacloutput  + sgoutput  + iamoutput  + windowsscriptoutput\n       \n   return {'output': Results}\n\n\n\n\n\n"
      },
      "outputs": [
        {
          "Name": "output",
          "Selector": "$.Payload.output",
          "Type": "String"
        }
      ]
    },
    {
      "name": "InstanceisOnline",
      "action": "aws:executeScript",
      "onFailure": "Abort",
      "isEnd": "true",
      "inputs": {
        "Runtime": "python3.8",
        "Handler": "script_handler",
        "Script": "def script_handler(events, context):\n    import boto3\n    \n    Info = \"Instance is already Online under Fleet Manager.\"\n\n    return {'output' : Info}\n\n\n"
      },
      "outputs": [
        {
          "Name": "output",
          "Selector": "$.Payload.output",
          "Type": "String"
        }
      ]
    }
  ]
}
