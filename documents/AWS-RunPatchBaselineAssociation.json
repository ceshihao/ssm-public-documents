{
  "description": "Scans for or installs patches from a patch baseline to a Linux, Windows or MacOS operating system using the specified patch baseline names.",
  "mainSteps": [
    {
      "action": "aws:runPowerShellScript",
      "inputs": {
        "runCommand": [
          "# error code definitions",
          "$ERROR_CODE_GENERIC = -1",
          "$ERROR_CODE_TOO_MANY_REBOOTS_FAILURE = 3",
          "$ERROR_CODE_CANNOT_ACQUIRE_LOCK = 4",
          "$ERROR_CODE_PAYLOAD_BUCKET_ACCESS_DENIED = 14",
          "$ERROR_CODE_PAYLOAD_BUCKET_UNREACHABLE = 15",
          "$ERROR_CODE_CHECKSUM_MISMATCH = 16",
          "$ERROR_CODE_LOCAL_IO_ERROR = 17",
          "$ERROR_CODE_OS_OR_SSM_AGENT_VERSION = 18",
          "$ERROR_CODE_PAYLOAD_BUCKET_TLS = 21",
          "$ERROR_CODE_PAYLOAD_BUCKET_CERT_AUTH = 22",
          "$ERROR_MESSAGE_FORMAT = \"An error occurred when executing {0}: {1}`r`n\"",
          "",
          "# default generic error code if an error is thrown",
          "$global:ErrorCode = $ERROR_CODE_GENERIC",
          "",
          "# Check the OS version",
          "if ([Environment]::OSVersion.Version.Major -le 5) {",
          "\tWrite-Error 'This command is not supported on Windows 2003 or lower.'",
          "\texit $ERROR_CODE_OS_OR_SSM_AGENT_VERSION",
          "} elseif ([Environment]::OSVersion.Version.Major -ge 10) {",
          "    $sku = (Get-CimInstance -ClassName Win32_OperatingSystem).OperatingSystemSKU",
          "\tif ($sku -eq 143 -or $sku -eq 144) {",
          "\t\tWrite-Error 'This command is not supported on Windows 2016 Nano Server.'",
          "\t\texit $ERROR_CODE_OS_OR_SSM_AGENT_VERSION",
          "\t}",
          "}",
          "# Check the SSM agent version",
          "$ssmAgentService = Get-ItemProperty 'HKLM:SYSTEM\\CurrentControlSet\\Services\\AmazonSSMAgent\\'",
          "$ssmAgentVersion = $ssmAgentService.Version",
          "if (-not $ssmAgentVersion) {",
          "\t$ssmAgentPath = [IO.Path]::Combine([Environment]::GetEnvironmentVariable([Environment+SpecialFolder]::ProgramFiles), 'Amazon', 'SSM', 'amazon-ssm-agent.exe')",
          "\t$versionString = Invoke-Expression \"& `\"$ssmAgentPath`\" -version\"",
          "\t$ssmAgentVersion = $versionString.Split(':')[-1].trim()",
          "}",
          "if ($ssmAgentVersion -lt '2.0.834.0') {",
          "\tWrite-Error 'This command is not supported with SSM Agent version less than 2.0.834.0.'",
          "\texit $ERROR_CODE_OS_OR_SSM_AGENT_VERSION",
          "}",
          "",
          "# Application specific constants",
          "$appName = 'PatchBaselineOperations'",
          "$psModuleFileName = 'Amazon.PatchBaselineOperations.dll'",
          "$s3FileName = 'Amazon.PatchBaselineOperationsWindowsCrossAccount-1.27.zip'",
          "$s3FileHash = '46A76D361C1AD8CE33CB23900BCF48A0B4532E2454F11AEDA19E4BC75C3DE6DF'",
          "$psModuleHashes = @{",
          "    'AWSSDK.CognitoIdentity.dll' = '733B334501E9EC0D1D4999910E5384D26EF7B3113D37A4078B183887EB9C0057';",
          "    'AWSSDK.Core.dll' = '8A2E6E3463F38BB62B71840EB74ADD7532F8009AFDABDF18E7BD3F91ADEB0587';",
          "    'AWSSDK.Pinpoint.dll' = '300075578C54E803E596EB442136AC81B74D755E0AF90121241D566F30A964A1';",
          "    'AWSSDK.ResourceGroupsTaggingAPI.dll' = 'A34D218C5EF0B20A9EC5F37AD74E0AC185AB34D3B6E79918FC9148D6B0A59FCD';",
          "    'AWSSDK.S3.dll' = '4DDF0E3F05D945358C37AAE2BCCF089B48899D3FD1726963AF2153B7B597AE9F';",
          "    'AWSSDK.SecurityToken.dll' = 'E9ABA063F4701357F14865AB4856C9D27691766BA316C0D57AB4D5E97CED8B98';",
          "    'AWSSDK.SimpleSystemsManagement.dll' = '754EC925728F877F300F3E7C55EEEF82E14F4A4452697D68B426DCBAF71F38CD';",
          "    'Amazon.PatchBaselineOperations.dll' = '6280AAE85C3CD98D35A04B416F73A9C0D1408EFA7E716F75CA60715B8449C15D';",
          "    'Newtonsoft.Json.dll' = '0516D4109263C126C779E4E8F5879349663FA0A5B23D6D44167403E14066E6F9';",
          "    'THIRD_PARTY_LICENSES.txt' = '6468E28E2C9EDAF28E98B025EE95C936ED7493AEB19207C36525A5ED5AD4AA56';",
          "    'YamlDotNet.dll' = 'D59E777A42A965327FCC18FC0AB7FA6729C0BCF845D239AC2811BD78F73A7F70';",
          "",
          "}",
          "$lockFileName = 'C:\\ProgramData\\Amazon\\SSM\\patch-baseline-concurrent.lock'",
          "$lockFilePath = [IO.Path]::Combine([Environment]::GetEnvironmentVariable([Environment+SpecialFolder]::ProgramFiles), 'Amazon', $lockFileName)",
          "$commandId = $env:SSM_COMMAND_ID",
          "",
          "# Folders and Logging",
          "$tempDirectory = split-path -parent $MyInvocation.MyCommand.Definition",
          "$downloadPath = [IO.Path]::Combine($tempDirectory, $s3FileName)",
          "$psModuleInstallLocation = [IO.Path]::Combine([Environment]::GetEnvironmentVariable([Environment+SpecialFolder]::ProgramFiles), 'Amazon', $appName)",
          "$psModuleInstallFile = [IO.Path]::Combine($psModuleInstallLocation, $psModuleFileName)",
          "",
          "# Regional domain information. Not currently used by windows payload, but added here for completeness.",
          "# Use the \"$env:\" syntax because it only needs to be active for this process",
          "$Env:AWS_SSM_PATCHMANAGER_API_DOMAIN=\"amazonaws.com\"",
          "$Env:AWS_SSM_PATCHMANAGER_API_DOMAIN_DUALSTACK=\"api.aws\"",
          "",
          "function Acquire-FileLock {",
          "    param (",
          "        [System.IO.FileStream]$fileStream",
          "    )",
          "",
          "    try {",
          "        $fileStream.Lock(0, 0)",
          "        Write-Host \"Acquired lock on the lock file\"",
          "        return $fileStream",
          "    }",
          "    catch {",
          "        Write-Warning \"Cannot acquire lock on the lock file\"",
          "        return $null",
          "    }",
          "}",
          "",
          "function Release-FileLock {",
          "    param (",
          "        [System.IO.FileStream]$fileStream",
          "    )",
          "",
          "    if ($fileStream) {",
          "        $fileStream.Unlock(0, 0)",
          "        $fileStream.Close()",
          "        $fileStream.Dispose()",
          "        Write-Host \"Released lock on the lock file\"",
          "    }",
          "}",
          "",
          "function Try-CreateLockFile {",
          "    param (",
          "        [string]$commandId",
          "    )",
          "",
          "    try {",
          "        $fileStream = New-Object System.IO.FileStream -ArgumentList @(",
          "            $lockFilePath,",
          "            [System.IO.FileMode]::CreateNew,",
          "            [System.IO.FileAccess]::ReadWrite,",
          "            [System.IO.FileShare]::Read",
          "        )",
          "",
          "        $lockedStream = Acquire-FileLock -fileStream $fileStream",
          "        if (-not $lockedStream) {",
          "            return $null",
          "        }",
          "",
          "        $lockContent = @{",
          "            commandId = $commandId",
          "            createdAt = (Get-Date).ToUniversalTime().ToString(\"o\")",
          "            rebootCount = 0",
          "        } | ConvertTo-Json",
          "",
          "        $writer = New-Object System.IO.StreamWriter($fileStream)",
          "        $writer.WriteLine($lockContent)",
          "        $writer.Flush()",
          "",
          "        Write-Host \"Lock file $lockFilePath created: $lockContent\"",
          "        return $fileStream",
          "    }",
          "    catch {",
          "        Write-Warning \"Failed to create lock file: $_\"",
          "        return $null",
          "    }",
          "}",
          "",
          "function Test-LockFileForSameCommand {",
          "    param (",
          "        [string]$commandId",
          "    )",
          "",
          "    try {",
          "        $content = Get-Content $lockFilePath | ConvertFrom-Json",
          "        return $content.commandId -eq $commandId",
          "    }",
          "    catch {",
          "        Write-Error \"Cannot read lock file contents: $_\"",
          "        return $false",
          "    }",
          "}",
          "",
          "function Lock-ExistingFile {",
          "    try {",
          "        $fileStream = New-Object System.IO.FileStream -ArgumentList @(",
          "            $lockFilePath,",
          "            [System.IO.FileMode]::Open,",
          "            [System.IO.FileAccess]::ReadWrite,",
          "            [System.IO.FileShare]::Read",
          "        )",
          "        return (Acquire-FileLock -fileStream $fileStream)",
          "    }",
          "    catch {",
          "        Write-Warning \"Cannot lock existing file: $_\"",
          "        return $null",
          "    }",
          "}",
          "",
          "function Remove-LockFile {",
          "    Write-Debug \"Removing orphaned lock file $lockFilePath\"",
          "    Remove-Item -Path $lockFilePath -Force",
          "    Write-Host \"Patch concurrent lock file deleted\"",
          "}",
          "",
          "function Test-CanForciblyReacquireLock {",
          "    for ($i = 0; $i -lt 10; $i++) {",
          "        Write-Host \"Trying to forcibly reacquire lock. Attempt #$($i + 1)\"",
          "",
          "        try {",
          "            $existingLockCommandId = $null",
          "            $lockContent = Get-Content $lockFilePath | ConvertFrom-Json",
          "            $existingLockCommandId = $lockContent.commandId",
          "            Write-Host \"Existing lock command id: $existingLockCommandId\"",
          "        }",
          "        catch {",
          "            Write-Error \"Cannot determine if existing lock related to a running command, unable to read lock file contents: $_\"",
          "        }",
          "",
          "        $runningProcesses = Get-Process | Select @{",
          "            Name='CommandLine';",
          "            Expression={ (Get-CimInstance Win32_Process -Filter \"ProcessId = $($_.Id)\").CommandLine }",
          "        }",
          "        foreach ($process in $runningProcesses) {",
          "            if ([string]::IsNullOrEmpty($process.CommandLine)) { continue }",
          "            if ($process.CommandLine -match $commandId) { continue }",
          "            if ([string]::IsNullOrEmpty($existingLockCommandId)) { continue }",
          "            if ($process.CommandLine -match $existingLockCommandId) {",
          "                Write-Host \"Patching already running: $($process.CommandLine)\"",
          "                return $false",
          "            }",
          "        }",
          "",
          "        Start-Sleep -Seconds 30",
          "    }",
          "    return $true",
          "}",
          "",
          "# Check the lock file for the current reboot count. If there have been too many reboots, return $false,",
          "# otherwise increment the count and return $true. Intentionally does not call .Close(), to keep the",
          "# lockStream open. Uses the existing lockStream for read/write, since that stream is locked.",
          "function IncrementRebootCountAndCHeckIfCanContinue {",
          "\tparam (",
          "        [System.IO.FileStream]$lockStream",
          "    )",
          "",
          "\ttry {",
          "\t\t# reset stream position and read contents",
          "\t\t$lockStream.Position = 0",
          "\t\t$reader = New-Object System.IO.StreamReader($lockStream)",
          "\t\t$content = $reader.ReadToEnd() | ConvertFrom-Json",
          "",
          "\t\t$count = $content.rebootCount",
          "\t\tif ($count -ge 6) {",
          "\t\t\tWrite-Error \"Execution reboot count exceeded limit of 6, failing execution.\"",
          "\t\t\treturn $false",
          "\t\t}",
          "\t\telse {",
          "\t\t\t# on next document startup, this is the total number of reboots done so far",
          "\t\t\t$content.rebootCount = $count + 1",
          "",
          "\t\t\t# reset file stream to 0 and write content",
          "\t\t\t$lockStream.Position = 0",
          "\t\t\t$writer = New-Object System.IO.StreamWriter($lockStream)",
          "\t\t\t$writer.WriteLine(($content | ConvertTo-Json))",
          "\t\t\t$writer.Flush()",
          "",
          "\t\t\t# set new file length to current position",
          "\t\t\t$lockStream.SetLength($lockStream.Position)",
          "\t\t\t$lockStream.Flush()",
          "\t\t\treturn $true",
          "\t\t}",
          "\t}",
          "\tcatch {",
          "\t\t# this is very unlikely. we only call this method after openning the file stream and locking it",
          "\t\tWrite-Error \"Failed to check reboot count in lock file.\"",
          "\t\treturn $false",
          "\t}",
          "}",
          "",
          "$lockStream = $null",
          "",
          "if ($commandId) {",
          "    if (-not (Test-Path $lockFilePath)) {",
          "        Write-Host \"Initial try to acquire lock on the lock file\"",
          "        $lockStream = Try-CreateLockFile -commandId $commandId",
          "        if (-not $lockStream) {",
          "            Write-Host \"Cannot acquire lock on the lock file at initial try\"",
          "        }",
          "    }",
          "    else {",
          "        if (Test-LockFileForSameCommand -commandId $commandId) {",
          "            $lockStream = Lock-ExistingFile",
          "        }",
          "        else {",
          "            if (Test-CanForciblyReacquireLock) {",
          "                Remove-LockFile",
          "                $lockStream = Try-CreateLockFile -commandId $commandId",
          "            }",
          "        }",
          "    }",
          "",
          "    if (-not $lockStream) {",
          "        Write-Error \"Cannot acquire lock on $lockFilePath. Another patching operation is in progress.\"",
          "        exit $ERROR_CODE_CANNOT_ACQUIRE_LOCK",
          "    } else {",
          "\t\tif (-Not (IncrementRebootCountAndCHeckIfCanContinue -lockStream $lockStream)) {",
          "\t\t\tWrite-Host \"Releasing and removing lock file $lockFilePath\"",
          "\t\t\tRelease-FileLock -fileStream $lockStream",
          "\t\t\tRemove-Item -Path $lockFilePath -Force",
          "\t\t\texit $ERROR_CODE_TOO_MANY_REBOOTS_FAILURE",
          "\t\t}",
          "\t}",
          "} else {",
          "    Write-Warning \"Skipping concurrent lock file creation. SSM_COMMAND_ID env variable not set. Running with very old SSM agent versions. Upgrade SSM Agent to a newer version to enable concurrent patching execution detection.\"",
          "}",
          "",
          "function CheckFileHash ($filePath, $fileHash) {",
          "\tif (Test-Path($filePath)) {",
          "\t\t$fileStream = New-Object System.IO.FileStream($filePath, [System.IO.FileMode]::Open, [System.IO.FileAccess]::Read)",
          "\t\t$sha256 = [System.Security.Cryptography.HashAlgorithm]::Create('System.Security.Cryptography.SHA256CryptoServiceProvider')",
          "\t\t$sourceHash = [System.BitConverter]::ToString($sha256.ComputeHash($fileStream), 0).Replace('-', '').ToLowerInvariant()",
          "\t\t$sha256.Dispose()",
          "\t\t$fileStream.Dispose()",
          "",
          "\t\tif ($sourceHash -ne $fileHash) {",
          "\t\t\treturn $false",
          "\t\t}",
          "\t\telse {",
          "\t\t\treturn $true",
          "\t\t}",
          "\t}",
          "\telse {",
          "\t\treturn $false",
          "\t}",
          "}",
          "",
          "function CheckPowerShellModuleInstallation ([bool]$suppressError) {",
          "\t$isInstalled = $false",
          "\t# Path does not exist meaning it has never been downloaded.",
          "\tif (Test-Path($psModuleInstallLocation)) {",
          "\t\t# Check if the expected number of files and directories are in the folder",
          "\t\tif (((Get-ChildItem $psModuleInstallLocation -Directory | Measure-Object | %{$_.Count}) -eq 0) -and",
          "\t\t\t((Get-ChildItem $psModuleInstallLocation -File | Measure-Object | %{$_.Count}) -eq $psModuleHashes.Count)) {",
          "\t\t\t$validFileHashes = $true",
          "",
          "\t\t\t# Check each file for their expected file hash.",
          "\t\t\tGet-ChildItem $psModuleInstallLocation -File | ForEach-Object {",
          "\t\t\t\tif ($psModuleHashes.ContainsKey($_.Name)) {",
          "\t\t\t\t\t$installFile = [IO.Path]::Combine($psModuleInstallLocation, $_.Name)",
          "\t\t\t\t\tif (-Not (CheckFileHash $installFile $psModuleHashes[$_.Name])) {",
          "\t\t\t\t\t\tif (-Not $suppressError) {",
          "\t\t\t\t\t\t\tWrite-Error ('The SHA hash of the {0} file does not match the expected value.' -f $_.Name)",
          "\t\t\t\t\t\t}",
          "\t\t\t\t\t\t$validFileHashes = $false",
          "\t\t\t\t\t}",
          "\t\t\t\t} else {",
          "\t\t\t\t\tif (-Not $suppressError) {",
          "\t\t\t\t\t\tWrite-Error ('The PowerShellModule installation folder contains an unexpected file with name {0}.' -f $_.Name)",
          "\t\t\t\t\t}",
          "\t\t\t\t\t$validFileHashes = $false",
          "\t\t\t\t}",
          "\t\t\t}",
          "\t\t\t$isInstalled = $validFileHashes",
          "\t\t} else {",
          "\t\t\tif (-Not $suppressError) {",
          "\t\t\t\tWrite-Error ('An incorrect number of files were present in the PowerShellModule installation folder. The contents will be deleted.')",
          "\t\t\t}",
          "\t\t}",
          "\t\tif (-Not $isInstalled) {",
          "\t\t\t# Remove all files and folders as the folder contains potentially malicious software.",
          "\t\t\tRemove-Item $psModuleInstallLocation -Recurse",
          "\t\t}",
          "\t}",
          "",
          "\treturn $isInstalled",
          "}",
          "",
          "function ExtractZipCoreOs ([string]$zipFilePath, [string]$destPath) {",
          "\ttry {",
          "\t\t[System.Reflection.Assembly]::LoadWithPartialName('System.IO.Compression.FileSystem') | Out-Null",
          "\t\t$zip = [System.IO.Compression.ZipFile]::OpenRead($zipFilePath)",
          "\t\tforeach ($item in $zip.Entries) {",
          "\t\t\t$extractedPath = Join-Path $destPath $item.FullName",
          "",
          "\t\t\tif ($item.Length -eq 0) {",
          "\t\t\tif ((Test-Path $extractedPath) -eq 0) {",
          "\t\t\t\tmkdir $extractedPath | Out-Null",
          "\t\t\t}",
          "\t\t\t} else {",
          "\t\t\t$fileParent = Split-Path $extractedPath",
          "",
          "\t\t\tif ((Test-Path $fileParent) -eq 0) {",
          "\t\t\t\tmkdir $fileParent | Out-Null",
          "\t\t\t}",
          "",
          "\t\t\t[System.IO.Compression.ZipFileExtensions]::ExtractToFile($item, $extractedPath, $true)",
          "\t\t\t}",
          " \t\t}",
          "\t} catch {",
          "\t\t$global:ErrorCode = $ERROR_CODE_LOCAL_IO_ERROR",
          "\t\tthrow (\"Error encountered when extracting patch management zip file: {0}\" -f $_.Exception.Message)",
          "\t} finally {",
          "\t\t$zip.Dispose()",
          "\t}",
          "}",
          "",
          "# Hash of bucket digest",
          "function Get-HashString([String]$InString) {",
          "\t$StringBuilder = New-Object System.Text.StringBuilder",
          "\t[System.Security.Cryptography.HashAlgorithm]::Create(\"SHA256\").ComputeHash([System.Text.Encoding]::UTF8.GetBytes($InString)) | ForEach-Object {",
          "\t[Void]$StringBuilder.Append($_.ToString(\"x2\"))",
          "\t}",
          "\treturn $StringBuilder.ToString()",
          "}",
          "",
          "function MakeWebClient {",
          "\tparam(",
          "\t\t[boolean] $addUserAgentHeader",
          "\t)",
          "",
          "\t# Add Tls 1.2 support.",
          "\t[Net.ServicePointManager]::SecurityProtocol = [Net.ServicePointManager]::SecurityProtocol -bOr [Net.SecurityProtocolType]::Tls12",
          "\t$webClient = New-Object Net.WebClient",
          "",
          "\tif ($addUserAgentHeader) {",
          "\t\t# Get environment variables with fallback to \"<missing>\"",
          "\t\t$instanceId = if ($env:AWS_SSM_INSTANCE_ID) { $env:AWS_SSM_INSTANCE_ID } else { \"<missing>\" }",
          "\t\t$ssmCommandId = if ($env:SSM_COMMAND_ID) { $env:SSM_COMMAND_ID } else { \"<missing>\" }",
          "",
          "\t\t# Get PowerShell version",
          "\t\t$downloadAgent = \"PowerShell/$($PSVersionTable.PSVersion.ToString())\"",
          "",
          "\t\t# Create user agent header in same format as Python version",
          "\t\t$userAgent = \"RPB(instance_id=$instanceId; ssm_command_id=$ssmCommandId; download_agent=$downloadAgent)\"",
          "\t\t$webClient.Headers.Add(\"User-Agent\", $userAgent)",
          "\t}",
          "",
          "\treturn $webClient",
          "}",
          "",
          "function DownloadToFile {",
          "\tparam(",
          "\t\t[String] $appName,",
          "\t\t[String] $s3Location,",
          "\t\t[String] $downloadPath",
          "\t)",
          "\tWrite-Host (\"Downloading {0} PowerShell module from {1} to {2}.`r`n\" -f $appName, $s3Location, $downloadPath)",
          "\t$webClientWithUserAgent = MakeWebClient -addUserAgentHeader $true",
          "\ttry {",
          "\t\t$webClientWithUserAgent.DownloadFile($s3Location, $downloadPath)",
          "\t} catch {",
          "\t\tWrite-Host (\"Call with custom user agent failed. Retry downloading {0} PowerShell module from {1} to {2} without setting user agent`r`n\" -f $appName, $s3Location, $downloadPath)",
          "",
          "\t\t$webClient = MakeWebClient -addUserAgentHeader $false",
          "\t\t$webClient.DownloadFile($s3Location, $downloadPath)",
          "\t}",
          "}",
          "function DownloadToFileWithFallbacks {",
          "\tparam(",
          "\t\t[String] $appName,",
          "\t\t[String] $s3Location,",
          "\t\t[String] $downloadPath,",
          "\t\t[boolean] $retryWithoutDualstack = $true",
          "\t)",
          "\ttry {",
          "\t\tDownloadToFile $appName $s3Location $downloadPath",
          "\t} catch {",
          "\t\t$pattern = \".dualstack.\"",
          "\t\tif (-not ($s3Location -match $pattern)) {",
          "\t\t\tthrow",
          "\t\t}",
          "\t\tif (-not $retryWithoutDualstack) {",
          "\t\t\tWrite-Host (\"Download attempt from dualstack URL failed, but retryWithoutDualstack is false so I am failing now.\")",
          "\t\t\tthrow",
          "\t\t}",
          "\t\tWrite-Host (\"Download failed. I will retry without dualstack.\")",
          "\t\t$standardUrl = $s3Location -replace $pattern, \".\"",
          "\t\tDownloadToFile $appName $standardUrl $downloadPath",
          "\t}",
          "}",
          "",
          "function GetUseDualStackSetting {",
          "\tif ($env:AWS_SSM_USE_DUALSTACK_ENDPOINT) {",
          "\t\t$value = $env:AWS_SSM_USE_DUALSTACK_ENDPOINT",
          "\t\tWrite-Host (\"Found use_dual_stack configuration in environment variables (AWS_SSM_USE_DUALSTACK_ENDPOINT={0})\" -f $value)",
          "\t\tif ($value -eq \"true\") {",
          "\t\t\treturn $true",
          "\t\t} else {",
          "\t\t\treturn $false",
          "\t\t}",
          "\t}",
          "\tWrite-Host (\"Could not find a use_dual_stack configuration anywhere\")",
          "\treturn $false",
          "}",
          "",
          "function InstallPowerShellModule {",
          "\tif (-Not (CheckPowerShellModuleInstallation $true)) {",
          "\t\tWrite-Host (\"Preparing to download {0} PowerShell module from S3.`r`n\" -f $appName)",
          "",
          "\t\t#Setup the directories if they do not exist.",
          "\t\tif (-Not (Test-Path($psModuleInstallLocation))) {",
          "\t\t\t$noOp = New-Item $psModuleInstallLocation -ItemType Directory",
          "\t\t}",
          "",
          "\t\tif (-Not (Test-Path($tempDirectory))) {",
          "\t\t\t$noOp = New-Item $tempDirectory -ItemType Directory",
          "\t\t}",
          "\t\t$s3Path = $appName.ToLower() + '/crossaccount/payloads/' + $s3FileName",
          "",
          "\t\t# Region Specific Payload S3 Bucket Location",
          "\t\t$useDualStack = GetUseDualStackSetting",
          "\t\tWrite-Host (\"use_dual_stack = {0}\" -f $useDualStack)",
          "\t\t# This is a hack to never use dualstack when the CFN stack parameter is not set",
          "\t\tif ($useDualStack -and 's3.dualstack.us-east-1.amazonaws.com/aws-ssm-us-east-1') {",
          "\t\t\t$s3DualStackLocation = 'https://s3.dualstack.us-east-1.amazonaws.com/aws-ssm-us-east-1/' + $s3Path",
          "\t\t\tWrite-Host \"downloading from dualstack payload location...\"",
          "\t\t\tDownloadToFileWithFallbacks $appName $s3DualStackLocation $downloadPath -retryWithoutDualstack $false",
          "\t\t} else {",
          "\t\t\tWrite-Host \"downloading from standard payload location...\"",
          "\t\t\t$s3Location = 'https://s3.amazonaws.com/aws-ssm-us-east-1/' + $s3Path",
          "\t\t\tDownloadToFileWithFallbacks $appName $s3Location $downloadPath -retryWithoutDualstack $true",
          "\t\t}",
          "",
          "\t\tif (CheckFileHash $downloadPath $s3FileHash ) {",
          "\t\t\tWrite-Output (\"Extracting {0} zip file contents to temporary folder.`r`n\" -f $appName)",
          "\t\t\ttry {",
          "\t\t\t(New-Object -Com Shell.Application).namespace($psModuleInstallLocation).CopyHere((New-Object -Com Shell.Application).namespace($downloadPath).Items(), 16)",
          "\t\t\t} catch [Exception] {",
          "\t\t\tExtractZipCoreOs $downloadPath $psModuleInstallLocation",
          "\t\t\t}",
          " \t\t}",
          "\t\telse {",
          "\t\t\t$global:ErrorCode = $ERROR_CODE_CHECKSUM_MISMATCH",
          "\t\t\tthrow ('The SHA hash of the {0} S3 source file does not match the expected value.' -f $appName)",
          "\t\t}",
          "",
          "\t\tWrite-Output (\"Verifying SHA 256 of the {0} PowerShell module files.`r`n\" -f $appName)",
          "\t\tif (-Not (CheckPowerShellModuleInstallation $false)) {",
          "\t\t\t$global:ErrorCode = $ERROR_CODE_CHECKSUM_MISMATCH",
          "\t\t\tthrow ('The verification of the {0} PowerShell module did not pass.' -f $appName)",
          "\t\t}",
          "\t\tWrite-Output (\"Successfully downloaded and installed the {0} PowerShell module.`r`n\" -f $appName)",
          "\t} else {",
          "\t\tWrite-Output (\"Powershell module is already installed.\")",
          "\t}",
          "}",
          "",
          "try {",
          "\tInstallPowerShellModule",
          "} catch [System.Net.WebException] {",
          "\t$errorMessage = $_.Exception.Message",
          "\t$responseCode = $_.Exception.Response.StatusCode",
          "",
          "\t$msg = $ERROR_MESSAGE_FORMAT -f $appName, $_.Exception.Message",
          "\tWrite-Error $msg",
          "",
          "\tif ($errorMessage.Contains('Could not create SSL/TLS secure channel') -or (($responseCode -ne $null) -and ('SecureChannelFailure' -eq $responseCode.ToString()))) {",
          "\t\texit $ERROR_CODE_PAYLOAD_BUCKET_TLS",
          "\t} elseif ($errorMessage.Contains('Could not establish trust relationship for the SSL/TLS secure channel') -or (($responseCode -ne $null) -and ('TrustFailure' -eq $responseCode.ToString()))) {",
          "\t\texit $ERROR_CODE_PAYLOAD_BUCKET_CERT_AUTH",
          "\t} elseif ($errorMessage.Contains('Unable to connect to the remote server') -or $errorMessage.Contains('The remote name could not be resolved')) {",
          "\t\texit $ERROR_CODE_PAYLOAD_BUCKET_UNREACHABLE",
          "\t} elseif (($responseCode -ne $null) -and ('NotFound' -eq $responseCode.ToString())) {",
          "\t\texit $ERROR_CODE_PAYLOAD_BUCKET_UNREACHABLE",
          "\t} elseif (($responseCode -ne $null) -and ('Forbidden' -eq $responseCode.ToString())) {",
          "\t\texit $ERROR_CODE_PAYLOAD_BUCKET_ACCESS_DENIED",
          "\t} else {",
          "\t\texit $ERROR_CODE_GENERIC;",
          "\t}",
          "} catch [Exception] {",
          "\t$msg = $ERROR_MESSAGE_FORMAT -f $appName, $_.Exception.Message",
          "\tWrite-Error $msg",
          "\texit $global:ErrorCode",
          "} finally {",
          "\tif (Test-Path $downloadPath) {",
          "\t\trm $downloadPath",
          "\t}",
          "}",
          "",
          "#setup the command",
          "import-module $psmoduleinstallfile",
          "$response = Invoke-PatchBaselineOperationCrossAccount -Operation {{Operation}} -BaselineTag '{{BaselineTags}}' -AssociationId '{{AssociationId}}' -InstallOverrideList '{{InstallOverrideList}}' -RebootOption '{{RebootOption}}' -InstanceId $env:AWS_SSM_INSTANCE_ID -Region $env:AWS_SSM_REGION_NAME",
          "",
          "if ($lockStream) {",
          "    Release-FileLock -fileStream $lockStream",
          "    Write-Host \"Lock released after operation completion\"",
          "}",
          "",
          "if ($response.exitcode -ne 3010)",
          "{",
          "\t$response.tostring()",
          "",
          "    function Test-LockFileForSameCommand {",
          "        param(",
          "            [string]$commandId",
          "        )",
          "",
          "        try {",
          "            if (Test-Path $lockFilePath) {",
          "                $lockContent = Get-Content $lockFilePath | ConvertFrom-Json",
          "                return $lockContent.commandId -eq $commandId",
          "            }",
          "            return $false",
          "        }",
          "        catch {",
          "\t\t    Write-Host \"Cannot remove lock file, unable to read lock file contents at $lockFilePath. $_\"",
          "            return $false",
          "        }",
          "    }",
          "",
          "    if ($commandId -and (Test-LockFileForSameCommand -commandId $commandId)) {",
          "\t\tWrite-Host \"Removing lock file $lockFilePath\"",
          "        Remove-Item -Path $lockFilePath -Force",
          "\t\tWrite-Host \"Patch concurrent lock file deleted\"",
          "    }",
          "}",
          "",
          "exit $response.exitcode"
        ],
        "timeoutSeconds": 7200
      },
      "name": "PatchWindows",
      "precondition": {
        "StringEquals": [
          "platformType",
          "Windows"
        ]
      }
    },
    {
      "action": "aws:runShellScript",
      "inputs": {
        "runCommand": [
          "#!/bin/bash",
          "PYTHON_CMD=''",
          "",
          "ERROR_CODE_PYTHON_MISSING=13",
          "ERROR_CODE_PYTHON_VERSION=16",
          "",
          "check_binary() {",
          "    HAS_VAR_NAME=HAS_$2",
          "    CMD_VAR_NAME=$2_CMD",
          "    if [ \"$(eval echo \\${${HAS_VAR_NAME}})\" = \"0\" ]; then return; fi",
          "    which $1 2>/dev/null",
          "    RET_CODE=$?",
          "    eval \"${HAS_VAR_NAME}=${RET_CODE}\"",
          "    if [ ${RET_CODE} -eq 0 ]; then eval \"${CMD_VAR_NAME}=$1\"; fi",
          "}",
          "",
          "check_binary python3 PYTHON3",
          "check_binary python2.6 PYTHON2_6",
          "check_binary python26 PYTHON26",
          "check_binary python2.7 PYTHON2_7",
          "check_binary python27 PYTHON27",
          "check_binary python2 PYTHON2",
          "",
          "which python 2>/dev/null",
          "if [ $? -eq 0 ]; then",
          "  PYTHON_VERSION=$(python --version 2>&1 | grep -Po '(?<=Python )[\\d]')",
          "  eval \"HAS_PYTHON${PYTHON_VERSION}=0\"",
          "  eval \"PYTHON${PYTHON_VERSION}_CMD='python'\"",
          "fi",
          "",
          "check_binary apt-get APT",
          "check_binary yum YUM",
          "check_binary dnf DNF",
          "check_binary zypper ZYPP",
          "",
          "check_install_code() {",
          "    if [ $1 -ne 0 ]",
          "    then",
          "        echo \"WARNING: Could not install the $2, this may cause the patching operation to fail.\" >&2",
          "    fi",
          "}",
          "",
          "CANDIDATES=( $HAS_PYTHON2_6 $HAS_PYTHON26 $HAS_PYTHON2_7 $HAS_PYTHON27 $HAS_PYTHON2 )",
          "HAS_ANY_PYTHON2=1",
          "for CANDIDATE in \"${CANDIDATES[@]}\"",
          "do",
          "    if [ $CANDIDATE -eq 0 ]",
          "    then",
          "        HAS_ANY_PYTHON2=0",
          "    fi",
          "done",
          "",
          "if [ $HAS_PYTHON3 -eq 1 -a $HAS_ANY_PYTHON2 -eq 1 ]; then",
          "    echo \"Unable to find python.\" 1>&2",
          "    exit $ERROR_CODE_PYTHON_MISSING",
          "fi",
          "",
          "check_instance_is_debian_8() {",
          "    if [ -f /etc/os-release ] && grep \"ID=debian\" /etc/os-release >/dev/null; then",
          "        IS_DEBIAN=true",
          "        if grep 'VERSION_ID=\"8\"' /etc/os-release >/dev/null; then",
          "            IS_DEBIAN_8=true",
          "        fi",
          "    fi",
          "}",
          "check_if_debian_signing_key_exist() {",
          "    MISSING_KEY=0",
          "    if [ \"$HAS_APT_KEY\" = \"0\" ] && (apt-key list | grep -w 8AE22BA9) > /dev/null; then",
          "      MISSING_KEY=1",
          "    fi",
          "}",
          "prepare_instance_if_debian_8() {",
          "    KEY_IMPORTED=0",
          "    COMMENTED_OUT_BACKPORTS=0",
          "    check_instance_is_debian_8",
          "    if [ ! -z $IS_DEBIAN ] && [ ! -z $IS_DEBIAN_8 ]; then",
          "        HAS_APT_KEY=1",
          "        check_binary apt-key APT_KEY",
          "        check_if_debian_signing_key_exist",
          "        if [ \"$HAS_APT_KEY\" = \"0\" ]; then",
          "            if [ \"$MISSING_KEY\" = \"0\" ]; then",
          "                apt-key adv --keyserver keyserver.ubuntu.com --recv-keys AA8E81B4331F7F50 >/dev/null 2>&1",
          "                KEY_IMPORTED=1",
          "                echo \"Imported missing signing key: AA8E81B4331F7F50\"",
          "            else",
          "                echo \"Skip to synchronize pakcage index for DEBIAN 8 instance. \"",
          "            fi",
          "        else",
          "            echo \"Could not locate apt-key.\"",
          "        fi",
          "        if [ -f /etc/apt/sources.list.d/backports.list ]; then",
          "            if grep -i \"^#[[:space:]]*deb http://cloudfront.debian.net/debian jessie-backports main\" /etc/apt/sources.list.d/backports.list >/dev/null;then",
          "                echo \"Already commented out jessie backports\"",
          "            else",
          "                sed -e \"/jessie-backports main/ s/^#*/#/\" -i /etc/apt/sources.list.d/backports.list",
          "                COMMENTED_OUT_BACKPORTS=1",
          "            fi",
          "        fi",
          "        echo \"Synchronizing pakcage index for DEBIAN 8 instance\"",
          "        apt-get update >/dev/null",
          "    fi",
          "}",
          "",
          "clean_up_instances_if_debian_8() {",
          "    if [ \"$KEY_IMPORTED\" = \"1\" ]; then",
          "        apt-key del 8AE22BA9 > /dev/null",
          "    fi",
          "    if [ \"$COMMENTED_OUT_BACKPORTS\" = \"1\" ]; then",
          "        sudo sed -e '/jessie-backports main/ s/^#//g' -i /etc/apt/sources.list.d/backports.list",
          "    fi",
          "}",
          "",
          "if [ $HAS_APT -eq 0 -a $HAS_PYTHON3 -eq 0 ]",
          "then",
          "    PYTHON_CMD=${PYTHON3_CMD}",
          "    prepare_instance_if_debian_8",
          "    apt update",
          "    apt-get install python3-apt -y",
          "    check_install_code $? \"python3-apt\"",
          "",
          "elif  [ $HAS_DNF -eq 0 ] && [ $HAS_PYTHON2 -eq 0 -o $HAS_PYTHON3 -eq 0 ]",
          "then",
          "    if [ $HAS_PYTHON3 -eq 0 ]",
          "    then",
          "        PYTHON_CMD=${PYTHON3_CMD}",
          "    elif [ $HAS_PYTHON2 -eq 0 ]",
          "    then",
          "        PYTHON_CMD=${PYTHON2_CMD}",
          "    fi",
          "",
          "elif [ $HAS_YUM -eq 0 -a $HAS_ANY_PYTHON2 -eq 0 ]",
          "then",
          "",
          "    HAS_COMPATIBLE_YUM=false",
          "",
          "    INSTALLED_PYTHON=( $PYTHON2_7_CMD $PYTHON27_CMD $PYTHON2_CMD $PYTHON2_6_CMD $PYTHON26_CMD  )",
          "    for TEST_PYTHON_CMD in \"${INSTALLED_PYTHON[@]}\"",
          "    do",
          "        ${TEST_PYTHON_CMD} -c \"import yum\" 2>/dev/null",
          "        if [ $? -ne 0 ]; then",
          "            echo \"Unable to import yum module on $TEST_PYTHON_CMD\" 1>&2",
          "        else",
          "            PYTHON_CMD=${TEST_PYTHON_CMD}",
          "            HAS_COMPATIBLE_YUM=true",
          "            break",
          "        fi",
          "    done",
          "    if ! $HAS_COMPATIBLE_YUM; then",
          "        echo \"Unable to import yum module, please check version compatibility between Yum and Python\" 1>&2",
          "        exit $ERROR_CODE_PYTHON_VERSION",
          "    else",
          "        YUM_VERSION=$(yum --version 2>/dev/null | sed -n 1p)",
          "        echo \"Using Yum version: $YUM_VERSION\"",
          "    fi",
          "",
          "elif [ $HAS_ZYPP -eq 0 -a $HAS_PYTHON3 -eq 0 ]",
          "then",
          "    PYTHON_CMD=${PYTHON3_CMD}",
          "elif [ $HAS_ZYPP -eq 0 -a $HAS_PYTHON2 -eq 0 ]",
          "then",
          "    PYTHON_CMD=${PYTHON2_CMD}",
          "else",
          "    echo \"An unsupported package manager and python version combination was found.\" 1>&2",
          "    if [ $HAS_DNF -eq 0 ]",
          "    then",
          "        echo \"Dnf requires Python2 or Python3 to be installed.\" 1>&2",
          "    elif [ $HAS_YUM -eq 0 ]",
          "    then",
          "        echo \"Yum requires Python2 to be installed.\" 1>&2",
          "    elif [ $HAS_APT -eq 0 ]",
          "    then",
          "        echo \"Apt requires Python3 to be installed.\" 1>&2",
          "    elif [ $HAS_ZYPP -eq 0 ]",
          "    then",
          "        echo \"ZYpp requires Python2 or Python3 to be installed.\" 1>&2",
          "    fi",
          "    echo \"Python3=$HAS_PYTHON3, Python2=$HAS_ANY_PYTHON2, Yum=$HAS_YUM, Apt=$HAS_APT, Zypper=$HAS_ZYPP, Dnf=$HAS_DNF\" 1>&2",
          "    echo \"Exiting...\" 1>&2",
          "    exit $ERROR_CODE_PYTHON_VERSION",
          "fi",
          "",
          "echo \"Using python binary: '${PYTHON_CMD}'\"",
          "PYTHON_VERSION=$(${PYTHON_CMD} --version  2>&1)",
          "PYTHON_DECIMAL_VERSION=$(${PYTHON_CMD} --version  2>&1 | grep -Po '(?<=Python )[\\d].[\\d]+')",
          "export PYTHON_MAJOR_VERSION=$(echo $PYTHON_DECIMAL_VERSION | cut -d. -f1)",
          "export PYTHON_MINOR_VERSION=$(echo $PYTHON_DECIMAL_VERSION | cut -d. -f2)",
          "echo \"Using Python Version: $PYTHON_VERSION\"",
          "",
          "# Supply these for the payload to (optionally) consume",
          "export AWS_SSM_PATCHMANAGER_API_ENDPOINT_DOMAIN=\"amazonaws.com\"",
          "export AWS_SSM_PATCHMANAGER_API_ENDPOINT_DOMAIN_DUALSTACK=\"api.aws\"",
          "",
          "echo '_K='\"'\"'patch-baseline-operations-*.zip'\"'\"'",
          "_J='\"'\"'SSM_COMMAND_ID'\"'\"'",
          "_I='\"'\"'%s sha256 check failed, should be %s, but is %s'\"'\"'",
          "_H='\"'\"'utf-8'\"'\"'",
          "_G='\"'\"'rebootCount'\"'\"'",
          "_F='\"'\"'commandId'\"'\"'",
          "_E='\"'\"'wget'\"'\"'",
          "_D='\"'\"'curl'\"'\"'",
          "_C=None",
          "_B=True",
          "_A=False",
          "import errno,glob,hashlib,logging,os,shutil,subprocess,tarfile,sys,re,fcntl,time,datetime,json",
          "ssm_base_dir=os.path.abspath('\"'\"'/var/log/amazon/ssm/'\"'\"')",
          "tmp_dir=os.path.abspath('\"'\"'/var/log/amazon/ssm/patch-baseline-operations/'\"'\"')",
          "reboot_dir=os.path.abspath('\"'\"'/var/log/amazon/ssm/patch-baseline-operations-reboot-194/'\"'\"')",
          "reboot_with_failure_dir=os.path.abspath('\"'\"'/var/log/amazon/ssm/patch-baseline-operations-reboot-195/'\"'\"')",
          "reboot_with_dependency_failure_dir=os.path.abspath('\"'\"'/var/log/amazon/ssm/patch-baseline-operations-reboot-196/'\"'\"')",
          "LOGGER_FORMAT='\"'\"'%(asctime)s %(name)s [%(levelname)s]: %(message)s'\"'\"'",
          "LOGGER_DATEFORMAT='\"'\"'%m/%d/%Y %X'\"'\"'",
          "log_format=logging.Formatter(fmt=LOGGER_FORMAT,datefmt=LOGGER_DATEFORMAT)",
          "handler_out=logging.StreamHandler(sys.stdout)",
          "handler_out.setLevel(logging.INFO)",
          "handler_out.setFormatter(log_format)",
          "handler_err=logging.StreamHandler(sys.stderr)",
          "handler_err.setLevel(logging.WARNING)",
          "handler_err.setFormatter(log_format)",
          "logger=logging.getLogger()",
          "logger.setLevel(logging.INFO)",
          "logger.addHandler(handler_out)",
          "logger.addHandler(handler_err)",
          "ERROR_CODE_TOO_MANY_REBOOTS_FAILURE=3",
          "ERROR_CANNOT_ACQUIRE_LOCK=4",
          "ERROR_CODE_CURL=12",
          "ERROR_CODE_DOWNLOAD=15",
          "ERROR_CODE_CHECKSUM=16",
          "ERROR_CODE_LOCAL_IO=17",
          "ERROR_CODE_DOWNLOAD_TLS=21",
          "ERROR_CODE_DOWNLOAD_CERT_AUTH=22",
          "DEFAULT_DOWNLOAD_ERROR='\"'\"'Unable to download payload: %s.'\"'\"'",
          "ERROR_CODE_MESSAGE_MAP={ERROR_CODE_CURL:'\"'\"'Neither curl nor wget is installed on the instance, abort.'\"'\"',ERROR_CODE_DOWNLOAD:DEFAULT_DOWNLOAD_ERROR,ERROR_CODE_CHECKSUM:_I,ERROR_CODE_LOCAL_IO:'\"'\"'Unable to perform local file operation.'\"'\"',ERROR_CODE_DOWNLOAD_TLS:DEFAULT_DOWNLOAD_ERROR+'\"'\"' TLS related error was detected.'\"'\"',ERROR_CODE_DOWNLOAD_CERT_AUTH:DEFAULT_DOWNLOAD_ERROR+'\"'\"' Certificate authentication related error was detected.'\"'\"'}",
          "lock_file_path='\"'\"'/var/log/amazon/ssm/patch-baseline-concurrent.lock'\"'\"'",
          "command_id=os.environ[_J]",
          "def acquire_lock(fd):",
          "\tA=_C",
          "\ttry:fcntl.flock(fd,fcntl.LOCK_EX|fcntl.LOCK_NB);A=fd;logger.info('\"'\"'Acquired lock on the lock file'\"'\"')",
          "\texcept(IOError,OSError):logger.warn('\"'\"'Cannot acquire lock on the lock file'\"'\"')",
          "\treturn A",
          "def release_lock(lock_file_fd):A=lock_file_fd;fcntl.flock(A,fcntl.LOCK_UN);os.close(A);logger.info('\"'\"'Released lock on the lock file'\"'\"')",
          "def try_create_lock_file(command_id):",
          "\tC=os.O_RDWR|os.O_CREAT|os.O_EXCL|os.O_NONBLOCK;D=os.open(lock_file_path,C);A=acquire_lock(D)",
          "\tif A is _C:return",
          "\tE=datetime.datetime.utcnow().replace(microsecond=0).isoformat();B=json.dumps({_F:command_id,'\"'\"'createdAt'\"'\"':E,_G:0});os.write(A,B.encode());os.fsync(A);logger.info('\"'\"'Lock file contents written to disk %s'\"'\"'%B);return A",
          "def is_lock_file_for_the_same_command(command_id):",
          "\ttry:",
          "\t\twith open(lock_file_path)as A:B=json.load(A);C=B[_F];return C==command_id",
          "\texcept:logger.error('\"'\"'Cannot read lock file contents'\"'\"');return _A",
          "def lock_lock_file():A=os.O_RDWR|os.O_NONBLOCK|os.O_EXCL;B=os.open(lock_file_path,A);C=acquire_lock(B);return C",
          "def delete_lock_file():logger.debug('\"'\"'Removing lock file'\"'\"');os.remove(lock_file_path);logger.info('\"'\"'Patch concurrent lock file deleted'\"'\"')",
          "def can_forcibly_reacquire_lock():",
          "\tfor C in range(10):",
          "\t\tlogger.info('\"'\"'Trying to forcibly reacquire lock. Attempt #%d'\"'\"'%(C+1))",
          "\t\ttry:",
          "\t\t\twith open(lock_file_path)as D:E=json.load(D);A=E[_F];logger.info('\"'\"'Existing lock command id: %s'\"'\"'%A)",
          "\t\texcept:logger.error('\"'\"'Cannot determine if existing lock related to a running command, unable to read lock file contents'\"'\"');A=_C",
          "\t\tF=subprocess.Popen(['\"'\"'ps'\"'\"','\"'\"'aux'\"'\"'],stdout=subprocess.PIPE);G,I=F.communicate();H=G.decode(_H)",
          "\t\tfor B in H.splitlines():",
          "\t\t\tif not B.strip():continue",
          "\t\t\tif command_id in B:continue",
          "\t\t\tif not A:continue",
          "\t\t\tif A in B:logger.info('\"'\"'Patching already running : %s'\"'\"'%B);return _A",
          "\t\ttime.sleep(30)",
          "\treturn _B",
          "def increment_reboot_count_and_check_if_can_continue(lock_fd):",
          "\tA=lock_fd",
          "\ttry:",
          "\t\tos.lseek(A,0,os.SEEK_SET);C=os.read(A,os.fstat(A).st_size);B=json.loads(C.decode(_H));D=B[_G]",
          "\t\tif D>=6:logger.error('\"'\"'Execution reboot count exceeded limit of 6, failing execution.'\"'\"');return _A",
          "\t\telse:B[_G]+=1;E=json.dumps(B);os.lseek(A,0,os.SEEK_SET);os.write(A,E.encode());os.ftruncate(A,os.lseek(A,0,os.SEEK_CUR));os.fsync(A);return _B",
          "\texcept:logger.exception('\"'\"'Failed to check reboot count in lock file.'\"'\"');return _A",
          "lock_fd=_C",
          "if not os.path.exists(lock_file_path):",
          "\tlogger.info('\"'\"'Initial try to acquire lock on the lock file'\"'\"');lock_fd=try_create_lock_file(command_id)",
          "\tif not lock_fd:logger.info('\"'\"'Cannot acquire lock on the lock file at initial try'\"'\"')",
          "elif is_lock_file_for_the_same_command(command_id):lock_fd=lock_lock_file()",
          "elif can_forcibly_reacquire_lock():delete_lock_file();lock_fd=try_create_lock_file(command_id)",
          "if not lock_fd:logger.error('\"'\"'Cannot acquire lock on '\"'\"'+lock_file_path+'\"'\"'. Another patching operation is in progress.'\"'\"');sys.exit(ERROR_CANNOT_ACQUIRE_LOCK)",
          "elif not increment_reboot_count_and_check_if_can_continue(lock_fd):release_lock(lock_fd);sys.exit(ERROR_CODE_TOO_MANY_REBOOTS_FAILURE)",
          "if os.path.exists(reboot_dir)or os.path.exists(reboot_with_failure_dir)or os.path.exists(reboot_with_dependency_failure_dir):",
          "\tif os.path.exists(tmp_dir):shutil.rmtree(tmp_dir)",
          "def create_dir(dirpath):",
          "\tA=dirpath;A=os.path.abspath(A)",
          "\tif not os.path.exists(A):",
          "\t\ttry:os.makedirs(A)",
          "\t\texcept OSError as B:",
          "\t\t\tif B.errno!=errno.EEXIST:raise B",
          "\t\texcept Exception as B:logger.error('\"'\"'Unable to create dir: %s'\"'\"',A,exc_info=_B);abort(ERROR_CODE_LOCAL_IO)",
          "def use_curl():B,A=shell_command(['\"'\"'which'\"'\"',_D]);return A==0",
          "def use_wget():B,A=shell_command(['\"'\"'which'\"'\"',_E]);return A==0",
          "class DownloadResult:",
          "\tdef __init__(A,output,download_agent,download_agent_rc,patch_rc,patch_error_params):A.output=output;A.download_agent=download_agent;A.download_agent_rc=download_agent_rc;A.patch_rc=patch_rc;A.patch_error_params=patch_error_params",
          "CURL_TLS_ERRORS=[2,35]",
          "def download_from_url_to_path_using_curl(url,file_path):",
          "\tE=file_path;A=url;F=make_user_agent_header(_D);logger.info(\"Attempting to use user agent: '\"'\"'%s'\"'\"'\"%F);G,B=shell_command([_D,'\"'\"'-f'\"'\"','\"'\"'-o'\"'\"',E,A,'\"'\"'-A'\"'\"',F])",
          "\tif B!=0:logger.info('\"'\"'Downloading from %s via curl with custom user agent failed, trying without user agent...'\"'\"',A);G,B=shell_command([_D,'\"'\"'-f'\"'\"','\"'\"'-o'\"'\"',E,A])",
          "\tif B==0:C=0;D=tuple()",
          "\telif B in CURL_TLS_ERRORS:C=ERROR_CODE_DOWNLOAD_TLS;D=A,",
          "\telif B==60:C=ERROR_CODE_DOWNLOAD_CERT_AUTH;D=A,",
          "\telse:C=ERROR_CODE_DOWNLOAD;D=A,",
          "\treturn DownloadResult(G,_D,B,C,D)",
          "WGET_TLS_ERRORS=[4,5]",
          "def download_from_url_to_path_using_wget(url,file_path):",
          "\tE=file_path;A=url;G=make_user_agent_header(_E);F,B=shell_command([_E,'\"'\"'-O'\"'\"',E,A,'\"'\"'-U'\"'\"',G])",
          "\tif B!=0:logger.info('\"'\"'Downloading from %s via wget with custom user agent failed, trying without user agent...'\"'\"',A);F,B=shell_command([_E,'\"'\"'-O'\"'\"',E,A])",
          "\tif B==0:C=0;D=tuple()",
          "\telif B in WGET_TLS_ERRORS:C=ERROR_CODE_DOWNLOAD_TLS;D=A,",
          "\telse:C=ERROR_CODE_DOWNLOAD;D=A,",
          "\treturn DownloadResult(F,_E,B,C,D)",
          "def download_from_url_to_path(url,file_path):",
          "\tB=file_path;A=url;logger.info('\"'\"'Downloading payload from %s'\"'\"',A)",
          "\tif use_curl():return download_from_url_to_path_using_curl(A,B)",
          "\tif use_wget():return download_from_url_to_path_using_wget(A,B)",
          "\treturn DownloadResult(output='\"'\"''\"'\"',download_agent='\"'\"'None'\"'\"',download_agent_rc=1,patch_rc=ERROR_CODE_CURL,patch_error_params=tuple())",
          "def download_to(url,file_path,retry_without_dualstack=_B):",
          "\tG='\"'\"'dualstack'\"'\"';E=file_path;B=url;D=10;F=30",
          "\tfor C in range(D):",
          "\t\tif C>0:logger.info('\"'\"'Retrying download attempt %d/%d after %d seconds...'\"'\"',C+1,D,F);time.sleep(F)",
          "\t\tA=download_from_url_to_path(B,E)",
          "\t\tif A.patch_rc==0:",
          "\t\t\tif C>0:logger.info('\"'\"'Download succeeded on attempt %d/%d'\"'\"',C+1,D)",
          "\t\t\treturn",
          "\t\tif A.patch_rc and G in B and retry_without_dualstack:",
          "\t\t\tlogger.info('\"'\"'Failed to download payload from %s: %s, retrying without dualstack...'\"'\"',B,A.output);B=B.replace('\"'\"'.dualstack.'\"'\"','\"'\"'.'\"'\"');A=download_from_url_to_path(B,E)",
          "\t\t\tif A.patch_rc==0:",
          "\t\t\t\tif C>0:logger.info('\"'\"'Download succeeded on attempt %d/%d after removing dualstack'\"'\"',C+1,D)",
          "\t\t\t\treturn",
          "\t\telif A.patch_rc and G in B:logger.info('\"'\"'Failed to download payload from %s: %s, and I am configured to skip retrying without dualstack.'\"'\"'%(B,A.output))",
          "\t\tif A.patch_rc==ERROR_CODE_CURL:logger.error('\"'\"'Neither wget nor curl exit on the instance. Exiting...'\"'\"');abort(ERROR_CODE_CURL)",
          "\t\tlogger.warning('\"'\"'Download attempt %d/%d failed: %s (error code: %d)'\"'\"',C+1,D,A.output,A.download_agent_rc)",
          "\tlogger.error('\"'\"'All %d download attempts failed. Error code returned from %s is %d'\"'\"',D,A.download_agent,A.download_agent_rc);abort(A.patch_rc,A.patch_error_params)",
          "def extract_tar(path):",
          "\tB=path;B=os.path.abspath(B);A=_C",
          "\ttry:",
          "\t\tA=tarfile.open(B,'\"'\"'r|gz'\"'\"');C=int(os.environ.get('\"'\"'PYTHON_MAJOR_VERSION'\"'\"'));D=int(os.environ.get('\"'\"'PYTHON_MINOR_VERSION'\"'\"'))",
          "\t\tif(C,D)>=(3,12):A.extractall(filter='\"'\"'fully_trusted'\"'\"')",
          "\t\telse:A.extractall()",
          "\texcept Exception as E:logger.error('\"'\"'Unable to extract tar file: %s.'\"'\"',B);logger.exception(E);abort(ERROR_CODE_LOCAL_IO)",
          "\tfinally:",
          "\t\tif A:A.close()",
          "def shell_command(cmd_list):",
          "\twith open(os.devnull,'\"'\"'w'\"'\"')as C:",
          "\t\tB=subprocess.Popen(cmd_list,stdout=subprocess.PIPE,stderr=C);A,D=B.communicate()",
          "\t\tif not type(A)==str:A=A.decode(_H)",
          "\t\treturn A,B.returncode",
          "def abort(error_code,params=()):",
          "\tA=error_code",
          "\tif os.path.exists(tmp_dir):shutil.rmtree(tmp_dir)",
          "\tlogger.error(ERROR_CODE_MESSAGE_MAP.get(A)%params);sys.exit(A)",
          "def sha256_checksum(filename):",
          "\tA=hashlib.sha256()",
          "\twith open(filename,'\"'\"'rb'\"'\"')as B:",
          "\t\tfor C in iter(lambda:B.read(4096),b'\"'\"''\"'\"'):A.update(C)",
          "\t\treturn A.hexdigest().upper()",
          "def get_use_dualstack_setting():",
          "\tA='\"'\"'AWS_SSM_USE_DUALSTACK_ENDPOINT'\"'\"'",
          "\tif os.environ.get(A):",
          "\t\tB=os.environ.get(A);print('\"'\"'found use_dualstack configuration in environment variables (%s=%s)'\"'\"'%(A,B))",
          "\t\tif B=='\"'\"'true'\"'\"':return _B",
          "\t\telse:return _A",
          "\tprint('\"'\"'Could not find a use_dualstack configuration anywhere'\"'\"');return _A",
          "def make_user_agent_header(download_agent_cmd_name):",
          "\tB='\"'\"'<missing>'\"'\"';A=download_agent_cmd_name;D=os.environ.get('\"'\"'AWS_SSM_INSTANCE_ID'\"'\"',B);E=os.environ.get(_J,B);F,G=shell_command([A,'\"'\"'--version'\"'\"'])",
          "\tif G==0:H=re.search('\"'\"'[0-9.]+'\"'\"',F).group(0)or B;C='\"'\"'%s/%s'\"'\"'%(A,H)",
          "\telse:C='\"'\"'%s/<missing>'\"'\"'%(A,)",
          "\treturn'\"'\"'RPB(instance_id=%s; ssm_command_id=%s; download_agent=%s)'\"'\"'%(D,E,C)",
          "create_dir(tmp_dir)",
          "os.chdir(tmp_dir)",
          "region=os.environ['\"'\"'AWS_SSM_REGION_NAME'\"'\"']",
          "s3_prefix='\"'\"'patchbaselineoperations/crossaccount/payloads'\"'\"'",
          "payload_name='\"'\"'patch-baseline-operations-cross-account-178.0.tar.gz'\"'\"'",
          "payload_sha256='\"'\"'FB7C9C0C44EC67F6E276298EC5202894496FFC669CB4101478230A5A43D4B0C5'\"'\"'",
          "s3_path=os.path.join(s3_prefix,payload_name)",
          "skip_download=_A",
          "payload_path=os.path.join(ssm_base_dir,payload_name)",
          "if os.path.exists(payload_path):",
          "\texisting_sha256=sha256_checksum(payload_path)",
          "\tif existing_sha256==payload_sha256:logger.info('\"'\"'Payload %s already exists with correct hash %s, skipping download'\"'\"',payload_path,payload_sha256);skip_download=_B",
          "\telse:",
          "\t\tlogger.info('\"'\"'Payload %s exists but hash mismatch (expected %s, got %s), re-downloading'\"'\"',payload_path,payload_sha256,existing_sha256)",
          "\t\tfor old_payload in glob.glob(os.path.join(ssm_base_dir,_K)):os.remove(old_payload)",
          "else:",
          "\tlogger.info('\"'\"'Cleaning up old payload cache'\"'\"')",
          "\tfor old_payload in glob.glob(os.path.join(ssm_base_dir,_K)):os.remove(old_payload)",
          "if not skip_download:",
          "\tuse_dualstack=get_use_dualstack_setting();print('\"'\"'Using dualstack = %s'\"'\"'%use_dualstack)",
          "\tif use_dualstack and'\"'\"'s3.dualstack.us-east-1.amazonaws.com/aws-ssm-us-east-1'\"'\"':dualstack_url='\"'\"'https://s3.dualstack.us-east-1.amazonaws.com/aws-ssm-us-east-1/%s'\"'\"'%s3_path;download_to(dualstack_url,payload_path,retry_without_dualstack=_A)",
          "\telse:standard_url='\"'\"'https://s3.us-east-1.amazonaws.com/aws-ssm-us-east-1/%s'\"'\"'%s3_path;download_to(standard_url,payload_path)",
          "shutil.copy(payload_path,payload_name)",
          "payloads=[]",
          "try:",
          "\tsha256_code=sha256_checksum(payload_name)",
          "\tif not sha256_code==payload_sha256:error_msg=_I%(payload_name,payload_sha256,sha256_code);logger.error(error_msg);abort(ERROR_CODE_CHECKSUM,(payload_name,payload_sha256,sha256_code))",
          "\textract_tar(payload_name);shell_command(['\"'\"'chown'\"'\"','\"'\"'-R'\"'\"','\"'\"'0:0'\"'\"',tmp_dir])",
          "except Exception as e:error_msg='\"'\"'Unable to load and extract the content of payload, abort.'\"'\"';logger.error(error_msg);logger.exception(e);abort(ERROR_CODE_LOCAL_IO)",
          "import sys",
          "try:import common_startup_entrance;common_startup_entrance.execute('\"'\"'os_selector_cross_account'\"'\"','\"'\"'PatchLinux'\"'\"','\"'\"'{{BaselineTags}}'\"'\"','\"'\"'{{AssociationId}}'\"'\"','\"'\"'{{Operation}}'\"'\"','\"'\"'{{InstallOverrideList}}'\"'\"','\"'\"'{{RebootOption}}'\"'\"')",
          "except Exception as e:",
          "\terror_code=156",
          "\tif hasattr(e,'\"'\"'error_code'\"'\"')and type(e.error_code)==int:error_code=e.error_code",
          "\tlogger.exception(e);sys.exit(error_code)' | $PYTHON_CMD",
          "",
          "export RETURN_CODE=$?",
          "",
          "echo 'import json,os,logging,sys",
          "LOGGER_FORMAT='\"'\"'%(asctime)s %(name)s [%(levelname)s]: %(message)s'\"'\"'",
          "LOGGER_DATEFORMAT='\"'\"'%m/%d/%Y %X'\"'\"'",
          "log_format=logging.Formatter(fmt=LOGGER_FORMAT,datefmt=LOGGER_DATEFORMAT)",
          "handler_out=logging.StreamHandler(sys.stdout)",
          "handler_out.setLevel(logging.INFO)",
          "handler_out.setFormatter(log_format)",
          "handler_err=logging.StreamHandler(sys.stderr)",
          "handler_err.setLevel(logging.WARNING)",
          "handler_err.setFormatter(log_format)",
          "logger=logging.getLogger()",
          "logger.setLevel(logging.INFO)",
          "logger.addHandler(handler_out)",
          "logger.addHandler(handler_err)",
          "lock_file_path='\"'\"'/var/log/amazon/ssm/patch-baseline-concurrent.lock'\"'\"'",
          "command_id=os.environ['\"'\"'SSM_COMMAND_ID'\"'\"']",
          "patch_return_code=os.environ['\"'\"'RETURN_CODE'\"'\"']",
          "def is_lock_file_for_the_same_command(command_id):",
          "\ttry:",
          "\t\twith open(lock_file_path)as A:B=json.load(A);C=B['\"'\"'commandId'\"'\"'];return C==command_id",
          "\texcept:logger.error('\"'\"'Cannot remove lock file, unable to read lock file contents'\"'\"');return False",
          "if str(patch_return_code)!='\"'\"'194'\"'\"'and is_lock_file_for_the_same_command(command_id):logger.debug('\"'\"'Removing lock file'\"'\"');os.remove(lock_file_path);logger.info('\"'\"'Patch concurrent lock file deleted'\"'\"')' | $PYTHON_CMD",
          "",
          "clean_up_instances_if_debian_8",
          "",
          "exit $RETURN_CODE"
        ],
        "timeoutSeconds": 7200
      },
      "name": "PatchLinux",
      "precondition": {
        "StringEquals": [
          "platformType",
          "Linux"
        ]
      }
    },
    {
      "action": "aws:runShellScript",
      "inputs": {
        "runCommand": [
          "#!/bin/bash",
          "PYTHON_CMD=''",
          "",
          "ERROR_CODE_PYTHON_MISSING=13",
          "",
          "check_binary() {",
          "    HAS_VAR_NAME=HAS_$2",
          "    CMD_VAR_NAME=$2_CMD",
          "    if [ \"$(eval echo \\${${HAS_VAR_NAME}})\" = \"0\" ]; then return; fi",
          "    which $1 2>/dev/null",
          "    RET_CODE=$?",
          "    eval \"${HAS_VAR_NAME}=${RET_CODE}\"",
          "    if [ ${RET_CODE} -eq 0 ]; then eval \"${CMD_VAR_NAME}=$1\"; fi",
          "}",
          "",
          "check_binary python3 PYTHON3",
          "check_binary python2.6 PYTHON2_6",
          "check_binary python26 PYTHON26",
          "check_binary python2.7 PYTHON2_7",
          "check_binary python27 PYTHON27",
          "check_binary python2 PYTHON2",
          "",
          "which python 2>/dev/null",
          "if [ $? -eq 0 ]; then",
          "  PYTHON_VERSION=$(python --version 2>&1 | awk '{split($2,v,\".\"); print v[1]}')",
          "  eval \"HAS_PYTHON${PYTHON_VERSION}=0\"",
          "  eval \"PYTHON${PYTHON_VERSION}_CMD='python'\"",
          "fi",
          "",
          "check_install_code() {",
          "    if [ $1 -ne 0 ]",
          "    then",
          "        echo \"WARNING: Could not install the $2, this may cause the patching operation to fail.\" >&2",
          "    fi",
          "}",
          "",
          "CANDIDATES=( $HAS_PYTHON2_6 $HAS_PYTHON26 $HAS_PYTHON2_7 $HAS_PYTHON27 $HAS_PYTHON2 )",
          "HAS_ANY_PYTHON2=1",
          "for CANDIDATE in \"${CANDIDATES[@]}\"",
          "do",
          "    if [ $CANDIDATE -eq 0 ]",
          "    then",
          "        HAS_ANY_PYTHON2=0",
          "    fi",
          "done",
          "",
          "if [ $HAS_PYTHON3 -eq 1 -a $HAS_ANY_PYTHON2 -eq 1 ]; then",
          "    echo \"Unable to find python.\" 1>&2",
          "    exit $ERROR_CODE_PYTHON_MISSING",
          "fi",
          "",
          "if [ $HAS_PYTHON3 -eq 0 ]",
          "then",
          "    PYTHON_CMD=${PYTHON3_CMD}",
          "fi",
          "",
          "echo \"Using python binary: '${PYTHON_CMD}'\"",
          "PYTHON_VERSION=$(${PYTHON_CMD} --version  2>&1)",
          "PYTHON_DECIMAL_VERSION=$(${PYTHON_CMD} --version  2>&1 | awk '{split($2,v,\".\"); print v[1]\".\"v[2]}')",
          "export PYTHON_MAJOR_VERSION=$(echo $PYTHON_DECIMAL_VERSION | cut -d. -f1)",
          "export PYTHON_MINOR_VERSION=$(echo $PYTHON_DECIMAL_VERSION | cut -d. -f2)",
          "echo \"Using Python Version: $PYTHON_VERSION\"",
          "",
          "export AWS_SSM_PATCHMANAGER_API_ENDPOINT_DOMAIN=\"amazonaws.com\"",
          "export AWS_SSM_PATCHMANAGER_API_ENDPOINT_DOMAIN_DUALSTACK=\"api.aws\"",
          "",
          "echo '_K='\"'\"'patch-baseline-operations-*.zip'\"'\"'",
          "_J='\"'\"'SSM_COMMAND_ID'\"'\"'",
          "_I='\"'\"'%s sha256 check failed, should be %s, but is %s'\"'\"'",
          "_H='\"'\"'utf-8'\"'\"'",
          "_G='\"'\"'rebootCount'\"'\"'",
          "_F='\"'\"'commandId'\"'\"'",
          "_E='\"'\"'wget'\"'\"'",
          "_D='\"'\"'curl'\"'\"'",
          "_C=None",
          "_B=True",
          "_A=False",
          "import errno,glob,hashlib,logging,os,shutil,subprocess,tarfile,sys,re,fcntl,time,datetime,json",
          "ssm_base_dir=os.path.abspath('\"'\"'/var/log/amazon/ssm/'\"'\"')",
          "tmp_dir=os.path.abspath('\"'\"'/var/log/amazon/ssm/patch-baseline-operations/'\"'\"')",
          "reboot_dir=os.path.abspath('\"'\"'/var/log/amazon/ssm/patch-baseline-operations-reboot-194/'\"'\"')",
          "reboot_with_failure_dir=os.path.abspath('\"'\"'/var/log/amazon/ssm/patch-baseline-operations-reboot-195/'\"'\"')",
          "reboot_with_dependency_failure_dir=os.path.abspath('\"'\"'/var/log/amazon/ssm/patch-baseline-operations-reboot-196/'\"'\"')",
          "LOGGER_FORMAT='\"'\"'%(asctime)s %(name)s [%(levelname)s]: %(message)s'\"'\"'",
          "LOGGER_DATEFORMAT='\"'\"'%m/%d/%Y %X'\"'\"'",
          "log_format=logging.Formatter(fmt=LOGGER_FORMAT,datefmt=LOGGER_DATEFORMAT)",
          "handler_out=logging.StreamHandler(sys.stdout)",
          "handler_out.setLevel(logging.INFO)",
          "handler_out.setFormatter(log_format)",
          "handler_err=logging.StreamHandler(sys.stderr)",
          "handler_err.setLevel(logging.WARNING)",
          "handler_err.setFormatter(log_format)",
          "logger=logging.getLogger()",
          "logger.setLevel(logging.INFO)",
          "logger.addHandler(handler_out)",
          "logger.addHandler(handler_err)",
          "ERROR_CODE_TOO_MANY_REBOOTS_FAILURE=3",
          "ERROR_CANNOT_ACQUIRE_LOCK=4",
          "ERROR_CODE_CURL=12",
          "ERROR_CODE_DOWNLOAD=15",
          "ERROR_CODE_CHECKSUM=16",
          "ERROR_CODE_LOCAL_IO=17",
          "ERROR_CODE_DOWNLOAD_TLS=21",
          "ERROR_CODE_DOWNLOAD_CERT_AUTH=22",
          "DEFAULT_DOWNLOAD_ERROR='\"'\"'Unable to download payload: %s.'\"'\"'",
          "ERROR_CODE_MESSAGE_MAP={ERROR_CODE_CURL:'\"'\"'Neither curl nor wget is installed on the instance, abort.'\"'\"',ERROR_CODE_DOWNLOAD:DEFAULT_DOWNLOAD_ERROR,ERROR_CODE_CHECKSUM:_I,ERROR_CODE_LOCAL_IO:'\"'\"'Unable to perform local file operation.'\"'\"',ERROR_CODE_DOWNLOAD_TLS:DEFAULT_DOWNLOAD_ERROR+'\"'\"' TLS related error was detected.'\"'\"',ERROR_CODE_DOWNLOAD_CERT_AUTH:DEFAULT_DOWNLOAD_ERROR+'\"'\"' Certificate authentication related error was detected.'\"'\"'}",
          "lock_file_path='\"'\"'/var/log/amazon/ssm/patch-baseline-concurrent.lock'\"'\"'",
          "command_id=os.environ[_J]",
          "def acquire_lock(fd):",
          "\tA=_C",
          "\ttry:fcntl.flock(fd,fcntl.LOCK_EX|fcntl.LOCK_NB);A=fd;logger.info('\"'\"'Acquired lock on the lock file'\"'\"')",
          "\texcept(IOError,OSError):logger.warn('\"'\"'Cannot acquire lock on the lock file'\"'\"')",
          "\treturn A",
          "def release_lock(lock_file_fd):A=lock_file_fd;fcntl.flock(A,fcntl.LOCK_UN);os.close(A);logger.info('\"'\"'Released lock on the lock file'\"'\"')",
          "def try_create_lock_file(command_id):",
          "\tC=os.O_RDWR|os.O_CREAT|os.O_EXCL|os.O_NONBLOCK;D=os.open(lock_file_path,C);A=acquire_lock(D)",
          "\tif A is _C:return",
          "\tE=datetime.datetime.utcnow().replace(microsecond=0).isoformat();B=json.dumps({_F:command_id,'\"'\"'createdAt'\"'\"':E,_G:0});os.write(A,B.encode());os.fsync(A);logger.info('\"'\"'Lock file contents written to disk %s'\"'\"'%B);return A",
          "def is_lock_file_for_the_same_command(command_id):",
          "\ttry:",
          "\t\twith open(lock_file_path)as A:B=json.load(A);C=B[_F];return C==command_id",
          "\texcept:logger.error('\"'\"'Cannot read lock file contents'\"'\"');return _A",
          "def lock_lock_file():A=os.O_RDWR|os.O_NONBLOCK|os.O_EXCL;B=os.open(lock_file_path,A);C=acquire_lock(B);return C",
          "def delete_lock_file():logger.debug('\"'\"'Removing lock file'\"'\"');os.remove(lock_file_path);logger.info('\"'\"'Patch concurrent lock file deleted'\"'\"')",
          "def can_forcibly_reacquire_lock():",
          "\tfor C in range(10):",
          "\t\tlogger.info('\"'\"'Trying to forcibly reacquire lock. Attempt #%d'\"'\"'%(C+1))",
          "\t\ttry:",
          "\t\t\twith open(lock_file_path)as D:E=json.load(D);A=E[_F];logger.info('\"'\"'Existing lock command id: %s'\"'\"'%A)",
          "\t\texcept:logger.error('\"'\"'Cannot determine if existing lock related to a running command, unable to read lock file contents'\"'\"');A=_C",
          "\t\tF=subprocess.Popen(['\"'\"'ps'\"'\"','\"'\"'aux'\"'\"'],stdout=subprocess.PIPE);G,I=F.communicate();H=G.decode(_H)",
          "\t\tfor B in H.splitlines():",
          "\t\t\tif not B.strip():continue",
          "\t\t\tif command_id in B:continue",
          "\t\t\tif not A:continue",
          "\t\t\tif A in B:logger.info('\"'\"'Patching already running : %s'\"'\"'%B);return _A",
          "\t\ttime.sleep(30)",
          "\treturn _B",
          "def increment_reboot_count_and_check_if_can_continue(lock_fd):",
          "\tA=lock_fd",
          "\ttry:",
          "\t\tos.lseek(A,0,os.SEEK_SET);C=os.read(A,os.fstat(A).st_size);B=json.loads(C.decode(_H));D=B[_G]",
          "\t\tif D>=6:logger.error('\"'\"'Execution reboot count exceeded limit of 6, failing execution.'\"'\"');return _A",
          "\t\telse:B[_G]+=1;E=json.dumps(B);os.lseek(A,0,os.SEEK_SET);os.write(A,E.encode());os.ftruncate(A,os.lseek(A,0,os.SEEK_CUR));os.fsync(A);return _B",
          "\texcept:logger.exception('\"'\"'Failed to check reboot count in lock file.'\"'\"');return _A",
          "lock_fd=_C",
          "if not os.path.exists(lock_file_path):",
          "\tlogger.info('\"'\"'Initial try to acquire lock on the lock file'\"'\"');lock_fd=try_create_lock_file(command_id)",
          "\tif not lock_fd:logger.info('\"'\"'Cannot acquire lock on the lock file at initial try'\"'\"')",
          "elif is_lock_file_for_the_same_command(command_id):lock_fd=lock_lock_file()",
          "elif can_forcibly_reacquire_lock():delete_lock_file();lock_fd=try_create_lock_file(command_id)",
          "if not lock_fd:logger.error('\"'\"'Cannot acquire lock on '\"'\"'+lock_file_path+'\"'\"'. Another patching operation is in progress.'\"'\"');sys.exit(ERROR_CANNOT_ACQUIRE_LOCK)",
          "elif not increment_reboot_count_and_check_if_can_continue(lock_fd):release_lock(lock_fd);sys.exit(ERROR_CODE_TOO_MANY_REBOOTS_FAILURE)",
          "if os.path.exists(reboot_dir)or os.path.exists(reboot_with_failure_dir)or os.path.exists(reboot_with_dependency_failure_dir):",
          "\tif os.path.exists(tmp_dir):shutil.rmtree(tmp_dir)",
          "def create_dir(dirpath):",
          "\tA=dirpath;A=os.path.abspath(A)",
          "\tif not os.path.exists(A):",
          "\t\ttry:os.makedirs(A)",
          "\t\texcept OSError as B:",
          "\t\t\tif B.errno!=errno.EEXIST:raise B",
          "\t\texcept Exception as B:logger.error('\"'\"'Unable to create dir: %s'\"'\"',A,exc_info=_B);abort(ERROR_CODE_LOCAL_IO)",
          "def use_curl():B,A=shell_command(['\"'\"'which'\"'\"',_D]);return A==0",
          "def use_wget():B,A=shell_command(['\"'\"'which'\"'\"',_E]);return A==0",
          "class DownloadResult:",
          "\tdef __init__(A,output,download_agent,download_agent_rc,patch_rc,patch_error_params):A.output=output;A.download_agent=download_agent;A.download_agent_rc=download_agent_rc;A.patch_rc=patch_rc;A.patch_error_params=patch_error_params",
          "CURL_TLS_ERRORS=[2,35]",
          "def download_from_url_to_path_using_curl(url,file_path):",
          "\tE=file_path;A=url;F=make_user_agent_header(_D);logger.info(\"Attempting to use user agent: '\"'\"'%s'\"'\"'\"%F);G,B=shell_command([_D,'\"'\"'-f'\"'\"','\"'\"'-o'\"'\"',E,A,'\"'\"'-A'\"'\"',F])",
          "\tif B!=0:logger.info('\"'\"'Downloading from %s via curl with custom user agent failed, trying without user agent...'\"'\"',A);G,B=shell_command([_D,'\"'\"'-f'\"'\"','\"'\"'-o'\"'\"',E,A])",
          "\tif B==0:C=0;D=tuple()",
          "\telif B in CURL_TLS_ERRORS:C=ERROR_CODE_DOWNLOAD_TLS;D=A,",
          "\telif B==60:C=ERROR_CODE_DOWNLOAD_CERT_AUTH;D=A,",
          "\telse:C=ERROR_CODE_DOWNLOAD;D=A,",
          "\treturn DownloadResult(G,_D,B,C,D)",
          "WGET_TLS_ERRORS=[4,5]",
          "def download_from_url_to_path_using_wget(url,file_path):",
          "\tE=file_path;A=url;G=make_user_agent_header(_E);F,B=shell_command([_E,'\"'\"'-O'\"'\"',E,A,'\"'\"'-U'\"'\"',G])",
          "\tif B!=0:logger.info('\"'\"'Downloading from %s via wget with custom user agent failed, trying without user agent...'\"'\"',A);F,B=shell_command([_E,'\"'\"'-O'\"'\"',E,A])",
          "\tif B==0:C=0;D=tuple()",
          "\telif B in WGET_TLS_ERRORS:C=ERROR_CODE_DOWNLOAD_TLS;D=A,",
          "\telse:C=ERROR_CODE_DOWNLOAD;D=A,",
          "\treturn DownloadResult(F,_E,B,C,D)",
          "def download_from_url_to_path(url,file_path):",
          "\tB=file_path;A=url;logger.info('\"'\"'Downloading payload from %s'\"'\"',A)",
          "\tif use_curl():return download_from_url_to_path_using_curl(A,B)",
          "\tif use_wget():return download_from_url_to_path_using_wget(A,B)",
          "\treturn DownloadResult(output='\"'\"''\"'\"',download_agent='\"'\"'None'\"'\"',download_agent_rc=1,patch_rc=ERROR_CODE_CURL,patch_error_params=tuple())",
          "def download_to(url,file_path,retry_without_dualstack=_B):",
          "\tG='\"'\"'dualstack'\"'\"';E=file_path;B=url;D=10;F=30",
          "\tfor C in range(D):",
          "\t\tif C>0:logger.info('\"'\"'Retrying download attempt %d/%d after %d seconds...'\"'\"',C+1,D,F);time.sleep(F)",
          "\t\tA=download_from_url_to_path(B,E)",
          "\t\tif A.patch_rc==0:",
          "\t\t\tif C>0:logger.info('\"'\"'Download succeeded on attempt %d/%d'\"'\"',C+1,D)",
          "\t\t\treturn",
          "\t\tif A.patch_rc and G in B and retry_without_dualstack:",
          "\t\t\tlogger.info('\"'\"'Failed to download payload from %s: %s, retrying without dualstack...'\"'\"',B,A.output);B=B.replace('\"'\"'.dualstack.'\"'\"','\"'\"'.'\"'\"');A=download_from_url_to_path(B,E)",
          "\t\t\tif A.patch_rc==0:",
          "\t\t\t\tif C>0:logger.info('\"'\"'Download succeeded on attempt %d/%d after removing dualstack'\"'\"',C+1,D)",
          "\t\t\t\treturn",
          "\t\telif A.patch_rc and G in B:logger.info('\"'\"'Failed to download payload from %s: %s, and I am configured to skip retrying without dualstack.'\"'\"'%(B,A.output))",
          "\t\tif A.patch_rc==ERROR_CODE_CURL:logger.error('\"'\"'Neither wget nor curl exit on the instance. Exiting...'\"'\"');abort(ERROR_CODE_CURL)",
          "\t\tlogger.warning('\"'\"'Download attempt %d/%d failed: %s (error code: %d)'\"'\"',C+1,D,A.output,A.download_agent_rc)",
          "\tlogger.error('\"'\"'All %d download attempts failed. Error code returned from %s is %d'\"'\"',D,A.download_agent,A.download_agent_rc);abort(A.patch_rc,A.patch_error_params)",
          "def extract_tar(path):",
          "\tB=path;B=os.path.abspath(B);A=_C",
          "\ttry:",
          "\t\tA=tarfile.open(B,'\"'\"'r|gz'\"'\"');C=int(os.environ.get('\"'\"'PYTHON_MAJOR_VERSION'\"'\"'));D=int(os.environ.get('\"'\"'PYTHON_MINOR_VERSION'\"'\"'))",
          "\t\tif(C,D)>=(3,12):A.extractall(filter='\"'\"'fully_trusted'\"'\"')",
          "\t\telse:A.extractall()",
          "\texcept Exception as E:logger.error('\"'\"'Unable to extract tar file: %s.'\"'\"',B);logger.exception(E);abort(ERROR_CODE_LOCAL_IO)",
          "\tfinally:",
          "\t\tif A:A.close()",
          "def shell_command(cmd_list):",
          "\twith open(os.devnull,'\"'\"'w'\"'\"')as C:",
          "\t\tB=subprocess.Popen(cmd_list,stdout=subprocess.PIPE,stderr=C);A,D=B.communicate()",
          "\t\tif not type(A)==str:A=A.decode(_H)",
          "\t\treturn A,B.returncode",
          "def abort(error_code,params=()):",
          "\tA=error_code",
          "\tif os.path.exists(tmp_dir):shutil.rmtree(tmp_dir)",
          "\tlogger.error(ERROR_CODE_MESSAGE_MAP.get(A)%params);sys.exit(A)",
          "def sha256_checksum(filename):",
          "\tA=hashlib.sha256()",
          "\twith open(filename,'\"'\"'rb'\"'\"')as B:",
          "\t\tfor C in iter(lambda:B.read(4096),b'\"'\"''\"'\"'):A.update(C)",
          "\t\treturn A.hexdigest().upper()",
          "def get_use_dualstack_setting():",
          "\tA='\"'\"'AWS_SSM_USE_DUALSTACK_ENDPOINT'\"'\"'",
          "\tif os.environ.get(A):",
          "\t\tB=os.environ.get(A);print('\"'\"'found use_dualstack configuration in environment variables (%s=%s)'\"'\"'%(A,B))",
          "\t\tif B=='\"'\"'true'\"'\"':return _B",
          "\t\telse:return _A",
          "\tprint('\"'\"'Could not find a use_dualstack configuration anywhere'\"'\"');return _A",
          "def make_user_agent_header(download_agent_cmd_name):",
          "\tB='\"'\"'<missing>'\"'\"';A=download_agent_cmd_name;D=os.environ.get('\"'\"'AWS_SSM_INSTANCE_ID'\"'\"',B);E=os.environ.get(_J,B);F,G=shell_command([A,'\"'\"'--version'\"'\"'])",
          "\tif G==0:H=re.search('\"'\"'[0-9.]+'\"'\"',F).group(0)or B;C='\"'\"'%s/%s'\"'\"'%(A,H)",
          "\telse:C='\"'\"'%s/<missing>'\"'\"'%(A,)",
          "\treturn'\"'\"'RPB(instance_id=%s; ssm_command_id=%s; download_agent=%s)'\"'\"'%(D,E,C)",
          "create_dir(tmp_dir)",
          "os.chdir(tmp_dir)",
          "region=os.environ['\"'\"'AWS_SSM_REGION_NAME'\"'\"']",
          "s3_prefix='\"'\"'patchbaselineoperations/crossaccount/payloads'\"'\"'",
          "payload_name='\"'\"'patch-baseline-operations-macos-cross-account-4.26.tar.gz'\"'\"'",
          "payload_sha256='\"'\"'A93CF2C842461CDED85048558DB7FCFF930DDA3922A9C3954E178AA3AD8AC06E'\"'\"'",
          "s3_path=os.path.join(s3_prefix,payload_name)",
          "skip_download=_A",
          "payload_path=os.path.join(ssm_base_dir,payload_name)",
          "if os.path.exists(payload_path):",
          "\texisting_sha256=sha256_checksum(payload_path)",
          "\tif existing_sha256==payload_sha256:logger.info('\"'\"'Payload %s already exists with correct hash %s, skipping download'\"'\"',payload_path,payload_sha256);skip_download=_B",
          "\telse:",
          "\t\tlogger.info('\"'\"'Payload %s exists but hash mismatch (expected %s, got %s), re-downloading'\"'\"',payload_path,payload_sha256,existing_sha256)",
          "\t\tfor old_payload in glob.glob(os.path.join(ssm_base_dir,_K)):os.remove(old_payload)",
          "else:",
          "\tlogger.info('\"'\"'Cleaning up old payload cache'\"'\"')",
          "\tfor old_payload in glob.glob(os.path.join(ssm_base_dir,_K)):os.remove(old_payload)",
          "if not skip_download:",
          "\tuse_dualstack=get_use_dualstack_setting();print('\"'\"'Using dualstack = %s'\"'\"'%use_dualstack)",
          "\tif use_dualstack and'\"'\"'s3.dualstack.us-east-1.amazonaws.com/aws-patchmanager-macos-us-east-1-1970c647d'\"'\"':dualstack_url='\"'\"'https://s3.dualstack.us-east-1.amazonaws.com/aws-patchmanager-macos-us-east-1-1970c647d/%s'\"'\"'%s3_path;download_to(dualstack_url,payload_path,retry_without_dualstack=_A)",
          "\telse:standard_url='\"'\"'https://s3.us-east-1.amazonaws.com/aws-patchmanager-macos-us-east-1-1970c647d/%s'\"'\"'%s3_path;download_to(standard_url,payload_path)",
          "shutil.copy(payload_path,payload_name)",
          "payloads=[]",
          "try:",
          "\tsha256_code=sha256_checksum(payload_name)",
          "\tif not sha256_code==payload_sha256:error_msg=_I%(payload_name,payload_sha256,sha256_code);logger.error(error_msg);abort(ERROR_CODE_CHECKSUM,(payload_name,payload_sha256,sha256_code))",
          "\textract_tar(payload_name);shell_command(['\"'\"'chown'\"'\"','\"'\"'-R'\"'\"','\"'\"'0:0'\"'\"',tmp_dir])",
          "except Exception as e:error_msg='\"'\"'Unable to load and extract the content of payload, abort.'\"'\"';logger.error(error_msg);logger.exception(e);abort(ERROR_CODE_LOCAL_IO)",
          "import sys",
          "try:import common_startup_entrance;common_startup_entrance.execute('\"'\"'os_selector_cross_account'\"'\"','\"'\"'PatchMacOS'\"'\"','\"'\"'{{BaselineTags}}'\"'\"','\"'\"'{{AssociationId}}'\"'\"','\"'\"'{{Operation}}'\"'\"','\"'\"'{{InstallOverrideList}}'\"'\"','\"'\"'{{RebootOption}}'\"'\"')",
          "except Exception as e:",
          "\terror_code=156",
          "\tif hasattr(e,'\"'\"'error_code'\"'\"')and type(e.error_code)==int:error_code=e.error_code",
          "\tlogger.exception(e);sys.exit(error_code)' | $PYTHON_CMD",
          "",
          "export RETURN_CODE=$?",
          "",
          "echo 'import json,os,logging,sys",
          "LOGGER_FORMAT='\"'\"'%(asctime)s %(name)s [%(levelname)s]: %(message)s'\"'\"'",
          "LOGGER_DATEFORMAT='\"'\"'%m/%d/%Y %X'\"'\"'",
          "log_format=logging.Formatter(fmt=LOGGER_FORMAT,datefmt=LOGGER_DATEFORMAT)",
          "handler_out=logging.StreamHandler(sys.stdout)",
          "handler_out.setLevel(logging.INFO)",
          "handler_out.setFormatter(log_format)",
          "handler_err=logging.StreamHandler(sys.stderr)",
          "handler_err.setLevel(logging.WARNING)",
          "handler_err.setFormatter(log_format)",
          "logger=logging.getLogger()",
          "logger.setLevel(logging.INFO)",
          "logger.addHandler(handler_out)",
          "logger.addHandler(handler_err)",
          "lock_file_path='\"'\"'/var/log/amazon/ssm/patch-baseline-concurrent.lock'\"'\"'",
          "command_id=os.environ['\"'\"'SSM_COMMAND_ID'\"'\"']",
          "patch_return_code=os.environ['\"'\"'RETURN_CODE'\"'\"']",
          "def is_lock_file_for_the_same_command(command_id):",
          "\ttry:",
          "\t\twith open(lock_file_path)as A:B=json.load(A);C=B['\"'\"'commandId'\"'\"'];return C==command_id",
          "\texcept:logger.error('\"'\"'Cannot remove lock file, unable to read lock file contents'\"'\"');return False",
          "if str(patch_return_code)!='\"'\"'194'\"'\"'and is_lock_file_for_the_same_command(command_id):logger.debug('\"'\"'Removing lock file'\"'\"');os.remove(lock_file_path);logger.info('\"'\"'Patch concurrent lock file deleted'\"'\"')' | $PYTHON_CMD",
          "",
          "exit $RETURN_CODE"
        ],
        "timeoutSeconds": 7200
      },
      "name": "PatchMacOS",
      "precondition": {
        "StringEquals": [
          "platformType",
          "MacOS"
        ]
      }
    }
  ],
  "parameters": {
    "AssociationId": {
      "allowedPattern": "^((([0-9a-fA-F]){8}-([0-9a-fA-F]){4}-([0-9a-fA-F]){4}-([0-9a-fA-F]){4}-([0-9a-fA-F]){12}){0,1})$",
      "description": "(Required) The Association ID of the State Manager Association executing the document.",
      "type": "String"
    },
    "BaselineTags": {
      "allowedPattern": "(^$)|^Key=([^'\"\\`\\$\\v\\n]){1,256},Values=(([^'\"\\`\\$\\v\\n]){0,255}[^,'\"\\`\\$\\v\\n])?$",
      "default": "",
      "description": "(Optional) The baseline tags to use during the patching operation.",
      "type": "String"
    },
    "InstallOverrideList": {
      "allowedPattern": "(^$)|^(https|s3)://([^/'\"\\`\\$\\v\\s]+)/(([^/'\"\\`\\$\\v\\s]+)/)*([^/'\"\\`\\$\\v\\s])+$",
      "default": "",
      "description": "(Optional) An https URL or an Amazon S3 path-style URL to the list of patches to be installed. This patch installation list overrides the patches specified by the default patch baseline.",
      "type": "String"
    },
    "Operation": {
      "allowedValues": [
        "Scan",
        "Install"
      ],
      "description": "(Required) The update or configuration to perform on the instance. The system checks if patches specified in the patch baseline are installed on the instance. The install operation installs patches missing from the baseline.",
      "type": "String"
    },
    "RebootOption": {
      "allowedValues": [
        "RebootIfNeeded",
        "NoReboot"
      ],
      "default": "RebootIfNeeded",
      "description": "(Optional) Reboot behavior after a patch Install operation. If you choose NoReboot and patches are installed, the instance is marked as non-compliant until a subsequent reboot and scan.",
      "type": "String"
    }
  },
  "schemaVersion": "2.2"
}
