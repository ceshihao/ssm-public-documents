{
  "description": "Scans for or installs patches from a patch baseline to a Linux, Windows or MacOS operating system using the specified patch baseline names.",
  "mainSteps": [
    {
      "action": "aws:runPowerShellScript",
      "inputs": {
        "runCommand": [
          "# Check the OS version",
          "if ([Environment]::OSVersion.Version.Major -le 5) {",
          "    Write-Error 'This command is not supported on Windows 2003 or lower.'",
          "    exit -1",
          "} elseif ([Environment]::OSVersion.Version.Major -ge 10) {",
          "    $sku = (Get-CimInstance -ClassName Win32_OperatingSystem).OperatingSystemSKU",
          "    if ($sku -eq 143 -or $sku -eq 144) {",
          "        Write-Host 'This command is not supported on Windows 2016 Nano Server.'",
          "        exit -1",
          "    }",
          "}",
          "# Check the SSM agent version",
          "$ssmAgentService = Get-ItemProperty 'HKLM:SYSTEM\\CurrentControlSet\\Services\\AmazonSSMAgent\\'",
          "$ssmAgentVersion = $ssmAgentService.Version",
          "if (-not $ssmAgentVersion) {",
          "    $ssmAgentPath = [IO.Path]::Combine([Environment]::GetEnvironmentVariable([Environment+SpecialFolder]::ProgramFiles), 'Amazon', 'SSM', 'amazon-ssm-agent.exe')",
          "    $versionString = Invoke-Expression \"& `\"$ssmAgentPath`\" -version\"",
          "    $ssmAgentVersion = $versionString.Split(':')[-1].trim()",
          "}",
          "if ($ssmAgentVersion -lt '2.0.834.0') {",
          "    Write-Host 'This command is not supported with SSM Agent version less than 2.0.834.0.'",
          "    exit -1",
          "}",
          "",
          "# Application specific constants",
          "$appName = 'PatchBaselineOperations'",
          "$psModuleFileName = 'Amazon.PatchBaselineOperations.dll'",
          "$s3FileName = 'Amazon.PatchBaselineOperationsWindowsCrossAccount-1.11.zip'",
          "$s3FileHash = '747AABA407DBD3D6EAD8D76FDDBD52C40436F003F1C8B8F5A099BA76E9F53ACF'",
          "$psModuleHashes = @{",
          "    'AWSSDK.CognitoIdentity.dll' = '733B334501E9EC0D1D4999910E5384D26EF7B3113D37A4078B183887EB9C0057';",
          "    'AWSSDK.Core.dll' = 'F674B21DC8F912362DBC36EB5640190EAAF3481D3B47E866DDA6F1B5C0CE6EE4';",
          "    'AWSSDK.Pinpoint.dll' = '300075578C54E803E596EB442136AC81B74D755E0AF90121241D566F30A964A1';",
          "    'AWSSDK.ResourceGroupsTaggingAPI.dll' = 'A34D218C5EF0B20A9EC5F37AD74E0AC185AB34D3B6E79918FC9148D6B0A59FCD';",
          "    'AWSSDK.S3.dll' = '4DDF0E3F05D945358C37AAE2BCCF089B48899D3FD1726963AF2153B7B597AE9F';",
          "    'AWSSDK.SecurityToken.dll' = 'E9ABA063F4701357F14865AB4856C9D27691766BA316C0D57AB4D5E97CED8B98';",
          "    'AWSSDK.SimpleSystemsManagement.dll' = '40AE48158862D44D6BEAC9382C9BEE2A601868B9F757D5309797B46F803F00FD';",
          "    'Amazon.PatchBaselineOperations.dll' = 'A4E38686CC2197AF28881BFC3F4AB254AE96DCD97B67CDE86FF338D47D1C20EE';",
          "    'Newtonsoft.Json.dll' = '0516D4109263C126C779E4E8F5879349663FA0A5B23D6D44167403E14066E6F9';",
          "    'THIRD_PARTY_LICENSES.txt' = '6468E28E2C9EDAF28E98B025EE95C936ED7493AEB19207C36525A5ED5AD4AA56';",
          "    'YamlDotNet.dll' = 'D59E777A42A965327FCC18FC0AB7FA6729C0BCF845D239AC2811BD78F73A7F70';",
          "",
          "}",
          "",
          "# Folders and Logging",
          "$tempDirectory = split-path -parent $MyInvocation.MyCommand.Definition",
          "$downloadPath = [IO.Path]::Combine($tempDirectory, $s3FileName)",
          "$psModuleInstallLocation = [IO.Path]::Combine([Environment]::GetEnvironmentVariable([Environment+SpecialFolder]::ProgramFiles), 'Amazon', $appName)",
          "$psModuleInstallFile = [IO.Path]::Combine($psModuleInstallLocation, $psModuleFileName)",
          "",
          "function CheckFileHash ($filePath, $fileHash) {",
          "    if (Test-Path($filePath)) {",
          "        $fileStream = New-Object System.IO.FileStream($filePath, [System.IO.FileMode]::Open, [System.IO.FileAccess]::Read)",
          "        $sha256 = [System.Security.Cryptography.HashAlgorithm]::Create('System.Security.Cryptography.SHA256CryptoServiceProvider')",
          "        $sourceHash = [System.BitConverter]::ToString($sha256.ComputeHash($fileStream), 0).Replace('-', '').ToLowerInvariant()",
          "        $sha256.Dispose()",
          "        $fileStream.Dispose()",
          "",
          "        if ($sourceHash -ne $fileHash) {",
          "            return $false",
          "        }",
          "        else {",
          "            return $true",
          "        }",
          "    }",
          "    else {",
          "        return $false",
          "    }",
          "}",
          "",
          "function CheckPowerShellModuleInstallation ([bool]$suppressError) {",
          "    $isInstalled = $false",
          "    # Path does not exist meaning it has never been downloaded.",
          "    if (Test-Path($psModuleInstallLocation)) {",
          "        # Check if the expected number of files and directories are in the folder",
          "        if (((Get-ChildItem $psModuleInstallLocation -Directory | Measure-Object | %{$_.Count}) -eq 0) -and",
          "            ((Get-ChildItem $psModuleInstallLocation -File | Measure-Object | %{$_.Count}) -eq $psModuleHashes.Count)) {",
          "            $validFileHashes = $true",
          "",
          "            # Check each file for their expected file hash.",
          "            Get-ChildItem $psModuleInstallLocation -File | ForEach-Object {",
          "                if ($psModuleHashes.ContainsKey($_.Name)) {",
          "                    $installFile = [IO.Path]::Combine($psModuleInstallLocation, $_.Name)",
          "                    if (-Not (CheckFileHash $installFile $psModuleHashes[$_.Name])) {",
          "                        if (-Not $suppressError) {",
          "                            Write-Error ('The SHA hash of the {0} file does not match the expected value.' -f $_.Name)",
          "                        }",
          "                        $validFileHashes = $false",
          "                    }",
          "                } else {",
          "                    if (-Not $suppressError) {",
          "                        Write-Error ('The PowerShellModule installation folder contains an unexpected file with name {0}.' -f $_.Name)",
          "                    }",
          "                    $validFileHashes = $false",
          "                }",
          "            }",
          "            $isInstalled = $validFileHashes",
          "        } else {",
          "            if (-Not $suppressError) {",
          "                Write-Error ('An incorrect number of files were present in the PowerShellModule installation folder. The contents will be deleted.')",
          "            }",
          "        }",
          "        if (-Not $isInstalled) {",
          "            # Remove all files and folders as the folder contains potentially malicious software.",
          "            Remove-Item $psModuleInstallLocation -Recurse",
          "        }",
          "    }",
          "",
          "    return $isInstalled",
          "}",
          "",
          "function ExtractZipCoreOs ([string]$zipFilePath, [string]$destPath) {",
          "    try {",
          "        [System.Reflection.Assembly]::LoadWithPartialName('System.IO.Compression.FileSystem') | Out-Null",
          "        $zip = [System.IO.Compression.ZipFile]::OpenRead($zipFilePath)",
          "        foreach ($item in $zip.Entries) {",
          "            $extractedPath = Join-Path $destPath $item.FullName",
          "",
          "            if ($item.Length -eq 0) {",
          "                if ((Test-Path $extractedPath) -eq 0) {",
          "                    mkdir $extractedPath | Out-Null",
          "                }",
          "            } else {",
          "                $fileParent = Split-Path $extractedPath",
          "",
          "                if ((Test-Path $fileParent) -eq 0) {",
          "                    mkdir $fileParent | Out-Null",
          "                }",
          "",
          "                [System.IO.Compression.ZipFileExtensions]::ExtractToFile($item, $extractedPath, $true)",
          "            }",
          "        }",
          "    } catch {",
          "        throw 'Error encountered when extracting patch management zip file.`n$($_.Exception.Message)'",
          "    } finally {",
          "        $zip.Dispose()",
          "    }",
          "}",
          "",
          "# Hash of bucket digest",
          "function Get-HashString([String]$InString) {",
          "  $StringBuilder = New-Object System.Text.StringBuilder",
          "  [System.Security.Cryptography.HashAlgorithm]::Create(\"SHA256\").ComputeHash([System.Text.Encoding]::UTF8.GetBytes($InString)) | ForEach-Object {",
          "    [Void]$StringBuilder.Append($_.ToString(\"x2\"))",
          "  }",
          "  return $StringBuilder.ToString()",
          "}",
          "",
          "function InstallPowerShellModule {",
          "    if (-Not (CheckPowerShellModuleInstallation $true)) {",
          "        Write-Output (\"Preparing to download {0} PowerShell module from S3.`r`n\" -f $appName)",
          "",
          "        #Setup the directories if they do not exist.",
          "        if (-Not (Test-Path($psModuleInstallLocation))) {",
          "            $noOp = New-Item $psModuleInstallLocation -ItemType Directory",
          "        }",
          "",
          "        if (-Not (Test-Path($tempDirectory))) {",
          "            $noOp = New-Item $tempDirectory -ItemType Directory",
          "        }",
          "        $s3Location = 'https://s3.amazonaws.com/aws-ssm-us-east-1/' + $appName.ToLower() + '/crossaccount/payloads/' + $s3FileName",
          "",
          "        Write-Output (\"Downloading {0} PowerShell module from {1} to {2}.`r`n\" -f $appName, $s3Location, $downloadPath)",
          "",
          "        # Add Tls 1.2 support.",
          "        [Net.ServicePointManager]::SecurityProtocol = [Net.ServicePointManager]::SecurityProtocol -bOr [Net.SecurityProtocolType]::Tls12",
          "",
          "        (New-Object Net.WebClient).DownloadFile($s3Location, $downloadPath)",
          "",
          "        if (CheckFileHash $downloadPath $s3FileHash ) {",
          "            Write-Output (\"Extracting {0} zip file contents to temporary folder.`r`n\" -f $appName)",
          "            try {",
          "               (New-Object -Com Shell.Application).namespace($psModuleInstallLocation).CopyHere((New-Object -Com Shell.Application).namespace($downloadPath).Items(), 16)",
          "            } catch [Exception] {",
          "                ExtractZipCoreOs $downloadPath $psModuleInstallLocation",
          "            }",
          "        }",
          "        else {",
          "            throw ('The SHA hash of the {0} S3 source file does not match the expected value.' -f $appName)",
          "        }",
          "",
          "        Write-Output (\"Verifying SHA 256 of the {0} PowerShell module files.`r`n\" -f $appName)",
          "        if (-Not (CheckPowerShellModuleInstallation $false)) {",
          "            throw ('The verification of the {0} PowerShell module did not pass.' -f $appName)",
          "        }",
          "        Write-Output (\"Successfully downloaded and installed the {0} PowerShell module.`r`n\" -f $appName)",
          "    }",
          "}",
          "",
          "try {",
          "    InstallPowerShellModule",
          "} catch [Exception] {",
          "    $msg = \"An error occurred when executing {0}: {1}`r`n\" -f $appName, $_.Exception.Message",
          "    Write-Error $msg",
          "    exit -1",
          "}",
          "finally {",
          "    if (Test-Path $downloadPath) {",
          "        rm $downloadPath",
          "    }",
          "}",
          "",
          "#setup the command",
          "import-module $psmoduleinstallfile",
          "$response = Invoke-PatchBaselineOperationCrossAccount -Operation {{Operation}} -BaselineTag '{{BaselineTags}}' -AssociationId '{{AssociationId}}' -InstallOverrideList '{{InstallOverrideList}}' -RebootOption '{{RebootOption}}' -InstanceId $env:AWS_SSM_INSTANCE_ID -Region $env:AWS_SSM_REGION_NAME",
          "",
          "if ($response.exitcode -ne 3010)",
          "{",
          "    $response.tostring()",
          "}",
          "",
          "exit $response.exitcode"
        ],
        "timeoutSeconds": 7200
      },
      "name": "PatchWindows",
      "precondition": {
        "StringEquals": [
          "platformType",
          "Windows"
        ]
      }
    },
    {
      "action": "aws:runShellScript",
      "inputs": {
        "runCommand": [
          "#!/bin/bash",
          "PYTHON_CMD=''",
          "",
          "check_binary() {",
          "    HAS_VAR_NAME=HAS_$2",
          "    CMD_VAR_NAME=$2_CMD",
          "    if [ \"$(eval echo \\${${HAS_VAR_NAME}})\" = \"0\" ]; then return; fi",
          "    which $1 2>/dev/null",
          "    RET_CODE=$?",
          "    eval \"${HAS_VAR_NAME}=${RET_CODE}\"",
          "    if [ ${RET_CODE} -eq 0 ]; then eval \"${CMD_VAR_NAME}=$1\"; fi",
          "}",
          "",
          "check_binary python3 PYTHON3",
          "check_binary python2.6 PYTHON2_6",
          "check_binary python26 PYTHON26",
          "check_binary python2.7 PYTHON2_7",
          "check_binary python27 PYTHON27",
          "check_binary python2 PYTHON2",
          "",
          "which python 2>/dev/null",
          "if [ $? -eq 0 ]; then",
          "  PYTHON_VERSION=$(python --version 2>&1 | grep -Po '(?<=Python )[\\d]')",
          "  eval \"HAS_PYTHON${PYTHON_VERSION}=0\"",
          "  eval \"PYTHON${PYTHON_VERSION}_CMD='python'\"",
          "fi",
          "",
          "check_binary apt-get APT",
          "check_binary yum YUM",
          "check_binary dnf DNF",
          "check_binary zypper ZYPP",
          "",
          "check_install_code() {",
          "    if [ $1 -ne 0 ]",
          "    then",
          "        echo \"WARNING: Could not install the $2, this may cause the patching operation to fail.\" >&2",
          "    fi",
          "}",
          "",
          "get_env_var_hash_key() {",
          "    # Get an environment variable that is a dictionary and retrieve the provided key.",
          "    # $1 is the environment variable.",
          "    # $2 is the dictionary key.",
          "    # $3 is the python version & command found on instance.",
          "    result=$(echo -e \"import json\\nimport os\\nprint(json.loads(os.environ[\\\"$1\\\"])[\\\"$2\\\"])\" | $3)",
          "    if [ -z \"$result\" ]",
          "    then",
          "        exit 1",
          "    fi",
          "    echo $result",
          "}",
          "",
          "CANDIDATES=( $HAS_PYTHON2_6 $HAS_PYTHON26 $HAS_PYTHON2_7 $HAS_PYTHON27 $HAS_PYTHON2 )",
          "HAS_ANY_PYTHON2=1",
          "for CANDIDATE in \"${CANDIDATES[@]}\"",
          "do",
          "    if [ $CANDIDATE -eq 0 ]",
          "    then",
          "        HAS_ANY_PYTHON2=0",
          "    fi",
          "done",
          "",
          "check_instance_is_debian_8() {",
          "    if [ -f /etc/os-release ] && grep \"ID=debian\" /etc/os-release >/dev/null; then",
          "        IS_DEBIAN=true",
          "        if grep 'VERSION_ID=\"8\"' /etc/os-release >/dev/null; then",
          "            IS_DEBIAN_8=true",
          "        fi",
          "    fi",
          "}",
          "check_if_debian_signing_key_exist() {",
          "    MISSING_KEY=0",
          "    if [ \"$HAS_APT_KEY\" = \"0\" ] && (apt-key list | grep -w 8AE22BA9) > /dev/null; then",
          "      MISSING_KEY=1",
          "    fi",
          "}",
          "prepare_instance_if_debian_8() {",
          "    KEY_IMPORTED=0",
          "    COMMENTED_OUT_BACKPORTS=0",
          "    check_instance_is_debian_8",
          "    if [ ! -z $IS_DEBIAN ] && [ ! -z $IS_DEBIAN_8 ]; then",
          "        HAS_APT_KEY=1",
          "        check_binary apt-key APT_KEY",
          "        check_if_debian_signing_key_exist",
          "        if [ \"$HAS_APT_KEY\" = \"0\" ]; then",
          "            if [ \"$MISSING_KEY\" = \"0\" ]; then",
          "                apt-key adv --keyserver keyserver.ubuntu.com --recv-keys AA8E81B4331F7F50 >/dev/null 2>&1",
          "                KEY_IMPORTED=1",
          "                echo \"Imported missing signing key: AA8E81B4331F7F50\"",
          "            else",
          "                echo \"Skip to synchronize pakcage index for DEBIAN 8 instance. \"",
          "            fi",
          "        else",
          "            echo \"Could not locate apt-key.\"",
          "        fi",
          "        if [ -f /etc/apt/sources.list.d/backports.list ]; then",
          "            if grep -i \"^#[[:space:]]*deb http://cloudfront.debian.net/debian jessie-backports main\" /etc/apt/sources.list.d/backports.list >/dev/null;then",
          "                echo \"Already commented out jessie backports\"",
          "            else",
          "                sed -e \"/jessie-backports main/ s/^#*/#/\" -i /etc/apt/sources.list.d/backports.list",
          "                COMMENTED_OUT_BACKPORTS=1",
          "            fi",
          "        fi",
          "        echo \"Synchronizing pakcage index for DEBIAN 8 instance\"",
          "        apt-get update >/dev/null",
          "    fi",
          "}",
          "",
          "clean_up_instances_if_debian_8() {",
          "    if [ \"$KEY_IMPORTED\" = \"1\" ]; then",
          "        apt-key del 8AE22BA9 > /dev/null",
          "    fi",
          "    if [ \"$COMMENTED_OUT_BACKPORTS\" = \"1\" ]; then",
          "        sudo sed -e '/jessie-backports main/ s/^#//g' -i /etc/apt/sources.list.d/backports.list",
          "    fi",
          "}",
          "",
          "if [ $HAS_APT -eq 0 -a $HAS_PYTHON3 -eq 0 ]",
          "then",
          "    PYTHON_CMD=${PYTHON3_CMD}",
          "    prepare_instance_if_debian_8",
          "    apt-get install python3-apt -y",
          "    check_install_code $? \"python3-apt\"",
          "",
          "elif  [ $HAS_DNF -eq 0 ] && [ $HAS_PYTHON2 -eq 0 -o $HAS_PYTHON3 -eq 0 ]",
          "then",
          "    if [ $HAS_PYTHON2 -eq 0 ]",
          "    then",
          "        PYTHON_CMD=${PYTHON2_CMD}",
          "    elif [ $HAS_PYTHON3 -eq 0 ]",
          "    then",
          "        PYTHON_CMD=${PYTHON3_CMD}",
          "    fi",
          "",
          "elif [ $HAS_YUM -eq 0 -a $HAS_ANY_PYTHON2 -eq 0 ]",
          "then",
          "",
          "    HAS_COMPATIBLE_YUM=false",
          "",
          "    INSTALLED_PYTHON=( $PYTHON2_7_CMD $PYTHON27_CMD $PYTHON2_CMD $PYTHON2_6_CMD $PYTHON26_CMD  )",
          "    for TEST_PYTHON_CMD in \"${INSTALLED_PYTHON[@]}\"",
          "    do",
          "        ${TEST_PYTHON_CMD} -c \"import yum\" 2>/dev/null",
          "        if [ $? -ne 0 ]; then",
          "            echo \"Unable to import yum module on $TEST_PYTHON_CMD\"",
          "        else",
          "            PYTHON_CMD=${TEST_PYTHON_CMD}",
          "            HAS_COMPATIBLE_YUM=true",
          "            break",
          "        fi",
          "    done",
          "    if ! $HAS_COMPATIBLE_YUM; then",
          "        echo \"Unable to import yum module, please check version compatibility between Yum and Python\"",
          "        exit 1",
          "    else",
          "        YUM_VERSION=$(yum --version 2>/dev/null | sed -n 1p)",
          "        echo \"Using Yum version: $YUM_VERSION\"",
          "    fi",
          "",
          "elif [ $HAS_ZYPP -eq 0 -a $HAS_PYTHON3 -eq 0 ]",
          "then",
          "    PYTHON_CMD=${PYTHON3_CMD}",
          "elif [ $HAS_ZYPP -eq 0 -a $HAS_PYTHON2 -eq 0 ]",
          "then",
          "    PYTHON_CMD=${PYTHON2_CMD}",
          "else",
          "    echo \"An unsupported package manager and python version combination was found.\"",
          "    if [ $HAS_DNF -eq 0 ]",
          "    then",
          "        echo \"Dnf requires Python2 or Python3 to be installed.\"",
          "    elif [ $HAS_YUM -eq 0 ]",
          "    then",
          "        echo \"Yum requires Python2 to be installed.\"",
          "    elif [ $HAS_APT -eq 0 ]",
          "    then",
          "        echo \"Apt requires Python3 to be installed.\"",
          "    elif [ $HAS_ZYPP -eq 0 ]",
          "    then",
          "        echo \"ZYpp requires Python2 or Python3 to be installed.\"",
          "    fi",
          "    echo \"Python3=$HAS_PYTHON3, Python2=$HAS_ANY_PYTHON2, Yum=$HAS_YUM, Apt=$HAS_APT, Zypper=$HAS_ZYPP, Dnf=$HAS_DNF\"",
          "    echo \"Exiting...\"",
          "    exit 1",
          "fi",
          "",
          "echo \"Using python binary: '${PYTHON_CMD}'\"",
          "PYTHON_VERSION=$(${PYTHON_CMD} --version  2>&1)",
          "echo \"Using Python Version: $PYTHON_VERSION\"",
          "",
          "echo '",
          "import errno",
          "import hashlib",
          "import json",
          "import logging",
          "import os",
          "import shutil",
          "import subprocess",
          "import tarfile",
          "import sys",
          "",
          "tmp_dir = os.path.abspath(\"/var/log/amazon/ssm/patch-baseline-operations/\")",
          "reboot_dir = os.path.abspath(\"/var/log/amazon/ssm/patch-baseline-operations-reboot-194/\")",
          "reboot_with_failure_dir = os.path.abspath(\"/var/log/amazon/ssm/patch-baseline-operations-reboot-195/\")",
          "reboot_with_dependency_failure_dir = os.path.abspath(\"/var/log/amazon/ssm/patch-baseline-operations-reboot-196/\")",
          "",
          "# initialize logging",
          "LOGGER_FORMAT = \"%(asctime)s %(name)s [%(levelname)s]: %(message)s\"",
          "LOGGER_DATEFORMAT = \"%m/%d/%Y %X\"",
          "LOGGER_LEVEL = logging.INFO",
          "LOGGER_STREAM = sys.stdout",
          "",
          "logging.basicConfig(format=LOGGER_FORMAT, datefmt=LOGGER_DATEFORMAT, level=LOGGER_LEVEL, stream=LOGGER_STREAM)",
          "logger = logging.getLogger()",
          "",
          "ERROR_CODE_MAP = {",
          "    150: \"Neither curl nor wget is installed on the instance, abort.\",",
          "    151: \"%s sha256 check failed, should be %s, but is %s\",",
          "    152: \"Unable to load and extract the content of payload, abort.\",",
          "    154: \"Unable to create dir: %s\",",
          "    155: \"Unable to extract tar file: %s.\",",
          "    156: \"Unable to download payload: %s.\"",
          "}",
          "",
          "# When an install occurs and the instance needs a reboot, the agent restarts our plugin.",
          "# Check if these folders exist to know how to succeed or fail a command after a reboot.",
          "# DO NOT remove these files here. They are cleaned in the common startup.",
          "if os.path.exists(reboot_dir) or os.path.exists(reboot_with_failure_dir) or os.path.exists(reboot_with_dependency_failure_dir):",
          "    # Reload Payload so that we remove reboot directories",
          "    if os.path.exists(tmp_dir):",
          "        shutil.rmtree(tmp_dir)",
          "",
          "def create_dir(dirpath):",
          "    dirpath = os.path.abspath(dirpath)",
          "    if not os.path.exists(dirpath):",
          "        try:",
          "            os.makedirs(dirpath)",
          "        except OSError as e:  # Guard against race condition",
          "            if e.errno != errno.EEXIST:",
          "                raise e",
          "        except Exception as e:",
          "            logger.error(\"Unable to create dir: %s\", dirpath)",
          "            logger.exception(e)",
          "            abort(154, (dirpath))",
          "",
          "def use_curl():",
          "    output, has_curl = shell_command([\"which\", \"curl\"])",
          "    if has_curl == 0:",
          "        return True",
          "    else:",
          "        return False",
          "",
          "def use_wget():",
          "    output, has_wget = shell_command([\"which\", \"wget\"])",
          "    if has_wget == 0:",
          "        return True",
          "    else:",
          "        return False",
          "",
          "def download_to(url, file_path):",
          "    curl_present = use_curl()",
          "    logger.info(\"Downloading payload from %s\", url)",
          "    if curl_present:",
          "        output, curl_return = shell_command([\"curl\", \"-f\", \"-o\", file_path, url])",
          "    else:",
          "        wget_present = use_wget()",
          "        if not wget_present:",
          "            logger.error(\"Neither curl nor wget is installed on the instance. Exiting...\")",
          "            abort(150)",
          "        output, curl_return = shell_command([\"wget\", \"-O\", file_path, url])",
          "",
          "    if curl_return != 0:",
          "        download_agent = \"curl\" if curl_present else \"wget\"",
          "        logger.error(\"Error code returned from %s is %d\", download_agent, curl_return)",
          "        abort(156, (url))",
          "",
          "def extract_tar(path):",
          "    path = os.path.abspath(path)",
          "    try:",
          "        f = tarfile.open(path, \"r|gz\")",
          "        f.extractall()",
          "    except Exception as e:",
          "        logger.error(\"Unable to extract tar file: %s.\", path)",
          "        logger.exception(e)",
          "        abort(155, (path))",
          "    finally:",
          "        f.close()",
          "",
          "def shell_command(cmd_list):",
          "    with open(os.devnull, \"w\") as devnull:",
          "        p = subprocess.Popen(cmd_list, stdout=subprocess.PIPE, stderr=devnull)",
          "        (std_out, _) = p.communicate()",
          "        if not type(std_out) == str:",
          "            std_out = std_out.decode(\"utf-8\")",
          "        return (std_out, p.returncode)",
          "",
          "def abort(error_code, params = ()):",
          "    if os.path.exists(tmp_dir):",
          "        shutil.rmtree(tmp_dir)",
          "    sys.stderr.write(ERROR_CODE_MAP.get(error_code) % params)",
          "    sys.exit(error_code)",
          "",
          "def sha256_checksum(filename):",
          "    sha256_hash = hashlib.sha256()",
          "    with open(filename,\"rb\") as f:",
          "        # Read and update hash string value in blocks of 4K",
          "        for byte_block in iter(lambda: f.read(4096),b\"\"):",
          "            sha256_hash.update(byte_block)",
          "        return sha256_hash.hexdigest().upper()",
          "",
          "# cd into the temp directory",
          "create_dir(tmp_dir)",
          "os.chdir(tmp_dir)",
          "",
          "region = os.environ[\"AWS_SSM_REGION_NAME\"]",
          "",
          "# main logic",
          "s3_bucket = \"aws-ssm-%s\"%(region)",
          "s3_prefix = \"patchbaselineoperations/crossaccount/payloads\"",
          "payload_name = \"patch-baseline-operations-cross-account-98.0.tar.gz\"",
          "payload_sha256 = \"069713700B5215C2923F759E3B7AFADC22A1BD1CB5E2D28E911BB4439F474932\"",
          "",
          "# New bucket location",
          "url_template = \"https://s3.us-east-1.amazonaws.com/aws-ssm-us-east-1/%s\"",
          "download_to(url_template % (os.path.join(s3_prefix, payload_name)), payload_name)",
          "",
          "# payloads are the actual files to be used for linux patching",
          "payloads = []",
          "try:",
          "    sha256_code = sha256_checksum(payload_name)",
          "    if not sha256_code == payload_sha256:",
          "        error_msg = \"%s sha256 check failed, should be %s, but is %s\" % (payload_name, payload_sha256, sha256_code)",
          "        logger.error(error_msg)",
          "        abort(151, (payload_name, payload_sha256, sha256_code))",
          "    extract_tar(payload_name)",
          "    # Change owner & group to be root user for the payload.",
          "    shell_command([\"chown\", \"-R\", \"0:0\", tmp_dir])",
          "except Exception as e:",
          "    error_msg = \"Unable to load and extract the content of payload, abort.\"",
          "    logger.error(error_msg)",
          "    logger.exception(e)",
          "    abort(152)",
          "",
          "",
          "import sys",
          "try:",
          "    import common_startup_entrance",
          "    common_startup_entrance.execute(\"os_selector_cross_account\", \"PatchLinux\", \"{{BaselineTags}}\",\\",
          "            \"{{AssociationId}}\", \"{{Operation}}\",\\",
          "            \"{{InstallOverrideList}}\", \"{{RebootOption}}\")",
          "except Exception as e:",
          "    error_code = 156",
          "    if hasattr(e, \"error_code\") and type(e.error_code) == int:",
          "        error_code = e.error_code;",
          "    logger.exception(e)",
          "    sys.exit(error_code)",
          "    ",
          "",
          "' | $PYTHON_CMD",
          "",
          "RETURN_CODE=$?",
          "",
          "clean_up_instances_if_debian_8",
          "",
          "exit $RETURN_CODE"
        ],
        "timeoutSeconds": 7200
      },
      "name": "PatchLinux",
      "precondition": {
        "StringEquals": [
          "platformType",
          "Linux"
        ]
      }
    },
    {
      "action": "aws:runShellScript",
      "inputs": {
        "runCommand": [
          "#!/bin/bash",
          "PYTHON_CMD=''",
          "",
          "check_binary() {",
          "    HAS_VAR_NAME=HAS_$2",
          "    CMD_VAR_NAME=$2_CMD",
          "    if [ \"$(eval echo \\${${HAS_VAR_NAME}})\" = \"0\" ]; then return; fi",
          "    which $1 2>/dev/null",
          "    RET_CODE=$?",
          "    eval \"${HAS_VAR_NAME}=${RET_CODE}\"",
          "    if [ ${RET_CODE} -eq 0 ]; then eval \"${CMD_VAR_NAME}=$1\"; fi",
          "}",
          "",
          "check_binary python3 PYTHON3",
          "check_binary python2.6 PYTHON2_6",
          "check_binary python26 PYTHON26",
          "check_binary python2.7 PYTHON2_7",
          "check_binary python27 PYTHON27",
          "check_binary python2 PYTHON2",
          "",
          "which python 2>/dev/null",
          "if [ $? -eq 0 ]; then",
          "  PYTHON_VERSION=$(python --version 2>&1 | perl -lne 'print $& if /(?<=Python )[\\\\d]/')",
          "  eval \"HAS_PYTHON${PYTHON_VERSION}=0\"",
          "  eval \"PYTHON${PYTHON_VERSION}_CMD='python'\"",
          "fi",
          "",
          "check_install_code() {",
          "    if [ $1 -ne 0 ]",
          "    then",
          "        echo \"WARNING: Could not install the $2, this may cause the patching operation to fail.\" >&2",
          "    fi",
          "}",
          "",
          "get_env_var_hash_key() {",
          "    # Get an environment variable that is a dictionary and retrieve the provided key.",
          "    # $1 is the environment variable.",
          "    # $2 is the dictionary key.",
          "    # $3 is the python version & command found on instance.",
          "    result=$(echo -e \"import json\\nimport os\\nprint(json.loads(os.environ[\\\"$1\\\"])[\\\"$2\\\"])\" | $3)",
          "    if [ -z \"$result\" ]",
          "    then",
          "        exit 1",
          "    fi",
          "    echo $result",
          "}",
          "",
          "CANDIDATES=( $HAS_PYTHON2_6 $HAS_PYTHON26 $HAS_PYTHON2_7 $HAS_PYTHON27 $HAS_PYTHON2 )",
          "HAS_ANY_PYTHON2=1",
          "for CANDIDATE in \"${CANDIDATES[@]}\"",
          "do",
          "    if [ $CANDIDATE -eq 0 ]",
          "    then",
          "        HAS_ANY_PYTHON2=0",
          "    fi",
          "done",
          "",
          "if [ $HAS_PYTHON3 -eq 0 ]",
          "then",
          "    PYTHON_CMD=${PYTHON3_CMD}",
          "fi",
          "",
          "echo \"Using python binary: '${PYTHON_CMD}'\"",
          "PYTHON_VERSION=$(${PYTHON_CMD} --version  2>&1)",
          "echo \"Using Python Version: $PYTHON_VERSION\"",
          "",
          "echo '",
          "import errno",
          "import hashlib",
          "import json",
          "import logging",
          "import os",
          "import shutil",
          "import subprocess",
          "import tarfile",
          "import sys",
          "",
          "tmp_dir = os.path.abspath(\"/var/log/amazon/ssm/patch-baseline-operations/\")",
          "reboot_dir = os.path.abspath(\"/var/log/amazon/ssm/patch-baseline-operations-reboot-194/\")",
          "reboot_with_failure_dir = os.path.abspath(\"/var/log/amazon/ssm/patch-baseline-operations-reboot-195/\")",
          "reboot_with_dependency_failure_dir = os.path.abspath(\"/var/log/amazon/ssm/patch-baseline-operations-reboot-196/\")",
          "",
          "# initialize logging",
          "LOGGER_FORMAT = \"%(asctime)s %(name)s [%(levelname)s]: %(message)s\"",
          "LOGGER_DATEFORMAT = \"%m/%d/%Y %X\"",
          "LOGGER_LEVEL = logging.INFO",
          "LOGGER_STREAM = sys.stdout",
          "",
          "logging.basicConfig(format=LOGGER_FORMAT, datefmt=LOGGER_DATEFORMAT, level=LOGGER_LEVEL, stream=LOGGER_STREAM)",
          "logger = logging.getLogger()",
          "",
          "ERROR_CODE_MAP = {",
          "    150: \"Neither curl nor wget is installed on the instance, abort.\",",
          "    151: \"%s sha256 check failed, should be %s, but is %s\",",
          "    152: \"Unable to load and extract the content of payload, abort.\",",
          "    154: \"Unable to create dir: %s\",",
          "    155: \"Unable to extract tar file: %s.\",",
          "    156: \"Unable to download payload: %s.\"",
          "}",
          "",
          "# When an install occurs and the instance needs a reboot, the agent restarts our plugin.",
          "# Check if these folders exist to know how to succeed or fail a command after a reboot.",
          "# DO NOT remove these files here. They are cleaned in the common startup.",
          "if os.path.exists(reboot_dir) or os.path.exists(reboot_with_failure_dir) or os.path.exists(reboot_with_dependency_failure_dir):",
          "    # Reload Payload so that we remove reboot directories",
          "    if os.path.exists(tmp_dir):",
          "        shutil.rmtree(tmp_dir)",
          "",
          "def create_dir(dirpath):",
          "    dirpath = os.path.abspath(dirpath)",
          "    if not os.path.exists(dirpath):",
          "        try:",
          "            os.makedirs(dirpath)",
          "        except OSError as e:  # Guard against race condition",
          "            if e.errno != errno.EEXIST:",
          "                raise e",
          "        except Exception as e:",
          "            logger.error(\"Unable to create dir: %s\", dirpath)",
          "            logger.exception(e)",
          "            abort(154, (dirpath))",
          "",
          "def use_curl():",
          "    output, has_curl = shell_command([\"which\", \"curl\"])",
          "    if has_curl == 0:",
          "        return True",
          "    else:",
          "        return False",
          "",
          "def use_wget():",
          "    output, has_wget = shell_command([\"which\", \"wget\"])",
          "    if has_wget == 0:",
          "        return True",
          "    else:",
          "        return False",
          "",
          "def download_to(url, file_path):",
          "    curl_present = use_curl()",
          "    logger.info(\"Downloading payload from %s\", url)",
          "    if curl_present:",
          "        output, curl_return = shell_command([\"curl\", \"-f\", \"-o\", file_path, url])",
          "    else:",
          "        wget_present = use_wget()",
          "        if not wget_present:",
          "            logger.error(\"Neither curl nor wget exists on the instance. Exiting...\")",
          "            abort(150)",
          "        output, curl_return = shell_command([\"wget\", \"-O\", file_path, url])",
          "",
          "    if curl_return != 0:",
          "        download_agent = \"curl\" if curl_present else \"wget\"",
          "        logger.error(\"Error code returned from %s is %d\", download_agent, curl_return)",
          "        abort(156, (url))",
          "",
          "def extract_tar(path):",
          "    path = os.path.abspath(path)",
          "    try:",
          "        f = tarfile.open(path, \"r|gz\")",
          "        f.extractall()",
          "    except Exception as e:",
          "        logger.error(\"Unable to extract tar file: %s.\", path)",
          "        logger.exception(e)",
          "        abort(155, (path))",
          "    finally:",
          "        f.close()",
          "",
          "def shell_command(cmd_list):",
          "    with open(os.devnull, \"w\") as devnull:",
          "        p = subprocess.Popen(cmd_list, stdout=subprocess.PIPE, stderr=devnull)",
          "        (std_out, _) = p.communicate()",
          "        if not type(std_out) == str:",
          "            std_out = std_out.decode(\"utf-8\")",
          "        return (std_out, p.returncode)",
          "",
          "def abort(error_code, params = ()):",
          "    if os.path.exists(tmp_dir):",
          "        shutil.rmtree(tmp_dir)",
          "    sys.stderr.write(ERROR_CODE_MAP.get(error_code) % params)",
          "    sys.exit(error_code)",
          "",
          "def sha256_checksum(filename):",
          "    sha256_hash = hashlib.sha256()",
          "    with open(filename,\"rb\") as f:",
          "        # Read and update hash string value in blocks of 4K",
          "        for byte_block in iter(lambda: f.read(4096),b\"\"):",
          "            sha256_hash.update(byte_block)",
          "        return sha256_hash.hexdigest().upper()",
          "",
          "# cd into the temp directory",
          "create_dir(tmp_dir)",
          "os.chdir(tmp_dir)",
          "",
          "region = os.environ[\"AWS_SSM_REGION_NAME\"]",
          "",
          "# main logic",
          "# Replace the region placeholder with correct region.",
          "digest = hashlib.sha256((\"-\".join([\"prod\", region, \"internal-patch-public-bucket\"])).encode(\"utf8\")).hexdigest()[0:9]",
          "if region == \"me-central-1\":",
          "    digest = hashlib.sha256((\"-\".join([\"prod\", region + region, \"internal-patch-public-bucket\"])).encode(\"utf8\")).hexdigest()[0:9]",
          "",
          "s3_bucket = \"aws-patchmanager-macos-%s-%s\"%(region, digest)",
          "s3_prefix = \"patchbaselineoperations/crossaccount/payloads\"",
          "payload_name = \"patch-baseline-operations-macos-cross-account-4.10.tar.gz\"",
          "payload_sha256 = \"CDA02E6BFF33E8B9373B9BA01879CFE8935B62CA2B395E15F44137D615E9FC01\"",
          "",
          "# download payload file and do signature verification",
          "url_template = \"https://s3.us-east-1.amazonaws.com/aws-patchmanager-macos-us-east-1-1970c647d/%s\"",
          "download_to(url_template % (os.path.join(s3_prefix, payload_name)), payload_name)",
          "",
          "# payloads are the actual files to be used for linux patching",
          "payloads = []",
          "try:",
          "    sha256_code = sha256_checksum(payload_name)",
          "    if not sha256_code == payload_sha256:",
          "        error_msg = \"%s sha256 check failed, should be %s, but is %s\" % (payload_name, payload_sha256, sha256_code)",
          "        logger.error(error_msg)",
          "        abort(151, (payload_name, payload_sha256, sha256_code))",
          "    extract_tar(payload_name)",
          "    # Change owner & group to be root user for the payload.",
          "    shell_command([\"chown\", \"-R\", \"0:0\", tmp_dir])",
          "except Exception as e:",
          "    error_msg = \"Unable to load and extract the content of payload, abort.\"",
          "    logger.error(error_msg)",
          "    logger.exception(e)",
          "    abort(152)",
          "",
          "",
          "import sys",
          "try:",
          "    import common_startup_entrance",
          "    common_startup_entrance.execute(\"os_selector_cross_account\", \"PatchMacOS\", \"{{BaselineTags}}\",\\",
          "            \"{{AssociationId}}\", \"{{Operation}}\",\\",
          "            \"{{InstallOverrideList}}\", \"{{RebootOption}}\")",
          "except Exception as e:",
          "    error_code = 156",
          "    if hasattr(e, \"error_code\") and type(e.error_code) == int:",
          "        error_code = e.error_code;",
          "    logger.exception(e)",
          "    sys.exit(error_code)",
          "    ",
          "",
          "' | $PYTHON_CMD",
          "",
          "RETURN_CODE=$?",
          "",
          "exit $RETURN_CODE"
        ],
        "timeoutSeconds": 7200
      },
      "name": "PatchMacOS",
      "precondition": {
        "StringEquals": [
          "platformType",
          "MacOS"
        ]
      }
    }
  ],
  "parameters": {
    "AssociationId": {
      "allowedPattern": "^((([0-9a-fA-F]){8}-([0-9a-fA-F]){4}-([0-9a-fA-F]){4}-([0-9a-fA-F]){4}-([0-9a-fA-F]){12}){0,1})$",
      "description": "(Required) The Association ID of the State Manager Association executing the document.",
      "type": "String"
    },
    "BaselineTags": {
      "allowedPattern": "(^$)|^Key=(.){1,256},Values=(.){0,256}[^,]$",
      "default": "",
      "description": "(Optional) The baseline tags to use during the patching operation.",
      "type": "String"
    },
    "InstallOverrideList": {
      "allowedPattern": "(^$)|^(https|s3)://([^/]+)/(([^/]+)/)*[^/]+$",
      "default": "",
      "description": "(Optional) An https URL or an Amazon S3 path-style URL to the list of patches to be installed. This patch installation list overrides the patches specified by the default patch baseline.",
      "type": "String"
    },
    "Operation": {
      "allowedValues": [
        "Scan",
        "Install"
      ],
      "description": "(Required) The update or configuration to perform on the instance. The system checks if patches specified in the patch baseline are installed on the instance. The install operation installs patches missing from the baseline.",
      "type": "String"
    },
    "RebootOption": {
      "allowedValues": [
        "RebootIfNeeded",
        "NoReboot"
      ],
      "default": "RebootIfNeeded",
      "description": "(Optional) Reboot behavior after a patch Install operation. If you choose NoReboot and patches are installed, the instance is marked as non-compliant until a subsequent reboot and scan.",
      "type": "String"
    }
  },
  "schemaVersion": "2.2"
}
