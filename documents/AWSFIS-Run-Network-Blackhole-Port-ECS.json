{
  "description": "### Document name - AWSFIS-Run-Network-Blackhole-Port-ECS\n\n## What does this document do?\nIt drops incoming or outgoing traffic for a configurable protocol (tcp / udp) and port, using the ECS fault injection endpoints.\n\n## Dependencies installed by this SSM Document\n* atd\n* curl-minimal\n* dig\n* jq\n\n## Input Parameters\n* Protocol: The protocol to blackhole (Supported: tcp|udp).\n* Port: The port to blackhole.\n* TrafficType: The type of traffic to blackhole (Supported: egress|ingress).\n* DurationSeconds: The duration - in seconds - of the test.\n* InstallDependencies: If set to True, the required dependencies will be installed.\n* FISActionState: The FIS-populated action state JSON.",
  "schemaVersion": "2.2",
  "parameters": {
    "FISActionState": {
      "type": "String",
      "description": "The FIS-populated action state JSON.",
      "allowedPattern": "^\\{\"id\":\"[\\s\\S]+\",\"callTime\":\\d{10},\"callCount\":\\d+}$"
    },
    "Protocol": {
      "type": "String",
      "description": "The protocol to blackhole (Supported: tcp|udp).",
      "allowedValues": [
        "tcp",
        "udp"
      ]
    },
    "Port": {
      "type": "String",
      "description": "The port to blackhole.",
      "allowedPattern": "^([1-9][0-9]{0,3}|[1-5][0-9]{4}|6[0-4][0-9]{3}|65[0-4][0-9]{2}|655[0-2][0-9]|6553[0-5])$"
    },
    "TrafficType": {
      "type": "String",
      "description": "The type of traffic to blackhole (Supported: egress|ingress).",
      "allowedValues": [
        "egress",
        "ingress"
      ]
    },
    "DurationSeconds": {
      "type": "String",
      "description": "The duration - in seconds - of the test.",
      "allowedPattern": "^[0-9]+$"
    },
    "InstallDependencies": {
      "type": "String",
      "description": "If set to True, the required dependencies will be installed.",
      "allowedValues": [
        "True",
        "False"
      ]
    }
  },
  "mainSteps": [
    {
      "action": "aws:runShellScript",
      "name": "InstallDependencies",
      "precondition": {
        "StringEquals": [
          "platformType",
          "Linux"
        ]
      },
      "description": "## Parameter: InstallDependencies\nIf set to True, this step installs the required dependencies using the yum package manager.\n",
      "inputs": {
        "onFailure": "exit",
        "runCommand": [
          "#!/bin/bash\n\n\nif [[ \"$( command -v atd 2>/dev/null )\" && \"$( command -v curl-minimal 2>/dev/null )\" && \"$( command -v dig 2>/dev/null )\" && \"$( command -v jq 2>/dev/null )\" ]]; then\n  echo Dependency is already installed. ; exit ;\nfi\n\nif  [[ \"{{ InstallDependencies }}\" == True ]] ; then\n  echo \"Installing required dependencies\"\n  yum -y install at curl-minimal bind-utils jq\n\n  if ! systemctl is-enabled atd || ! systemctl is-active atd; then\n      echo \"Enabling and starting atd\"\n      systemctl enable atd\n      systemctl start atd\n  fi\nelse\n    echo \"Dependencies are not installed - Please set InstallDependencies to True.\"\n    exit 1\nfi\n"
        ]
      }
    },
    {
      "action": "aws:runShellScript",
      "name": "FaultInjection",
      "precondition": {
        "StringEquals": [
          "platformType",
          "Linux"
        ]
      },
      "description": "# Parameters: Protocol, Port, TrafficType, and DurationSeconds\nThis step blocks Protocol TrafficType traffic to Port for the given DurationSeconds, using the ECS fault injection endpoints.\nIt has two rollback mechanisms in place:\n- It will listen for exit signals (SIGINT and SIGTERM), and will stop the fault injection if any of them is received.\n- It will periodically enqueue rollback checks into a queue (using at command). This way, if the command is stopped and the rollback was not executed, the enqueued commands will try to stop it. (for example, if the command is stopped using kill -9).\nThis is just an extra safety check to avoid having the latency remain injected after the script is no longer running.\nThis document is also “pessimistic”: every 20 seconds, FIS will update a file with the “last update” timestamp. If for any reason FIS stops updating that file, the document will assume that something is wrong with FIS and the fault will be stopped after 60 seconds.\n",
      "inputs": {
        "maxAttempts": 1,
        "timeoutSeconds": 43200,
        "runCommand": [
          "#!/bin/bash\n\n\n# Treat unset variables as an error\nset -o nounset\n\n\n########################\n# Fault-specific logic #\n########################\n\n# identify if the document is executed in heartbeat mode\nread -r -d '' FIS_ACTION_STATE_JSON <<'EOF'\n  {{ FISActionState }}\nEOF\nCALL_COUNT=\"$(echo $FIS_ACTION_STATE_JSON | jq -r '.callCount // empty')\"\nEXECUTION_MODE=\"$(if [[ \"$CALL_COUNT\" == \"1\" ]]; then echo \"START\"; else echo \"HEARTBEAT\"; fi)\"\n\nPORT={{ Port }}\nPROTOCOL={{ Protocol }}\nTRAFFIC={{ TrafficType }}\nDURATION={{ DurationSeconds }}\n\nFAULT_NAME=\"Run-Network-Blackhole-Port-ECS\"\n\n\n##################################\n#       Regional Endpoints       #\n##################################\n\nSSMMESSAGES_ENDPOINT=ssmmessages.us-east-1.amazonaws.com\nSSM_ENDPOINT=ssm.us-east-1.amazonaws.com\nEC2MESSAGES_ENDPOINT=ec2messages.us-east-1.amazonaws.com\n\n##################################\n\n##################################\n#            IP Ranges           #\n##################################\n\nIP_RANGES_URL=https://ip-ranges.amazonaws.com/ip-ranges.json\n\n##################################\n\nIP_REGEX=\"^(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])$\"\nIP_CIDR_REGEX=\"^(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\/(3[0-2]|[1-2][0-9]|[0-9]))$\"\n\nDELETE_MSG=\"#delete-after-fault-injection\"\n\nTARGET_IPS=()\nPROTECTED_IPS=()\nINVALID_SOURCES=()\n\n# add the line $1 at the end of file $2\nwrite_to_file()\n{\n  echo \"$1\" >> $2\n}\n\n# remove lines that contains the substring $1 in file $2\nremove_from_file()\n{\n  temp_file=$(mktemp)\n  sed \"/$1/d\" $2 > $temp_file\n  cat $temp_file > $2\n}\n\nforce_dns()\n{\n    # Force any new DNS resolution for that host to the latest known IPs\n    params=(\"$@\")\n    hostname=${params[0]}   # Hostname is expected as first argument\n    ips=(\"${params[@]:1}\")  # The rest will be the IPs\n    for ip in $(echo \"${ips[@]}\"); do\n      write_to_file \"$ip $hostname $DELETE_MSG\" /etc/hosts\n    done\n}\n\nget_ips()\n{\n    # Returns if the input is a valid IP/CIDR string, empty otherwise\n    local var_ip_cidr=$(grep -E \"$IP_CIDR_REGEX\" <<< \"$1\")\n    [  -z \"$var_ip_cidr\" ] || { echo $var_ip_cidr ; return ;}\n\n    # Returns if the input is a valid IP string, empty otherwise\n    local var_ip=$(grep -E \"$IP_REGEX\" <<< \"$1\")\n    [  -z \"$var_ip\" ] || { echo $var_ip ; return ;}\n\n    # Returns IPs of the domain and force DNS resolution to that IP, empty otherwise\n    # Since `dig` can return different IPs, we call it 10 times to maximize the chances of covering as many IPs as possible for the provided domain\n    local var_dns=()\n    for i in $(seq 1 10)\n    do\n        dig_output=( $(dig +short $1 | grep -v '[[:alpha:]]') )\n        [ ${#dig_output[@]} -eq 0 ] || var_dns+=(\"${dig_output[@]}\")\n    done\n    var_unique_dns=( $(printf '%s\\n' \"${var_dns[@]}\" | sort -u) )\n    [ ${#var_unique_dns[@]} -eq 0 ] || { echo \"${var_unique_dns[@]}\" ; force_dns $1 \"${var_unique_dns[@]}\" ; return ;}\n\n    # Only accepting DYNAMODB and S3 from ip-range service\n    if [[ \"$1\" =~ ^(\"DYNAMODB\"|\"S3\")$ ]]; then\n      # Return IPS of the Service, empty otherwise\n      curl -s \"${IP_RANGES_URL}\" --connect-timeout 5 | jq -r '.prefixes[] | select(.region==\"'$AWS_SSM_REGION_NAME'\") | select(.service==\"'$1'\") | .ip_prefix' | tr '\\n' ' ' | sed 's/ $/\\n/'\n    fi\n}\n\nget_target_ips()\n{\n  # Prepare the sources and get IPs for all of them\n  for source in ${SOURCES//,/ }\n  do\n      ips=$(get_ips $source)\n      if [ -n \"$ips\" ]; then\n        for ip in \"${ips[@]}\"\n          do\n          TARGET_IPS+=(\"${ip}\")\n        done\n      else\n          INVALID_SOURCES+=(\"${source}\")\n      fi\n  done\n\n  if [ ${#INVALID_SOURCES[@]} -gt 0 ]; then\n    echo \"Invalid sources (malformed service name, DNS or IP address): ${INVALID_SOURCES[@]}\" >&2\n    exit 1\n  fi\n\n  echo \"Target IPs and ranges: ${TARGET_IPS[@]}\"\n}\n\nget_tmds_ip()\n{\n    if [ -z \"$ECS_AGENT_URI\" ]; then\n        echo \"ECS_AGENT_URI is not set, exiting\";\n        exit 1;\n    fi\n    echo $ECS_AGENT_URI | cut -d \"/\" -f 3\n}\n\n# List of endpoint we want to preserve (SSM, EC2, ECS)\nPROTECTED_ENDPOINTS=(\n  \"${SSMMESSAGES_ENDPOINT}\"\n  \"${SSM_ENDPOINT}\"\n  \"${EC2MESSAGES_ENDPOINT}\"\n  $(get_tmds_ip)\n)\n\nget_protected_ips()\n{\n  # Getting IPs from protected endpoints\n  for e in \"${PROTECTED_ENDPOINTS[@]}\";\n  do\n      var_endpoint=$(get_ips $e)\n      PROTECTED_IPS+=(\"${var_endpoint[@]}\")\n  done\n\n  # Getting IPs from existing SSM connections\n  if pgrep ssm > /dev/null\n  then\n      var_ssm_connections=( $(lsof -a -nPi4 -c /ssm/ -Fn | awk '$1 ~ /^n/' | awk -F'->' '{print $2}' | awk -F':' '{print $1}' | awk \"/$IP_REGEX/\" | awk NF) )\n      [ ${#var_ssm_connections[@]} -eq 0 ] || PROTECTED_IPS+=(\"${var_ssm_connections[@]}\")\n  fi\n\n  # Removes duplicates\n  PROTECTED_IPS=($(for ip in \"${PROTECTED_IPS[@]}\"; do echo \"${ip}\"; done | sort -u))\n\n  # Check if any of the protected IPs are in the sources and exit if true\n  for e in \"${TARGET_IPS[@]}\"; do\n    for ip in \"${PROTECTED_IPS[@]}\"; do\n      [[ \"$e\" = \"$ip\" ]] && {\n        echo \"Sources contain a protected endpoint: ${e} - exiting\";\n        remove_from_file \"$DELETE_MSG\" /etc/hosts\n        exit 1;\n      }\n    done;\n  done;\n\n  echo \"Protected IPs: ${PROTECTED_IPS[@]}\"\n}\n\nget_enable_fault_command(){\n  local fault_type=\"\"\n  local payload=\"\"\n  local file_to_clean_up=\"/etc/hosts\"\n\n  while [ $# -gt 0 ]; do\n      case \"$1\" in\n          --fault-type=*)\n              fault_type=\"${1#*=}\"\n              ;;\n          --payload=*)\n              payload=\"${1#*=}\"\n              ;;\n          --file-to-clean-up=*)\n              file_to_clean_up=\"${1#*=}\"\n              ;;\n          *)\n              echo \"Unknown parameter: $1\"\n              return 1\n              ;;\n      esac\n      shift\n  done\n\n  if [ -z \"$fault_type\" ]; then\n      echo \"Error: --fault-type is required\"\n      return 1\n  fi\n\n  if [ -z \"$payload\" ]; then\n      echo \"Error: --payload is required\"\n      return 1\n  fi\n\n  read -r -d '' ENABLE_FAULT_COMMAND << EOF\n    # Call the ECS Agent start fault injection API\n    START_COMMAND=\"curl -s -X POST ${ECS_AGENT_URI}/fault/v1/$fault_type/start -H \\\"Content-Type: application/json\\\" -d '${payload}' --write-out '#%{response_code}'\"\n    echo \\${START_COMMAND}\n    CURL_RESPONSE=\\$(eval \\${START_COMMAND})\n    echo \\$CURL_RESPONSE\n    STATUS_CODE=\\$(echo \\$CURL_RESPONSE | cut -d \"#\" -f 2)\n    if [[ \\$STATUS_CODE -ge 400 ]]; then\n      echo \"There was an error starting the fault injection.\";\n\n      temp_file=\\$(mktemp)\n      sed \"/$DELETE_MSG/d\" $file_to_clean_up > \\$temp_file\n      cat \\$temp_file > $file_to_clean_up\n\n      rm -f \\$FLAG_PATH\n      rm -f \\$ROLLBACK_PATH\n      rm -f \\$HEARTBEAT_EXPIRATION_PATH\n\n      exit 1\n    fi\nEOF\n  echo \"$ENABLE_FAULT_COMMAND\"\n}\n\nget_disable_fault_command() {\n    local fault_type=\"\"\n    local payload=\"\"\n    local file_to_clean_up=\"/etc/hosts\"\n\n    while [ $# -gt 0 ]; do\n        case \"$1\" in\n            --fault-type=*)\n                fault_type=\"${1#*=}\"\n                ;;\n            --payload=*)\n                payload=\"${1#*=}\"\n                ;;\n            --file-to-clean-up=*)\n                file_to_clean_up=\"${1#*=}\"\n                ;;\n            *)\n                echo \"Unknown parameter: $1\"\n                return 1\n                ;;\n        esac\n        shift\n    done\n\n    if [ -z \"$fault_type\" ]; then\n        echo \"Error: --fault-type is required\"\n        return 1\n    fi\n\n    if [[ -z \"$payload\" ]]; then\n        STOP_REQUEST=\"curl -s -X POST ${ECS_AGENT_URI}/fault/v1/$fault_type/stop --write-out '#%{response_code}'\"\n        STATUS_REQUEST=\"curl -s -X POST ${ECS_AGENT_URI}/fault/v1/$fault_type/status | jq --raw-output '.Status'\"\n    else\n        STOP_REQUEST=\"curl -s -X POST ${ECS_AGENT_URI}/fault/v1/$fault_type/stop -H \\\\\\\"Content-Type: application/json\\\\\\\" -d '${payload}' --write-out '#%{response_code}'\"\n        STATUS_REQUEST=\"curl -s -X POST ${ECS_AGENT_URI}/fault/v1/$fault_type/status -H \\\\\\\"Content-Type: application/json\\\\\\\" -d '${payload}' | jq --raw-output '.Status'\"\n    fi\n    disable_fault_command \"$STOP_REQUEST\" \"$STATUS_REQUEST\" $file_to_clean_up\n}\n\ndisable_fault_command(){\n  STOP_REQUEST=$1\n  STATUS_REQUEST=$2\n  FILE_TO_CLEAN_UP=$3\n\n  read -r -d '' DISABLE_FAULT_COMMAND << EOF\n      temp_file=\\$(mktemp)\n      sed \"/$DELETE_MSG/d\" $FILE_TO_CLEAN_UP > \\$temp_file\n      cat \\$temp_file > $FILE_TO_CLEAN_UP\n\n      # Call status API before stop to verify the fault is still running\n      STATUS_COMMAND=\"$STATUS_REQUEST\"\n      FAULT_STATUS=\\$(eval \\${STATUS_COMMAND})\n      echo \"The fault injection status is: \\$FAULT_STATUS\"\n      if [[ \\$FAULT_STATUS == 'not-running' ]]; then\n        echo \"The fault injection is already stopped. No need to call stop API.\"\n      else\n        # Call the ECS Agent stop fault injection API\n        STOP_COMMAND=\"$STOP_REQUEST\"\n        echo \\${STOP_COMMAND}\n        CURL_RESPONSE=\\$(eval \\${STOP_COMMAND})\n        echo \\$CURL_RESPONSE\n        STATUS_CODE=\\$(echo \\$CURL_RESPONSE | cut -d \"#\" -f 2)\n        if [[ \\$STATUS_CODE -ge 400 ]]; then\n          echo \"There was an error stopping the fault injection.\";\n          exit 1\n        fi\n      fi\nEOF\n  echo \"$DISABLE_FAULT_COMMAND\"\n}\n\n# when running in heartbeat mode, there is no need to calculate the target and protected IPs again\nif [[ \"$EXECUTION_MODE\" == \"START\" ]]; then\n\n  # this defines PROTECTED_IPS\n  get_protected_ips\n\nfi\n\nJSON_PAYLOAD=$(jq --null-input \\\n                  --argjson Port $PORT \\\n                  --arg Protocol $PROTOCOL \\\n                  --arg TrafficType $TRAFFIC \\\n                  --arg FilterSources \"${PROTECTED_IPS[*]}\" \\\n                  '{\"Port\": $Port,\n                  \"Protocol\": $Protocol,\n                  \"TrafficType\": $TrafficType,\n                  \"SourcesToFilter\": ($FilterSources|split(\" \"))} | tojson')\n\nENABLE_FAULT_COMMAND=$(get_enable_fault_command --fault-type=\"network-blackhole-port\" --payload=\"$JSON_PAYLOAD\")\n\nDISABLE_FAULT_COMMAND=$(get_disable_fault_command --fault-type=\"network-blackhole-port\" --payload=\"$JSON_PAYLOAD\")\n\n\n#################################\n# General fault-execution logic #\n#################################\n\nSTOP_TIME=$(( $(date +%s) + $DURATION ))\nMAX_FLAG_AGE_SECONDS=10\nINJECTION_LOOP_SLEEP_SECONDS=5\nATTEMPT_ROLLBACK_AT_SECONDS=20\n\n# Parameters for heartbeating/rollback\nread -r -d '' FIS_ACTION_STATE_JSON <<'EOF'\n  {{ FISActionState }}\nEOF\n\nFAULT_IDENTIFIER=\"$(echo $FIS_ACTION_STATE_JSON | jq -r '.id // empty')\"\nFLAG_PATH=\"/var/lib/amazon/ssm/$FAULT_NAME-$FAULT_IDENTIFIER.flag\"\nROLLBACK_PATH=\"/var/lib/amazon/ssm/$FAULT_NAME-$FAULT_IDENTIFIER-Rollback.sh\"\n\n\nCALL_COUNT=\"$(echo $FIS_ACTION_STATE_JSON | jq -r '.callCount // empty')\"\nHEARTBEAT_TIMESTAMP=\"$(echo $FIS_ACTION_STATE_JSON | jq -r '.callTime // empty')\"\n\nif [[ -z \"$FAULT_IDENTIFIER\" || -z \"$CALL_COUNT\" || -z \"$HEARTBEAT_TIMESTAMP\" ]] ; then\n  echo \"Required FISActionState fields were not populated.\"\n  exit 1\nfi\n\nHEARTBEAT_EXPIRATION_SECONDS=60\nHEARTBEAT_EXPIRATION_TIME=$(($HEARTBEAT_TIMESTAMP + $HEARTBEAT_EXPIRATION_SECONDS))\nHEARTBEAT_EXPIRATION_PATH=\"/var/lib/amazon/ssm/$FAULT_NAME-$FAULT_IDENTIFIER-Heartbeat-Expiration\"\nHEARTBEAT_MODE=\"$(if [[ \"$CALL_COUNT\" == \"1\" ]]; then echo START; else echo HEARTBEAT; fi)\"\n\nif [[ \"$HEARTBEAT_MODE\" == \"HEARTBEAT\" ]] ; then\n  if ! [[ -f \"$HEARTBEAT_EXPIRATION_PATH\" ]] ; then\n    echo \"Fault $FAULT_IDENTIFIER is not running. Heartbeat failed.\"\n    exit 1\n  fi\n\n  # since Heartbeat-Expiration file is read/written from a separate processes, we\n  # protect access with flock (using a subshell to make read+write atomic)\n  (\n    # fd 9 is bound below to $HEARTBEAT_EXPIRATION_PATH\n    flock --exclusive 9\n\n    # update the HEARTBEAT_expiration time (but cautiously avoid reducing it)\n    CURRENT_HEARTBEAT_EXPIRATION=$(< $HEARTBEAT_EXPIRATION_PATH)\n    if [[ $HEARTBEAT_EXPIRATION_TIME > $CURRENT_HEARTBEAT_EXPIRATION ]] ; then\n      echo \"Updating heartbeat expiration to $HEARTBEAT_EXPIRATION_TIME\"\n      echo $HEARTBEAT_EXPIRATION_TIME > $HEARTBEAT_EXPIRATION_PATH\n    else\n      echo \"Update heartbeat expiration value older than current value. Skipping update.\"\n    fi\n  ) 9< $HEARTBEAT_EXPIRATION_PATH\n\n  exit 0\nelse\n  # $HEARTBEAT_MODE is START, initialize expiration and\n  # fall through to logic below to start the fault.\n  echo $HEARTBEAT_EXPIRATION_TIME > \"$HEARTBEAT_EXPIRATION_PATH\"\nfi\n\n# Creating a file with rollback check command to be executed by atd\ncat << EOF > \"$ROLLBACK_PATH\"\n#!/bin/bash\n# Dont sleep if run in terminal\nif ! [ -t 0 ] ; then\n  sleep $ATTEMPT_ROLLBACK_AT_SECONDS\nfi\nif ! [ -f \"$FLAG_PATH\" ] || [ \"\\$(( \\$(date +%s) - \\$(stat -c \"%Y\" \"$FLAG_PATH\") ))\" -gt $MAX_FLAG_AGE_SECONDS ] || [ -t 0 ]; then\n  $DISABLE_FAULT_COMMAND\n  rm -f \"$FLAG_PATH\"\n  rm -f \"$HEARTBEAT_EXPIRATION_PATH\"\n  # Dont delete rollback script if run in terminal\n  if ! [ -t 0 ] ; then\n    rm -f \"$ROLLBACK_PATH\"\n  fi\nfi\nEOF\necho \"Temporary rollback file created: $ROLLBACK_PATH\"\n\n# Enqueue a rollback check after $ATTEMPT_ROLLBACK_AT_SECONDS seconds\nschedule_rollback_attempt() {\n  echo \"bash $ROLLBACK_PATH\" | at now 2> >(sed '/warning: commands will be executed using \\/bin\\/sh/d' )\n}\n\n# Function to delete the flag file and rollback the fault injection\nrollback() {\n  eval \"$DISABLE_FAULT_COMMAND\" ; STATUS=$?\n  rm -f \"$FLAG_PATH\"\n  rm -f \"$ROLLBACK_PATH\"\n  rm -f \"$HEARTBEAT_EXPIRATION_PATH\"\n  echo Rollback done.\n  return $STATUS\n}\n\n# Binding the rollback function to these exit signals\ntrap rollback INT\ntrap rollback TERM\n\necho \"Making sure atd daemon is running\"\n# atd must be running in order to use \"at\" later\natd || { echo Failed to run atd daemon, exiting... 1>&2 ; exit 1; }\n\necho \"Scheduling rollback\"\nschedule_rollback_attempt\n\n# Injecting fault\necho \"Enabling fault injection\"\ntouch \"$FLAG_PATH\"\neval \"$ENABLE_FAULT_COMMAND\"\n\nRESULT=0\n\n# loop for duration of fault\nwhile : ; do\n  if [[ $(date +%s) -gt $STOP_TIME ]] ; then\n    echo \"Fault duration has completed.\"\n    break\n  fi\n\n  CURRENT_HEARTBEAT_EXPIRATION=$(flock $HEARTBEAT_EXPIRATION_PATH cat $HEARTBEAT_EXPIRATION_PATH)\n  if [[ $(date +%s) -gt $CURRENT_HEARTBEAT_EXPIRATION ]] ; then\n    echo \"Fault expiring due to age of last heartbeat.\"\n    RESULT=1\n    break\n  fi\n\n  # update flag to indicate that script is still alive\n  touch \"$FLAG_PATH\"\n\n  # enqueue a rollback check\n  schedule_rollback_attempt\n\n  sleep $INJECTION_LOOP_SLEEP_SECONDS\ndone\n\n# After the desired duration, the fault injection is removed\nrollback || RESULT=1\nexit $RESULT\n"
        ]
      }
    }
  ]
}
