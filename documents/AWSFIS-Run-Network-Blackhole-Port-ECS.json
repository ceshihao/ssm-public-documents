{
  "description": "### Document name - AWSFIS-Run-Network-Blackhole-Port-ECS\n\n## What does this document do?\nIt drops incoming or outgoing traffic for a configurable protocol (tcp / udp) and port, using the ECS fault injection endpoints.\nThis SSM document supports Amazon Linux and Ubuntu operating systems only.\n\n## Dependencies installed by this SSM Document\n* atd\n* curl\n* dig\n* jq\n* lsof\n* pgrep\nNote: This SSM document does not uninstall dependencies once installed. If you don't want this SSM document to install any dependencies, set InstallDependencies to False and bake the dependencies into your EC2 instance. For example, by using image-builder (https://aws.amazon.com/image-builder/).\n\n## Input Parameters\n* FISActionState: The FIS-populated action state JSON.\n* Protocol: (Required) Specify the protocol to blackhole (tcp|udp).\n* Port: (Required) Specify the port to blackhole.\n* TrafficType: Specify the type of traffic to delay (egress|ingress) (default: ingress).\n* DurationSeconds: (Required) The duration - in seconds - of the fault injection.\n* InstallDependencies: If set to True, Systems Manager installs the required dependencies on the target instances (default: True).\n\n## Output Parameters\nNone.",
  "schemaVersion": "2.2",
  "parameters": {
    "FISActionState": {
      "type": "String",
      "description": "The FIS-populated action state JSON.",
      "allowedPattern": "^\\{\"id\":\"[\\s\\S]+\",\"callTime\":\\d{10},\"callCount\":\\d+}$"
    },
    "Protocol": {
      "type": "String",
      "description": "(Required) Specify the protocol to blackhole (tcp|udp).",
      "allowedValues": [
        "tcp",
        "udp"
      ]
    },
    "Port": {
      "type": "String",
      "description": "(Required) Specify the port to blackhole.",
      "allowedPattern": "^([1-9][0-9]{0,3}|[1-5][0-9]{4}|6[0-4][0-9]{3}|65[0-4][0-9]{2}|655[0-2][0-9]|6553[0-5])$"
    },
    "TrafficType": {
      "type": "String",
      "description": "Specify the type of traffic to delay (egress|ingress) (default: ingress).",
      "default": "ingress",
      "allowedValues": [
        "egress",
        "ingress"
      ]
    },
    "DurationSeconds": {
      "type": "String",
      "description": "(Required) The duration - in seconds - of the fault injection.",
      "allowedPattern": "^[0-9]+$"
    },
    "InstallDependencies": {
      "type": "String",
      "description": "If set to True, Systems Manager installs the required dependencies on the target instances (default: True).",
      "default": "True",
      "allowedValues": [
        "True",
        "False"
      ]
    }
  },
  "mainSteps": [
    {
      "action": "aws:runShellScript",
      "name": "InstallDependencies",
      "precondition": {
        "StringEquals": [
          "platformType",
          "Linux"
        ]
      },
      "description": "## Parameter: InstallDependencies\nIf set to True, this step installs the required dependency via operating system's repository. It supports both\nDebian (apt) and CentOS (yum) based package managers.",
      "inputs": {
        "onFailure": "exit",
        "runCommand": [
          "#!/bin/bash\n\nvalidate_installation_settings() {\n  if [[ \"{{ InstallDependencies }}\" == False ]]; then\n    echo \"Dependencies are not installed - Please set InstallDependencies to True.\"\n    exit 1\n  fi\n  echo \"Installing required dependencies\"\n}\n\n#################################\n#       Dependency Logic        #\n#################################\n\nfunction install_sch_netem_module() {\n  ssm_working_dir=$(pwd)\n  # Work from a directory that Amazon SSM Agent creates\n  cd /etc/amazon/ssm/\n  current_working_dir=$(pwd)\n  kernel_version=$(uname -r)\n  # Default location of sch_netem module\n  sched_module_local_path=/lib/modules/\"$kernel_version\"/kernel/net/sched/\n  sch_netem_kernel_module_file=sch_netem.ko\n  # Check if there is no compressed and uncompressed version of the module\n  if [ ! -f \"${sched_module_local_path}$sch_netem_kernel_module_file\" ] && [ ! -f \"${sched_module_local_path}$sch_netem_kernel_module_file\".xz ]; then\n    echo \"sch_netem does not exist, installing\"\n    # We will download and install the sch_netem kernel module to avoid the need for a reboot, as\n    # would be required if we used `yum install kernel-modules-extra`.\n    temp_dir=kernel-lib\n    # If the yumdownloader comes back with no module available, then fail\n    if yumdownloader kernel-modules-extra-\"$kernel_version\" --destdir \"$temp_dir\" 2>&1 | grep \"No package kernel-modules-extra-$kernel_version available.\"; then\n      echo \"No sch_netem module for the kernel version $kernel_version\"\n      echo \"Exiting - Unable to install sch_netem. kernel module sch_netem must be installed for this document to run\"\n      rm -rf \"$temp_dir\"\n      exit 1\n    fi\n    # We need to CD into the temp_dir for cpio since it does not work with absolute or relative paths well\n    cd \"$temp_dir\"\n    # Unpacks the modules into lib/\n    # version is downloaded but will differ from $kernel_version, depending OS.\n    rpm2cpio kernel-modules-extra-\"$kernel_version\".rpm | cpio -id\n    # Move back to the working dir.\n    cd \"$current_working_dir\"\n    # if sch_netem exists in the rpm lib, move it to /etc/amazon/ssm\n    sch_netem_path=$(find \"$temp_dir\"/lib -name \"$sch_netem_kernel_module_file\".xz)\n    if [ -n \"${sch_netem_path}\" ]; then\n      echo \"Downloaded Kernel Modules, and sch_netem exists. Loading Module\"\n      mv \"${sch_netem_path}\" \"$current_working_dir\"\n      # Do not need the rest of the temp_dir\n      rm -rf \"$temp_dir\"\n      echo \"Unpacking sch_netem\"\n      xz -d \"$sch_netem_kernel_module_file\".xz\n      rm -f \"$sch_netem_kernel_module_file\".xz\n      # Create a symlink to the default location so that the module can be added to the list of available modules by depmod\n      ln -s \"$current_working_dir\"/$sch_netem_kernel_module_file /lib/modules/\"$kernel_version\"/\"$sch_netem_kernel_module_file\"\n      echo \"Loading sch_netem\"\n      # Refresh the list of available modules\n      depmod -a\n      modprobe sch_netem\n      # Check if loaded successfully\n      if lsmod | grep -wq \"sch_netem\"; then\n        echo \"$sch_netem_kernel_module_file module installed and loaded\"\n      else\n        echo \"Exiting - Error loading module, kernel module sch_netem.ko must be installed for this document to run\"\n        exit 1\n      fi\n    else\n      # make sure our temp file deleted.\n      rm -rf \"$temp_dir\"\n      echo \"Exiting - Unable to install sch_netem. kernel module sch_netem must be installed for this document to run\"\n      exit 1\n    fi\n  # Check if the module exists and enable it\n  elif [[ -f \"${sched_module_local_path}/$sch_netem_kernel_module_file\" ]]; then\n    if modinfo ${sched_module_local_path}/$sch_netem_kernel_module_file -F vermagic | awk '{print $1}' | grep -Fi \"$kernel_version\"; then\n      # Lets build an updated list of available modules first\n      depmod -a\n      # Insert module\n      modprobe sch_netem\n    fi\n  # if the compressed module exist, uncompress and enable\n  elif [[ -f \"${sched_module_local_path}$sch_netem_kernel_module_file\".xz ]] && [ ! -f \"${sched_module_local_path}$sch_netem_kernel_module_file\" ]; then\n    # Module exists, so we need to unpack it and insert the module in the kernel it\n    xz -d -k \"${sched_module_local_path}/$sch_netem_kernel_module_file\".xz\n    if modinfo ${sched_module_local_path}/$sch_netem_kernel_module_file -F vermagic | awk '{print $1}' | grep -Fi \"$kernel_version\"; then\n      # Lets build an updated list of available modules first\n      depmod -a\n      # Insert module\n      modprobe sch_netem\n    fi\n  fi\n  cd \"$ssm_working_dir\"\n}\n\nfunction check_and_install_netem() {\n  if ! lsmod | grep -wq \"sch_netem\"; then\n    # To avoid issues with SELinux we wrap everything in sudo.\n    # In order to call the install_sch_netem_module function wrapped with sudo,\n    # we need to pass it as a command rather than a function call.\n    SUDOINSTALL=$(declare -f install_sch_netem_module)\n    sudo bash -c \"$SUDOINSTALL; install_sch_netem_module\" 2>&1\n    # Check if loaded\n    if lsmod | grep -wq \"sch_netem\"; then\n      echo \"sch_netem.ko Module loaded\"\n    else\n      echo \"Exiting - Error loading module, kernel module sch_netem.ko must be installed for this document to run\"\n      exit 1\n    fi\n  fi\n}\n\nfunction adjust_rhel_package() {\n  # For centos/rhel 7 the package is iproute, so remove the suffix if iproute is there\n  # since this command is directly related to the use of sch_netem.\n  if [[ ${rhel_package} == *iproute-tc* ]] && [ \"$os_major_version_number\" -eq \"7\" ]; then\n    rhel_package=${rhel_package/iproute-tc/iproute}\n  fi\n}\n\n# Configure ATD service if required\nconfigure_atd() {\n  if ! systemctl is-enabled atd || ! systemctl is-active atd; then\n    echo \"Enabling and starting atd\"\n    systemctl enable atd\n    systemctl start atd\n  fi\n}\n\n########################################################################################################################\n # This script builds a list of available modules and enables sch_netem                                                #\n # sch_netem kernel module is responsible for emulating traffic,                                                       #\n # FIS SSM Documents use this module when creating network faults, such as the packet loss fault and the latency fault #\n########################################################################################################################\n# Build a list of the available modules\nenable_netem() {\n  if ! command -v depmod &> /dev/null; then\n    echo \"WARN depmod is not available. Command could fail due to missing sch_netem\"\n    return 0\n  else\n    depmod -a\n    # Enable the sch_netem module, if there is a failure, exit\n    if ! modprobe sch_netem; then\n      echo \"WARN Cannot enable sch_netem\"\n      echo \"WARN Command could fail due to missing sch_netem\"\n      return 0\n    fi\n  fi\n  return 0\n}\n\n# Check if dependencies are already installed\ncheck_existing_dependencies() {\n  if [[ \"$( command -v atd 2>/dev/null )\" && \"$( command -v curl 2>/dev/null )\" && \"$( command -v dig 2>/dev/null )\" && \"$( command -v jq 2>/dev/null )\" && \"$( command -v lsof 2>/dev/null )\" && \"$( command -v pgrep 2>/dev/null )\" ]]; then\n  \n    echo \"Dependencies are already installed.\"\n    exit\n  \n  fi\n}\n\n# Handle Amazon Linux installations\ninstall_amazon_linux() {\n  if ! grep -Fiq 'VERSION_ID=\"2023\"' /etc/os-release; then\n  \n    yum -y install at bind-utils jq lsof procps-ng\n  elif grep -Fiq 'ID=\"amzn\"' /etc/os-release && grep -Fiq 'VERSION_ID=\"2023\"' /etc/os-release; then\n  \n    yum -y install at curl-minimal bind-utils jq lsof procps-ng\n  else\n    echo \"Exiting - This SSM document supports: Amazon Linux 2023, Amazon Linux 2, Ubuntu, CentOS 9 and RHEL (8, 9) operating systems\"\n    exit 1\n  fi\n}\n\n# Handle RHEL/CentOS installations\ninstall_rhel_centos() {\n  # Fetch OS Version\n  os_version_number=$(grep -oP '(?<=^VERSION_ID=).+' /etc/os-release | tr -d '\"')\n  # if the version has a decimal, this line will remove it\n  os_major_version_number=${os_version_number%.*}\n  # Replace with version number in the url if required\n  if ! rpm --quiet -q epel-release; then\n    epel_dl_url=\"https://dl.fedoraproject.org/pub/epel/epel-release-latest-VERSION.noarch.rpm\"\n    epel_with_version=\"${epel_dl_url/VERSION/$os_major_version_number}\"\n    yum -y install $epel_with_version\n  fi\n  rhel_package=\"at bind-utils jq lsof procps\"\n  \n  yum -y install $rhel_package\n}\n\n# Handle Ubuntu installations\ninstall_ubuntu() {\n  apt-get update -y\n  # when installing, sometimes ubuntu has stderr that are not breaking errors.\n  install_error=$(apt-get install -y at dnsutils jq lsof procps 2>&1)\n  if [[ -n \"$install_error\" ]]; then\n    echo \"$install_error\"\n  fi\n\n  ubuntu_commands=( atd curl dig jq lsof pgrep )\n  for dependency_command in \"${ubuntu_commands[@]}\"; do\n    if ! command -v $dependency_command >/dev/null 2>&1; then\n      echo \"Exiting - $dependency_command not installed\"\n      exit 1\n    fi\n  done\n}\n\n# Main function to orchestrate the installation process\nmain() {\n  check_existing_dependencies\n  validate_installation_settings\n\n  if [ -f \"/etc/system-release\" ] && grep -i 'Amazon Linux' /etc/system-release; then\n    install_amazon_linux\n  elif grep -Fiq 'ID=\"centos\"' /etc/os-release || grep -Fiq 'ID=\"rhel\"' /etc/os-release; then\n    install_rhel_centos\n  elif grep -i \"Ubuntu\" /etc/issue; then\n    install_ubuntu\n  else\n    echo \"Exiting - This SSM document supports: Amazon Linux 2023, Amazon Linux 2, Ubuntu, CentOS 9 and RHEL (8, 9) operating systems\"\n    exit 1\n  fi\n  configure_atd\n}\n\n# Execute main function\nmain\n"
        ]
      }
    },
    {
      "action": "aws:runShellScript",
      "name": "FaultInjection",
      "precondition": {
        "StringEquals": [
          "platformType",
          "Linux"
        ]
      },
      "description": "# Parameters: Protocol, Port, TrafficType, and DurationSeconds\nThis step blocks Protocol TrafficType traffic to Port for the given DurationSeconds, using the ECS fault injection endpoints.\nIt has two rollback mechanisms in place:\n- It will listen for exit signals (SIGINT and SIGTERM), and will stop the fault injection if any of them is received.\n- It will periodically enqueue rollback checks into a queue (using at command). This way, if the command is stopped and the rollback was not executed, the enqueued commands will try to stop it. (for example, if the command is stopped using kill -9).\nThis is just an extra safety check to avoid having the blackhole port remain injected after the script is no longer running.\nThis document is also executed in heartbeat mode: every 20 seconds, FIS will update a file with the “last update” timestamp. If for any reason FIS stops updating that file, the document will assume that something is wrong with FIS and the fault will be stopped after 60 seconds.",
      "inputs": {
        "maxAttempts": 1,
        "timeoutSeconds": 43200,
        "runCommand": [
          "#!/bin/bash\nset -o errexit -o errtrace -o nounset -o pipefail\n\n########################\n# Fault-specific logic #\n########################\n\n# Identify if the document is executed in heartbeat mode\nFIS_ACTION_STATE_JSON='{{ FISActionState }}'\nCALL_COUNT=\"$(echo $FIS_ACTION_STATE_JSON | jq -r '.callCount // empty')\"\nEXECUTION_MODE=\"$(if [[ \"$CALL_COUNT\" == \"1\" ]]; then echo \"START\"; else echo \"HEARTBEAT\"; fi)\"\n\nPORT={{ Port }}\nPROTOCOL={{ Protocol }}\nTRAFFIC_TYPE={{ TrafficType }}\nDURATION={{ DurationSeconds }}\n\nvalidate_variable_is_set() {\n    local -r variable_name=\"$1\"\n    local variable_value\n\n    eval \"variable_value=\\\"\\${$variable_name-}\\\"\"\n\n    if [[ -z \"${variable_value}\" ]]; then\n        echo \"Variable $variable_name is not set.\" >&2\n        return 1\n    fi\n\n    return 0\n}\nvalidate_parameter_within_range() {\n  local parameter=$1\n  local value=$2\n  local min=$3\n  local max=$4\n\n  if (( value >= min && value <= max )); then\n    return 0\n  fi\n\n  echo \"Parameter $parameter must be between $min and $max, was: '$value'\" >&2\n  exit 1\n}\n\nforce_dns() {\n  local -r hostname=\"$1\"    # Hostname is expected as first argument\n  local -ar ips=(\"${@:2}\")  # The rest will be the IPs\n\n  # Force any new DNS resolution for that host to the latest known IPs\n  for ip in \"${ips[@]}\"; do\n    echo \"$ip $hostname ${DELETE_MSG:-\"#delete-after-fault-injection\"}\" >> \"${HOSTS_FILE:-/etc/hosts}\"\n  done\n\n  return 0\n}\n\nadd_tmds_ip_to_protected_endpoints() {\n  local -r ecs_agent_url=\"$1\" \n\n  # Extracts IP from ECS agent URL using 'cut' with forward slash delimiter (-d \"/\") and selecting third field (-f 3)\n  # \n  # Example:\n  # http://169.254.170.2/api/59d3b9b8bb55476488cee0122ea98da3-0949121929\n  #\n  # [1] http:\n  # [2] *blank\n  # [3] 169.254.170.2\n  # [4] v1\n  # [5] metadata\n  # \n  # tmds_ip will be \"169.254.170.2\"\n  local -r tmds_ip=$(echo \"${ecs_agent_url}\" | cut -d \"/\" -f 3)\n  echo \"Adding ECS task metadata IP: ${tmds_ip} to PROTECTED_ENDPOINTS\"\n  PROTECTED_ENDPOINTS+=(\"${tmds_ip}\")\n\n  return 0\n}\n\nget_ips_from_input() {\n  local -r input=\"$1\"\n  local -r regex=\"$2\"\n\n  # Echoes the input and returns 0 if the input is valid, otherwise returns 1\n  local -r validated_input=$(grep -E \"$regex\" <<< \"$input\")\n  [ -z \"$validated_input\" ] || { echo \"$validated_input\" ; return 0 ;}\n\n  return 1\n}\n\nget_ips_from_dns() {\n  local -r domain=\"$1\"\n  local -a resolved_ips=()\n\n  # Echoes IPs of the domain and forces DNS resolution to the IPs then returns 0, otherwise returns 1\n  # Since `dig` can return different IPs, we call it 10 times to maximize the chances of covering as many IPs as possible for the provided domain\n  for _ in {1..10}\n    do\n      local -a dig_output=( $(dig +short \"$domain\" | grep -v '[[:alpha:]]') )\n      [ ${#dig_output[@]} -eq 0 ] || resolved_ips+=(\"${dig_output[@]}\")\n    done\n\n  if [ ${#resolved_ips[@]} -gt 0 ]; then\n    local -ar unique_resolved_ips=( $(printf '%s\\n' \"${resolved_ips[@]}\" | sort -u) )\n    [ ${#unique_resolved_ips[@]} -eq 0 ] || { echo \"${unique_resolved_ips[@]}\" ; force_dns \"$domain\" \"${unique_resolved_ips[@]}\" ; return 0 ;}\n  fi\n\n  return 1\n}\n\nget_protected_ips_from_protected_endpoints() {\n  local get_ips=\"$1\"\n  local -ar endpoints=(\"${@:2}\")\n\n  for e in \"${endpoints[@]}\"; do\n    local ips_output\n    ips_output=$(eval \"get_ips \\\"$e\\\"\")\n    if [[ -n \"$ips_output\" ]]; then\n      local -a ips=()\n      read -ra ips <<< \"$ips_output\"\n      PROTECTED_IPS+=(\"${ips[@]}\")\n    fi\n  done\n\n  return 0\n}\n\nget_protected_ips_from_ssm_connections() {\n  local -r regex=\"$1\"\n\n  if pgrep ssm > /dev/null; then\n    local -r ssm_connections=( $(lsof -a -nPi4 -c /ssm/ -Fn | awk '$1 ~ /^n/' | awk -F'->' '{print $2}' | awk -F':' '{print $1}' | awk \"/$regex/\" | awk NF) )\n    [ ${#ssm_connections[@]} -eq 0 ] || PROTECTED_IPS+=(\"${ssm_connections[@]}\")\n  fi\n\n  return 0\n}\n\nget_sorted_unique_protected_ips() {\n  if [ ${#PROTECTED_IPS[@]} -gt 0 ]; then\n    PROTECTED_IPS=($(for ip in \"${PROTECTED_IPS[@]}\"; do echo \"${ip}\"; done | sort -u))\n  fi\n\n  return 0\n}\n\nenable_fault_ecs() {\n  # Call the ECS Agent start fault injection API\n  local -r curl_response=$(curl -s -X POST \"${ECS_AGENT_URI}/fault/v1/$FAULT_TYPE/start\" \\\n    -H 'Content-Type: application/json' \\\n    -d \"$JSON_PAYLOAD\" \\\n    --write-out '#%{response_code}')\n\n  echo \"curl -s -X POST ${ECS_AGENT_URI}/fault/v1/$FAULT_TYPE/start -H 'Content-Type: application/json' -d '$JSON_PAYLOAD' --write-out '#%{response_code}'\"\n  echo \"$curl_response\"\n  \n  local -r status_code=$(echo \"$curl_response\" | cut -d \"#\" -f 2)\n  if [[ $status_code -ge 400 ]]; then\n    echo \"There was an error starting the fault injection.\";\n\n    local -r hosts_file=\"${HOSTS_FILE:-/etc/hosts}\"\n    temp_file=$(mktemp)\n    sed \"/${DELETE_MSG:-\"#delete-after-fault-injection\"}/d\" \"$hosts_file\" > \"$temp_file\"\n    cat \"$temp_file\" > \"$hosts_file\"\n\n    rm -f \"$FLAG_PATH\"\n    rm -f \"$ROLLBACK_PATH\"\n    rm -f \"$HEARTBEAT_EXPIRATION_PATH\"\n\n    exit 1\n  fi\n}\n\ndisable_fault_ecs() {\n  local -r hosts_file=\"${HOSTS_FILE:-/etc/hosts}\"\n  temp_file=$(mktemp)\n  sed \"/${DELETE_MSG:-\"#delete-after-fault-injection\"}/d\" $hosts_file > $temp_file\n  cat $temp_file > $hosts_file\n\n  # Call status API before stop to verify the fault is still running\n  local fault_status\n  if [[ -z \"$JSON_PAYLOAD\" ]]; then\n    fault_status=$(curl -s -X POST \"${ECS_AGENT_URI}/fault/v1/$FAULT_TYPE/status\" | jq --raw-output '.Status')\n  else\n    fault_status=$(curl -s -X POST \"${ECS_AGENT_URI}/fault/v1/$FAULT_TYPE/status\" \\\n      -H 'Content-Type: application/json' \\\n      -d \"$JSON_PAYLOAD\" | jq --raw-output '.Status')\n  fi\n\n  echo \"The fault injection status is: $fault_status\"\n  if [[ $fault_status == 'not-running' ]]; then\n    echo \"The fault injection is already stopped. No need to call stop API.\"\n  else\n    # Call the ECS Agent stop fault injection API\n    local curl_response\n    if [[ -z \"$JSON_PAYLOAD\" ]]; then\n      echo \"curl -s -X POST ${ECS_AGENT_URI}/fault/v1/$FAULT_TYPE/stop --write-out '#%{response_code}'\"\n      curl_response=$(curl -s -X POST \"${ECS_AGENT_URI}/fault/v1/$FAULT_TYPE/stop\" --write-out '#%{response_code}')\n    else\n      echo \"curl -s -X POST ${ECS_AGENT_URI}/fault/v1/$FAULT_TYPE/stop -H 'Content-Type: application/json' -d '$JSON_PAYLOAD' --write-out '#%{response_code}'\"\n      curl_response=$(curl -s -X POST \"${ECS_AGENT_URI}/fault/v1/$FAULT_TYPE/stop\" \\\n        -H 'Content-Type: application/json' \\\n        -d \"$JSON_PAYLOAD\" \\\n        --write-out '#%{response_code}')\n    fi\n\n    echo \"$curl_response\"\n    local -r status_code=$(echo \"$curl_response\" | cut -d \"#\" -f 2)\n    if [[ $status_code -ge 400 ]]; then\n      echo \"There was an error stopping the fault injection.\"\n      exit 1\n    fi\n  fi\n}\n\nget_ips()\n{\n  local -r input=\"$1\"\n\n  get_ips_from_input \"$input\" \"$IP_REGEX\" ||\n  get_ips_from_dns \"$input\"\n}\n\nget_protected_ips()\n{\n  add_tmds_ip_to_protected_endpoints \"$ECS_AGENT_URI\"\n  get_protected_ips_from_protected_endpoints get_ips \"${PROTECTED_ENDPOINTS[@]}\"\n  get_protected_ips_from_ssm_connections \"$IP_REGEX\"\n  get_sorted_unique_protected_ips\n  echo \"Protected IPs: ${PROTECTED_IPS[@]}\"\n}\n\nvalidate_variable_is_set \"ECS_AGENT_URI\"\nvalidate_parameter_within_range \"DurationSeconds\" $DURATION 1 43200\n\nFAULT_NAME=\"Run-Network-Blackhole-Port-ECS\"\n\nFAULT_TYPE=\"network-blackhole-port\"\n\nIP_RANGES_URL=\"https://ip-ranges.amazonaws.com/ip-ranges.json\"\n\nIP_REGEX=\"^(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])$\"\n\nIMDS_IP=169.254.169.254\n\nDELETE_MSG=\"#delete-after-fault-injection\"\n\n# Endpoints we want to preserve (SSM API)\nSSMMESSAGES_ENDPOINT=ssmmessages.$AWS_SSM_REGION_NAME.amazonaws.com\nSSM_ENDPOINT=ssm.$AWS_SSM_REGION_NAME.amazonaws.com\nEC2MESSAGES_ENDPOINT=ec2messages.$AWS_SSM_REGION_NAME.amazonaws.com\n\nPROTECTED_ENDPOINTS=(\n  \"${SSMMESSAGES_ENDPOINT}\"\n  \"${SSM_ENDPOINT}\"\n  \"${EC2MESSAGES_ENDPOINT}\"\n)\n\nPROTECTED_IPS=()\n# When running in heartbeat mode, there is no need to calculate the protected IPs again\nif [[ \"$EXECUTION_MODE\" == \"START\" ]]; then\n   get_protected_ips\nfi\n\nJSON_PAYLOAD=$(jq -c --null-input \\\n                  --argjson Port $PORT \\\n                  --arg Protocol $PROTOCOL \\\n                  --arg TrafficType $TRAFFIC_TYPE \\\n                  --arg FilterSources \"${PROTECTED_IPS[*]:-}\" \\\n                  '{\n                    \"Port\": $Port,\n                    \"Protocol\": $Protocol,\n                    \"TrafficType\": $TrafficType,\n                    \"SourcesToFilter\": ($FilterSources|split(\" \"))\n                  }')\n\n#################################\n# General fault-execution logic #\n#################################\n\n# Function to generate the heartbeat expiration path\nget_heartbeat_expiration_path() {\n  local fault_identifier=\"$1\"\n  echo \"/var/lib/amazon/ssm/$fault_identifier-Heartbeat-Expiration\"\n}\n\n# Function to generate the flag path\nget_flag_path() {\n  local fault_name=\"$1\"\n  local fault_identifier=\"$2\"\n  echo \"/var/lib/amazon/ssm/$fault_name-$fault_identifier.flag\"\n}\n\n# Function to generate the rollback path\nget_rollback_path() {\n  local fault_name=\"$1\"\n  local fault_identifier=\"$2\"\n  echo \"/var/lib/amazon/ssm/$fault_name-$fault_identifier-Rollback.sh\"\n}\n\n# Helper function to handle heartbeat mode logic\nhandle_heartbeat_mode() {\n  local HEARTBEAT_EXPIRATION_PATH=\"$1\"\n  local HEARTBEAT_EXPIRATION_TIME=\"$2\"\n\n  if ! [[ -f \"$HEARTBEAT_EXPIRATION_PATH\" ]]; then\n    echo \"Fault is not running. Heartbeat failed.\" >&2\n    exit 1\n  fi\n\n  # Use flock to protect file access (using a subshell to make read+write atomic)\n  (\n    # fd 9 is bound to $HEARTBEAT_EXPIRATION_PATH\n    flock --exclusive 9\n\n    # Update the heartbeat expiration time (but cautiously avoid reducing it)\n    local -r CURRENT_HEARTBEAT_EXPIRATION=$(< \"$HEARTBEAT_EXPIRATION_PATH\")\n    if [[ $HEARTBEAT_EXPIRATION_TIME -gt $CURRENT_HEARTBEAT_EXPIRATION ]]; then\n      echo \"Updating heartbeat expiration to $HEARTBEAT_EXPIRATION_TIME\"\n      echo \"$HEARTBEAT_EXPIRATION_TIME\" > \"$HEARTBEAT_EXPIRATION_PATH\"\n    else\n      echo \"Update heartbeat expiration value older than current value. Skipping update.\"\n    fi\n  ) 9< \"$HEARTBEAT_EXPIRATION_PATH\"\n}\n\nget_user_vars() {\n    # Define system variable patterns to exclude\n    local patterns=(\n        '^BASH_'\n        '^COMP_'\n        '^EUID$'\n        '^PPID$'\n        '^SHELLOPTS$'\n        '^UID$'\n        '^PWD$'\n        '^OLDPWD$'\n        '^SHLVL$'\n        '^_$'\n    )\n    \n    # Join patterns with |\n    local exclude_pattern=$(IFS='|'; echo \"${patterns[*]}\")\n\n    # Get variables using set, but exclude the function's own variables\n    set | grep \"^[A-Za-z][A-Za-z0-9_]*=\" | \n    grep -Ev \"$exclude_pattern\" | \n    grep -Ev \"^(patterns|exclude_pattern)=\"\n}\n\n# Function to create rollback script\ncreate_rollback_script() {\n  local FLAG_PATH=\"$1\"\n  local ROLLBACK_PATH=\"$2\"\n  local HEARTBEAT_EXPIRATION_PATH=\"$3\"\n  local MAX_FLAG_AGE_SECONDS=\"$4\"\n  local ATTEMPT_ROLLBACK_AT_SECONDS=\"$5\"\n  local DISABLE_FAULT_COMMAND=\"$6\"\n  \n  # Creating a file with rollback check command to be executed by atd\n  cat << EOF > \"$ROLLBACK_PATH\"\n#!/bin/bash\n# Environment variables needed to run the rollback command\n$(get_user_vars)\n\n# Dont sleep if run in terminal\nif ! [ -t 0 ] ; then\n  sleep $ATTEMPT_ROLLBACK_AT_SECONDS\nfi\n\n# Include the function definition\n$(declare -f \"$DISABLE_FAULT_COMMAND\")\n\nif ! [ -f \"$FLAG_PATH\" ] || [ \"\\$(( \\$(date +%s) - \\$(stat -c \"%Y\" \"$FLAG_PATH\") ))\" -gt $MAX_FLAG_AGE_SECONDS ] || [ -t 0 ]; then\n  $DISABLE_FAULT_COMMAND\n  rm -f \"$FLAG_PATH\"\n  rm -f \"$HEARTBEAT_EXPIRATION_PATH\"\n  # Dont delete rollback script if run in terminal\n  if ! [ -t 0 ] ; then\n    rm -f \"$ROLLBACK_PATH\"\n  fi\nfi\nEOF\n\n  echo \"Temporary rollback file created: $ROLLBACK_PATH\"\n}\n\n# Function to schedule rollback attempt\nschedule_rollback_attempt() {\n  local ROLLBACK_PATH=\"$1\"\n  echo \"bash $ROLLBACK_PATH\" | at now 2>&1 | grep -v \"warning: commands will be executed using /bin/sh\"\n}\n\n# Function to perform rollback\nrollback() {\n  local DISABLE_FAULT_COMMAND=\"$1\"\n  local FLAG_PATH=\"$2\"\n  local ROLLBACK_PATH=\"$3\"\n  local HEARTBEAT_EXPIRATION_PATH=\"$4\"\n\n  eval \"$DISABLE_FAULT_COMMAND\" ; local STATUS=$?\n  rm -f \"$FLAG_PATH\"\n  rm -f \"$ROLLBACK_PATH\"\n  rm -f \"$HEARTBEAT_EXPIRATION_PATH\"\n  echo \"Rollback done.\"\n  return $STATUS\n}\n\n# Function to run fault injection loop\nrun_fault_injection_loop() {\n  local STOP_TIME=\"$1\"\n  local FLAG_PATH=\"$2\"\n  local ROLLBACK_PATH=\"$3\"\n  local HEARTBEAT_EXPIRATION_PATH=\"$4\"\n  local INJECTION_LOOP_SLEEP_SECONDS=\"$5\"\n  local DISABLE_FAULT_COMMAND=\"$6\"\n\n  local RESULT=0\n\n  # Loop for duration of fault\n  while : ; do\n    if [[ $(date +%s) -gt $STOP_TIME ]]; then\n      echo \"Fault duration has completed.\"\n      break\n    fi\n\n    local CURRENT_HEARTBEAT_EXPIRATION=$(flock \"$HEARTBEAT_EXPIRATION_PATH\" cat \"$HEARTBEAT_EXPIRATION_PATH\")\n    if [[ $(date +%s) -gt $CURRENT_HEARTBEAT_EXPIRATION ]]; then\n      echo \"Fault expiring due to age of last heartbeat.\"\n      RESULT=1\n      break\n    fi\n\n    # Update flag to indicate that script is still alive\n    touch \"$FLAG_PATH\"\n\n    # Enqueue a rollback check\n    schedule_rollback_attempt \"$ROLLBACK_PATH\"\n\n    sleep \"$INJECTION_LOOP_SLEEP_SECONDS\"\n  done\n\n  # After the desired duration, the fault injection is removed\n  rollback \"$DISABLE_FAULT_COMMAND\" \"$FLAG_PATH\" \"$ROLLBACK_PATH\" \"$HEARTBEAT_EXPIRATION_PATH\" || RESULT=1\n  return $RESULT\n}\n\n# Function to handle post fault-execution logic\n# Parameters:\n# - FIS_ACTION_STATE_JSON: JSON string containing fault action state\n# - FAULT_NAME: Name of the fault\n# - DURATION: Duration of the fault in seconds\n# - ENABLE_FAULT_COMMAND: Command to enable the fault\n# - DISABLE_FAULT_COMMAND: Command to disable the fault\n# Returns 0 if successful, 1 if failed\nrun_post_fault_injection() {\n  local FIS_ACTION_STATE_JSON=\"$1\"\n  local FAULT_NAME=\"$2\"\n  local DURATION=\"$3\"\n  local ENABLE_FAULT_COMMAND=\"$4\"\n  local DISABLE_FAULT_COMMAND=\"$5\"\n  \n  # Constants\n  local -r MAX_FLAG_AGE_SECONDS=10\n  local -r INJECTION_LOOP_SLEEP_SECONDS=5\n  local -r ATTEMPT_ROLLBACK_AT_SECONDS=20\n  local -r STOP_TIME=$(( $(date +%s) + DURATION ))\n\n  # Extract required fields from JSON\n  local -r FAULT_IDENTIFIER=\"$(echo \"$FIS_ACTION_STATE_JSON\" | jq -r '.id // empty')\"\n  local -r CALL_COUNT=\"$(echo \"$FIS_ACTION_STATE_JSON\" | jq -r '.callCount // empty')\"\n  local -r HEARTBEAT_TIMESTAMP=\"$(echo \"$FIS_ACTION_STATE_JSON\" | jq -r '.callTime // empty')\"\n\n  # Validate required fields\n  if [[ -z \"$FAULT_IDENTIFIER\" || -z \"$CALL_COUNT\" || -z \"$HEARTBEAT_TIMESTAMP\" ]]; then\n    echo \"Required FISActionState fields were not populated.\" >&2\n    exit 1\n  fi\n\n  # Define paths\n  local -r FLAG_PATH=$(get_flag_path \"$FAULT_NAME\" \"$FAULT_IDENTIFIER\")\n  local -r ROLLBACK_PATH=$(get_rollback_path \"$FAULT_NAME\" \"$FAULT_IDENTIFIER\")\n  local -r HEARTBEAT_EXPIRATION_SECONDS=60\n  local -r HEARTBEAT_EXPIRATION_TIME=$((HEARTBEAT_TIMESTAMP + HEARTBEAT_EXPIRATION_SECONDS))\n  local -r HEARTBEAT_EXPIRATION_PATH=$(get_heartbeat_expiration_path \"$FAULT_IDENTIFIER\")\n  local -r HEARTBEAT_MODE=\"$(if [[ \"$CALL_COUNT\" == \"1\" ]]; then echo START; else echo HEARTBEAT; fi)\"\n\n  # Handle heartbeat mode\n  if [[ \"$HEARTBEAT_MODE\" == \"HEARTBEAT\" ]]; then\n    handle_heartbeat_mode \"$HEARTBEAT_EXPIRATION_PATH\" \"$HEARTBEAT_EXPIRATION_TIME\"\n    # Exit with code 0 to indicate successful heartbeat\n    exit 0\n  fi\n\n  # $HEARTBEAT_MODE is START, initialize expiration\n  echo \"$HEARTBEAT_EXPIRATION_TIME\" > \"$HEARTBEAT_EXPIRATION_PATH\"\n\n  # Create rollback script\n  create_rollback_script \"$FLAG_PATH\" \"$ROLLBACK_PATH\" \"$HEARTBEAT_EXPIRATION_PATH\" \"$MAX_FLAG_AGE_SECONDS\" \"$ATTEMPT_ROLLBACK_AT_SECONDS\" \"$DISABLE_FAULT_COMMAND\"\n\n  # Binding the rollback function to these exit signals\n  trap 'rollback \"$DISABLE_FAULT_COMMAND\" \"$FLAG_PATH\" \"$ROLLBACK_PATH\" \"$HEARTBEAT_EXPIRATION_PATH\"' INT TERM\n\n  echo \"Making sure atd daemon is running\"\n  # atd must be running in order to use \"at\" later\n  atd || { echo \"Failed to run atd daemon, exiting...\" 1>&2 ; exit 1; }\n\n  echo \"Scheduling rollback\"\n  schedule_rollback_attempt \"$ROLLBACK_PATH\"\n\n  # Injecting fault\n  echo \"Enabling fault injection\"\n  touch \"$FLAG_PATH\"\n  eval \"$ENABLE_FAULT_COMMAND\"\n\n  # Run fault injection loop\n  run_fault_injection_loop \"$STOP_TIME\" \"$FLAG_PATH\" \"$ROLLBACK_PATH\" \"$HEARTBEAT_EXPIRATION_PATH\" \"$INJECTION_LOOP_SLEEP_SECONDS\" \"$DISABLE_FAULT_COMMAND\"\n  return $?\n}\nrun_post_fault_injection \"$FIS_ACTION_STATE_JSON\" \"$FAULT_NAME\" \"$DURATION\" enable_fault_ecs disable_fault_ecs\n"
        ]
      }
    }
  ]
}
