{
  "schemaVersion": "2.2",
  "description": "Create an application consistent snapshot of all EBS volumes attached to an instance.",
  "parameters": {
    "executionTimeout": {
      "default": "800",
      "description": "(Optional) The time in seconds for this command to be completed before it is considered to have failed. Extending this timeout will cause the command to wait longer for VSS to start its freeze. Default is 800 seconds. Maximum is 172800 (48 hours). Minimum is 120.",
      "type": "String",
      "allowedPattern": "^((1[2-9][0-9]{1})|([2-9][0-9]{2})|([1-9][0-9]{3,4})|(1[0-6][0-9]{4})|(17[0-1][0-9]{3})|(172[0-7][0-9]{2})|(172800))$"
    },
    "ExcludeBootVolume": {
      "allowedValues": [
        "True",
        "False"
      ],
      "default": "False",
      "description": "(Optional) Select True to exclude the boot volume from the snapshot process.",
      "type": "String"
    },
    "AmiName": {
      "default": "",
      "description": "(Optional) Specify a name for created AMI.  This option only has affect if the CreateAmi option is selected.",
      "maxChars": 128,
      "type": "String",
      "allowedPattern": "^([a-zA-Z0-9()\\[\\] ./\\-@_{}:]|^'[a-zA-Z0-9()\\[\\] ./\\-_{}:]|^'$|[a-zA-Z0-9()\\[\\] ./\\-@_{}:]'){0,128}$"
    },
    "description": {
      "default": "",
      "description": "(Optional) Specify a description to apply to created EBS snaphots.",
      "maxChars": 255,
      "type": "String",
      "allowedPattern": "^([^'\\n\\r]|(\\r|\\n)?'[^@]|(\\r|\\n)([^']|'?$)|'$|[^\\r\\n]'@){0,255}$"
    },
    "CreateAmi": {
      "allowedValues": [
        "True",
        "False"
      ],
      "default": "False",
      "description": "(Optional) Select True to create an Amazon Machine Image (AMI) backup.",
      "type": "String"
    },
    "CopyOnly": {
      "allowedValues": [
        "True",
        "False"
      ],
      "default": "False",
      "description": "(Optional) Select True to indicate a COPY ONLY backup operation.  By default a FULL backup operation is performed.  This option will prevent breaking the differential backup chain in SQL Server when performing a backup.",
      "type": "String"
    },
    "NoWriters": {
      "allowedValues": [
        "True",
        "False"
      ],
      "default": "False",
      "description": "(Optional) Select True to exclude application VSS writers from the snapshot process. This option may be useful to resolve conflicts with third party VSS backup solutions.",
      "type": "String"
    },
    "tags": {
      "default": "Key=Name,Value=",
      "description": "(Optional) Specify descriptive key-value pair tags to apply to created EBS snapshots.  Use a semicolon as a separator between tags pairs. Example: Key=Name,Value=VSS Snapshot;Key=BackupId,Value=01234",
      "type": "String",
      "allowedPattern": "^([Kk]ey=([a-zA-Z0-9() ./\\-\"'@_+:={}]*),[Vv]alue=([a-zA-Z0-9() ./\\-\"'@_+:={}]*);?)*$"
    }
  },
  "mainSteps": [
    {
      "inputs": {
        "workingDirectory": "",
        "timeoutSeconds": "{{executionTimeout}}",
        "runCommand": [
          "Set-StrictMode -Version Latest",
          "$ErrorActionPreference = \"Stop\"",
          "trap {",
          "Write-Log \"Encountered unexpected error. Please see error details below.\"",
          "$_.Exception | Format-List -Force",
          "$_.InvocationInfo | Format-List -Force",
          "Write-DiagnosticInformation",
          "[Environment]::Exit(1)",
          "}",
          "$EBS_VOLUME_MATCH = '(?<=vol)[0-9a-zA-Z]*(?= *_)'",
          "$EBS_VOLUME_MATCH2 = '(?<=vol)(.*)'",
          "$vssAgentPath = \"$env:ProgramFiles\\Amazon\\AwsVssComponents\\ec2-vss-agent.exe\"",
          "$vssPath = \"$env:ProgramFiles\\Amazon\\AwsVssComponents\\\"",
          "$vssStdErr = $vssPath + 'vsserr.log'",
          "$vssStdOut = $vssPath + 'vssout.log'",
          "[hashtable[]]$script:diagnosticBuffer = @()",
          "[hashtable[]]$script:logBuffer = @()",
          "[bool]$script:BufferOutput = $false",
          "function Set-OutputMode {",
          "param(",
          "[Parameter(Mandatory=$true,",
          "ParameterSetName=\"Buffered\")]",
          "[switch]$Buffered,",
          "[Parameter(Mandatory=$true,",
          "ParameterSetName=\"UnBuffered\")]",
          "[switch]$UnBuffered",
          ")",
          "if ($Buffered) {",
          "$script:BufferOutput = $true",
          "}",
          "else {",
          "$script:BufferOutput = $false",
          "Write-BufferedLog",
          "}",
          "}",
          "function Write-Log {",
          "[CmdletBinding()]",
          "param(",
          "[Parameter(Position = 0,",
          "Mandatory=$true,",
          "ValueFromPipeline=$true)]",
          "$message",
          ")",
          "if ($script:BufferOutput) {",
          "$script:logBuffer += @{Message=$message;Stream=\"Success\"}",
          "}",
          "else {",
          "Write-Host $message",
          "}",
          "}",
          "function Write-ErrorLog {",
          "[CmdletBinding()]",
          "param(",
          "[Parameter(Position = 0,",
          "Mandatory=$true,",
          "ValueFromPipeline=$true)]",
          "$message",
          ")",
          "if ($script:BufferOutput) {",
          "$script:logBuffer += @{Message=$message;Stream=\"Error\"}",
          "}",
          "else {",
          "Write-Error $message",
          "}",
          "}",
          "function Write-BufferedLog {",
          "foreach ($line in $script:logBuffer) {",
          "switch ($line.Stream)",
          "{",
          "\"Success\" { Write-Host $line.Message; break; }",
          "\"Error\" { Write-Error $line.Message; break; }",
          "Default { Write-Host $line.Message; break; }",
          "}",
          "}",
          "$script:logBuffer = @()",
          "}",
          "function Write-DiagnosticLog {",
          "[CmdletBinding()]",
          "param(",
          "[Parameter(Position = 0,",
          "Mandatory=$true,",
          "ValueFromPipeline=$true)]",
          "$message",
          ")",
          "$script:diagnosticBuffer += @{Timestamp=(Get-Date); Message=$message}",
          "}",
          "function Write-DiagnosticLogOut {",
          "foreach ($line in $script:diagnosticBuffer) {",
          "$ts = $line.Timestamp",
          "$timestring = \"[{0:d2}:{1:d2}.{2:d4}]\" -f @($ts.Minute, $ts.Second, $ts.Millisecond)",
          "Write-Host \"$timestring $($line.Message)\"",
          "}",
          "$script:diagnosticBuffer = @()",
          "}",
          "Function Get-VssEventLogs {",
          "Param(",
          "[System.DateTime]$After",
          ")",
          "$EventViewerMessageFilters = @(",
          "@{",
          "LogName = \"Application\"",
          "Source = \"Ec2VssSoftwareProvider\"",
          "},",
          "@{",
          "LogName = \"Application\"",
          "Source = \"VSS\"",
          "},",
          "@{",
          "LogName = \"System\"",
          "Source = \"Service Control Manager\"",
          "MatchText = \"(Volume Shadow Copy|Ec2VssSoftwareProvider)\"",
          "},",
          "@{",
          "LogName = \"Application\"",
          "Source = \"Application Error\"",
          "EntryType = \"Error\"",
          "MatchText = \"Faulting application name: vssvc.exe\"",
          "}",
          ")",
          "$foundMessages = New-Object 'System.Collections.Generic.List[String]'",
          "foreach ($filter in $EventViewerMessageFilters) {",
          "try {",
          "$matchText = if($filter.ContainsKey(\"MatchText\")) { $filter.MatchText } else { \"\" }",
          "$filter.Remove(\"MatchText\")",
          "$FilteredEvents = (Get-EventLog @filter -After $After -ErrorAction Stop)",
          "if (-not $FilteredEvents) {",
          "continue",
          "}",
          "$matchingEvents = @($FilteredEvents | where {$_.Message -match $matchText})",
          "foreach ($matchingEvent in $matchingEvents) {",
          "$ts = $matchingEvent.TimeGenerated",
          "$timestring = \"[{0:d2}:{1:d2}:{2:d2}]\" -f @($ts.Hour, $ts.Minute, $ts.Second)",
          "$message = $matchingEvent.Message -replace \"[`n`r]+\", \"; \"",
          "$message = \"$timestring $message\"",
          "$foundMessages.Add($message)",
          "}",
          "}",
          "catch [System.ArgumentException] {",
          "}",
          "catch {",
          "$message = $_.Exception -replace \"[`n`r]+\", \"; \"",
          "$message = \"Caught exception reading event log: $message\"",
          "$foundMessages.Add($message)",
          "}",
          "}",
          "return ($foundMessages | Sort)",
          "}",
          "function Write-DiagnosticInformation {",
          "Write-Host \"Begin diagnostic information.\"",
          "Write-Host \"Script execution began $($global:ScriptStartTime).\"",
          "@(",
          "{",
          "Write-Host \"Diagnostic log:\"",
          "Write-DiagnosticLogOut",
          "},",
          "{",
          "Write-Host \"Current pipe states:\"",
          "foreach ($pipe in @(\"freezePipeServer\", \"thawPipeClient\", \"freezePipeWaitHandle\", \"freezePipeReader\", \"thawPipeReader\")) {",
          "if(Get-Variable -Name $pipe -ErrorAction SilentlyContinue){",
          "if ((Get-Variable -Name $pipe -ValueOnly) -eq $null) {",
          "Write-Host \"Pipe $pipe is uninitialized or has been disposed.\"",
          "} else {",
          "Write-Host \"Pipe $pipe is active.\"",
          "}",
          "} else {",
          "Write-Host \"Pipe variable $pipe does not exist.\"",
          "}",
          "}",
          "},",
          "{",
          "$eventLogMessages = (Get-VssEventLogs -After $global:ScriptStartTime)",
          "if ($eventLogMessages) {",
          "Write-Host \"VSS entries in the Event Log:\"",
          "foreach ($eventLogMessage in $eventLogMessages) {",
          "Write-Host $eventLogMessage",
          "}",
          "} else {",
          "Write-Host \"No VSS entries in the Event Log since the start of script execution.\"",
          "}",
          "},",
          "{",
          "Write-Host \"Listing VSS Providers\"",
          "Write-Host (vssadmin list providers)",
          "Write-Host \"Listing VSS Writers\"",
          "Write-Host (vssadmin list writers)",
          "},",
          "{",
          "if ($null -ne (Get-Process -Name \"ec2-vss-agent\" -ea SilentlyContinue)) {",
          "Write-Host \"ec2-vss-agent is running.\"",
          "} else {",
          "Write-Host \"ec2-vss-agent is not running.\"",
          "}",
          "},",
          "{",
          "Write-Host \"Running tasklist /m ec2vssprovider.dll\"",
          "Write-Host (tasklist /m ec2vssprovider.dll)",
          "},",
          "{",
          "$vssAgentVersion = Get-VssAgentVersion",
          "if ($vssAgentVersion) {",
          "Write-Host \"EC2 VSS Agent Version: $vssAgentVersion\"",
          "} else {",
          "Write-Host \"EC2 VSS Agent not found.\"",
          "}",
          "},",
          "{",
          "Write-Host \"PowerShell version:\"",
          "Write-Host $PSVersionTable.PSVersion",
          "if(Get-Command -Name Get-AWSPowerShellVersion -ErrorAction SilentlyContinue) {",
          "Write-Host \"Active AWSPowerShell version:\"",
          "Write-Host (Get-AWSPowerShellVersion)",
          "} else {",
          "Write-Host \"Get-AWSPowerShellVersion not found.\"",
          "}",
          "Write-Host \"All available PowerShell Modules matching AWS*:\"",
          "Write-Host (Get-Module \"AWS*\" | Select Name, Version)",
          "}",
          ") | ForEach-Object {",
          "try {",
          "Invoke-Expression $_",
          "} catch {",
          "Write-Host \"Exception occurred while printing diagnostic information:\"",
          "Write-Host ($_.Exception | Out-String)",
          "Write-Host ($_.InvocationInfo.PositionMessage | Out-String)",
          "}",
          "}",
          "Write-Host \"End diagnostic information.\"",
          "}",
          "function PrintVssAgentOutput($process) {",
          "$exited = $process.WaitForExit(30 * 1000)",
          "if (-not $exited) {",
          "Write-Log \"VSS Requester did not exit after 30 seconds, stopping.\"",
          "Stop-Process -InputObject $process",
          "}",
          "$out = Get-Content $vssStdOut",
          "if ($out) {",
          "$out = [string]::join(\"`n\", $out)",
          "Write-Log $out",
          "}",
          "$out = Get-Content $vssStdErr",
          "if ($out) {",
          "$out = [string]::join(\"`n\", $out)",
          "Write-Log $out",
          "}",
          "}",
          "function PrintTimeoutTroubleshootingBanner {",
          "Write-Log \"EC2 Images or Snapshots created may not be application-consistent\"",
          "Write-Log \"This is probably due to activity on a volume by an application or service slowing/preventing VSS from progressing,\"",
          "Write-Log \" or in calls to New-EC2Snapshot/New-EC2Image taking longer than expected to complete.\"",
          "Write-Log \"Windows VSS has a non-configurable 10 second period in which snapshots must complete to be guaranteed as Application-Consistent.\"",
          "Write-Log \"\"",
          "Write-Log \"Please consider trying this command again, or attempting snapshots again when the activity on the instance is reduced.\"",
          "}",
          "$global:freezePipeServer = $null",
          "$global:thawPipeClient = $null",
          "$global:freezePipeWaitHandle = $null",
          "$global:freezePipeReader = $null",
          "$global:thawPipeReader = $null",
          "function Initialize-VssOperationChannel {",
          "param (",
          "[DateTime] $startTime,",
          "[int] $waitForFreezeTimeout",
          ")",
          "$freezeNamedPipe = '01C0026F-7357-49CD-BD74-657EAF079673'",
          "$thawNamedPipe = '8EF5C9E5-9C84-43EB-A8F7-C60B0EFD7B72'",
          "$global:waitForFreezeTimeout = $waitForFreezeTimeout",
          "if ($null -ne (Get-Process -Name \"ec2-vss-agent\" -ea SilentlyContinue)) {",
          "Write-Log \"ec2-vss-agent is current running, snapshot already in progress.\"",
          "return $false",
          "}",
          "Write-Log \"Starting Initialize Vss Operation Channel at $($(New-Timespan $startTime $(Get-Date)).TotalMilliseconds) ms\"",
          "try {",
          "$global:freezePipeServer = New-Object System.IO.Pipes.NamedPipeServerStream($freezeNamedPipe,",
          "[System.IO.Pipes.PipeDirection]::In,",
          "1,",
          "[System.IO.Pipes.PipeTransmissionMode]::Byte,",
          "[System.IO.Pipes.PipeOptions]::Asynchronous,",
          "0,",
          "256)",
          "Write-DiagnosticLog \"Named pipe server stream for freeze messages created at $($(New-Timespan $startTime $(Get-Date)).TotalMilliseconds) ms\"",
          "$asyncResult = $global:freezePipeServer.WaitForConnectionAsync()",
          "Write-DiagnosticLog \"Named pipe server stream waiting for connections at $($(New-Timespan $startTime $(Get-Date)).TotalMilliseconds) ms\"",
          "$global:thawPipeClient = New-Object System.IO.Pipes.NamedPipeClientStream(\".\",",
          "$thawNamedPipe,",
          "[System.IO.Pipes.PipeDirection]::In,",
          "[System.IO.Pipes.PipeOptions]::Asynchronous)",
          "Write-DiagnosticLog \"Named pipe client stream for thaw messages created at $($(New-Timespan $startTime $(Get-Date)).TotalMilliseconds) ms\"",
          "$global:freezeWaitHandle = $asyncResult.AsyncWaitHandle",
          "}",
          "catch {",
          "$initException = $_",
          "Write-DiagnosticLog \"Creating named pipes for VSS messages failed at $($(New-Timespan $startTime $(Get-Date)).TotalMilliseconds) ms with exception\"",
          "Write-DiagnosticLog ($initException.Exception | Out-String)",
          "Write-DiagnosticLog ($initException.InvocationInfo | Out-String)",
          "return $false",
          "}",
          "return $true",
          "}",
          "function Close-VssOperationChannel {",
          "param (",
          "[DateTime] $startTime",
          ")",
          "Write-Log \"Disposing pipes at $($(New-Timespan $startTime $(Get-Date)).TotalMilliseconds) ms\"",
          "if ($null -ne $global:freezePipeWaitHandle) {",
          "$global:freezePipeWaitHandle.Close()",
          "}",
          "if ($null -ne $global:freezePipeReader) {",
          "$global:freezePipeReader.Dispose()",
          "}",
          "if ($null -ne $global:freezePipeServer) {",
          "$global:freezePipeServer.Dispose()",
          "}",
          "if ($null -ne $global:thawPipeReader) {",
          "$global:thawPipeReader.Dispose()",
          "}",
          "if ($null -ne $global:thawPipeClient) {",
          "$global:thawPipeClient.Dispose()",
          "}",
          "$global:thawPipeClient = $null",
          "$global:freezePipeReader = $null",
          "$global:thawPipeReader = $null",
          "$global:freezePipeServer = $null",
          "$global:freezePipeWaitHandle = $null",
          "}",
          "function Wait-ForVssFreezeMessage {",
          "param (",
          "[DateTime] $startTime,",
          "[string]$agentParams",
          ")",
          "Write-Log \"Starting VSS Agent at $($(New-Timespan $startTime $(Get-Date)).TotalMilliseconds) ms\"",
          "Set-OutputMode -Buffered",
          "$process = Start-Process $vssAgentPath $agentParams -PassThru -RedirectStandardError $vssStdErr -RedirectStandardOutput $vssStdOut",
          "if ($process -eq $null) {",
          "return $null",
          "}",
          "try {",
          "Write-Log \"Waiting for Freeze pipe at $($(New-Timespan $startTime $(Get-Date)).TotalMilliseconds) ms\"",
          "if ($global:freezeWaitHandle.WaitOne($global:waitForFreezeTimeout * 1000)) {",
          "Write-Log \"Freeze pipe connected at $($(New-Timespan $startTime $(Get-Date)).TotalMilliseconds) ms\"",
          "$pipeReader = new-object System.IO.StreamReader($global:freezePipeServer)",
          "$string = $pipeReader.ReadLine()",
          "$global:freezeStartTime = $(New-Timespan $startTime $(Get-Date)).TotalMilliseconds",
          "Write-Log \"EBS snapshot Freeze message received at $($global:freezeStartTime) ms $string\"",
          "} else {",
          "Write-Log \"Timed out at $($(New-Timespan $startTime $(Get-Date)).TotalMilliseconds) ms\"",
          "Write-Log \"Timeout waiting for VSS Freeze. Consider increasing the executionTimeout parameter.\"",
          "PrintVssAgentOutput $process",
          "return $null",
          "}",
          "} catch {",
          "Write-Log \"Freeze pipe read failed at $($(New-Timespan $startTime $(Get-Date)).TotalMilliseconds) ms\"",
          "Write-ErrorLog $_",
          "return $null",
          "}",
          "return $process",
          "}",
          "function Wait-ForVssThawmessage {",
          "param (",
          "[DateTime] $startTime",
          ")",
          "$string = [string]::Empty",
          "$thawStartTime = $($(New-Timespan $startTime $(Get-Date))).TotalMilliseconds",
          "Write-Log \"Thaw pipe waiting for connection at $thawStartTime ms\"",
          "try {",
          "$global:thawPipeClient.Connect(10000)",
          "} catch {",
          "Write-Log \"Thaw pipe connection failed at $($(New-Timespan $startTime $(Get-Date)).TotalMilliseconds) ms\"",
          "if ($thawStartTime - $global:freezeStartTime -gt 9000) {",
          "Write-Log \"ERROR: Timestamps indicate more than 9000ms elapsed between freeze and thaw. Kernel hold on I/O has expired.\"",
          "PrintTimeoutTroubleshootingBanner",
          "}",
          "Write-ErrorLog $_",
          "return $string",
          "}",
          "Write-Log \"Thaw pipe connected at $($(New-Timespan $startTime $(Get-Date)).TotalMilliseconds) ms\"",
          "try {",
          "$global:thawPipeReader = New-Object System.IO.StreamReader($global:thawPipeClient)",
          "$string = $global:thawPipeReader.ReadLine()",
          "} catch {",
          "Write-Log \"Thaw pipe read failed at $($(New-Timespan $startTime $(Get-Date)).TotalMilliseconds) ms\"",
          "Write-ErrorLog $_",
          "return $string",
          "}",
          "Write-Log \"Pipe message read at $($(New-Timespan $startTime $(Get-Date)).TotalMilliseconds) ms\"",
          "return $string",
          "}",
          "function EbsVssFreeze {",
          "param (",
          "[string]$driveLetter,",
          "[DateTime]$startTime,",
          "[boolean]$copyOnly,",
          "[boolean]$noWriters",
          ")",
          "$params = $driveLetter",
          "if ($copyOnly) {",
          "Write-Log \"Copy only option selected\"",
          "$params = \"-copy \" + $params",
          "}",
          "if ($noWriters) {",
          "Write-Log \"No writers option selected\"",
          "$params = \"-nw \" + $params",
          "}",
          "$process = Wait-ForVssFreezeMessage -StartTime $startTime -agentParams $params",
          "return $process",
          "}",
          "function EbsVssThaw {",
          "param (",
          "[System.DateTime] $startTime = $(Get-Date)",
          ")",
          "$thawResult = Wait-ForVssThawmessage -StartTime $startTime",
          "Set-OutputMode -UnBuffered",
          "if ($thawResult -like 'EBS done') {",
          "Write-Log \"Pipe message read at $($(New-Timespan $startTime $(Get-Date)).TotalMilliseconds) ms\"",
          "return $true",
          "} else {",
          "Write-Log \"Thaw pipe returned wrong value: $thawResult\"",
          "if ($thawResult -like 'EBS timeout') {",
          "Write-Log \"ERROR: Provider gave timeout message, indicating kernel hold on I/O expired.\"",
          "PrintTimeoutTroubleshootingBanner",
          "}",
          "return $false",
          "}",
          "}",
          "function Get-EC2InstanceId {",
          "return $env:AWS_SSM_INSTANCE_ID",
          "}",
          "function Convert-SCSITargetIdToDeviceName {",
          "param([int]$SCSITargetId)",
          "If ($SCSITargetId -eq 0) {",
          "return '/dev/sda1'",
          "}",
          "$deviceName = 'xvd'",
          "If ($SCSITargetId -gt 25) {",
          "$deviceName += [char](0x60 + [int]($SCSITargetId / 26))",
          "}",
          "$deviceName += [char](0x61 + $SCSITargetId % 26)",
          "return $deviceName",
          "}",
          "function Get-DynamicDiskPartitionsOnEBSVolumes {",
          "Try {",
          "$InstanceId = Get-EC2InstanceId",
          "$BlockDeviceMappings = (Get-EC2Instance -Instance $InstanceId).Instances.BlockDeviceMappings",
          "} Catch {",
          "Write-Log \"Could not access the AWS API, therefore, VolumeId is not available.\"",
          "Write-Log \"Verify that your instance role has Describe-Instances permission.\"",
          "throw",
          "}",
          "$diskList = Get-WmiObject -Class Win32_DiskDrive | ForEach-Object {",
          "$DiskDrive = $_",
          "$LogicalDiskManagerPartitions = Get-WmiObject -Query \"ASSOCIATORS OF {Win32_DiskDrive.DeviceID='$($DiskDrive.DeviceID)'} WHERE AssocClass=Win32_DiskDriveToDiskPartition\" | Where {$_.Type -match \"Logical Disk Manager\"}",
          "if (-not $LogicalDiskManagerPartitions) {",
          "return",
          "}",
          "$Volumes = $LogicalDiskManagerPartitions | ForEach-Object {",
          "$DiskPartition = $_",
          "Get-WmiObject -Query \"ASSOCIATORS OF {Win32_DiskPartition.DeviceID='$($DiskPartition.DeviceID)'} WHERE AssocClass=Win32_LogicalDiskToPartition\"",
          "}",
          "$volumeNumber = $DiskDrive.SerialNumber | Select-String $EBS_VOLUME_MATCH | % { $_.Matches } | % { $_.Value }",
          "if ($volumeNumber -eq $null) {",
          "$volumeNumber = $DiskDrive.SerialNumber | Select-String $EBS_VOLUME_MATCH2 | % { $_.Matches } | % { $_.Value }",
          "}",
          "if ($volumeNumber -ne $null) {",
          "$ebsVolumeId = \"vol-$volumeNumber\"",
          "$BlockDevice = $BlockDeviceMappings | Where-Object { $_.Ebs.VolumeId -eq $ebsVolumeId }",
          "if ($BlockDevice -ne $null) {",
          "$BlockDeviceName = $BlockDevice.DeviceName",
          "}",
          "}",
          "elseif ($DiskDrive.PNPDeviceID -like \"*PROD_PVDISK*\") {",
          "$BlockDeviceName = Convert-SCSITargetIdToDeviceName($DiskDrive.SCSITargetId)",
          "$BlockDevice = $BlockDeviceMappings | Where-Object { $_.DeviceName -like (\"*\" + $BlockDeviceName) }",
          "}",
          "else {",
          "$BlockDeviceName = $null",
          "$BlockDevice = $null",
          "}",
          "$foundWriteableVolume = $false",
          "foreach ($volume in $Volumes) {",
          "if ($volume.Access -ne 1) {",
          "$foundWriteableVolume = $true",
          "}",
          "}",
          "if ($BlockDevice -ne $null -and $BlockDevice.Ebs -ne $null) {",
          "New-Object PSObject -Property @{",
          "Disk = $DiskDrive.Index;",
          "Partitions = $DiskDrive.Partitions;",
          "AccessPath = If ($Volumes -eq $null) { $null } Else { $Volumes.DeviceID };",
          "EbsVolumeId = If ($BlockDevice -eq $null) { $null } Else { $BlockDevice.Ebs.VolumeId };",
          "Device = If ($BlockDeviceName -eq $null) { $null } Else { $BlockDeviceName };",
          "VolumeName = If ($Volumes -eq $null) { $null } Else { $Volumes.VolumeName };",
          "IsReadOnly = If (-not $foundWriteableVolume) { $true } Else { $false };",
          "}",
          "}",
          "} | Sort-Object Disk",
          "return $diskList",
          "}",
          "function Get-AwsNvmeStorageSpacesEbsDiskMapping {",
          "$disklist = @()",
          "$physicalDisks = @()",
          "$physicalDisks += Get-PhysicalDisk | Where-Object {",
          "(($_.Manufacturer -match 'NVMe') -and ($_.Model -match 'Amazon') -and",
          "($_.SerialNumber -match $EBS_VOLUME_MATCH)) -or",
          "((Get-Member -InputObject $_ -Name \"AdapterSerialNumber\") -and ($_.AdapterSerialNumber -match $EBS_VOLUME_MATCH2))",
          "}",
          "if (!$physicalDisks -or ($physicalDisks.Count -eq 0)) {",
          "return $null",
          "}",
          "$InstanceId = Get-EC2InstanceId",
          "$BlockDeviceMapping = (Get-EC2Instance -Instance $InstanceId).Instances.BlockDeviceMappings",
          "foreach ($pd in $physicalDisks) {",
          "$pool1 = Get-StoragePool -PhysicalDisk $pd -IsPrimordial $False -ErrorAction SilentlyContinue",
          "$volumeNumber = $pd.SerialNumber | Select-String $EBS_VOLUME_MATCH | % { $_.Matches } | % { $_.Value }",
          "if ($volumeNumber -eq $null) {",
          "$volumeNumber = $pd.AdapterSerialNumber | Select-String $EBS_VOLUME_MATCH2 | % { $_.Matches } | % { $_.Value }",
          "}",
          "$ebsVolumeId = \"vol-$volumeNumber\"",
          "$matchingBlockDevice = $BlockDeviceMapping | Where-Object {($_.Ebs -ne $null) -and ($_.Ebs.VolumeId -eq $ebsVolumeId)}",
          "foreach ($vd in Get-VirtualDisk) {",
          "$pool2 = Get-StoragePool -VirtualDisk $vd",
          "if (($pool1 -like $pool2) -and ($volumeNumber -ne $null)) {",
          "$disk = ($vd | Get-Disk)",
          "$parts = @($disk | Get-Partition | Where-Object -Property Type -NE Reserved | Where-Object -Property Type -NE \"XINT13 Extended\")",
          "foreach ($part in $parts) {",
          "$vol = ($part | Get-Volume)",
          "$isReadOnly = ($pool2.IsReadOnly -or $disk.IsReadOnly -or $part.IsReadOnly)",
          "$diskList += New-Object PSObject -Property @{",
          "Disk = If ($pd -eq $null) { $null } Else { $pd.DeviceId };",
          "Partitions = 0;",
          "AccessPath = If ($vol -ne $null -and $vol.DriveLetter) { ($vol.DriveLetter + ':') } elseif ($part.AccessPaths) { $part.AccessPaths[0] } else { $null };",
          "EbsVolumeId = If ($pd -eq $null) { $null } Else { $ebsVolumeId };",
          "Device = If ($matchingBlockDevice -eq $null) { $pd.FriendlyName } Else { $matchingBlockDevice.DeviceName };",
          "VolumeName = If ($vol -eq $null) { $null } Else { $vol.FileSystemLabel };",
          "IsReadOnly = $isReadOnly;",
          "}",
          "}",
          "}",
          "}",
          "}",
          "return $disklist",
          "}",
          "function Get-XenStorageSpacesEbsDiskMapping {",
          "$disklist = @()",
          "$physicalDisks = @()",
          "$ATTACHMENT_ORDER_MATCH = '^(\\d{4})$'",
          "$physicalDisks += Get-PhysicalDisk | Where-Object {",
          "($_.SerialNumber -match $ATTACHMENT_ORDER_MATCH -and $_.SerialNumber -ne '0000') -or",
          "(($_.SerialNumber -match $EBS_VOLUME_MATCH2) -and",
          "($_.Manufacturer -match 'AWS' -and $_.Model -match 'PVDISK'))",
          "}",
          "if (!$physicalDisks -or ($physicalDisks.Count -eq 0)) {",
          "return $null",
          "}",
          "$InstanceId = Get-EC2InstanceId",
          "$BlockDeviceMapping = (Get-EC2Instance -Instance $InstanceId).Instances.BlockDeviceMappings",
          "foreach ($pd in $physicalDisks) {",
          "$volumeNumber = $pd.SerialNumber | Select-String $EBS_VOLUME_MATCH2 | % { $_.Matches } | % { $_.Value }",
          "if ($volumeNumber -ne $null) {",
          "$ebsVolumeId = \"vol-$volumeNumber\"",
          "$device = $BlockDeviceMapping | Where-Object { $_.Ebs.VolumeId -eq $ebsVolumeId }",
          "if ($device -ne $null) {",
          "$BlockDeviceName = $device.DeviceName",
          "}",
          "else {",
          "Write-Log \"Found disk with unrecognized volume id: $ebsVolumeId. Ignoring as instance store\"",
          "$BlockDeviceName = $null",
          "$ebsVolumeId = $null",
          "}",
          "}",
          "elseif ($pd.SerialNumber -match $ATTACHMENT_ORDER_MATCH) {",
          "$BlockDeviceName = Convert-SCSITargetIdToDeviceName $pd.SerialNumber",
          "$device = $BlockDeviceMapping | Where-Object {$_.DeviceName -like (\"*\" + $BlockDeviceName)}",
          "if ($device -ne $null) {",
          "$ebsVolumeId = $device.Ebs.VolumeId",
          "}",
          "else {",
          "Write-Log \"Found disk with unrecognized block device: $BlockDeviceName. Ignoring as instance store\"",
          "$ebsVolumeId = $null",
          "}",
          "}",
          "else {",
          "Write-Log \"Found disk with unrecognized serial number: $($pd.SerialNumber). Will ignore.\"",
          "$BlockDeviceName = $null",
          "$ebsVolumeId = $null",
          "}",
          "$pool1 = Get-StoragePool -PhysicalDisk $pd -IsPrimordial $False -ErrorAction SilentlyContinue",
          "foreach ($vd in Get-VirtualDisk) {",
          "$pool2 = Get-StoragePool -VirtualDisk $vd",
          "if (($pool1 -like $pool2) -and ($ebsVolumeId -ne $null)) {",
          "$disk = ($vd | Get-Disk)",
          "$parts = @($disk | Get-Partition | Where-Object -Property Type -NE Reserved | Where-Object -Property Type -NE \"XINT13 Extended\")",
          "foreach ($part in $parts) {",
          "$vol = ($part | Get-Volume)",
          "$isReadOnly = ($pool2.IsReadOnly -or $disk.IsReadOnly -or $part.IsReadOnly)",
          "$diskList += New-Object PSObject -Property @{",
          "Disk = If ($pd -eq $null) { $null } Else { $pd.DeviceId };",
          "Partitions = 0;",
          "AccessPath = If ($vol -ne $null -and $vol.DriveLetter) { ($vol.DriveLetter + ':') } elseif ($part.AccessPaths) { $part.AccessPaths[0] } else { $null };",
          "EbsVolumeId = If ($pd -eq $null) { $null } Else { $ebsVolumeId };",
          "Device = If ($pd -eq $null) { $null } Else { $BlockDeviceName };",
          "VolumeName = If ($vol -eq $null) { $null } Else { $vol.FileSystemLabel };",
          "IsReadOnly = $isReadOnly;",
          "}",
          "}",
          "}",
          "}",
          "}",
          "return $disklist",
          "}",
          "function Get-EbsDiskMapping {",
          "$disklist = @()",
          "$physicalDisks = @()",
          "$ATTACHMENT_ORDER_MATCH = '^(\\d{4})$'",
          "$physicalDisks += Get-PhysicalDisk | Where-Object {",
          "($_.SerialNumber -match $ATTACHMENT_ORDER_MATCH) -or",
          "(($_.SerialNumber -match $EBS_VOLUME_MATCH2) -and",
          "($_.Manufacturer -match 'AWS' -and $_.Model -match 'PVDISK')) -or",
          "($_.SerialNumber -match $EBS_VOLUME_MATCH)",
          "}",
          "if (!$physicalDisks -or ($physicalDisks.Count -eq 0)) {",
          "return $null",
          "}",
          "$InstanceId = Get-EC2InstanceId",
          "$BlockDeviceMapping = (Get-EC2Instance -Instance $InstanceId).Instances.BlockDeviceMappings",
          "foreach ($pd in $physicalDisks) {",
          "$volumeNumber = $pd.SerialNumber | Select-String $EBS_VOLUME_MATCH | % { $_.Matches } | % { $_.Value }",
          "if ($volumeNumber -eq $null) {",
          "$volumeNumber = $pd.SerialNumber | Select-String $EBS_VOLUME_MATCH2 | % { $_.Matches } | % { $_.Value }",
          "}",
          "if ($volumeNumber -ne $null) {",
          "$ebsVolumeId = \"vol-$volumeNumber\"",
          "$device = $BlockDeviceMapping | Where-Object { $_.Ebs.VolumeId -eq $ebsVolumeId }",
          "if ($device -ne $null) {",
          "$BlockDeviceName = $device.DeviceName",
          "}",
          "else {",
          "Write-Log \"Found disk with unrecognized volume id: $ebsVolumeId. Ignoring as instance store\"",
          "$BlockDeviceName = $null",
          "$ebsVolumeId = $null",
          "}",
          "}",
          "elseif ($pd.SerialNumber -match $ATTACHMENT_ORDER_MATCH) {",
          "$BlockDeviceName = Convert-SCSITargetIdToDeviceName $pd.SerialNumber",
          "$device = $BlockDeviceMapping | Where-Object {$_.DeviceName -like (\"*\" + $BlockDeviceName)}",
          "if ($device -ne $null) {",
          "$ebsVolumeId = $device.Ebs.VolumeId",
          "}",
          "else {",
          "Write-Log \"Found disk with unrecognized block device: $BlockDeviceName. Ignoring as instance store\"",
          "$ebsVolumeId = $null",
          "}",
          "}",
          "else {",
          "Write-Log \"Found disk with unrecognized serial number: $($pd.SerialNumber). Will ignore.\"",
          "$BlockDeviceName = $null",
          "$ebsVolumeId = $null",
          "}",
          "$disk = ($pd | Get-Disk -ErrorAction Ignore) ",
          "$parts = @($disk | Get-Partition | Where-Object -Property Type -NE Reserved | Where-Object -Property Type -NE \"XINT13 Extended\")",
          "foreach ($part in $parts) {",
          "$vol = ($part | Get-Volume)",
          "$isReadOnly = ($disk.IsReadOnly -or $part.IsReadOnly)",
          "$diskList += New-Object PSObject -Property @{",
          "Disk = If ($pd -eq $null) { $null } Else { $pd.DeviceId };",
          "Partitions = 0;",
          "AccessPath = If ($vol -ne $null -and $vol.DriveLetter) { ($vol.DriveLetter + ':') } elseif ($part.AccessPaths) { $part.AccessPaths[0] } else { $null };",
          "EbsVolumeId = If ($pd -eq $null) { $null } Else { $ebsVolumeId };",
          "Device = If ($pd -eq $null) { $null } Else { $BlockDeviceName };",
          "VolumeName = If ($vol -eq $null) { $null } Else { $vol.FileSystemLabel };",
          "IsReadOnly = $isReadOnly;",
          "}",
          "}",
          "}",
          "return $disklist",
          "}",
          "function Get-EbsConnectedVolume",
          "{",
          "$diskList = @()",
          "$disks = Get-EbsDiskMapping",
          "if ($disks) {",
          "Write-DiagnosticLog \"Mapped simple volumes:\"",
          "Write-DiagnosticLog ($disks | ConvertTo-Json -Compress)",
          "$diskList += $disks",
          "}",
          "$disks = Get-XenStorageSpacesEbsDiskMapping",
          "if ($disks) {",
          "Write-DiagnosticLog \"Mapped Xen Storage Spaces volumes:\"",
          "Write-DiagnosticLog ($disks | ConvertTo-Json -Compress)",
          "$diskList += $disks",
          "}",
          "$disks = Get-AwsNvmeStorageSpacesEbsDiskMapping",
          "if ($disks) {",
          "Write-DiagnosticLog \"Mapped NVMe Storage Spaces volumes:\"",
          "Write-DiagnosticLog ($disks | ConvertTo-Json -Compress)",
          "$diskList += $disks",
          "}",
          "$disks = Get-DynamicDiskPartitionsOnEBSVolumes",
          "if ($disks) {",
          "Write-DiagnosticLog \"Mapped Dynamic Disk volumes:\"",
          "Write-DiagnosticLog ($disks | ConvertTo-Json -Compress)",
          "$diskList += $disks",
          "}",
          "return $diskList",
          "}",
          "function New-TagSpecification {",
          "param(",
          "[string]$resourceType,",
          "[amazon.EC2.Model.Tag[]]$Tags",
          ")",
          "$tagSpec = New-Object Amazon.EC2.Model.TagSpecification",
          "$tagSpec.ResourceType = $resourceType",
          "$tagSpec.Tags = $Tags",
          "return $tagSpec",
          "}",
          "function Tag-Snapshots {",
          "param(",
          "[System.Object[]]$SnapshotsData,",
          "[System.Object]$AmiData,",
          "[boolean]$AppConsistent,",
          "[Parameter(Mandatory = $false)][amazon.EC2.Model.Tag[]]$Tags",
          ")",
          "$Tag = New-Object amazon.EC2.Model.Tag",
          "$Tag.Key = \"AppConsistent\"",
          "$Tag.Value = \"$AppConsistent\"",
          "$Tags += $Tag",
          "foreach ($SnapshotData in $SnapshotsData) {",
          "$Tag = New-Object amazon.EC2.Model.Tag",
          "$Tag.Key = \"Device\"",
          "$Tag.Value = $SnapshotData.Device",
          "$AllTags = $Tags + $Tag",
          "New-EC2Tag -Resources $SnapshotData.SnapshotId -Tags $AllTags",
          "}",
          "if ($AmiData) {",
          "New-EC2Tag -Resources $AmiData.ImageId -Tags $Tags",
          "}",
          "}",
          "function Get-OSVersionNumber {",
          "return ([Decimal]([environment]::OSVersion.Version).Major + [Decimal]([environment]::OSVersion.Version).Minor * .1)",
          "}",
          "function Get-VssAgentVersion {",
          "if(!(Test-Path $vssAgentPath)) {",
          "return 0",
          "}",
          "$vssAgentFileInfo = Get-Item $vssAgentPath",
          "return $vssAgentFileInfo.VersionInfo.FileVersion",
          "}",
          "function Invoke-VssSnapshot() {",
          "param(",
          "[boolean]$ExcludeBootVolume,",
          "[boolean]$CopyOnly,",
          "[boolean]$NoWriters,",
          "[boolean]$CreateAmi,",
          "[string]$AmiName,",
          "[string]$Description,",
          "[string]$Tags,",
          "[uint32]$waitForFreezeTimeout=180",
          ")",
          "$startTime = Get-Date",
          "$VolumesToFreeze = @()",
          "$DrivesToFreeze = @()",
          "$instanceId = Get-Ec2InstanceId",
          "if (($null -eq $instanceId) -or ($instanceId -notlike 'i-*')) {",
          "Write-Log \"Error: Must be running on EC2 Instance as an SSM document\"",
          "return $false",
          "}",
          "if ((Get-OSVersionNumber) -lt 6.2) {",
          "Write-Log \"Error: Must be running on Windows Server 2012 or later. Please target an older version of this document.\"",
          "Write-Log \"For more details see: https://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/application-consistent-snapshots-prereqs.html\"",
          "return $false",
          "}",
          "if ($ExcludeBootVolume -and $CreateAmi) {",
          "Write-Log \"The CreateAMI option is not compatible with ExcludeBootVolume.\"",
          "return $false",
          "}",
          "if (!(Get-VssAgentVersion)) {",
          "Write-Log 'ec2-vss-agent.exe is not installed. To install, run command AWS-ConfigureAWSPackage with package AwsVssComponents'",
          "return $false",
          "}",
          "$toolsModuleName = $null",
          "if ($null -ne (Get-Module -ListAvailable -Name 'AWSPowerShell')) {",
          "$toolsModuleName = 'AWSPowerShell'",
          "}",
          "elseif ($null -ne (Get-Module -ListAvailable -Name 'AWS.Tools.EC2')) {",
          "$toolsModuleName = 'AWS.Tools.EC2'",
          "}",
          "elseif ($null -ne (Get-Module -ListAvailable -Name 'AWSPowerShell.NetCore')) {",
          "$toolsModuleName = 'AWSPowerShell.NetCore'",
          "}",
          "else {",
          "Write-Log \"Error: Unable to locate AWS PowerShell tools that are necessary for tagging.\"",
          "Write-Log \"Please ensure that AWS PowerShell tools are installed\"",
          "return $false",
          "}",
          "Import-Module -Name $toolsModuleName",
          "[amazon.EC2.Model.Tag[]]$TagArray = @()",
          "$Tags -split \";\" | ForEach-Object {",
          "if (-not [string]::IsNullOrEmpty($_)) {",
          "$TagParts = ($_ -split \",\", 2)",
          "if ($TagParts.Count -ne 2) {",
          "Write-Log \"Error parsing tags, tags need to be in the format Name=tag-key,Values=tag-value\"",
          "return $false",
          "}",
          "$TagName, $TagValue = $TagParts",
          "$Tag = New-Object amazon.EC2.Model.Tag",
          "$Tag.Key = ($TagName -split \"=\", 2)[1].Trim()",
          "$Tag.Value = ($TagValue -split \"=\", 2)[1].Trim()",
          "$TagArray += $Tag",
          "}",
          "}",
          "if (Test-Path $vssStdErr) {",
          "del $vssStdErr",
          "}",
          "if (Test-Path $vssStdOut) {",
          "del $vssStdOut",
          "}",
          "$InstanceId = Get-EC2InstanceId",
          "$NumberOfAttachedEBSVolumes = @((Get-EC2Instance -Instance $InstanceId).Instances.BlockDeviceMappings).Count",
          "$volumeList = Get-EbsConnectedVolume",
          "$foundWriteableVolume = $false",
          "foreach ($v in $volumeList) {",
          "if ( ($v.AccessPath -ne $null) -and ($v.EbsVolumeId -ne $null)) {",
          "if (($ExcludeBootVolume -eq $false) -or ($v.Device -ne \"/dev/sda1\")) {",
          "$DrivesToFreeze += $v.AccessPath",
          "$VolumesToFreeze += $v",
          "if (-not $v.IsReadOnly) {",
          "$foundWriteableVolume = $true",
          "}",
          "}",
          "}",
          "}",
          "if ($VolumesToFreeze.Count -eq 0) {",
          "Write-Log \"No mounted EBS drives detected\"",
          "return $false",
          "}",
          "if ($createAmi -And (-Not $amiName)) {",
          "$amiName = \"EC2_VSS_Backup_$($InstanceId)_$((Get-WMIObject win32_operatingsystem).Caption)_$(get-date -format yyyy-MM-ddTHH-mm-ss)\"",
          "$amiName = $amiName.replace(' ','')",
          "}",
          "$tagOnCreate = $false",
          "if ($TagArray.Count -ge 1) {",
          "if ($CreateAmi) {",
          "$tagOnCreate = (Get-Command New-EC2Image).ParameterSets.Parameters.Name -contains \"TagSpecification\"",
          "if ($tagOnCreate) {",
          "$tagSpecImage = New-TagSpecification -ResourceType \"Image\" -tags $TagArray",
          "}",
          "} else {",
          "$tagOnCreate = (Get-Command New-EC2Snapshot).ParameterSets.Parameters.Name -contains \"TagSpecification\"",
          "}",
          "if ($tagOnCreate) {",
          "$tagSpecSnapshot = New-TagSpecification -ResourceType \"Snapshot\" -tags $TagArray",
          "}",
          "}",
          "try {",
          "if ($foundWriteableVolume) {",
          "$DrivesToFreezeString = \"`\"\" + ((($DrivesToFreeze | sort -Unique ) -replace '\\\\$','\\\\') -join \"`\" `\"\") + \"`\"\"",
          "Write-Log \"Beginning snapshot for drives $DrivesToFreezeString\"",
          "$initResult = Initialize-VssOperationChannel -startTime $startTime -waitForFreezeTimeout $waitForFreezeTimeout",
          "if ($false -eq $initResult) {",
          "return $false",
          "}",
          "$process = EbsVssFreeze $DrivesToFreezeString $startTime $CopyOnly $NoWriters",
          "if ($process -eq $null) {",
          "return $false",
          "}",
          "Write-Log \"Freeze complete at $($(New-Timespan $startTime $(Get-Date)).TotalMilliseconds) ms\"",
          "}",
          "else {",
          "Write-Log 'All volumes found are read-only or on a read-only disk or storage pool. Snapshotting without freezing IO.'",
          "}",
          "$SnapshotData = @()",
          "$AmiData = @()",
          "$amiId = ''",
          "if ($createAmi) {",
          "try {",
          "$newImageArguments = @{",
          "InstanceId = $instanceId",
          "Name = $amiName",
          "Description = $Description",
          "NoReboot = $true",
          "}",
          "if ($tagOnCreate) {",
          "$newImageArguments += @{TagSpecification = $tagSpecSnapshot,$tagSpecImage}",
          "}",
          "$amiId = New-EC2Image @newImageArguments",
          "Write-Log \"New-EC2Image returned at $($(New-Timespan $startTime $(Get-Date)).TotalMilliseconds) ms\"",
          "$timeOut = 10 ",
          "while ($timeOut) {",
          "try {",
          "$AmiData = Get-EC2Image -ImageId $amiId",
          "} catch {",
          "if($timeOut -gt 1 -and $_.Exception.InnerException.ErrorCode -eq \"InvalidAMIID.NotFound\") {",
          "$AmiData = $False",
          "} else {",
          "throw $_",
          "}",
          "}",
          "if ($AmiData -And ($AmiData.State -Like \"pending\" -Or $AmiData.State -Like \"available\")) {",
          "if ($AmiData.PSobject.Properties.name -match \"BlockDeviceMappings\") {",
          "$SnapshotData = @()",
          "foreach ($b in $AmiData.BlockDeviceMappings) {",
          "if ($b.PSobject.Properties.name -match \"Ebs\" -And",
          "$b.Ebs -And $b.Ebs.PSobject.Properties.name -match \"SnapshotId\" -And",
          "$b.PSobject.Properties.name -match \"DeviceName\" -And",
          "$b.Ebs.SnapshotId) {",
          "$SnapshotData += New-Object PSObject -Property @{",
          "Device = $b.DeviceName",
          "SnapshotId = $b.Ebs.SnapshotId",
          "}",
          "}",
          "}",
          "if ($SnapshotData.Count -eq $NumberOfAttachedEBSVolumes) {",
          "Write-Log \"Get-EC2Image contains all snapshot metadata at $($(New-Timespan $startTime $(Get-Date)).TotalMilliseconds) ms\"",
          "break;",
          "}",
          "}",
          "}",
          "Start-Sleep -Seconds 1",
          "$timeOut--",
          "}",
          "if ($timeOut -le 0) {",
          "Write-Log \"ERROR: Took longer than 10 seconds to describe snapshots in AMI, kernel hold on I/O has expired.\"",
          "PrintTimeoutTroubleshootingBanner",
          "return $false",
          "}",
          "} catch {",
          "Write-Log \"Exception caught creating AMI:\"",
          "Write-Log $_",
          "return $false",
          "}",
          "} else {",
          "foreach ($v in $VolumesToFreeze) {",
          "if ($SnapshotData | Where-Object {$_.EbsVolumeId -eq $v.EbsVolumeId}) {",
          "continue",
          "}",
          "try {",
          "$newSnapshotArguments = @{",
          "VolumeId = $v.EbsVolumeId",
          "Description = $Description",
          "}",
          "if ($tagOnCreate) {",
          "$newSnapshotArguments += @{TagSpecification = $tagSpecSnapshot}",
          "}",
          "$Snapshot = New-EC2Snapshot @newSnapshotArguments",
          "} catch {",
          "Write-Log \"Exception caught creating EBS snapshot:\"",
          "Write-Log $_.ToString()",
          "return $false",
          "}",
          "$SnapshotData += New-Object PSObject -Property @{",
          "EbsVolumeId = $v.EbsVolumeId",
          "Device = $v.Device",
          "SnapshotId = $Snapshot.SnapshotId",
          "}",
          "}",
          "}",
          "if ($foundWriteableVolume) {",
          "Write-Log \"Starting Thaw at $($(New-Timespan $startTime $(Get-Date)).TotalMilliseconds) ms\"",
          "$AppConsistent = EbsVssThaw $startTime",
          "if ($AppConsistent) {",
          "Write-Log \"Thaw successful at $($(New-Timespan $startTime $(Get-Date)).TotalMilliseconds) ms\"",
          "} else {",
          "Write-Log \"Thaw unsuccesful, snapshots may not be app consistent, see event log for more details $($(New-Timespan $startTime $(Get-Date)).TotalMilliseconds) ms\"",
          "}",
          "if ($amiId) {",
          "Write-Log \"AMI: $amiId\"",
          "}",
          "foreach ($Snapshot in $SnapshotData) {",
          "Write-Log \"Snapshot: $($Snapshot.SnapshotId) DeviceName: $($Snapshot.Device)\"",
          "}",
          "PrintVssAgentOutput $process",
          "}",
          "else {",
          "$AppConsistent = $true",
          "Write-Log 'All volumes found are read-only or on a read-only disk or storage pool. Skipping VssThaw.'",
          "}",
          "}",
          "catch {",
          "Write-Log \"Unknown Exception Occurred\"",
          "Write-Log ($_.Exception | Out-String)",
          "Write-Log ($_.InvocationInfo.PositionMessage | Out-String)",
          "}",
          "finally {",
          "Set-OutputMode -UnBuffered",
          "}",
          "if($tagOnCreate){",
          "$TagArray = @()",
          "}",
          "Tag-Snapshots -SnapshotsData $SnapshotData -AmiData $AmiData -AppConsistent $AppConsistent -Tags $TagArray",
          "Close-VssOperationChannel -startTime $startTime",
          "return $AppConsistent",
          "}",
          "function VssSnapshot() {",
          "param(",
          "[boolean]$ExcludeBootVolume,",
          "[boolean]$CopyOnly,",
          "[boolean]$NoWriters,",
          "[boolean]$CreateAmi,",
          "[string]$AmiName,",
          "[string]$Description,",
          "[string]$Tags,",
          "[uint32]$waitForFreezeTimeout=180",
          ")",
          "$global:ScriptStartTime = Get-Date",
          "$AppConsistent = Invoke-VssSnapshot @PSBoundParameters",
          "if (-not $AppConsistent) {",
          "try {",
          "Write-DiagnosticInformation",
          "} catch {",
          "Write-Host \"Exception occurred while printing diagnostic information.\"",
          "Write-Host ($_.Exception | Out-String)",
          "Write-Host ($_.InvocationInfo.PositionMessage | Out-String)",
          "}",
          "}",
          "return $AppConsistent",
          "}",
          "",
          "[boolean]$ExcludeBootVolume = [System.Convert]::ToBoolean(\"{{ExcludeBootVolume}}\")",
          "",
          "[boolean]$CopyOnly = [System.Convert]::ToBoolean(\"{{CopyOnly}}\")",
          "",
          "[boolean]$NoWriters = [System.Convert]::ToBoolean(\"{{NoWriters}}\")",
          "",
          "[boolean]$CreateAmi = [System.Convert]::ToBoolean(\"{{CreateAmi}}\")",
          "",
          "$AmiName = @'",
          "{{AmiName}}",
          "'@",
          "",
          "$description = @'",
          "{{description}}",
          "'@",
          "",
          "$tags = @'",
          "{{tags}}",
          "'@",
          "",
          "[uint32]$executionTimeout = {{executionTimeout}}",
          "[uint32]$waitForFreezeTimeout = $executionTimeout - 60",
          "",
          "$AppConsistent = VssSnapshot $ExcludeBootVolume $CopyOnly $NoWriters $CreateAmi $AmiName $description $tags $executionTimeout",
          "exit [int](-not $AppConsistent)",
          ""
        ]
      },
      "name": "runPowerShellScript",
      "action": "aws:runPowerShellScript",
      "precondition": {
        "StringEquals": [
          "platformType",
          "Windows"
        ]
      }
    }
  ]
}
