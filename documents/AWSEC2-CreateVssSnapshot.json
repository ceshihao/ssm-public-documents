{
  "description": "Create application consistent snapshots of all EBS volumes attached to an instance.",
  "schemaVersion": "2.2",
  "parameters": {
    "executionTimeout": {
      "default": "800",
      "description": "(Optional) The time in seconds for this command to be completed before it is considered to have failed. Extending this timeout will cause the command to wait longer for VSS to start its freeze. Default is 800 seconds. Maximum is 172800 (48 hours). Minimum is 120.",
      "type": "String",
      "allowedPattern": "(1[2-9][0-9]{1})|([2-9][0-9]{2})|([1-9][0-9]{3,4})|(1[0-6][0-9]{4})|(17[0-1][0-9]{3})|(172[0-7][0-9]{2})|(172800)"
    },
    "ExcludeBootVolume": {
      "allowedValues": [
        "True",
        "False"
      ],
      "default": "False",
      "description": "(Optional) Select True to exclude the boot volume from the snapshot process.",
      "type": "String"
    },
    "description": {
      "default": "",
      "description": "(Optional) Specify a description to apply to created EBS snaphots.",
      "maxChars": 255,
      "type": "String",
      "allowedPattern": "^(\\n|('[^@\\n]|'$|[^'\\n]).*\\n?)*$"
    },
    "AmiName": {
      "default": "",
      "description": "(Optional) Specify a name for created AMI.  This option only has affect if the CreateAmi option is selected.",
      "maxChars": 128,
      "type": "String",
      "allowedPattern": "[a-zA-Z0-9()\\[\\] .\\/\\-\"@_]*"
    },
    "CreateAmi": {
      "allowedValues": [
        "True",
        "False"
      ],
      "default": "False",
      "description": "(Optional) Select True to create an Amazon Machine Image (AMI) backup.",
      "type": "String"
    },
    "CopyOnly": {
      "allowedValues": [
        "True",
        "False"
      ],
      "default": "False",
      "description": "(Optional) Select True to indicate a COPY ONLY backup operation.  By default a FULL backup operation is performed.  This option will prevent breaking the differential backup chain in SQL Server when performing a backup.",
      "type": "String"
    },
    "tags": {
      "default": "Key=Name,Value=",
      "description": "(Optional) Specify descriptive key-value pair tags to apply to created EBS snapshots.  Use a semicolon as a separator between tags pairs. Example: Key=Name,Value=VSS Snapshot;Key=BackupId,Value=01234",
      "type": "String",
      "allowedPattern": "^([Kk]ey=(.*),[Vv]alue=(.*);?)*$"
    },
    "NoWriters": {
      "allowedValues": [
        "True",
        "False"
      ],
      "default": "False",
      "description": "(Optional) Select True to exclude application VSS writers from the snapshot process. This option may be useful to resolve conflicts with third party VSS backup solutions.",
      "type": "String"
    }
  },
  "mainSteps": [
    {
      "inputs": {
        "workingDirectory": "",
        "timeoutSeconds": "{{executionTimeout}}",
        "runCommand": [
          "# Copyright 2017-2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.",
          "",
          "Set-StrictMode -Version Latest",
          "$ErrorActionPreference = \"Stop\"",
          "",
          "# PowerShell does not necessarily set the exit code as 1 in the event of exception.",
          "# In order to ensure Run Command reports the correct status, we must set the exit code.",
          "trap {",
          "    [Environment]::Exit(1)",
          "}",
          "",
          "# Matches NVMe EBS volumes SerialNumber. E.g. vol123456789abcd_000001",
          "# Also matches cases where there are spaces between the volume id and namespace id E.g. 'vol1234567     _000001'",
          "$EBS_VOLUME_MATCH = '(?<=vol)[0-9a-zA-Z]*(?= *_)'",
          "# Matches PV 8.2.3+ disks SerialNumber and NVMe EBS volumes AdapterSerialNumber. E.g. vol123456789abcd",
          "$EBS_VOLUME_MATCH2 = '(?<=vol)(.*)'",
          "",
          "$vssAgentPath = \"$env:ProgramFiles\\Amazon\\AwsVssComponents\\ec2-vss-agent.exe\"",
          "$vssPath = \"$env:ProgramFiles\\Amazon\\AwsVssComponents\\\"",
          "$vssStdErr = $vssPath + 'vsserr.log'",
          "$vssStdOut = $vssPath + 'vssout.log'",
          "",
          "",
          "#",
          "# ec2-vss-agent.exe runs as a separate process with it's output redirected to a log file.",
          "# After it completes read the file and output it to the console.",
          "#",
          "function PrintVssAgentOutput($process) {",
          "    # SSM Document is configured to provide a minimum of 120 seconds for us to run.",
          "    # All but 60 seconds of that is reserved for waiting for the VSS Writer Freeze.",
          "    # Hence we will wait 30 seconds here for the agent. Should be more than enough given",
          "    # the only hard coded timeout in the provider is the 10 second IO freeze",
          "    $exited = $process.WaitForExit(30 * 1000)",
          "    if (-not $exited) {",
          "        Write-Host \"VSS Requester did not exit after 30 seconds, stopping.\"",
          "        Stop-Process -InputObject $process",
          "    }",
          "    $out = Get-Content $vssStdOut",
          "    if ($out) {",
          "        $out = [string]::join(\"`n\", $out)",
          "        Write-Host $out",
          "    }",
          "",
          "    $out = Get-Content $vssStdErr",
          "    if ($out) {",
          "        $out = [string]::join(\"`n\", $out)",
          "        Write-Host $out",
          "    }",
          "}",
          "",
          "#",
          "# Provide a helpful banner for cases where the document failed because of a timeout.",
          "#",
          "function PrintTimeoutTroubleshootingBanner {",
          "    Write-Host \"EC2 Images or Snapshots created may not be application-consistent\"",
          "    Write-Host \"This is probably due to activity on a volume by an application or service slowing/preventing VSS from progressing,\"",
          "    Write-Host \" or in calls to New-EC2Snapshot/New-EC2Image taking longer than expected to complete.\"",
          "    Write-Host \"Windows VSS has a non-configurable 10 second period in which snapshots must complete to be guaranteed as Application-Consistent.\"",
          "    Write-Host \"\"",
          "    Write-Host \"Please consider trying this command again, or attempting snapshots again when the activity on the instance is reduced.\"",
          "}",
          "",
          "#",
          "# Function to begin the VSS snapshot of a EBS volume",
          "#",
          "function EbsVssFreeze {",
          "    param (",
          "        [string]$driveLetter,",
          "        [DateTime]$startTime,",
          "        [boolean]$copyOnly,",
          "        [boolean]$noWriters,",
          "        [uint32]$waitForFreezeTimeout=180",
          "    )",
          "",
          "    # We have two methods to prevent re-entrace. First we check if the VSS Agent is running.  Second",
          "    # if the named pipe server creation fails we know another instance of this script is running.",
          "    if ((get-process \"ec2-vss-agent\" -ea SilentlyContinue) -ne $Null) { ",
          "        Write-Host \"ec2-vss-agent is current running, snapshot already in progress.\" ",
          "        return $null",
          "    }",
          "",
          "    try {",
          "        $namedPipe = '01C0026F-7357-49CD-BD74-657EAF079673'",
          "        $pipeServer = new-object System.IO.Pipes.NamedPipeServerStream($namedPipe, ",
          "            [System.IO.Pipes.PipeDirection]::In,",
          "            1,",
          "            [System.IO.Pipes.PipeTransmissionMode]::Byte,",
          "            [System.IO.Pipes.PipeOptions]::Asynchronous)",
          "",
          "        $asyncResult = $pipeServer.WaitForConnectionAsync()",
          "",
          "        Write-Host 'Pipe server started after' $(New-Timespan $startTime $(Get-Date)).TotalMilliseconds 'ms'",
          "    } catch {",
          "        Write-Host \"Pipe server failed to start.  Possibly another instance of this script is running.\"",
          "        return $null",
          "    }",
          "",
          "    $params = $driveLetter",
          "",
          "    if ($copyOnly) {",
          "        Write-Host \"Copy only option selected\"",
          "        $params = \"-copy \" + $params",
          "    }",
          "",
          "    if ($noWriters) {",
          "        Write-Host \"No writers option selected\"",
          "        $params = \"-nw \" + $params",
          "    }",
          "",
          "    $process = Start-Process $vssAgentPath $params -PassThru -RedirectStandardError $vssStdErr -RedirectStandardOutput $vssStdOut",
          "    if ($process -eq $null) {",
          "        return $false",
          "    }",
          "",
          "    Write-Host 'Waiting for Freeze pipe at' $(New-Timespan $startTime $(Get-Date)).TotalMilliseconds 'ms'",
          "",
          "    #",
          "    # Wait for connection from provider indicating VSS freeze has begun.",
          "    # Some VSS writers can delay the snapshot process so we must wait enough time for all writers to complete.",
          "    #",
          "    try {",
          "        if ($asyncResult.AsyncWaitHandle.WaitOne($waitForFreezeTimeout * 1000)){",
          "            Write-Host 'Freeze pipe connected at' $(New-Timespan $startTime $(Get-Date)).TotalMilliseconds 'ms'",
          "            $pipeReader = new-object System.IO.StreamReader($pipeServer)",
          "            $string = $pipeReader.ReadLine()",
          "            $global:freezeStartTime = $(New-Timespan $startTime $(Get-Date)).TotalMilliseconds",
          "            Write-Host 'EBS snapshot Freeze message received at' $global:freezeStartTime 'ms' $string",
          "        } else {",
          "            Write-Host \"Timeout waiting for VSS Freeze. Consider increasing the executionTimeout parameter.\"",
          "            PrintVssAgentOutput $process",
          "            $process = $null",
          "        }",
          "    } catch {",
          "        Write-Host \"Freeze pipe read failed at\" $(New-Timespan $startTime $(Get-Date)).TotalMilliseconds 'ms'",
          "        Write-Error  $_",
          "    } finally {",
          "        Write-Host 'Disposing of pipes at' $(New-Timespan $startTime $(Get-Date)).TotalMilliseconds 'ms'",
          "        if ((Test-Path variable:pipeReader) -and $pipeReader) { $pipeReader.Dispose() }",
          "        $pipeServer.Dispose()",
          "        $asyncResult.AsyncWaitHandle.Close()",
          "    }",
          "",
          "    return $process",
          "}",
          "",
          "",
          "#",
          "# Function to release VSS freeze of EBS volume after snapshot is complete.",
          "#",
          "function EbsVssThaw($startTime = (Get-Date)) {",
          "",
          "    $namedPipe = '8ef5c9e5-9c84-43eb-a8f7-c60b0efd7b72'",
          "    $string = [string]::Empty",
          "",
          "    try {",
          "        $pipeClient = new-object System.IO.Pipes.NamedPipeClientStream(\".\",",
          "            $namedPipe, ",
          "            [System.IO.Pipes.PipeDirection]::In,",
          "            [System.IO.Pipes.PipeOptions]::Asynchronous)",
          "",
          "        $thawStartTime = $(New-Timespan $startTime $(Get-Date)).TotalMilliseconds",
          "        Write-Host \"Thaw pipe waiting for connection at\" $thawStartTime 'ms'",
          "        # Wait for thaw connection from provider",
          "        $pipeClient.Connect(10000)",
          "        Write-Host \"Thaw pipe connected at\" $(New-Timespan $startTime $(Get-Date)).TotalMilliseconds 'ms'",
          "        try {",
          "            $pipeReader = new-object System.IO.StreamReader($pipeClient)",
          "            $string = $pipeReader.ReadLine()",
          "        } catch {",
          "            Write-Host \"Thaw pipe read failed at\" $(New-Timespan $startTime $(Get-Date)).TotalMilliseconds 'ms'",
          "            Write-Error  $_",
          "        } finally {",
          "            $pipeReader.Dispose()",
          "        }",
          "    } catch {",
          "        Write-Host \"Thaw pipe connection failed at\" $(New-Timespan $startTime $(Get-Date)).TotalMilliseconds 'ms'",
          "        if ($thawStartTime - $global:freezeStartTime -gt 9000) {",
          "            # In cases where our Freeze and Thaw seemed to occur more than ~10 seconds apart, we should",
          "            # provide more detailed information before failing.",
          "            Write-Host \"ERROR: Timestamps indicate more than 9000ms elapsed between freeze and thaw. Kernel hold on I/O has expired.\"",
          "            PrintTimeoutTroubleshootingBanner",
          "        }",
          "        Write-Error  $_",
          "    } finally {",
          "        $pipeClient.Dispose()",
          "    }",
          "",
          "    Write-Host \"Pipe message read at\" $(New-Timespan $startTime $(Get-Date)).TotalMilliseconds 'ms'",
          "",
          "    if ($string -like 'EBS done') {",
          "        return $true",
          "    } else {",
          "        Write-Host \"Thaw pipe returned wrong value: \" $string ",
          "        if ($string -like 'EBS timeout') {",
          "            Write-Host \"ERROR: Provider gave timeout message, indicating kernel hold on I/O expired.\"",
          "            PrintTimeoutTroubleshootingBanner",
          "        }",
          "        return $false",
          "    }",
          "}",
          "",
          "",
          "#",
          "# Helper function to retrieve EC2 instance meta-data.",
          "#",
          "function Get-EC2InstanceMetadata {",
          "    param([string]$Path)",
          "",
          "    try {",
          "        ## Attempt v1 IMDS API",
          "        return Invoke-RestMethod -Method \"GET\" -URI \"http://169.254.169.254/latest/$Path\"",
          "    } catch {",
          "        ## IMDSv1 not supported, will attempt IMDSv2",
          "        $Token = [string](Invoke-RestMethod -Method \"PUT\" -URI \"http://169.254.169.254/latest/api/token\" `",
          "                    -Headers @{\"X-aws-ec2-metadata-token-ttl-seconds\"=\"1200\"})",
          "        $Headers = @{\"X-aws-ec2-metadata-token\"=$Token}",
          "        return Invoke-RestMethod -Method \"GET\" -URI \"http://169.254.169.254/latest/$Path\" -Headers $Headers",
          "    }",
          "}",
          "",
          "",
          "#",
          "# Helper function to convert SCSI target ID to xvd* EBS device name.",
          "#",
          "function Convert-SCSITargetIdToDeviceName {",
          "    param([int]$SCSITargetId)",
          "    If ($SCSITargetId -eq 0) {",
          "        return '/dev/sda1'",
          "    }",
          "    $deviceName = 'xvd'",
          "    If ($SCSITargetId -gt 25) {",
          "        $deviceName += [char](0x60 + [int]($SCSITargetId / 26))",
          "    }",
          "    $deviceName += [char](0x61 + $SCSITargetId % 26)",
          "    return $deviceName",
          "}",
          "",
          "#",
          "# Retrieve Storage Spaces drive mapping with EBS volume ID for C5 and newer instance types",
          "#",
          "function Get-AwsNvmeStorageSpacesEbsDiskMapping {",
          "    ",
          "    $disklist = @()",
          "    $physicalDisks = @()",
          "",
          "    # Exit if we are not on at least Server 2012",
          "    if (([Decimal]([environment]::OSVersion.Version).Major + [Decimal]([environment]::OSVersion.Version).Minor * .1) -lt 6.2) {",
          "        return $null",
          "    }",
          "",
          "    $physicalDisks += Get-PhysicalDisk | Where-Object {",
          "        $_.Manufacturer -match 'NVMe' -and $_.Model -match 'Amazon' -and",
          "        ( $_.SerialNumber -match $EBS_VOLUME_MATCH -or",
          "        ( (Get-Member -InputObject $_ -Name \"AdapterSerialNumber\") -and $_.AdapterSerialNumber -match $EBS_VOLUME_MATCH2))",
          "    }",
          "    ",
          "    if (!$physicalDisks -or ($physicalDisks.Count -eq 0)) {",
          "        return $null",
          "    }",
          "",
          "    $InstanceId = Get-EC2InstanceMetadata \"meta-data/instance-id\"",
          "",
          "    $BlockDeviceMapping = (Get-EC2Instance -Instance $InstanceId).Instances.BlockDeviceMappings",
          "    ",
          "    foreach ($pd in $physicalDisks) {",
          "",
          "        $pool1 = Get-StoragePool -PhysicalDisk $pd -IsPrimordial $False -ErrorAction SilentlyContinue",
          "",
          "        $volumeNumber = $pd.SerialNumber | Select-String $EBS_VOLUME_MATCH | % { $_.Matches } | % { $_.Value }",
          "        ",
          "        if ($volumeNumber -eq $null) {",
          "            $volumeNumber = $pd.AdapterSerialNumber | Select-String $EBS_VOLUME_MATCH2 | % { $_.Matches } | % { $_.Value }",
          "        }",
          "",
          "        $ebsVolumeId = \"vol-$volumeNumber\"",
          "        $matchingBlockDevice = $BlockDeviceMapping | Where-Object {($_.Ebs -ne $null) -and ($_.Ebs.VolumeId -eq $ebsVolumeId)}",
          "",
          "        foreach ($vd in Get-VirtualDisk) {",
          "            $pool2 = Get-StoragePool -VirtualDisk $vd",
          "            if (($pool1 -like $pool2) -and ($volumeNumber -ne $null)) {",
          "                $disk = ($vd | Get-Disk)",
          "                $parts = @($disk | Get-Partition)",
          "                foreach ($part in $parts) {",
          "                    $vol = ($part | Get-Volume)",
          "                    $isReadOnly = ($pool2.IsReadOnly -or $disk.IsReadOnly -or $part.IsReadOnly)",
          "                    $diskList += New-Object PSObject -Property @{",
          "                        Disk          = If ($pd -eq $null) { $null } Else { $pd.DeviceId };",
          "                        Partitions    = 0;",
          "                        DriveLetter   = If ($vol -eq $null) { $null } Else { ($vol.DriveLetter + ':') };",
          "                        EbsVolumeId   = If ($pd -eq $null) { $null } Else { $ebsVolumeId };",
          "                        Device        = If ($matchingBlockDevice -eq $null) { $pd.FriendlyName } Else { $matchingBlockDevice.DeviceName };",
          "                        VolumeName    = If ($vol -eq $null) { $null } Else { $vol.FileSystemLabel };",
          "                        IsReadOnly    = $isReadOnly;",
          "                    }",
          "                }",
          "            }",
          "        }",
          "    }",
          "",
          "    return $disklist",
          "}",
          "",
          "",
          "#",
          "# Retrieve EBS volumes associated with a Storage Spaces pool ",
          "#",
          "function Get-XenStorageSpacesEbsDiskMapping {",
          "    ",
          "    $disklist = @()",
          "    $physicalDisks = @()",
          "",
          "    # Older versions of XenVBD use the attachment point to determine serial number",
          "    $ATTACHMENT_ORDER_MATCH = '^(\\d{4})$'",
          "",
          "    # Exit if we are not on at least Server 2012",
          "    if (([Decimal]([environment]::OSVersion.Version).Major + [Decimal]([environment]::OSVersion.Version).Minor * .1) -lt 6.2) {",
          "        return $null",
          "    }",
          "",
          "    $physicalDisks += Get-PhysicalDisk | Where-Object {",
          "        ( ($_.SerialNumber -match $ATTACHMENT_ORDER_MATCH -and $_.SerialNumber -ne '0000') -or",
          "        $_.SerialNumber -match $EBS_VOLUME_MATCH2 ) -and",
          "        $_.Manufacturer -match 'AWS' -and $_.Model -match 'PVDISK'",
          "    }",
          "    ",
          "    if (!$physicalDisks -or ($physicalDisks.Count -eq 0)) {",
          "        return $null",
          "    }",
          "",
          "    $InstanceId = Get-EC2InstanceMetadata \"meta-data/instance-id\"",
          "",
          "    $BlockDeviceMapping = (Get-EC2Instance -Instance $InstanceId).Instances.BlockDeviceMappings",
          "",
          "    foreach ($pd in $physicalDisks) {",
          "        $volumeNumber = $pd.SerialNumber | Select-String $EBS_VOLUME_MATCH2 | % { $_.Matches } | % { $_.Value }",
          "        if ($volumeNumber -ne $null) {",
          "            $ebsVolumeId = \"vol-$volumeNumber\"",
          "            $device = $BlockDeviceMapping | Where-Object { $_.Ebs.VolumeId -eq $ebsVolumeId }",
          "            if ($device -ne $null) {",
          "                $BlockDeviceName = $device.DeviceName",
          "            }",
          "            else {",
          "                $ebsVolumeId = $null",
          "            }",
          "        }",
          "        elseif ($pd.SerialNumber -match $ATTACHMENT_ORDER_MATCH) {",
          "            $BlockDeviceName = Convert-SCSITargetIdToDeviceName $pd.SerialNumber",
          "            $device = $BlockDeviceMapping | Where-Object {$_.DeviceName -like (\"*\" + $BlockDeviceName)}",
          "            if ($device -ne $null) {",
          "                $ebsVolumeId = $device.Ebs.VolumeId",
          "            }",
          "            else {",
          "                $ebsVolumeId = $null",
          "            }",
          "        }",
          "        else {",
          "            $ebsVolumeId = $null",
          "        }",
          "",
          "        $pool1 = Get-StoragePool -PhysicalDisk $pd -IsPrimordial $False -ErrorAction SilentlyContinue",
          "",
          "        foreach ($vd in Get-VirtualDisk) {",
          "            $pool2 = Get-StoragePool -VirtualDisk $vd",
          "            if (($pool1 -like $pool2) -and ($ebsVolumeId -ne $null)) {",
          "                $disk = ($vd | Get-Disk)",
          "                $parts = @($disk | Get-Partition)",
          "                foreach ($part in $parts) {",
          "                    $vol = ($part | Get-Volume)",
          "                    $isReadOnly = ($pool2.IsReadOnly -or $disk.IsReadOnly -or $part.IsReadOnly)",
          "                    $diskList += New-Object PSObject -Property @{",
          "                        Disk          = If ($pd -eq $null) { $null } Else { $pd.DeviceId };",
          "                        Partitions    = 0;",
          "                        DriveLetter   = If ($vol -eq $null) { $null } Else { ($vol.DriveLetter + ':') };",
          "                        EbsVolumeId   = If ($pd -eq $null) { $null } Else { $ebsVolumeId };",
          "                        Device        = If ($pd -eq $null) { $null } Else { $device.DeviceName };",
          "                        VolumeName    = If ($vol -eq $null) { $null } Else { $vol.FileSystemLabel };",
          "                        IsReadOnly    = $isReadOnly;",
          "                    }",
          "                }",
          "            }",
          "        }",
          "    }",
          "",
          "    return $disklist",
          "}",
          "",
          "",
          "#",
          "# Helper function to collect connected EBS volumes attached to local EC2 instance.",
          "#",
          "function Get-EbsDiskMapping {",
          "",
          "    Try {",
          "        $InstanceId = Get-EC2InstanceMetadata \"meta-data/instance-id\"",
          "        $BlockDeviceMappings = (Get-EC2Instance -Instance $InstanceId).Instances.BlockDeviceMappings",
          "    } Catch {",
          "        Write-Host \"Could not access the AWS API, therefore, VolumeId is not available. ",
          "        Verify that your instance role has Describe-Instances permission.\" -ForegroundColor Yellow",
          "        throw",
          "    }",
          "",
          "    $diskList = Get-WmiObject -Class Win32_DiskDrive | ForEach-Object {",
          "        $DiskDrive = $_",
          "        $Volumes = Get-WmiObject -Query \"ASSOCIATORS OF {Win32_DiskDrive.DeviceID='$($DiskDrive.DeviceID)'} WHERE AssocClass=Win32_DiskDriveToDiskPartition\" | ForEach-Object {",
          "            $DiskPartition = $_",
          "            Get-WmiObject -Query \"ASSOCIATORS OF {Win32_DiskPartition.DeviceID='$($DiskPartition.DeviceID)'} WHERE AssocClass=Win32_LogicalDiskToPartition\"",
          "        }",
          "        $volumeNumber = $DiskDrive.SerialNumber | Select-String $EBS_VOLUME_MATCH | % { $_.Matches } | % { $_.Value }",
          "        if ($volumeNumber -eq $null) {",
          "            $volumeNumber = $DiskDrive.SerialNumber | Select-String $EBS_VOLUME_MATCH2 | % { $_.Matches } | % { $_.Value }",
          "        }",
          "        if ($volumeNumber -ne $null) {",
          "            $ebsVolumeId = \"vol-$volumeNumber\"",
          "            $BlockDevice = $BlockDeviceMappings | Where-Object { $_.Ebs.VolumeId -eq $ebsVolumeId }",
          "            if ($BlockDevice -ne $null) {",
          "                $BlockDeviceName = $BlockDevice.DeviceName",
          "            }",
          "        }",
          "        elseif ($DiskDrive.PNPDeviceID -like \"*PROD_PVDISK*\") {",
          "            $BlockDeviceName = Convert-SCSITargetIdToDeviceName($DiskDrive.SCSITargetId)",
          "            $BlockDevice = $BlockDeviceMappings | Where-Object { $_.DeviceName -like (\"*\" + $BlockDeviceName) }",
          "        }",
          "        else {",
          "            $BlockDeviceName = $null",
          "            $BlockDevice = $null",
          "        }",
          "",
          "        $foundWriteableVolume = $false",
          "        foreach ($volume in $Volumes) {",
          "            if ($volume.Access -ne 1) {",
          "                $foundWriteableVolume = $true",
          "            }",
          "        }",
          "",
          "        if ($BlockDevice -ne $null -and $BlockDevice.Ebs -ne $null) {",
          "            New-Object PSObject -Property @{",
          "                Disk          = $DiskDrive.Index;",
          "                Partitions    = $DiskDrive.Partitions;",
          "                DriveLetter   = If ($Volumes -eq $null) { $null } Else { $Volumes.DeviceID };",
          "                EbsVolumeId   = If ($BlockDevice -eq $null) { $null } Else { $BlockDevice.Ebs.VolumeId };",
          "                Device        = If ($BlockDeviceName -eq $null) { $null } Else { $BlockDeviceName };",
          "                VolumeName    = If ($Volumes -eq $null) { $null } Else { $Volumes.VolumeName };",
          "                IsReadOnly    = If (-not $foundWriteableVolume) { $true } Else { $false };",
          "            }",
          "        }",
          "    } | Sort-Object Disk",
          "",
          "    return $diskList",
          "}",
          "",
          "",
          "#",
          "# Get a mapping of the local drives to EBS volumes",
          "#",
          "function Get-EbsConnectedVolume",
          "{",
          "    $diskList = @()",
          "",
          "    # If any of the functions return $null it will be added to the disk list which we do not want!",
          "    $disks = Get-EbsDiskMapping",
          "    if ($disks) {",
          "        $diskList += $disks",
          "    }",
          "",
          "    $disks =  Get-XenStorageSpacesEbsDiskMapping",
          "    if ($disks) {",
          "        $diskList += $disks",
          "    }",
          "",
          "    $disks =  Get-AwsNvmeStorageSpacesEbsDiskMapping",
          "    if ($disks) {",
          "        $diskList += $disks",
          "    }",
          "",
          "    return $diskList",
          "}",
          "",
          "",
          "#",
          "# Tag Snapshots",
          "#",
          "function Tag-Snapshots {",
          "    param(",
          "        [System.Object[]]$SnapshotsData,",
          "        [System.Object]$AmiData,",
          "        [boolean]$AppConsistent,",
          "        [Parameter(Mandatory = $false)][amazon.EC2.Model.Tag[]]$Tags",
          "    )",
          "    $Tag = new-object amazon.EC2.Model.Tag",
          "    $Tag.Key = \"AppConsistent\"",
          "    $Tag.Value = \"$AppConsistent\"",
          "    $Tags += $Tag",
          "    foreach ($SnapshotData in $SnapshotsData) {",
          "        $Tag = new-object amazon.EC2.Model.Tag",
          "        $Tag.Key = \"Device\"",
          "        $Tag.Value = $SnapshotData.Device",
          "        $AllTags = $Tags + $Tag",
          "        New-EC2Tag -Resources $SnapshotData.SnapshotId -Tags $AllTags",
          "    }",
          "",
          "    if ($AmiData) {",
          "        New-EC2Tag -Resources $AmiData.ImageId -Tags $Tags",
          "    }",
          "}",
          "",
          "function VssSnapshot() {",
          "    param(",
          "        [boolean]$ExcludeBootVolume,",
          "        [boolean]$CopyOnly,",
          "        [boolean]$NoWriters,",
          "        [boolean]$CreateAmi,",
          "        [string]$AmiName,",
          "        [string]$Description,",
          "        [string]$Tags,",
          "        [uint32]$waitForFreezeTimeout=180",
          "    )",
          "    $startTime = Get-Date",
          "    $VolumesToFreeze = @()",
          "    $VolumesToFreezeString = @()",
          "    $DrivesToFreeze = @()",
          "",
          "    if ($ExcludeBootVolume -and $CreateAmi) {",
          "        Write-Host \"The CreateAMI option is not compatible with ExcludeBootVolume.\"",
          "        return $false",
          "    }",
          "",
          "    if (!(Test-Path $vssAgentPath)) {",
          "        Write-Host 'ec2-vss-agent.exe is not installed. To install, run command AWS-ConfigureAWSPackage with package AwsVssComponents'",
          "        return $false",
          "    }",
          "",
          "    # Remove previous agent log files",
          "    if (Test-Path $vssStdErr) {",
          "        del $vssStdErr",
          "    }",
          "    if (Test-Path $vssStdOut) {",
          "        del $vssStdOut",
          "    }",
          "",
          "    $InstanceId = Get-EC2InstanceMetadata \"meta-data/instance-id\"",
          "",
          "    $volumeList = Get-EbsConnectedVolume",
          "    $foundWriteableVolume = $false",
          "    foreach ($v in $volumeList) {",
          "        if ( ($v.DriveLetter -ne $null) -and ($v.EbsVolumeId -ne $null)) {",
          "            if (($ExcludeBootVolume -eq $false) -or ($v.Device -ne \"/dev/sda1\")) {",
          "                $VolumesToFreezeString += ($v.DriveLetter -join ' ') + \" \"",
          "                $DrivesToFreeze += $v.DriveLetter",
          "                $VolumesToFreeze += $v",
          "                if (-not $v.IsReadOnly) {",
          "                    $foundWriteableVolume = $true",
          "                }",
          "            }",
          "        }",
          "    }",
          "    if ($VolumesToFreeze.Count -eq 0) {",
          "        Write-Host \"No mounted EBS drives detected\"",
          "        return $false",
          "    }",
          "",
          "    if ($CreateAmi) {",
          "        # Check here that all attached volumes have drive letters, as currently this script has a limitation",
          "        # where it does not freeze volumes without drive letters",
          "        foreach ($v in $volumeList) {",
          "            if ($v.DriveLetter -eq $null) {",
          "                # We have an attached EBS Volume without a drive letter. Various things can cause this, but either way",
          "                # we cannot freeze this volume currently due to a limitation in our volume-mapping logic, so we cannot create an application-consistent image.",
          "                Write-Host \"Found Attached EBS Volume $($v.EbsVolumeId) without drive letter assigned.\"",
          "                Write-Host \"The CreateAMI option requires all attached EBS volumes have drive letters assigned on the Windows instance.\"",
          "                Write-Host \"Please check that all volumes have drive letters assigned, and try again.\"",
          "                return $false",
          "            }",
          "        }",
          "    }",
          "",
          "    # AMI name is required and must be unique.  If it is not specified create a AMI name from instance ID, OS version,",
          "    # and time stamp.",
          "    if ($createAmi -And (-Not $amiName)) {",
          "        $amiName = \"EC2_VSS_Backup_$($InstanceId)_$((Get-WMIObject win32_operatingsystem).Caption)_$(get-date -format yyyy-MM-ddTHH-mm-ss)\"",
          "        $amiName = $amiName.replace(' ','')",
          "    }",
          "",
          "    if ($foundWriteableVolume) {",
          "        $DrivesToFreezeString = ($DrivesToFreeze | sort -Unique) -join ' '",
          "",
          "        Write-Host \"Beginning snapshot for drives\" $DrivesToFreezeString",
          "",
          "        $process = EbsVssFreeze $DrivesToFreezeString $startTime $CopyOnly $NoWriters $waitForFreezeTimeout",
          "        if ($process -eq $null) {",
          "            return $false",
          "        }",
          "",
          "        Write-Host 'Freeze complete at' $(New-Timespan $startTime $(Get-Date)).TotalMilliseconds 'ms'",
          "    }",
          "    else {",
          "        Write-Host 'All volumes found are read-only or on a read-only disk or storage pool. Snapshotting without freezing IO.'",
          "    }",
          "",
          "    $SnapshotData = @()",
          "    $AmiData = @()",
          "    $amiId = ''",
          "    if ($createAmi) {",
          "         try {",
          "            $amiId = New-EC2Image -InstanceId $InstanceId -Name $amiName -Description $Description -NoReboot $true",
          "            $timeOut = 10  # Kernel will only hold I/O for 10 seconds, so if we cannot describe AMI after 10 seconds, time out",
          "            while ($timeOut) {",
          "                try {",
          "                    $AmiData = Get-EC2Image -ImageId $amiId",
          "                } catch {",
          "                    # Occasionally Get-EC2Image can fail if called too soon after New-EC2Image. Retry in that case",
          "                    if($timeOut -gt 1 -and $_.Exception.InnerException.ErrorCode -eq \"InvalidAMIID.NotFound\") {",
          "                        $AmiData = $False",
          "                    } else {",
          "                        throw $_",
          "                    }",
          "                }",
          "                if ($AmiData -And ($AmiData.State -Like \"pending\" -Or $AmiData.State -Like \"available\")) {",
          "                    if ($AmiData.PSobject.Properties.name -match \"BlockDeviceMapping\") {",
          "                        $SnapshotData = @()",
          "                        foreach ($b in $AmiData.BlockDeviceMapping) {",
          "                            if ($b.PSobject.Properties.name -match \"Ebs\" -And",
          "                                $b.Ebs -And $b.Ebs.PSobject.Properties.name -match \"SnapshotId\" -And",
          "                                $b.PSobject.Properties.name -match \"DeviceName\" -And",
          "                                $b.Ebs.SnapshotId) {",
          "                                $SnapshotData += New-Object PSObject -Property @{",
          "                                    Device      = $b.DeviceName",
          "                                    SnapshotId  = $b.Ebs.SnapshotId",
          "                                }",
          "                            }",
          "                        }",
          "                        if ($SnapshotData.Count -eq $VolumesToFreeze.Count) {",
          "                            break;",
          "                        }",
          "                    }",
          "                }",
          "                Start-Sleep -Seconds 1",
          "                $timeOut--",
          "            }",
          "            if ($timeOut -le 0) {",
          "                Write-Host \"ERROR: Took longer than 10 seconds to describe snapshots in AMI, kernel hold on I/O has expired.\"",
          "                PrintTimeoutTroubleshootingBanner",
          "                return $false",
          "            } ",
          "         } catch {",
          "            Write-Host \"Exception caught creating AMI:\"",
          "            Write-Host $_",
          "            return $false",
          "        }",
          "    } else {",
          "        foreach ($v in $VolumesToFreeze) {",
          "            if ($SnapshotData | Where-Object {$_.EbsVolumeId -eq $v.EbsVolumeId}) {",
          "                continue",
          "            }",
          "            try {",
          "                $Snapshot = New-EC2Snapshot -VolumeId $v.EbsVolumeId -Description $Description",
          "            } catch {",
          "                Write-Host \"Exception caught creating EBS snapshot:\"",
          "                Write-Host $_",
          "                return $false",
          "            }",
          "            $SnapshotData += New-Object PSObject -Property @{",
          "                EbsVolumeId = $v.EbsVolumeId",
          "                Device      = $v.Device",
          "                SnapshotId  = $Snapshot.SnapshotId",
          "            }",
          "        }",
          "    }",
          "",
          "    if ($foundWriteableVolume) {",
          "        Write-Host 'Starting Thaw at' $(New-Timespan $startTime $(Get-Date)).TotalMilliseconds 'ms'",
          "        $AppConsistent = EbsVssThaw $startTime",
          "        if ($AppConsistent) {",
          "            Write-Host 'Thaw successful at' $(New-Timespan $startTime $(Get-Date)).TotalMilliseconds 'ms'",
          "        } else {",
          "            Write-Host 'Thaw unsuccesful, snapshots may not be app consistent, see event log for more details' $(New-Timespan $startTime $(Get-Date)).TotalMilliseconds 'ms'",
          "        }",
          "        if ($amiId) {",
          "            Write-Host \"AMI: $amiId\"",
          "        }",
          "        foreach ($Snapshot in $SnapshotData) {",
          "            Write-Host \"Snapshot: $($Snapshot.SnapshotId) DeviceName: $($Snapshot.Device)\"",
          "        }",
          "",
          "        PrintVssAgentOutput $process",
          "    }",
          "    else {",
          "        $AppConsistent = $true",
          "        Write-Host 'All volumes found are read-only or on a read-only disk or storage pool. Skipping VssThaw.'",
          "    }",
          "",
          "    [amazon.EC2.Model.Tag[]]$TagArray = @()",
          "    $Tags -split \";\" | ForEach-Object {",
          "        if (-not [string]::IsNullOrEmpty($_)) {",
          "            $TagParts = ($_ -split \",\", 2)",
          "            if ($TagParts.Count -ne 2) {",
          "                Write-Host \"Error parsing tags, tags need to be in the format Name=tag-key,Values=tag-value\"",
          "                return $false",
          "            }",
          "            $TagName, $TagValue = $TagParts",
          "            $Tag = new-object amazon.EC2.Model.Tag",
          "            $Tag.Key = ($TagName -split \"=\", 2)[1].Trim()",
          "            $Tag.Value = ($TagValue -split \"=\", 2)[1].Trim()",
          "            $TagArray += $Tag",
          "        }",
          "    }",
          "",
          "    Tag-Snapshots -SnapshotsData $SnapshotData -AmiData $AmiData -AppConsistent $AppConsistent -Tags $TagArray",
          "    return $AppConsistent",
          "}",
          "",
          "",
          "[boolean]$ExcludeBootVolume = [System.Convert]::ToBoolean(\"{{ExcludeBootVolume}}\")",
          "",
          "[boolean]$CopyOnly = [System.Convert]::ToBoolean(\"{{CopyOnly}}\")",
          "",
          "[boolean]$NoWriters = [System.Convert]::ToBoolean(\"{{NoWriters}}\")",
          "",
          "[boolean]$CreateAmi = [System.Convert]::ToBoolean(\"{{CreateAmi}}\")",
          "",
          "$AmiName = @'",
          "{{AmiName}}",
          "'@",
          "",
          "$description = @'",
          "{{description}}",
          "'@",
          "",
          "$tags = @'",
          "{{tags}}",
          "'@",
          "",
          "[uint32]$executionTimeout = {{executionTimeout}}",
          "[uint32]$waitForFreezeTimeout = $executionTimeout - 60",
          "",
          "$AppConsistent = VssSnapshot $ExcludeBootVolume $CopyOnly $NoWriters $CreateAmi $AmiName $description $tags $executionTimeout",
          "exit [int](-not $AppConsistent)",
          ""
        ]
      },
      "name": "runPowerShellScript",
      "action": "aws:runPowerShellScript",
      "precondition": {
        "StringEquals": [
          "platformType",
          "Windows"
        ]
      }
    }
  ]
}
