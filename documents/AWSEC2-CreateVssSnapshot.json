{
  "description": "Create an application consistent snapshot of all EBS volumes attached to an instance.",
  "schemaVersion": "2.2",
  "parameters": {
    "ExcludeBootVolume": {
      "allowedValues": [
        "True",
        "False"
      ],
      "default": "False",
      "description": "(Optional) Select True to exclude the boot volume from the snapshot process.",
      "type": "String"
    },
    "description": {
      "default": "",
      "description": "(Optional) Specify a description to apply to created EBS snaphots.",
      "maxChars": 255,
      "type": "String",
      "allowedPattern": "^(\\n|('[^@\\n]|'$|[^'\\n]).*\\n?)*$"
    },
    "AmiName": {
      "default": "",
      "description": "(Optional) Specify a name for created AMI.  This option only has affect if the CreateAmi option is selected.",
      "maxChars": 128,
      "type": "String",
      "allowedPattern": "[a-zA-Z0-9()\\[\\] .\\/\\-\"@_]*"
    },
    "CreateAmi": {
      "allowedValues": [
        "True",
        "False"
      ],
      "default": "False",
      "description": "(Optional) Select True to create an Amazon Machine Image (AMI) backup.",
      "type": "String"
    },
    "CopyOnly": {
      "allowedValues": [
        "True",
        "False"
      ],
      "default": "False",
      "description": "(Optional) Select True to indicate a COPY ONLY backup operation.  By default a FULL backup operation is performed.  This option will prevent breaking the differential backup chain in SQL Server when performing a backup.",
      "type": "String"
    },
    "tags": {
      "default": "Key=Name,Value=",
      "description": "(Optional) Specify descriptive key-value pair tags to apply to created EBS snapshots.  Use a semicolon as a separator between tags pairs. Example: Key=Name,Value=VSS Snapshot;Key=BackupId,Value=01234",
      "type": "String",
      "allowedPattern": "^([Kk]ey=(.*),[Vv]alue=(.*);?)*$"
    },
    "NoWriters": {
      "allowedValues": [
        "True",
        "False"
      ],
      "default": "False",
      "description": "(Optional) Select True to exclude application VSS writers from the snapshot process. This option may be useful to resolve conflicts with third party VSS backup solutions.",
      "type": "String"
    }
  },
  "mainSteps": [
    {
      "inputs": {
        "workingDirectory": "",
        "timeoutSeconds": "400",
        "runCommand": [
          "# Copyright 2017-2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.",
          "",
          "Set-StrictMode -Version Latest",
          "",
          "# Matches NVMe EBS volumes SerialNumber. E.g. vol123456789abcd_000001",
          "$EBS_VOLUME_MATCH = '(?<=vol).*(?=_)'",
          "# Matches PV 8.2.3+ disks SerialNumber and NVMe EBS volumes AdapterSerialNumber. E.g. vol123456789abcd",
          "$EBS_VOLUME_MATCH2 = '(?<=vol)(.*)'",
          "",
          "$vssAgentPath = \"$env:ProgramFiles\\Amazon\\AwsVssComponents\\ec2-vss-agent.exe\"",
          "$vssPath = \"$env:ProgramFiles\\Amazon\\AwsVssComponents\\\"",
          "$vssStdErr = $vssPath + 'vsserr.log'",
          "$vssStdOut = $vssPath + 'vssout.log'",
          "",
          "",
          "#",
          "# ec2-vss-agent.exe runs as a separate process with it's output redirected to a log file.",
          "# After it completes read the file and output it to the console.",
          "#",
          "function PrintVssAgentOutput($process) {",
          "",
          "    $process.WaitForExit()",
          "    $out = Get-Content $vssStdOut",
          "    if ($out) {",
          "        $out = [string]::join(\"`n\", $out)",
          "        Write-Host $out",
          "    }",
          "",
          "    $out = Get-Content $vssStdErr",
          "    if ($out) {",
          "        $out = [string]::join(\"`n\", $out)",
          "        Write-Host $out",
          "    }",
          "}",
          "",
          "#",
          "# Function to begin the VSS snapshot of a EBS volume",
          "#",
          "function EbsVssFreeze {",
          "    param (",
          "        [string]$driveLetter,",
          "        [DateTime]$startTime,",
          "        [boolean]$copyOnly,",
          "        [boolean]$noWriters",
          "    )",
          "",
          "    # We have two methods to prevent re-entrace. First we check if the VSS Agent is running.  Second",
          "    # if the named pipe server creation fails we know another instance of this script is running.",
          "    if ((get-process \"ec2-vss-agent\" -ea SilentlyContinue) -ne $Null) { ",
          "        Write-Host \"ec2-vss-agent is current running, snapshot already in progress.\" ",
          "        return $null",
          "    }",
          "",
          "    try {",
          "        $namedPipe = '01C0026F-7357-49CD-BD74-657EAF079673'",
          "        $pipeServer = new-object System.IO.Pipes.NamedPipeServerStream($namedPipe, ",
          "            [System.IO.Pipes.PipeDirection]::In,",
          "            1,",
          "            [System.IO.Pipes.PipeTransmissionMode]::Byte,",
          "            [System.IO.Pipes.PipeOptions]::Asynchronous)",
          "",
          "        $asyncResult = $pipeServer.WaitForConnectionAsync()",
          "",
          "        Write-Host 'Pipe server started after' $(New-Timespan $startTime $(Get-Date)).TotalMilliseconds 'ms'",
          "    } catch {",
          "        Write-Host \"Pipe server failed to start.  Possibly another instance of this script is running.\"",
          "        return $null",
          "    }",
          "",
          "    $params = $driveLetter",
          "",
          "    if ($copyOnly) {",
          "        Write-Host \"Copy only option selected\"",
          "        $params = \"-copy \" + $params",
          "    }",
          "",
          "    if ($noWriters) {",
          "        Write-Host \"No writers option selected\"",
          "        $params = \"-nw \" + $params",
          "    }",
          "",
          "    $process = Start-Process $vssAgentPath $params -PassThru -RedirectStandardError $vssStdErr -RedirectStandardOutput $vssStdOut",
          "    if ($process -eq $null) {",
          "        return $false",
          "    }",
          "",
          "    Write-Host 'Waiting for Freeze pipe at' $(New-Timespan $startTime $(Get-Date)).TotalMilliseconds 'ms'",
          "",
          "    #",
          "    # Wait up to 10 minutes for connection from provider indicating VSS freeze has begun.",
          "    # Some VSS writers can delay the snapshot process so we must wait enough time for all writers to complete.",
          "    #",
          "    try {",
          "        if ($asyncResult.AsyncWaitHandle.WaitOne(10 * 60 * 1000)){",
          "            Write-Host 'Freeze pipe connected at' $(New-Timespan $startTime $(Get-Date)).TotalMilliseconds 'ms'",
          "            $pipeReader = new-object System.IO.StreamReader($pipeServer)",
          "            $string = $pipeReader.ReadLine()",
          "            Write-Host 'EBS snapshot Freeze message received at' $(New-Timespan $startTime $(Get-Date)).TotalMilliseconds 'ms' $string",
          "        } else {",
          "            Write-Host \"Timeout waiting for VSS Freeze\"",
          "            PrintVssAgentOutput $process",
          "            $process = $null",
          "        }",
          "    } catch {",
          "        Write-Host \"Freeze pipe read failed at\" $(New-Timespan $startTime $(Get-Date)).TotalMilliseconds 'ms'",
          "        Write-Error  $_",
          "    } finally {",
          "        Write-Host 'Disposing of pipes at' $(New-Timespan $startTime $(Get-Date)).TotalMilliseconds 'ms'",
          "        if ((Test-Path variable:pipeReader) -and $pipeReader) { $pipeReader.Dispose() }",
          "        $pipeServer.Dispose()",
          "        $asyncResult.AsyncWaitHandle.Close()",
          "    }",
          "",
          "    return $process",
          "}",
          "",
          "",
          "#",
          "# Function to release VSS freeze of EBS volume after snapshot is complete.",
          "#",
          "function EbsVssThaw($startTime = (Get-Date)) {",
          "",
          "    $namedPipe = '8ef5c9e5-9c84-43eb-a8f7-c60b0efd7b72'",
          "    $string = [string]::Empty",
          "",
          "    try {",
          "        $pipeClient = new-object System.IO.Pipes.NamedPipeClientStream(\".\",",
          "            $namedPipe, ",
          "            [System.IO.Pipes.PipeDirection]::In,",
          "            [System.IO.Pipes.PipeOptions]::Asynchronous)",
          "",
          "        Write-Host \"Thaw pipe waiting for connection at\" $(New-Timespan $startTime $(Get-Date)).TotalMilliseconds 'ms'",
          "        # Wait for thaw connection from provider",
          "        $pipeClient.Connect(10000)",
          "        Write-Host \"Thaw pipe connected at\" $(New-Timespan $startTime $(Get-Date)).TotalMilliseconds 'ms'",
          "        try {",
          "            $pipeReader = new-object System.IO.StreamReader($pipeClient)",
          "            $string = $pipeReader.ReadLine()",
          "        } catch {",
          "            Write-Host \"Thaw pipe read failed at\" $(New-Timespan $startTime $(Get-Date)).TotalMilliseconds 'ms'",
          "            Write-Error  $_",
          "        } finally {",
          "            $pipeReader.Dispose()",
          "        }",
          "    } catch {",
          "        Write-Host \"Thaw pipe connection failed at\" $(New-Timespan $startTime $(Get-Date)).TotalMilliseconds 'ms'",
          "        Write-Error  $_",
          "    } finally {",
          "        $pipeClient.Dispose()",
          "    }",
          "",
          "    Write-Host \"Pipe message read at\" $(New-Timespan $startTime $(Get-Date)).TotalMilliseconds 'ms'",
          "",
          "    if ($string -like 'EBS done') {",
          "        return $true",
          "    } else {",
          "        Write-Host \"Thaw pipe returned wrong value: \" $string ",
          "        return $false",
          "    }",
          "}",
          "",
          "",
          "#",
          "# Helper function to retrieve EC2 instance meta-data.",
          "#",
          "function Get-EC2InstanceMetadata {",
          "    param([string]$Path)",
          "",
          "    try {",
          "        ## Attempt v1 IMDS API",
          "        return Invoke-RestMethod -Method \"GET\" -URI \"http://169.254.169.254/latest/$Path\"",
          "    } catch {",
          "        ## IMDSv1 not supported, will attempt IMDSv2",
          "        $Token = [string](Invoke-RestMethod -Method \"PUT\" -URI \"http://169.254.169.254/latest/api/token\" `",
          "                    -Headers @{\"X-aws-ec2-metadata-token-ttl-seconds\"=\"1200\"})",
          "        $Headers = @{\"X-aws-ec2-metadata-token\"=$Token}",
          "        return Invoke-RestMethod -Method \"GET\" -URI \"http://169.254.169.254/latest/$Path\" -Headers $Headers",
          "    }",
          "}",
          "",
          "",
          "#",
          "# Helper function to convert SCSI target ID to xvd* EBS device name.",
          "#",
          "function Convert-SCSITargetIdToDeviceName {",
          "    param([int]$SCSITargetId)",
          "    If ($SCSITargetId -eq 0) {",
          "        return '/dev/sda1'",
          "    }",
          "    $deviceName = 'xvd'",
          "    If ($SCSITargetId -gt 25) {",
          "        $deviceName += [char](0x60 + [int]($SCSITargetId / 26))",
          "    }",
          "    $deviceName += [char](0x61 + $SCSITargetId % 26)",
          "    return $deviceName",
          "}",
          "",
          "",
          "#",
          "# Retrieve Storage Spaces drive mapping with EBS volume ID for C5 and newer instance types",
          "#",
          "function Get-AwsNvmeStorageSpacesEbsDiskMapping {",
          "    ",
          "    $disklist = @()",
          "    $physicalDisks = @()",
          "",
          "    # Exit if we are not on at least Server 2012",
          "    if (([Decimal]([environment]::OSVersion.Version).Major + [Decimal]([environment]::OSVersion.Version).Minor * .1) -lt 6.2) {",
          "        return $null",
          "    }",
          "",
          "    $physicalDisks += Get-PhysicalDisk | Where-Object {",
          "        $_.Manufacturer -match 'NVMe' -and $_.Model -match 'Amazon' -and",
          "        ( $_.SerialNumber -match $EBS_VOLUME_MATCH -or",
          "        ( (Get-Member -InputObject $_ -Name \"AdapterSerialNumber\") -and $_.AdapterSerialNumber -match $EBS_VOLUME_MATCH2))",
          "    }",
          "    ",
          "    if (!$physicalDisks -or ($physicalDisks.Count -eq 0)) {",
          "        return $null",
          "    }",
          "",
          "    $InstanceId = Get-EC2InstanceMetadata \"meta-data/instance-id\"",
          "",
          "    $BlockDeviceMapping = (Get-EC2Instance -Instance $InstanceId).Instances.BlockDeviceMappings",
          "    ",
          "    foreach ($pd in $physicalDisks) {",
          "",
          "        $pool1 = Get-StoragePool -PhysicalDisk $pd -IsPrimordial $False -ErrorAction SilentlyContinue",
          "",
          "        $volumeNumber = $pd.SerialNumber | Select-String $EBS_VOLUME_MATCH | % { $_.Matches } | % { $_.Value }",
          "        ",
          "        if ($volumeNumber -eq $null) {",
          "            $volumeNumber = $pd.AdapterSerialNumber | Select-String $EBS_VOLUME_MATCH2 | % { $_.Matches } | % { $_.Value }",
          "        }",
          "",
          "        $ebsVolumeId = \"vol-$volumeNumber\"",
          "        $matchingBlockDevice = $BlockDeviceMapping | Where-Object {($_.Ebs -ne $null) -and ($_.Ebs.VolumeId -eq $ebsVolumeId)}",
          "",
          "        foreach ($vd in Get-VirtualDisk) {",
          "            $pool2 = Get-StoragePool -VirtualDisk $vd",
          "            if (($pool1 -like $pool2) -and ($volumeNumber -ne $null)) {",
          "                $disk = ($vd | Get-Disk)",
          "                $parts = @($disk | Get-Partition)",
          "                foreach ($part in $parts) {",
          "                    $vol = ($part | Get-Volume)",
          "                    $isReadOnly = ($pool2.IsReadOnly -or $disk.IsReadOnly -or $part.IsReadOnly)",
          "                    $diskList += New-Object PSObject -Property @{",
          "                        Disk          = If ($pd -eq $null) { $null } Else { $pd.DeviceId };",
          "                        Partitions    = 0;",
          "                        DriveLetter   = If ($vol -eq $null) { $null } Else { ($vol.DriveLetter + ':') };",
          "                        EbsVolumeId   = If ($pd -eq $null) { $null } Else { $ebsVolumeId };",
          "                        Device        = If ($matchingBlockDevice -eq $null) { $pd.FriendlyName } Else { $matchingBlockDevice.DeviceName };",
          "                        VolumeName    = If ($vol -eq $null) { $null } Else { $vol.FileSystemLabel };",
          "                        IsReadOnly    = $isReadOnly;",
          "                    }",
          "                }",
          "            }",
          "        }",
          "    }",
          "",
          "    return $disklist",
          "}",
          "",
          "",
          "#",
          "# Retrieve EBS volumes associated with a Storage Spaces pool ",
          "#",
          "function Get-XenStorageSpacesEbsDiskMapping {",
          "    ",
          "    $disklist = @()",
          "    $physicalDisks = @()",
          "",
          "    # Older versions of XenVBD use the attachment point to determine serial number",
          "    $ATTACHMENT_ORDER_MATCH = '^(\\d{4})$'",
          "",
          "    # Exit if we are not on at least Server 2012",
          "    if (([Decimal]([environment]::OSVersion.Version).Major + [Decimal]([environment]::OSVersion.Version).Minor * .1) -lt 6.2) {",
          "        return $null",
          "    }",
          "",
          "    $physicalDisks += Get-PhysicalDisk | Where-Object {",
          "        ( ($_.SerialNumber -match $ATTACHMENT_ORDER_MATCH -and $_.SerialNumber -ne '0000') -or",
          "        $_.SerialNumber -match $EBS_VOLUME_MATCH2 ) -and",
          "        $_.Manufacturer -match 'AWS' -and $_.Model -match 'PVDISK'",
          "    }",
          "    ",
          "    if (!$physicalDisks -or ($physicalDisks.Count -eq 0)) {",
          "        return $null",
          "    }",
          "",
          "    $InstanceId = Get-EC2InstanceMetadata \"meta-data/instance-id\"",
          "",
          "    $BlockDeviceMapping = (Get-EC2Instance -Instance $InstanceId).Instances.BlockDeviceMappings",
          "",
          "    foreach ($pd in $physicalDisks) {",
          "        $volumeNumber = $pd.SerialNumber | Select-String $EBS_VOLUME_MATCH2 | % { $_.Matches } | % { $_.Value }",
          "        if ($volumeNumber -ne $null) {",
          "            $ebsVolumeId = \"vol-$volumeNumber\"",
          "            $device = $BlockDeviceMapping | Where-Object { $_.Ebs.VolumeId -eq $ebsVolumeId }",
          "            if ($device -ne $null) {",
          "                $BlockDeviceName = $device.DeviceName",
          "            }",
          "            else {",
          "                $ebsVolumeId = $null",
          "            }",
          "        }",
          "        elseif ($pd.SerialNumber -match $ATTACHMENT_ORDER_MATCH) {",
          "            $BlockDeviceName = Convert-SCSITargetIdToDeviceName $pd.SerialNumber",
          "            $device = $BlockDeviceMapping | Where-Object {$_.DeviceName -like (\"*\" + $BlockDeviceName)}",
          "            if ($device -ne $null) {",
          "                $ebsVolumeId = $device.Ebs.VolumeId",
          "            }",
          "            else {",
          "                $ebsVolumeId = $null",
          "            }",
          "        }",
          "        else {",
          "            $ebsVolumeId = $null",
          "        }",
          "",
          "        $pool1 = Get-StoragePool -PhysicalDisk $pd -IsPrimordial $False -ErrorAction SilentlyContinue",
          "",
          "        foreach ($vd in Get-VirtualDisk) {",
          "            $pool2 = Get-StoragePool -VirtualDisk $vd",
          "            if (($pool1 -like $pool2) -and ($ebsVolumeId -ne $null)) {",
          "                $disk = ($vd | Get-Disk)",
          "                $parts = @($disk | Get-Partition)",
          "                foreach ($part in $parts) {",
          "                    $vol = ($part | Get-Volume)",
          "                    $isReadOnly = ($pool2.IsReadOnly -or $disk.IsReadOnly -or $part.IsReadOnly)",
          "                    $diskList += New-Object PSObject -Property @{",
          "                        Disk          = If ($pd -eq $null) { $null } Else { $pd.DeviceId };",
          "                        Partitions    = 0;",
          "                        DriveLetter   = If ($vol -eq $null) { $null } Else { ($vol.DriveLetter + ':') };",
          "                        EbsVolumeId   = If ($pd -eq $null) { $null } Else { $ebsVolumeId };",
          "                        Device        = If ($pd -eq $null) { $null } Else { $device.DeviceName };",
          "                        VolumeName    = If ($vol -eq $null) { $null } Else { $vol.FileSystemLabel };",
          "                        IsReadOnly    = $isReadOnly;",
          "                    }",
          "                }",
          "            }",
          "        }",
          "    }",
          "",
          "    return $disklist",
          "}",
          "",
          "",
          "#",
          "# Helper function to collect connected EBS volumes attached to local EC2 instance.",
          "#",
          "function Get-EbsDiskMapping {",
          "",
          "    Try {",
          "        $InstanceId = Get-EC2InstanceMetadata \"meta-data/instance-id\"",
          "        $BlockDeviceMappings = (Get-EC2Instance -Instance $InstanceId).Instances.BlockDeviceMappings",
          "    } Catch {",
          "        Write-Host \"Could not access the AWS API, therefore, VolumeId is not available. ",
          "        Verify that your instance role has Describe-Instances permission.\" -ForegroundColor Yellow",
          "        throw",
          "    }",
          "",
          "    $diskList = Get-WmiObject -Class Win32_DiskDrive | ForEach-Object {",
          "        $DiskDrive = $_",
          "        $Volumes = Get-WmiObject -Query \"ASSOCIATORS OF {Win32_DiskDrive.DeviceID='$($DiskDrive.DeviceID)'} WHERE AssocClass=Win32_DiskDriveToDiskPartition\" | ForEach-Object {",
          "            $DiskPartition = $_",
          "            Get-WmiObject -Query \"ASSOCIATORS OF {Win32_DiskPartition.DeviceID='$($DiskPartition.DeviceID)'} WHERE AssocClass=Win32_LogicalDiskToPartition\"",
          "        }",
          "        $volumeNumber = $DiskDrive.SerialNumber | Select-String $EBS_VOLUME_MATCH | % { $_.Matches } | % { $_.Value }",
          "        if ($volumeNumber -eq $null) {",
          "            $volumeNumber = $DiskDrive.SerialNumber | Select-String $EBS_VOLUME_MATCH2 | % { $_.Matches } | % { $_.Value }",
          "        }",
          "        if ($volumeNumber -ne $null) {",
          "            $ebsVolumeId = \"vol-$volumeNumber\"",
          "            $BlockDevice = $BlockDeviceMappings | Where-Object { $_.Ebs.VolumeId -eq $ebsVolumeId }",
          "            if ($BlockDevice -ne $null) {",
          "                $BlockDeviceName = $BlockDevice.DeviceName",
          "            }",
          "        }",
          "        elseif ($DiskDrive.PNPDeviceID -like \"*PROD_PVDISK*\") {",
          "            $BlockDeviceName = Convert-SCSITargetIdToDeviceName($DiskDrive.SCSITargetId)",
          "            $BlockDevice = $BlockDeviceMappings | Where-Object { $_.DeviceName -like (\"*\" + $BlockDeviceName) }",
          "        }",
          "        else {",
          "            $BlockDeviceName = $null",
          "            $BlockDevice = $null",
          "        }",
          "",
          "        $foundWriteableVolume = $false",
          "        foreach ($volume in $Volumes) {",
          "            if ($volume.Access -ne 1) {",
          "                $foundWriteableVolume = $true",
          "            }",
          "        }",
          "",
          "        if ($BlockDevice -ne $null -and $BlockDevice.Ebs -ne $null) {",
          "            New-Object PSObject -Property @{",
          "                Disk          = $DiskDrive.Index;",
          "                Partitions    = $DiskDrive.Partitions;",
          "                DriveLetter   = If ($Volumes -eq $null) { $null } Else { $Volumes.DeviceID };",
          "                EbsVolumeId   = If ($BlockDevice -eq $null) { $null } Else { $BlockDevice.Ebs.VolumeId };",
          "                Device        = If ($BlockDeviceName -eq $null) { $null } Else { $BlockDeviceName };",
          "                VolumeName    = If ($Volumes -eq $null) { $null } Else { $Volumes.VolumeName };",
          "                IsReadOnly    = If (-not $foundWriteableVolume) { $true } Else { $false };",
          "            }",
          "        }",
          "    } | Sort-Object Disk",
          "",
          "    return $diskList",
          "}",
          "",
          "",
          "#",
          "# Get a mapping of the local drives to EBS volumes",
          "#",
          "function Get-EbsConnectedVolume",
          "{",
          "    $diskList = @()",
          "",
          "    # If any of the functions return $null it will be added to the disk list which we do not want!",
          "    $disks = Get-EbsDiskMapping",
          "    if ($disks) {",
          "        $diskList += $disks",
          "    }",
          "",
          "    $disks =  Get-XenStorageSpacesEbsDiskMapping",
          "    if ($disks) {",
          "        $diskList += $disks",
          "    }",
          "",
          "    $disks =  Get-AwsNvmeStorageSpacesEbsDiskMapping",
          "    if ($disks) {",
          "        $diskList += $disks",
          "    }",
          "",
          "    return $diskList",
          "}",
          "",
          "",
          "#",
          "# Tag Snapshots",
          "#",
          "function Tag-Snapshots {",
          "    param(",
          "        [System.Object[]]$SnapshotsData,",
          "        [System.Object]$AmiData,",
          "        [boolean]$AppConsistent,",
          "        [Parameter(Mandatory = $false)][amazon.EC2.Model.Tag[]]$Tags",
          "    )",
          "    $Tag = new-object amazon.EC2.Model.Tag",
          "    $Tag.Key = \"AppConsistent\"",
          "    $Tag.Value = \"$AppConsistent\"",
          "    $Tags += $Tag",
          "    foreach ($SnapshotData in $SnapshotsData) {",
          "        $Tag = new-object amazon.EC2.Model.Tag",
          "        $Tag.Key = \"Device\"",
          "        $Tag.Value = $SnapshotData.Device",
          "        $AllTags = $Tags + $Tag",
          "        New-EC2Tag -Resources $SnapshotData.SnapshotId -Tags $AllTags",
          "    }",
          "",
          "    if ($AmiData) {",
          "        New-EC2Tag -Resources $AmiData.ImageId -Tags $Tags",
          "    }",
          "}",
          "",
          "function VssSnapshot() {",
          "    param(",
          "        [boolean]$ExcludeBootVolume,",
          "        [boolean]$CopyOnly,",
          "        [boolean]$NoWriters,",
          "        [boolean]$CreateAmi,",
          "        [string]$AmiName,",
          "        [string]$Description,",
          "        [string]$Tags",
          "    )",
          "    $startTime = Get-Date",
          "    $VolumesToFreeze = @()",
          "    $VolumesToFreezeString = @()",
          "    $DrivesToFreeze = @()",
          "",
          "    if ($ExcludeBootVolume -and $CreateAmi) {",
          "        Write-Host \"The CreateAMI option is not compatible with ExcludeBootVolume.\"",
          "        return $false",
          "    }",
          "",
          "    if (!(Test-Path $vssAgentPath)) {",
          "        Write-Host 'ec2-vss-agent.exe is not installed. To install, run command AWS-ConfigureAWSPackage with package AwsVssComponents'",
          "        return $false",
          "    }",
          "",
          "    # Remove previous agent log files",
          "    if (Test-Path $vssStdErr) {",
          "        del $vssStdErr",
          "    }",
          "    if (Test-Path $vssStdOut) {",
          "        del $vssStdOut",
          "    }",
          "",
          "    $InstanceId = Get-EC2InstanceMetadata \"meta-data/instance-id\"",
          "",
          "    $volumeList = Get-EbsConnectedVolume",
          "    $foundWriteableVolume = $false",
          "    foreach ($v in $volumeList) {",
          "        if ( ($v.DriveLetter -ne $null) -and ($v.EbsVolumeId -ne $null)) {",
          "            if (($ExcludeBootVolume -eq $false) -or ($v.Device -ne \"/dev/sda1\")) {",
          "                $VolumesToFreezeString += ($v.DriveLetter -join ' ') + \" \"",
          "                $DrivesToFreeze += $v.DriveLetter",
          "                $VolumesToFreeze += $v",
          "                if (-not $v.IsReadOnly) {",
          "                    $foundWriteableVolume = $true",
          "                }",
          "            }",
          "        }",
          "    }",
          "    if ($VolumesToFreeze.Count -eq 0) {",
          "        Write-Host \"No mounted EBS drives detected\"",
          "        return $false",
          "    }",
          "",
          "    # AMI name is required and must be unique.  If it is not specified create a AMI name from instance ID, OS version,",
          "    # and time stamp.",
          "    if ($createAmi -And (-Not $amiName)) {",
          "        $amiName = \"EC2_VSS_Backup_$($InstanceId)_$((Get-WMIObject win32_operatingsystem).Caption)_$(get-date -format yyyy-MM-ddTHH-mm-ss)\"",
          "        $amiName = $amiName.replace(' ','')",
          "    }",
          "",
          "    if ($foundWriteableVolume) {",
          "        $DrivesToFreezeString = ($DrivesToFreeze | sort -Unique) -join ' '",
          "",
          "        Write-Host \"Beginning snapshot for drives\" $DrivesToFreezeString",
          "",
          "        $process = EbsVssFreeze $DrivesToFreezeString $startTime $CopyOnly $NoWriters",
          "        if ($process -eq $null) {",
          "            return $false",
          "        }",
          "",
          "        Write-Host 'Freeze complete at' $(New-Timespan $startTime $(Get-Date)).TotalMilliseconds 'ms'",
          "    }",
          "    else {",
          "        Write-Host 'All volumes found are read-only or on a read-only disk or storage pool. Snapshotting without freezing IO.'",
          "    }",
          "",
          "    $SnapshotData = @()",
          "    $AmiData = @()",
          "    $amiId = ''",
          "    if ($createAmi) {",
          "         try {",
          "            $amiId = New-EC2Image -InstanceId $InstanceId -Name $amiName -Description $Description -NoReboot $true",
          "            $timeOut = 10",
          "            while ($timeOut) {",
          "                $AmiData = Get-EC2Image -ImageId $amiId",
          "                if ($AmiData -And ($AmiData.State -Like \"pending\" -Or $AmiData.State -Like \"available\")) {",
          "                    if ($AmiData.PSobject.Properties.name -match \"BlockDeviceMapping\") {",
          "                        $SnapshotData = @()",
          "                        foreach ($b in $AmiData.BlockDeviceMapping) {",
          "                            if ($b.PSobject.Properties.name -match \"Ebs\" -And",
          "                                $b.Ebs -And $b.Ebs.PSobject.Properties.name -match \"SnapshotId\" -And",
          "                                $b.PSobject.Properties.name -match \"DeviceName\" -And",
          "                                $b.Ebs.SnapshotId) {",
          "                                $SnapshotData += New-Object PSObject -Property @{",
          "                                    Device      = $b.DeviceName",
          "                                    SnapshotId  = $b.Ebs.SnapshotId",
          "                                }",
          "                            }",
          "                        }",
          "                        if ($SnapshotData.Count -eq $VolumesToFreeze.Count) {",
          "                            break;",
          "                        }",
          "                    }",
          "                }",
          "                Start-Sleep -Seconds 1",
          "                $timeOut--",
          "            }",
          "            if ($timeOut -le 0) {",
          "                Write-Host \"Error waiting for AMI\"",
          "                return $false",
          "            } ",
          "         } catch {",
          "            Write-Host \"Exception caught creating AMI:\"",
          "            Write-Host $_",
          "            return $false",
          "        }",
          "    } else {",
          "        foreach ($v in $VolumesToFreeze) {",
          "            if ($SnapshotData | Where-Object {$_.EbsVolumeId -eq $v.EbsVolumeId}) {",
          "                continue",
          "            }",
          "            try {",
          "                $Snapshot = New-EC2Snapshot -VolumeId $v.EbsVolumeId -Description $Description",
          "            } catch {",
          "                Write-Host \"Exception caught creating EBS snapshot:\"",
          "                Write-Host $_",
          "                return $false",
          "            }",
          "            $SnapshotData += New-Object PSObject -Property @{",
          "                EbsVolumeId = $v.EbsVolumeId",
          "                Device      = $v.Device",
          "                SnapshotId  = $Snapshot.SnapshotId",
          "            }",
          "        }",
          "    }",
          "",
          "    if ($foundWriteableVolume) {",
          "        Write-Host 'Starting Thaw at' $(New-Timespan $startTime $(Get-Date)).TotalMilliseconds 'ms'",
          "        $AppConsistent = EbsVssThaw $startTime",
          "        if ($AppConsistent) {",
          "            Write-Host 'Thaw successful at' $(New-Timespan $startTime $(Get-Date)).TotalMilliseconds 'ms'",
          "        } else {",
          "            Write-Host 'Thaw unsuccesful, snapshots may not be app consistent, see event log for more details' $(New-Timespan $startTime $(Get-Date)).TotalMilliseconds 'ms'",
          "        }",
          "        if ($amiId) {",
          "            Write-Host \"AMI: $amiId\"",
          "        }",
          "        foreach ($Snapshot in $SnapshotData) {",
          "            Write-Host \"Snapshot: $($Snapshot.SnapshotId) DeviceName: $($Snapshot.Device)\"",
          "        }",
          "",
          "        PrintVssAgentOutput $process",
          "    }",
          "    else {",
          "        $AppConsistent = $true",
          "        Write-Host 'All volumes found are read-only or on a read-only disk or storage pool. Skipping VssThaw.'",
          "    }",
          "",
          "    [amazon.EC2.Model.Tag[]]$TagArray = @()",
          "    $Tags -split \";\" | ForEach-Object {",
          "        if (-not [string]::IsNullOrEmpty($_)) {",
          "            $TagParts = ($_ -split \",\", 2)",
          "            if ($TagParts.Count -ne 2) {",
          "                Write-Host \"Error parsing tags, tags need to be in the format Name=tag-key,Values=tag-value\"",
          "                return $false",
          "            }",
          "            $TagName, $TagValue = $TagParts",
          "            $Tag = new-object amazon.EC2.Model.Tag",
          "            $Tag.Key = ($TagName -split \"=\", 2)[1].Trim()",
          "            $Tag.Value = ($TagValue -split \"=\", 2)[1].Trim()",
          "            $TagArray += $Tag",
          "        }",
          "    }",
          "",
          "    Tag-Snapshots -SnapshotsData $SnapshotData -AmiData $AmiData -AppConsistent $AppConsistent -Tags $TagArray",
          "    return $AppConsistent",
          "}",
          "",
          "",
          "[boolean]$ExcludeBootVolume = [System.Convert]::ToBoolean(\"{{ExcludeBootVolume}}\")",
          "",
          "[boolean]$CopyOnly = [System.Convert]::ToBoolean(\"{{CopyOnly}}\")",
          "",
          "[boolean]$NoWriters = [System.Convert]::ToBoolean(\"{{NoWriters}}\")",
          "",
          "[boolean]$CreateAmi = [System.Convert]::ToBoolean(\"{{CreateAmi}}\")",
          "",
          "$AmiName = @'",
          "{{AmiName}}",
          "'@",
          "",
          "$description = @'",
          "{{description}}",
          "'@",
          "",
          "$tags = @'",
          "{{tags}}",
          "'@",
          "",
          "$AppConsistent = VssSnapshot $ExcludeBootVolume $CopyOnly $NoWriters $CreateAmi $AmiName $description $tags",
          "exit [int](-not $AppConsistent)",
          ""
        ]
      },
      "name": "runPowerShellScript",
      "action": "aws:runPowerShellScript",
      "precondition": {
        "StringEquals": [
          "platformType",
          "Windows"
        ]
      }
    }
  ]
}
