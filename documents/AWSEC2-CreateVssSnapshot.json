{
  "schemaVersion": "2.2",
  "description": "Create an application consistent snapshot of all EBS volumes attached to an instance.",
  "parameters": {
    "executionTimeout": {
      "default": "800",
      "description": "(Optional) The time in seconds for this command to be completed before it is considered to have failed. Extending this timeout will cause the command to wait longer for VSS to start its freeze. Default is 800 seconds. Maximum is 172800 (48 hours). Minimum is 120.",
      "type": "String",
      "allowedPattern": "(1[2-9][0-9]{1})|([2-9][0-9]{2})|([1-9][0-9]{3,4})|(1[0-6][0-9]{4})|(17[0-1][0-9]{3})|(172[0-7][0-9]{2})|(172800)"
    },
    "ExcludeBootVolume": {
      "allowedValues": [
        "True",
        "False"
      ],
      "default": "False",
      "description": "(Optional) Select True to exclude the boot volume from the snapshot process.",
      "type": "String"
    },
    "description": {
      "default": "",
      "description": "(Optional) Specify a description to apply to created EBS snaphots.",
      "maxChars": 255,
      "type": "String",
      "allowedPattern": "^(\\n|('[^@\\n]|'$|[^'\\n]).*\\n?)*$"
    },
    "AmiName": {
      "default": "",
      "description": "(Optional) Specify a name for created AMI.  This option only has affect if the CreateAmi option is selected.",
      "maxChars": 128,
      "type": "String",
      "allowedPattern": "[a-zA-Z0-9()\\[\\] .\\/\\-\"@_]*"
    },
    "CreateAmi": {
      "allowedValues": [
        "True",
        "False"
      ],
      "default": "False",
      "description": "(Optional) Select True to create an Amazon Machine Image (AMI) backup.",
      "type": "String"
    },
    "CopyOnly": {
      "allowedValues": [
        "True",
        "False"
      ],
      "default": "False",
      "description": "(Optional) Select True to indicate a COPY ONLY backup operation.  By default a FULL backup operation is performed.  This option will prevent breaking the differential backup chain in SQL Server when performing a backup.",
      "type": "String"
    },
    "tags": {
      "default": "Key=Name,Value=",
      "description": "(Optional) Specify descriptive key-value pair tags to apply to created EBS snapshots.  Use a semicolon as a separator between tags pairs. Example: Key=Name,Value=VSS Snapshot;Key=BackupId,Value=01234",
      "type": "String",
      "allowedPattern": "^([Kk]ey=(.*),[Vv]alue=(.*);?)*$"
    },
    "NoWriters": {
      "allowedValues": [
        "True",
        "False"
      ],
      "default": "False",
      "description": "(Optional) Select True to exclude application VSS writers from the snapshot process. This option may be useful to resolve conflicts with third party VSS backup solutions.",
      "type": "String"
    }
  },
  "mainSteps": [
    {
      "inputs": {
        "workingDirectory": "",
        "timeoutSeconds": "{{executionTimeout}}",
        "runCommand": [
          "# Copyright 2017-2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.",
          "",
          "Set-StrictMode -Version Latest",
          "$ErrorActionPreference = \"Stop\"",
          "",
          "# PowerShell does not necessarily set the exit code as 1 in the event of exception.",
          "# In order to ensure Run Command reports the correct status, we must set the exit code.",
          "trap {",
          "    Write-Log \"Encountered unexpected error. Please see error details below\"",
          "    $_.Exception | Format-List -Force",
          "    $_.InvocationInfo | Format-List -Force",
          "    [Environment]::Exit(1)",
          "}",
          "",
          "# Matches NVMe EBS volumes SerialNumber. E.g. vol123456789abcd_000001",
          "# Also matches cases where there are spaces between the volume id and namespace id E.g. 'vol1234567     _000001'",
          "$EBS_VOLUME_MATCH = '(?<=vol)[0-9a-zA-Z]*(?= *_)'",
          "# Matches PV 8.2.3+ disks SerialNumber and NVMe EBS volumes AdapterSerialNumber. E.g. vol123456789abcd",
          "$EBS_VOLUME_MATCH2 = '(?<=vol)(.*)'",
          "",
          "$vssAgentPath = \"$env:ProgramFiles\\Amazon\\AwsVssComponents\\ec2-vss-agent.exe\"",
          "$vssPath = \"$env:ProgramFiles\\Amazon\\AwsVssComponents\\\"",
          "$vssStdErr = $vssPath + 'vsserr.log'",
          "$vssStdOut = $vssPath + 'vssout.log'",
          "",
          "",
          "#",
          "# Set the script rule to buffer the I/O or not",
          "#",
          "[hashtable[]]$script:logBuffer = @()",
          "[bool]$script:BufferOutput = $false",
          "function Set-OutputMode {",
          "    param(",
          "        [Parameter(Mandatory,",
          "        ParameterSetName=\"Buffered\")]",
          "        [switch]$Buffered,",
          "        [Parameter(Mandatory,",
          "        ParameterSetName=\"UnBuffered\")]",
          "        [switch]$UnBuffered",
          "    )",
          "",
          "    if ($Buffered) {",
          "        $script:BufferOutput = $true",
          "    }",
          "    else {",
          "        $script:BufferOutput = $false",
          "        Write-BufferedLog",
          "    }",
          "}",
          "",
          "#",
          "# Log function that follows the I/O buffer rule",
          "#",
          "function Write-Log {",
          "    [CmdletBinding()]",
          "    param(",
          "        [Parameter(Position = 0,",
          "        Mandatory,",
          "        ValueFromPipeline)]",
          "        $message",
          "    )",
          "    if ($script:BufferOutput) {",
          "        $script:logBuffer += @{Message=$message;Stream=\"Success\"}",
          "    }",
          "    else {",
          "        Write-Host $message",
          "    }",
          "}",
          "",
          "#",
          "# Log Error function that follows the I/O buffer rule",
          "#",
          "function Write-ErrorLog {",
          "    [CmdletBinding()]",
          "    param(",
          "        [Parameter(Position = 0,",
          "        Mandatory,",
          "        ValueFromPipeline)]",
          "        $message",
          "    )",
          "    if ($script:BufferOutput) {",
          "        $script:logBuffer += @{Message=$message;Stream=\"Error\"}",
          "    }",
          "    else {",
          "        Write-Error $message",
          "    }",
          "}",
          "",
          "#",
          "# Prints any logs that may be in the logBuffer",
          "#",
          "function Write-BufferedLog {",
          "    foreach ($line in $script:logBuffer) {",
          "        switch ($line.Stream)",
          "        {",
          "            \"Success\"   { Write-Host  $line.Message; break; }",
          "            \"Error\"     { Write-Error $line.Message; break; }",
          "            Default     { Write-Host  $line.Message; break; }",
          "        }",
          "    }",
          "    $script:logBuffer = @()",
          "}",
          "",
          "#",
          "# ec2-vss-agent.exe runs as a separate process with it's output redirected to a log file.",
          "# After it completes read the file and output it to the console.",
          "#",
          "function PrintVssAgentOutput($process) {",
          "    # SSM Document is configured to provide a minimum of 120 seconds for us to run.",
          "    # All but 60 seconds of that is reserved for waiting for the VSS Writer Freeze.",
          "    # Hence we will wait 30 seconds here for the agent. Should be more than enough given",
          "    # the only hard coded timeout in the provider is the 10 second IO freeze",
          "    $exited = $process.WaitForExit(30 * 1000)",
          "    if (-not $exited) {",
          "        Write-Log \"VSS Requester did not exit after 30 seconds, stopping.\"",
          "        Stop-Process -InputObject $process",
          "    }",
          "    $out = Get-Content $vssStdOut",
          "    if ($out) {",
          "        $out = [string]::join(\"`n\", $out)",
          "        Write-Log $out",
          "    }",
          "",
          "    $out = Get-Content $vssStdErr",
          "    if ($out) {",
          "        $out = [string]::join(\"`n\", $out)",
          "        Write-Log $out",
          "    }",
          "}",
          "",
          "#",
          "# Provide a helpful banner for cases where the document failed because of a timeout.",
          "#",
          "function PrintTimeoutTroubleshootingBanner {",
          "    Write-Log \"EC2 Images or Snapshots created may not be application-consistent\"",
          "    Write-Log \"This is probably due to activity on a volume by an application or service slowing/preventing VSS from progressing,\"",
          "    Write-Log \" or in calls to New-EC2Snapshot/New-EC2Image taking longer than expected to complete.\"",
          "    Write-Log \"Windows VSS has a non-configurable 10 second period in which snapshots must complete to be guaranteed as Application-Consistent.\"",
          "    Write-Log \"\"",
          "    Write-Log \"Please consider trying this command again, or attempting snapshots again when the activity on the instance is reduced.\"",
          "}",
          "",
          "#",
          "# Function to begin the VSS snapshot of a EBS volume",
          "#",
          "function EbsVssFreeze {",
          "    param (",
          "        [string]$driveLetter,",
          "        [DateTime]$startTime,",
          "        [boolean]$copyOnly,",
          "        [boolean]$noWriters,",
          "        [uint32]$waitForFreezeTimeout=180",
          "    )",
          "",
          "    # We have two methods to prevent re-entrace. First we check if the VSS Agent is running.  Second",
          "    # if the named pipe server creation fails we know another instance of this script is running.",
          "    if ((get-process \"ec2-vss-agent\" -ea SilentlyContinue) -ne $Null) { ",
          "        Write-Log \"ec2-vss-agent is current running, snapshot already in progress.\" ",
          "        return $null",
          "    }",
          "",
          "    try {",
          "        $namedPipe = '01C0026F-7357-49CD-BD74-657EAF079673'",
          "        $pipeServer = new-object System.IO.Pipes.NamedPipeServerStream($namedPipe, ",
          "            [System.IO.Pipes.PipeDirection]::In,",
          "            1,",
          "            [System.IO.Pipes.PipeTransmissionMode]::Byte,",
          "            [System.IO.Pipes.PipeOptions]::Asynchronous)",
          "",
          "        $asyncResult = $pipeServer.WaitForConnectionAsync()",
          "",
          "        Write-Log \"Pipe server started after $($(New-Timespan $startTime $(Get-Date)).TotalMilliseconds) ms\"",
          "    } catch {",
          "        Write-Log \"Pipe server failed to start.  Possibly another instance of this script is running.\"",
          "        return $null",
          "    }",
          "",
          "    $params = $driveLetter",
          "",
          "    if ($copyOnly) {",
          "        Write-Log \"Copy only option selected\"",
          "        $params = \"-copy \" + $params",
          "    }",
          "",
          "    if ($noWriters) {",
          "        Write-Log \"No writers option selected\"",
          "        $params = \"-nw \" + $params",
          "    }",
          "",
          "    Write-Log \"Starting to Freeze pipe at $($(New-Timespan $startTime $(Get-Date)).TotalMilliseconds) ms\"",
          "",
          "    #",
          "    # We are entering an I/O Critical Region between the Freeze and the Thaw, and want to Buffer the I/O",
          "    #",
          "    Set-OutputMode -Buffered",
          "",
          "    $process = Start-Process $vssAgentPath $params -PassThru -RedirectStandardError $vssStdErr -RedirectStandardOutput $vssStdOut",
          "    if ($process -eq $null) {",
          "        return $false",
          "    }",
          "",
          "    Write-Log \"Waiting for Freeze pipe at $($(New-Timespan $startTime $(Get-Date)).TotalMilliseconds) ms\"",
          "",
          "    #",
          "    # Wait for connection from provider indicating VSS freeze has begun.",
          "    # Some VSS writers can delay the snapshot process so we must wait enough time for all writers to complete.",
          "    #",
          "    try {",
          "        if ($asyncResult.AsyncWaitHandle.WaitOne($waitForFreezeTimeout * 1000)){",
          "            Write-Log \"Freeze pipe connected at $($(New-Timespan $startTime $(Get-Date)).TotalMilliseconds) ms\"",
          "            $pipeReader = new-object System.IO.StreamReader($pipeServer)",
          "            $string = $pipeReader.ReadLine()",
          "            $global:freezeStartTime = $(New-Timespan $startTime $(Get-Date)).TotalMilliseconds",
          "            Write-Log \"EBS snapshot Freeze message received at $($global:freezeStartTime) ms $string\"",
          "        } else {",
          "            Write-Log \"Timeout waiting for VSS Freeze. Consider increasing the executionTimeout parameter.\"",
          "            PrintVssAgentOutput $process",
          "            $process = $null",
          "        }",
          "    } catch {",
          "        Write-Log \"Freeze pipe read failed at $($(New-Timespan $startTime $(Get-Date)).TotalMilliseconds) ms\"",
          "        Write-ErrorLog $_",
          "    } finally {",
          "        Write-Log \"Disposing of pipes at $($(New-Timespan $startTime $(Get-Date)).TotalMilliseconds) ms\"",
          "        if ((Test-Path variable:pipeReader) -and $pipeReader) { $pipeReader.Dispose() }",
          "        $pipeServer.Dispose()",
          "        $asyncResult.AsyncWaitHandle.Close()",
          "    }",
          "",
          "    return $process",
          "}",
          "",
          "",
          "#",
          "# Function to release VSS freeze of EBS volume after snapshot is complete.",
          "#",
          "function EbsVssThaw($startTime = (Get-Date)) {",
          "",
          "    $namedPipe = '8ef5c9e5-9c84-43eb-a8f7-c60b0efd7b72'",
          "    $string = [string]::Empty",
          "",
          "    try {",
          "        $pipeClient = new-object System.IO.Pipes.NamedPipeClientStream(\".\",",
          "            $namedPipe, ",
          "            [System.IO.Pipes.PipeDirection]::In,",
          "            [System.IO.Pipes.PipeOptions]::Asynchronous)",
          "",
          "        $thawStartTime = $(New-Timespan $startTime $(Get-Date)).TotalMilliseconds",
          "        Write-Log \"Thaw pipe waiting for connection at $thawStartTime ms\"",
          "        # Wait for thaw connection from provider",
          "        $pipeClient.Connect(10000)",
          "        Write-Log \"Thaw pipe connected at $($(New-Timespan $startTime $(Get-Date)).TotalMilliseconds) ms\"",
          "        try {",
          "            $pipeReader = new-object System.IO.StreamReader($pipeClient)",
          "            $string = $pipeReader.ReadLine()",
          "        } catch {",
          "            Write-Log \"Thaw pipe read failed at $($(New-Timespan $startTime $(Get-Date)).TotalMilliseconds) ms\"",
          "            Write-ErrorLog  $_",
          "        } finally {",
          "            $pipeReader.Dispose()",
          "        }",
          "    } catch {",
          "        Write-Log \"Thaw pipe connection failed at $($(New-Timespan $startTime $(Get-Date)).TotalMilliseconds) ms\"",
          "        if ($thawStartTime - $global:freezeStartTime -gt 9000) {",
          "            # In cases where our Freeze and Thaw seemed to occur more than ~10 seconds apart, we should",
          "            # provide more detailed information before failing.",
          "            Write-Log \"ERROR: Timestamps indicate more than 9000ms elapsed between freeze and thaw. Kernel hold on I/O has expired.\"",
          "            PrintTimeoutTroubleshootingBanner",
          "        }",
          "        Write-ErrorLog  $_",
          "    } finally {",
          "        $pipeClient.Dispose()",
          "    }",
          "",
          "    Set-OutputMode -UnBuffered",
          "",
          "    Write-Log \"Pipe message read at $($(New-Timespan $startTime $(Get-Date)).TotalMilliseconds) ms\"",
          "",
          "    if ($string -like 'EBS done') {",
          "        return $true",
          "    } else {",
          "        Write-Log \"Thaw pipe returned wrong value: $string\" ",
          "        if ($string -like 'EBS timeout') {",
          "            Write-Log \"ERROR: Provider gave timeout message, indicating kernel hold on I/O expired.\"",
          "            PrintTimeoutTroubleshootingBanner",
          "        }",
          "        return $false",
          "    }",
          "}",
          "",
          "",
          "#",
          "# Helper function to retrieve EC2 instance meta-data.",
          "#",
          "function Get-EC2InstanceMetadata {",
          "    param([string]$Path)",
          "",
          "    try {",
          "        ## Attempt v1 IMDS API",
          "        return Invoke-RestMethod -Method \"GET\" -URI \"http://169.254.169.254/latest/$Path\"",
          "    } catch {",
          "        ## IMDSv1 not supported, will attempt IMDSv2",
          "        $Token = [string](Invoke-RestMethod -Method \"PUT\" -URI \"http://169.254.169.254/latest/api/token\" `",
          "                    -Headers @{\"X-aws-ec2-metadata-token-ttl-seconds\"=\"1200\"})",
          "        $Headers = @{\"X-aws-ec2-metadata-token\"=$Token}",
          "        return Invoke-RestMethod -Method \"GET\" -URI \"http://169.254.169.254/latest/$Path\" -Headers $Headers",
          "    }",
          "}",
          "",
          "",
          "#",
          "# Helper function to convert SCSI target ID to xvd* EBS device name.",
          "#",
          "function Convert-SCSITargetIdToDeviceName {",
          "    param([int]$SCSITargetId)",
          "    If ($SCSITargetId -eq 0) {",
          "        return '/dev/sda1'",
          "    }",
          "    $deviceName = 'xvd'",
          "    If ($SCSITargetId -gt 25) {",
          "        $deviceName += [char](0x60 + [int]($SCSITargetId / 26))",
          "    }",
          "    $deviceName += [char](0x61 + $SCSITargetId % 26)",
          "    return $deviceName",
          "}",
          "",
          "#",
          "# Retrieve Mapping for Dynamic Disks specifically. The Windows Storage Management APIs",
          "# cannot detect Dynamic Disks, and Dynamic Disks are deprecated, so we use the WMI instead.",
          "#",
          "function Get-DynamicDiskPartitionsOnEBSVolumes {",
          "",
          "    Try {",
          "        $InstanceId = Get-EC2InstanceMetadata \"meta-data/instance-id\"",
          "        $BlockDeviceMappings = (Get-EC2Instance -Instance $InstanceId).Instances.BlockDeviceMappings",
          "    } Catch {",
          "        Write-Log \"Could not access the AWS API, therefore, VolumeId is not available.\"",
          "        Write-Log \"Verify that your instance role has Describe-Instances permission.\"",
          "        throw",
          "    }",
          "",
          "    $diskList = Get-WmiObject -Class Win32_DiskDrive | ForEach-Object {",
          "        $DiskDrive = $_",
          "        ",
          "        # We are looking for partition types that indicate the presence of Dynamic Disks, which are:",
          "        #   MBR Partition Type 0x42, which the WMI returns as \"Logical Disk Manager\"",
          "        #   GPT Partition Type af9b60a0-1431-4f62-bc68-3311714a69ad, which the WMI returns as \"GPT: Logical Disk Manager Data\"",
          "        $LogicalDiskManagerPartitions = Get-WmiObject -Query \"ASSOCIATORS OF {Win32_DiskDrive.DeviceID='$($DiskDrive.DeviceID)'} WHERE AssocClass=Win32_DiskDriveToDiskPartition\" | Where {$_.Type -match \"Logical Disk Manager\"}",
          "        if (-not $LogicalDiskManagerPartitions) {",
          "            # Because this function processes the same physical disk objects as Get-EbsDiskMapping, we do not",
          "            # need to return \"empty\" disk objects here without volume information. We only need to consider",
          "            # the cases where there are Logical Disk Manager partitions, which Get-EbsDiskMapping cannot query.",
          "            return",
          "        }",
          "        ",
          "        # Note: https://docs.microsoft.com/en-us/previous-versions/windows/desktop/vdswmi/win32-mountpoint",
          "        #       > There may not be any way to search from Win32_MountPoint to get to the associated Win32_DiskDrive; such a combination is only possible with a drive letter mount.",
          "        #       We can only locate volumes with drive letters when using the WMI, so Dynamic Disks must have drive letters on their volumes.",
          "        $Volumes = $LogicalDiskManagerPartitions | ForEach-Object {",
          "            $DiskPartition = $_",
          "            Get-WmiObject -Query \"ASSOCIATORS OF {Win32_DiskPartition.DeviceID='$($DiskPartition.DeviceID)'} WHERE AssocClass=Win32_LogicalDiskToPartition\"",
          "        }",
          "        ",
          "        # Convert the serial number of these Win32_DiskDrives (Which represent physical volumes) to an EBS volume ID.",
          "        $volumeNumber = $DiskDrive.SerialNumber | Select-String $EBS_VOLUME_MATCH | % { $_.Matches } | % { $_.Value }",
          "        if ($volumeNumber -eq $null) {",
          "            $volumeNumber = $DiskDrive.SerialNumber | Select-String $EBS_VOLUME_MATCH2 | % { $_.Matches } | % { $_.Value }",
          "        }",
          "        if ($volumeNumber -ne $null) {",
          "            $ebsVolumeId = \"vol-$volumeNumber\"",
          "            $BlockDevice = $BlockDeviceMappings | Where-Object { $_.Ebs.VolumeId -eq $ebsVolumeId }",
          "            if ($BlockDevice -ne $null) {",
          "                $BlockDeviceName = $BlockDevice.DeviceName",
          "            }",
          "        }",
          "        elseif ($DiskDrive.PNPDeviceID -like \"*PROD_PVDISK*\") {",
          "            $BlockDeviceName = Convert-SCSITargetIdToDeviceName($DiskDrive.SCSITargetId)",
          "            $BlockDevice = $BlockDeviceMappings | Where-Object { $_.DeviceName -like (\"*\" + $BlockDeviceName) }",
          "        }",
          "        else {",
          "            $BlockDeviceName = $null",
          "            $BlockDevice = $null",
          "        }",
          "",
          "        $foundWriteableVolume = $false",
          "        foreach ($volume in $Volumes) {",
          "            if ($volume.Access -ne 1) {",
          "                $foundWriteableVolume = $true",
          "            }",
          "        }",
          "",
          "        # Create a disk object with EBS and Windows volume information",
          "        if ($BlockDevice -ne $null -and $BlockDevice.Ebs -ne $null) {",
          "            New-Object PSObject -Property @{",
          "                Disk          = $DiskDrive.Index;",
          "                Partitions    = $DiskDrive.Partitions;",
          "                AccessPath   = If ($Volumes -eq $null) { $null } Else { $Volumes.DeviceID };",
          "                EbsVolumeId   = If ($BlockDevice -eq $null) { $null } Else { $BlockDevice.Ebs.VolumeId };",
          "                Device        = If ($BlockDeviceName -eq $null) { $null } Else { $BlockDeviceName };",
          "                VolumeName    = If ($Volumes -eq $null) { $null } Else { $Volumes.VolumeName };",
          "                IsReadOnly    = If (-not $foundWriteableVolume) { $true } Else { $false };",
          "            }",
          "        }",
          "    } | Sort-Object Disk",
          "",
          "    return $diskList",
          "}",
          "",
          "#",
          "# Retrieve Storage Spaces drive mapping with EBS volume ID for C5 and newer instance types",
          "#",
          "function Get-AwsNvmeStorageSpacesEbsDiskMapping {",
          "    ",
          "    $disklist = @()",
          "    $physicalDisks = @()",
          "",
          "    $physicalDisks += Get-PhysicalDisk | Where-Object {",
          "        (($_.Manufacturer -match 'NVMe') -and ($_.Model -match 'Amazon') -and",
          "        ($_.SerialNumber -match $EBS_VOLUME_MATCH)) -or",
          "        ((Get-Member -InputObject $_ -Name \"AdapterSerialNumber\") -and ($_.AdapterSerialNumber -match $EBS_VOLUME_MATCH2))",
          "    }",
          "    ",
          "    if (!$physicalDisks -or ($physicalDisks.Count -eq 0)) {",
          "        return $null",
          "    }",
          "",
          "    $InstanceId = Get-EC2InstanceMetadata \"meta-data/instance-id\"",
          "",
          "    $BlockDeviceMapping = (Get-EC2Instance -Instance $InstanceId).Instances.BlockDeviceMappings",
          "    ",
          "    foreach ($pd in $physicalDisks) {",
          "",
          "        $pool1 = Get-StoragePool -PhysicalDisk $pd -IsPrimordial $False -ErrorAction SilentlyContinue",
          "",
          "        $volumeNumber = $pd.SerialNumber | Select-String $EBS_VOLUME_MATCH | % { $_.Matches } | % { $_.Value }",
          "        ",
          "        if ($volumeNumber -eq $null) {",
          "            $volumeNumber = $pd.AdapterSerialNumber | Select-String $EBS_VOLUME_MATCH2 | % { $_.Matches } | % { $_.Value }",
          "        }",
          "",
          "        $ebsVolumeId = \"vol-$volumeNumber\"",
          "        $matchingBlockDevice = $BlockDeviceMapping | Where-Object {($_.Ebs -ne $null) -and ($_.Ebs.VolumeId -eq $ebsVolumeId)}",
          "",
          "        foreach ($vd in Get-VirtualDisk) {",
          "            $pool2 = Get-StoragePool -VirtualDisk $vd",
          "            if (($pool1 -like $pool2) -and ($volumeNumber -ne $null)) {",
          "                $disk = ($vd | Get-Disk)",
          "                # Ignore partitions that don't map to Volumes/File Systems we'd want to freeze",
          "                $parts = @($disk | Get-Partition | Where-Object -Property Type -NE Reserved | Where-Object -Property Type -NE \"XINT13 Extended\")",
          "                foreach ($part in $parts) {",
          "                    $vol = ($part | Get-Volume)",
          "                    $isReadOnly = ($pool2.IsReadOnly -or $disk.IsReadOnly -or $part.IsReadOnly)",
          "                    $diskList += New-Object PSObject -Property @{",
          "                        Disk          = If ($pd -eq $null) { $null } Else { $pd.DeviceId };",
          "                        Partitions    = 0;",
          "                        # Get Drive Letter from Volume if possible, otherwise grab Access path from partition (Could be mount path or DOS Device path)",
          "                        AccessPath    = If ($vol -ne $null -and $vol.DriveLetter) { ($vol.DriveLetter + ':') } elseif ($part.AccessPaths) { $part.AccessPaths[0] } else { $null };",
          "                        EbsVolumeId   = If ($pd -eq $null) { $null } Else { $ebsVolumeId };",
          "                        Device        = If ($matchingBlockDevice -eq $null) { $pd.FriendlyName } Else { $matchingBlockDevice.DeviceName };",
          "                        VolumeName    = If ($vol -eq $null) { $null } Else { $vol.FileSystemLabel };",
          "                        IsReadOnly    = $isReadOnly;",
          "                    }",
          "                }",
          "            }",
          "        }",
          "    }",
          "",
          "    return $disklist",
          "}",
          "",
          "",
          "#",
          "# Retrieve EBS volumes associated with a Storage Spaces pool ",
          "#",
          "function Get-XenStorageSpacesEbsDiskMapping {",
          "    ",
          "    $disklist = @()",
          "    $physicalDisks = @()",
          "",
          "    # Older versions of XenVBD use the attachment point to determine serial number",
          "    $ATTACHMENT_ORDER_MATCH = '^(\\d{4})$'",
          "",
          "    $physicalDisks += Get-PhysicalDisk | Where-Object {",
          "        ($_.SerialNumber -match $ATTACHMENT_ORDER_MATCH -and $_.SerialNumber -ne '0000') -or",
          "        (($_.SerialNumber -match $EBS_VOLUME_MATCH2) -and",
          "         ($_.Manufacturer -match 'AWS' -and $_.Model -match 'PVDISK'))",
          "    }",
          "    ",
          "    if (!$physicalDisks -or ($physicalDisks.Count -eq 0)) {",
          "        return $null",
          "    }",
          "",
          "    $InstanceId = Get-EC2InstanceMetadata \"meta-data/instance-id\"",
          "",
          "    $BlockDeviceMapping = (Get-EC2Instance -Instance $InstanceId).Instances.BlockDeviceMappings",
          "",
          "    foreach ($pd in $physicalDisks) {",
          "        $volumeNumber = $pd.SerialNumber | Select-String $EBS_VOLUME_MATCH2 | % { $_.Matches } | % { $_.Value }",
          "        if ($volumeNumber -ne $null) {",
          "            $ebsVolumeId = \"vol-$volumeNumber\"",
          "            $device = $BlockDeviceMapping | Where-Object { $_.Ebs.VolumeId -eq $ebsVolumeId }",
          "            if ($device -ne $null) {",
          "                $BlockDeviceName = $device.DeviceName",
          "            }",
          "            else {",
          "                Write-Log \"Found disk with unrecognized volume id: $ebsVolumeId. Ignoring as instance store\"",
          "                $BlockDeviceName = $null",
          "                $ebsVolumeId = $null",
          "            }",
          "        }",
          "        elseif ($pd.SerialNumber -match $ATTACHMENT_ORDER_MATCH) {",
          "            $BlockDeviceName = Convert-SCSITargetIdToDeviceName $pd.SerialNumber",
          "            $device = $BlockDeviceMapping | Where-Object {$_.DeviceName -like (\"*\" + $BlockDeviceName)}",
          "            if ($device -ne $null) {",
          "                $ebsVolumeId = $device.Ebs.VolumeId",
          "            }",
          "            else {",
          "                Write-Log \"Found disk with unrecognized block device: $BlockDeviceName. Ignoring as instance store\"",
          "                $ebsVolumeId = $null",
          "            }",
          "        }",
          "        else {",
          "            Write-Log \"Found disk with unrecognized serial number: $($pd.SerialNumber). Will ignore.\"",
          "            $BlockDeviceName = $null",
          "            $ebsVolumeId = $null",
          "        }",
          "",
          "        $pool1 = Get-StoragePool -PhysicalDisk $pd -IsPrimordial $False -ErrorAction SilentlyContinue",
          "",
          "        foreach ($vd in Get-VirtualDisk) {",
          "            $pool2 = Get-StoragePool -VirtualDisk $vd",
          "            if (($pool1 -like $pool2) -and ($ebsVolumeId -ne $null)) {",
          "                $disk = ($vd | Get-Disk)",
          "                # Ignore partitions that don't map to Volumes/File Systems we'd want to freeze",
          "                $parts = @($disk | Get-Partition | Where-Object -Property Type -NE Reserved | Where-Object -Property Type -NE \"XINT13 Extended\")",
          "                foreach ($part in $parts) {",
          "                    $vol = ($part | Get-Volume)",
          "                    $isReadOnly = ($pool2.IsReadOnly -or $disk.IsReadOnly -or $part.IsReadOnly)",
          "                    $diskList += New-Object PSObject -Property @{",
          "                        Disk          = If ($pd -eq $null) { $null } Else { $pd.DeviceId };",
          "                        Partitions    = 0;",
          "                        # Get Drive Letter from Volume if possible, otherwise grab Access path from partition (Could be mount path or DOS Device path)",
          "                        AccessPath    = If ($vol -ne $null -and $vol.DriveLetter) { ($vol.DriveLetter + ':') } elseif ($part.AccessPaths) { $part.AccessPaths[0] } else { $null };",
          "                        EbsVolumeId   = If ($pd -eq $null) { $null } Else { $ebsVolumeId };",
          "                        Device        = If ($pd -eq $null) { $null } Else { $BlockDeviceName };",
          "                        VolumeName    = If ($vol -eq $null) { $null } Else { $vol.FileSystemLabel };",
          "                        IsReadOnly    = $isReadOnly;",
          "                    }",
          "                }",
          "            }",
          "        }",
          "    }",
          "",
          "    return $disklist",
          "}",
          "",
          "",
          "#",
          "# Helper function to collect connected EBS volumes attached to local EC2 instance.",
          "#",
          "function Get-EbsDiskMapping {",
          "",
          "    $disklist = @()",
          "    $physicalDisks = @()",
          "",
          "    # Older versions of XenVBD use the attachment point to determine serial number",
          "    $ATTACHMENT_ORDER_MATCH = '^(\\d{4})$'",
          "",
          "    $physicalDisks += Get-PhysicalDisk | Where-Object {",
          "        ($_.SerialNumber -match $ATTACHMENT_ORDER_MATCH) -or",
          "        (($_.SerialNumber -match $EBS_VOLUME_MATCH2) -and",
          "         ($_.Manufacturer -match 'AWS' -and $_.Model -match 'PVDISK')) -or",
          "        ($_.SerialNumber -match $EBS_VOLUME_MATCH)",
          "    }",
          "    ",
          "    if (!$physicalDisks -or ($physicalDisks.Count -eq 0)) {",
          "        return $null",
          "    }",
          "",
          "    $InstanceId = Get-EC2InstanceMetadata \"meta-data/instance-id\"",
          "",
          "    $BlockDeviceMapping = (Get-EC2Instance -Instance $InstanceId).Instances.BlockDeviceMappings",
          "",
          "    foreach ($pd in $physicalDisks) {",
          "        $volumeNumber = $pd.SerialNumber | Select-String $EBS_VOLUME_MATCH | % { $_.Matches } | % { $_.Value }",
          "        if ($volumeNumber -eq $null) {",
          "            $volumeNumber = $pd.SerialNumber | Select-String $EBS_VOLUME_MATCH2 | % { $_.Matches } | % { $_.Value }",
          "        }",
          "        if ($volumeNumber -ne $null) {",
          "            $ebsVolumeId = \"vol-$volumeNumber\"",
          "            $device = $BlockDeviceMapping | Where-Object { $_.Ebs.VolumeId -eq $ebsVolumeId }",
          "            if ($device -ne $null) {",
          "                $BlockDeviceName = $device.DeviceName",
          "            }",
          "            else {",
          "                Write-Log \"Found disk with unrecognized volume id: $ebsVolumeId. Ignoring as instance store\"",
          "                $BlockDeviceName = $null",
          "                $ebsVolumeId = $null",
          "            }",
          "        }",
          "        elseif ($pd.SerialNumber -match $ATTACHMENT_ORDER_MATCH) {",
          "            $BlockDeviceName = Convert-SCSITargetIdToDeviceName $pd.SerialNumber",
          "            $device = $BlockDeviceMapping | Where-Object {$_.DeviceName -like (\"*\" + $BlockDeviceName)}",
          "            if ($device -ne $null) {",
          "                $ebsVolumeId = $device.Ebs.VolumeId",
          "            }",
          "            else {",
          "                Write-Log \"Found disk with unrecognized block device: $BlockDeviceName. Ignoring as instance store\"",
          "                $ebsVolumeId = $null",
          "            }",
          "        }",
          "        else {",
          "            Write-Log \"Found disk with unrecognized serial number: $($pd.SerialNumber). Will ignore.\"",
          "            $BlockDeviceName = $null",
          "            $ebsVolumeId = $null",
          "        }",
          "",
          "",
          "        $disk = ($pd | Get-Disk -ErrorAction Ignore) # Physical disks in storage pools don't map to logical disks with Get-Disk, but ignore those",
          "        # Ignore partitions that don't map to Volumes/File Systems we'd want to freeze",
          "        $parts = @($disk | Get-Partition | Where-Object -Property Type -NE Reserved | Where-Object -Property Type -NE \"XINT13 Extended\")",
          "        foreach ($part in $parts) {",
          "            $vol = ($part | Get-Volume)",
          "            $isReadOnly = ($disk.IsReadOnly -or $part.IsReadOnly)",
          "            $diskList += New-Object PSObject -Property @{",
          "                Disk          = If ($pd -eq $null) { $null } Else { $pd.DeviceId };",
          "                Partitions    = 0;",
          "                # Get Drive Letter from Volume if possible, otherwise grab Access path from partition (Could be mount path or DOS Device path)",
          "                AccessPath    = If ($vol -ne $null -and $vol.DriveLetter) { ($vol.DriveLetter + ':') } elseif ($part.AccessPaths) { $part.AccessPaths[0] } else { $null };",
          "                EbsVolumeId   = If ($pd -eq $null) { $null } Else { $ebsVolumeId };",
          "                Device        = If ($pd -eq $null) { $null } Else { $BlockDeviceName };",
          "                VolumeName    = If ($vol -eq $null) { $null } Else { $vol.FileSystemLabel };",
          "                IsReadOnly    = $isReadOnly;",
          "            }",
          "        }",
          "    }",
          "",
          "    return $disklist",
          "}",
          "",
          "",
          "#",
          "# Get a mapping of the local drives to EBS volumes",
          "#",
          "function Get-EbsConnectedVolume",
          "{",
          "    $diskList = @()",
          "",
          "    # If any of the functions return $null it will be added to the disk list which we do not want!",
          "    $disks = Get-EbsDiskMapping",
          "    if ($disks) {",
          "        $diskList += $disks",
          "    }",
          "",
          "    $disks =  Get-XenStorageSpacesEbsDiskMapping",
          "    if ($disks) {",
          "        $diskList += $disks",
          "    }",
          "",
          "    $disks =  Get-AwsNvmeStorageSpacesEbsDiskMapping",
          "    if ($disks) {",
          "        $diskList += $disks",
          "    }",
          "",
          "    $disks =  Get-DynamicDiskPartitionsOnEBSVolumes",
          "    if ($disks) {",
          "        $diskList += $disks",
          "    }",
          "",
          "    return $diskList",
          "}",
          "",
          "",
          "#",
          "# Tag Snapshots",
          "#",
          "function Tag-Snapshots {",
          "    param(",
          "        [System.Object[]]$SnapshotsData,",
          "        [System.Object]$AmiData,",
          "        [boolean]$AppConsistent,",
          "        [Parameter(Mandatory = $false)][amazon.EC2.Model.Tag[]]$Tags",
          "    )",
          "    $Tag = new-object amazon.EC2.Model.Tag",
          "    $Tag.Key = \"AppConsistent\"",
          "    $Tag.Value = \"$AppConsistent\"",
          "    $Tags += $Tag",
          "    foreach ($SnapshotData in $SnapshotsData) {",
          "        $Tag = new-object amazon.EC2.Model.Tag",
          "        $Tag.Key = \"Device\"",
          "        $Tag.Value = $SnapshotData.Device",
          "        $AllTags = $Tags + $Tag",
          "        New-EC2Tag -Resources $SnapshotData.SnapshotId -Tags $AllTags",
          "    }",
          "",
          "    if ($AmiData) {",
          "        New-EC2Tag -Resources $AmiData.ImageId -Tags $Tags",
          "    }",
          "}",
          "",
          "# Returns the OS Version Number in decimal form",
          "function Get-OSVersionNumber {",
          "    return ([Decimal]([environment]::OSVersion.Version).Major + [Decimal]([environment]::OSVersion.Version).Minor * .1)",
          "}",
          "",
          "function VssSnapshot() {",
          "    param(",
          "        [boolean]$ExcludeBootVolume,",
          "        [boolean]$CopyOnly,",
          "        [boolean]$NoWriters,",
          "        [boolean]$CreateAmi,",
          "        [string]$AmiName,",
          "        [string]$Description,",
          "        [string]$Tags,",
          "        [uint32]$waitForFreezeTimeout=180",
          "    )",
          "    $startTime = Get-Date",
          "    $VolumesToFreeze = @()",
          "    $DrivesToFreeze = @()",
          "",
          "    # Exit if we are not on at least Server 2012",
          "    if ((Get-OSVersionNumber) -lt 6.2) {",
          "        Write-Log \"Error: Must be running on Windows Server 2012 or later. Please target an older version of this document.\"",
          "        Write-Log \"For more details see: https://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/application-consistent-snapshots-prereqs.html\"",
          "        return $false",
          "    }",
          "",
          "    if ($ExcludeBootVolume -and $CreateAmi) {",
          "        Write-Log \"The CreateAMI option is not compatible with ExcludeBootVolume.\"",
          "        return $false",
          "    }",
          "",
          "    if (!(Test-Path $vssAgentPath)) {",
          "        Write-Log 'ec2-vss-agent.exe is not installed. To install, run command AWS-ConfigureAWSPackage with package AwsVssComponents'",
          "        return $false",
          "    }",
          "",
          "    # Remove previous agent log files",
          "    if (Test-Path $vssStdErr) {",
          "        del $vssStdErr",
          "    }",
          "    if (Test-Path $vssStdOut) {",
          "        del $vssStdOut",
          "    }",
          "",
          "    $InstanceId = Get-EC2InstanceMetadata \"meta-data/instance-id\"",
          "",
          "    $NumberOfAttachedEBSVolumes = @((Get-EC2Instance -Instance $InstanceId).Instances.BlockDeviceMappings).Count",
          "",
          "    $volumeList = Get-EbsConnectedVolume",
          "    $foundWriteableVolume = $false",
          "    foreach ($v in $volumeList) {",
          "        if ( ($v.AccessPath -ne $null) -and ($v.EbsVolumeId -ne $null)) {",
          "            if (($ExcludeBootVolume -eq $false) -or ($v.Device -ne \"/dev/sda1\")) {",
          "                $DrivesToFreeze += $v.AccessPath",
          "                $VolumesToFreeze += $v",
          "                if (-not $v.IsReadOnly) {",
          "                    $foundWriteableVolume = $true",
          "                }",
          "            }",
          "        }",
          "    }",
          "    if ($VolumesToFreeze.Count -eq 0) {",
          "        Write-Log \"No mounted EBS drives detected\"",
          "        return $false",
          "    }",
          "",
          "    # AMI name is required and must be unique.  If it is not specified create a AMI name from instance ID, OS version,",
          "    # and time stamp.",
          "    if ($createAmi -And (-Not $amiName)) {",
          "        $amiName = \"EC2_VSS_Backup_$($InstanceId)_$((Get-WMIObject win32_operatingsystem).Caption)_$(get-date -format yyyy-MM-ddTHH-mm-ss)\"",
          "        $amiName = $amiName.replace(' ','')",
          "    }",
          "",
          "    try {",
          "        if ($foundWriteableVolume) {",
          "            # Must wrap each Access Path in quotes to correctly pass them to the Agent",
          "            $DrivesToFreezeString = \"`\"\" + ((($DrivesToFreeze | sort -Unique ) -replace '\\\\$','\\\\') -join \"`\" `\"\") + \"`\"\"",
          "",
          "            Write-Log \"Beginning snapshot for drives $DrivesToFreezeString\"",
          "",
          "            $process = EbsVssFreeze $DrivesToFreezeString $startTime $CopyOnly $NoWriters $waitForFreezeTimeout",
          "            if ($process -eq $null) {",
          "                return $false",
          "            }",
          "",
          "            Write-Log \"Freeze complete at $($(New-Timespan $startTime $(Get-Date)).TotalMilliseconds) ms\"",
          "        }",
          "        else {",
          "            Write-Log 'All volumes found are read-only or on a read-only disk or storage pool. Snapshotting without freezing IO.'",
          "        }",
          "",
          "        $SnapshotData = @()",
          "        $AmiData = @()",
          "        $amiId = ''",
          "        if ($createAmi) {",
          "            try {",
          "                $amiId = New-EC2Image -InstanceId $InstanceId -Name $amiName -Description $Description -NoReboot $true",
          "                $timeOut = 10  # Kernel will only hold I/O for 10 seconds, so if we cannot describe AMI after 10 seconds, time out",
          "                while ($timeOut) {",
          "                    try {",
          "                        $AmiData = Get-EC2Image -ImageId $amiId",
          "                    } catch {",
          "                        # Occasionally Get-EC2Image can fail if called too soon after New-EC2Image. Retry in that case",
          "                        if($timeOut -gt 1 -and $_.Exception.InnerException.ErrorCode -eq \"InvalidAMIID.NotFound\") {",
          "                            $AmiData = $False",
          "                        } else {",
          "                            throw $_",
          "                        }",
          "                    }",
          "                    if ($AmiData -And ($AmiData.State -Like \"pending\" -Or $AmiData.State -Like \"available\")) {",
          "                        if ($AmiData.PSobject.Properties.name -match \"BlockDeviceMappings\") {",
          "                            $SnapshotData = @()",
          "                            foreach ($b in $AmiData.BlockDeviceMappings) {",
          "                                if ($b.PSobject.Properties.name -match \"Ebs\" -And",
          "                                    $b.Ebs -And $b.Ebs.PSobject.Properties.name -match \"SnapshotId\" -And",
          "                                    $b.PSobject.Properties.name -match \"DeviceName\" -And",
          "                                    $b.Ebs.SnapshotId) {",
          "                                    $SnapshotData += New-Object PSObject -Property @{",
          "                                        Device      = $b.DeviceName",
          "                                        SnapshotId  = $b.Ebs.SnapshotId",
          "                                    }",
          "                                }",
          "                            }",
          "                            # This check ensures that all EBS Volumes have been snapshot by New-EC2Image before we thaw.",
          "                            if ($SnapshotData.Count -eq $NumberOfAttachedEBSVolumes) {",
          "                                break;",
          "                            }",
          "                        }",
          "                    }",
          "                    Start-Sleep -Seconds 1",
          "                    $timeOut--",
          "                }",
          "                if ($timeOut -le 0) {",
          "                    Write-Log \"ERROR: Took longer than 10 seconds to describe snapshots in AMI, kernel hold on I/O has expired.\"",
          "                    PrintTimeoutTroubleshootingBanner",
          "                    return $false",
          "                } ",
          "            } catch {",
          "                Write-Log \"Exception caught creating AMI:\"",
          "                Write-Log $_",
          "                return $false",
          "            }",
          "        } else {",
          "            foreach ($v in $VolumesToFreeze) {",
          "                if ($SnapshotData | Where-Object {$_.EbsVolumeId -eq $v.EbsVolumeId}) {",
          "                    continue",
          "                }",
          "                try {",
          "                    $Snapshot = New-EC2Snapshot -VolumeId $v.EbsVolumeId -Description $Description",
          "                } catch {",
          "                    Write-Log \"Exception caught creating EBS snapshot:\"",
          "                    Write-Log $_.ToString()",
          "                    return $false",
          "                }",
          "                $SnapshotData += New-Object PSObject -Property @{",
          "                    EbsVolumeId = $v.EbsVolumeId",
          "                    Device      = $v.Device",
          "                    SnapshotId  = $Snapshot.SnapshotId",
          "                }",
          "            }",
          "        }",
          "",
          "        if ($foundWriteableVolume) {",
          "            Write-Log \"Starting Thaw at $($(New-Timespan $startTime $(Get-Date)).TotalMilliseconds) ms\"",
          "            $AppConsistent = EbsVssThaw $startTime",
          "            if ($AppConsistent) {",
          "                Write-Log \"Thaw successful at $($(New-Timespan $startTime $(Get-Date)).TotalMilliseconds) ms\"",
          "            } else {",
          "                Write-Log \"Thaw unsuccesful, snapshots may not be app consistent, see event log for more details $($(New-Timespan $startTime $(Get-Date)).TotalMilliseconds) ms\"",
          "            }",
          "            if ($amiId) {",
          "                Write-Log \"AMI: $amiId\"",
          "            }",
          "            foreach ($Snapshot in $SnapshotData) {",
          "                Write-Log \"Snapshot: $($Snapshot.SnapshotId) DeviceName: $($Snapshot.Device)\"",
          "            }",
          "",
          "            PrintVssAgentOutput $process",
          "        }",
          "        else {",
          "            $AppConsistent = $true",
          "            Write-Log 'All volumes found are read-only or on a read-only disk or storage pool. Skipping VssThaw.'",
          "        }",
          "    }",
          "    finally {",
          "        # In all cases including errors, we want to make sure the logBuffer is printed",
          "        Set-OutputMode -UnBuffered",
          "    }",
          "",
          "    [amazon.EC2.Model.Tag[]]$TagArray = @()",
          "    $Tags -split \";\" | ForEach-Object {",
          "        if (-not [string]::IsNullOrEmpty($_)) {",
          "            $TagParts = ($_ -split \",\", 2)",
          "            if ($TagParts.Count -ne 2) {",
          "                Write-Log \"Error parsing tags, tags need to be in the format Name=tag-key,Values=tag-value\"",
          "                return $false",
          "            }",
          "            $TagName, $TagValue = $TagParts",
          "            $Tag = new-object amazon.EC2.Model.Tag",
          "            $Tag.Key = ($TagName -split \"=\", 2)[1].Trim()",
          "            $Tag.Value = ($TagValue -split \"=\", 2)[1].Trim()",
          "            $TagArray += $Tag",
          "        }",
          "    }",
          "",
          "    Tag-Snapshots -SnapshotsData $SnapshotData -AmiData $AmiData -AppConsistent $AppConsistent -Tags $TagArray",
          "    return $AppConsistent",
          "}",
          "",
          "",
          "[boolean]$ExcludeBootVolume = [System.Convert]::ToBoolean(\"{{ExcludeBootVolume}}\")",
          "",
          "[boolean]$CopyOnly = [System.Convert]::ToBoolean(\"{{CopyOnly}}\")",
          "",
          "[boolean]$NoWriters = [System.Convert]::ToBoolean(\"{{NoWriters}}\")",
          "",
          "[boolean]$CreateAmi = [System.Convert]::ToBoolean(\"{{CreateAmi}}\")",
          "",
          "$AmiName = @'",
          "{{AmiName}}",
          "'@",
          "",
          "$description = @'",
          "{{description}}",
          "'@",
          "",
          "$tags = @'",
          "{{tags}}",
          "'@",
          "",
          "[uint32]$executionTimeout = {{executionTimeout}}",
          "[uint32]$waitForFreezeTimeout = $executionTimeout - 60",
          "",
          "$AppConsistent = VssSnapshot $ExcludeBootVolume $CopyOnly $NoWriters $CreateAmi $AmiName $description $tags $executionTimeout",
          "exit [int](-not $AppConsistent)",
          ""
        ]
      },
      "name": "runPowerShellScript",
      "action": "aws:runPowerShellScript",
      "precondition": {
        "StringEquals": [
          "platformType",
          "Windows"
        ]
      }
    }
  ]
}
