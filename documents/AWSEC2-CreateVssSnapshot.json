{
  "schemaVersion": "2.2",
  "description": "Create an application consistent snapshot of all EBS volumes attached to an instance.",
  "parameters": {
    "ExcludeBootVolume": {
      "type": "String",
      "description": "(Optional) Select True to exclude the boot volume from the snapshot process.",
      "allowedValues": [
        "True",
        "False"
      ],
      "default": "False"
    },
    "NoWriters": {
      "type": "String",
      "description": "(Optional) Select True to exclude application VSS writers from the snapshot process. This option may be useful to resolve conflicts with third party VSS backup solutions.",
      "allowedValues": [
        "True",
        "False"
      ],
      "default": "False"
    },
    "CopyOnly": {
      "type": "String",
      "description": "(Optional) Select True to indicate a COPY ONLY backup operation.  By default a FULL backup operation is performed.  This option will prevent breaking the differential backup chain in SQL Server when performing a backup.",
      "allowedValues": [
        "True",
        "False"
      ],
      "default": "False"
    },
    "CreateAmi": {
      "type": "String",
      "description": "(Optional) Select True to create an Amazon Machine Image (AMI) backup.",
      "allowedValues": [
        "True",
        "False"
      ],
      "default": "False"
    },
    "AmiName": {
      "type": "String",
      "default": "",
      "description": "(Optional) Specify a name for created AMI.  This option only has affect if the CreateAmi option is selected.",
      "maxChars": 128,
      "allowedPattern": "^([a-zA-Z0-9()\\[\\] ./\\-@_{}:]|^'[a-zA-Z0-9()\\[\\] ./\\-_{}:]|^'$|[a-zA-Z0-9()\\[\\] ./\\-@_{}:]'){0,128}$"
    },
    "description": {
      "type": "String",
      "default": "",
      "description": "(Optional) Specify a description to apply to created EBS snaphots.",
      "maxChars": 255,
      "allowedPattern": "^([^'\\n\\r]|(\\r|\\n)?'[^@]|(\\r|\\n)([^']|'?$)|'$|[^\\r\\n]'@){0,255}$"
    },
    "tags": {
      "type": "String",
      "default": "Key=Name,Value=",
      "description": "(Optional) Specify descriptive key-value pair tags to apply to created EBS snapshots.  Use a semicolon as a separator between tags pairs. Example: Key=Name,Value=VSS Snapshot;Key=BackupId,Value=01234",
      "allowedPattern": "^([Kk]ey=([a-zA-Z0-9() ./\\-\"'@_+:={}]*),[Vv]alue=([a-zA-Z0-9() ./\\-\"'@_+:={}]*);?)*$"
    },
    "executionTimeout": {
      "type": "String",
      "default": "800",
      "description": "(Optional) The time in seconds for this command to be completed before it is considered to have failed. Extending this timeout will cause the command to wait longer for VSS to start its freeze. Default is 800 seconds. Maximum is 172800 (48 hours). Minimum is 120.",
      "allowedPattern": "^((1[2-9][0-9]{1})|([2-9][0-9]{2})|([1-9][0-9]{3,4})|(1[0-6][0-9]{4})|(17[0-1][0-9]{3})|(172[0-7][0-9]{2})|(172800))$"
    },
    "CollectDiagnosticLogs": {
      "type": "String",
      "description": "(Optional) Select True to collect extra diagnostic information.",
      "allowedValues": [
        "True",
        "False"
      ],
      "default": "False"
    },
    "SaveVssMetadata": {
      "type": "String",
      "description": "(Optional) If the installed AwsVssComponents' version is equal or greater than 2.4.0, select True to save VSS Backup Component Document. If SQL Server contributes to the snapshot, SqlServerWriter's metadata will also be saved. This option cannot be set to True if the installed AwsVssComponents' version is prior to 2.4.0.",
      "allowedValues": [
        "True",
        "False"
      ],
      "default": "False"
    }
  },
  "mainSteps": [
    {
      "precondition": {
        "StringEquals": [
          "platformType",
          "Windows"
        ]
      },
      "action": "aws:runPowerShellScript",
      "name": "runPowerShellScript",
      "inputs": {
        "runCommand": [
          "Set-StrictMode -Version Latest",
          "$ErrorActionPreference = \"Stop\"",
          "trap {",
          "Write-Host \"Encountered unexpected error. Please see error details below.\"",
          "Write-Host ($_.Exception | Format-List -Force | Out-String)",
          "Write-Host ($_.InvocationInfo | Format-List -Force | Out-String)",
          "exit 4000",
          "}",
          "$script:EBS_VOLUME_MATCH = '(?<=vol)[0-9a-zA-Z]*(?= *_)'",
          "$script:EBS_VOLUME_MATCH2 = '(?<=vol)(.*)'",
          "$script:START_TIME = Get-Date",
          "$datePrint = \"$($script:START_TIME.Month)-$($script:START_TIME.Day)-$($script:START_TIME.Year)\"",
          "$timePrint = \"$($script:START_TIME.Hour)-$($script:START_TIME.Minute)\"",
          "$script:VSS_PATH = \"$env:ProgramFiles\\Amazon\\AwsVssComponents\\\"",
          "$script:VSS_AGENT_PATH = Join-Path -Path $script:VSS_PATH -ChildPath \"ec2-vss-agent.exe\"",
          "$script:VSS_PROVIDER_PATH = Join-Path -Path $script:VSS_PATH -ChildPath \"Ec2VssProvider.dll\"",
          "$script:VSS_LOG_PATH = \"$env:ProgramData\\Amazon\\AwsVss\\Logs\"",
          "$script:DIAGNOSTIC_FOLDER_PATH = \"$script:VSS_LOG_PATH\\$datePrint-$timePrint\"",
          "$script:DIAGNOSTIC_SSM_LOG_PATH = \"$script:DIAGNOSTIC_FOLDER_PATH\\SsmLogs\"",
          "$script:VSS_STDERR = \"$script:VSS_LOG_PATH\\vsserr.log\"",
          "$script:VSS_STDOUT = \"$script:VSS_LOG_PATH\\vssout.log\"",
          "$script:VSS_METADATA_PATH = \"$env:ProgramData\\Amazon\\AwsVss\\VssMetadata\"",
          "$script:START_INFO_FILE = \"StartTime.log\"",
          "$script:PIPE_INFO_FILE = \"PipeInformation.log\"",
          "$script:VSS_LOG_FILE = \"VssEvents.log\"",
          "$script:VSS_WRITERS_PROVIDERS_FILE = \"VssProvidersAndWriters.log\"",
          "$script:VSS_AGENT_FILE = \"VssAgentInfo.log\"",
          "$script:VSS_PROVIDER_FILE = \"VssProviderInfo.log\"",
          "$script:POWERSHELL_VERSION_FILE = \"PowershellVersionInfo.log\"",
          "$script:DIAGNOSTIC_LOG_FILE = \"DiagnosticLogs.log\"",
          "$script:STDOUT_FILE = \"stdout.log\"",
          "$script:STDERR_FILE = \"stderr.log\"",
          "$script:VSS_TRACE_FILE = \"$script:DIAGNOSTIC_FOLDER_PATH\\vss.etl\"",
          "$script:EC2VSSPROVIDER_TRACE_FILE = \"$script:DIAGNOSTIC_FOLDER_PATH\\ec2VssProvider.etl\"",
          "$script:DIAGNOSTIC_ZIP = \"$script:DIAGNOSTIC_FOLDER_PATH.zip\"",
          "$script:CollectDiagnosticLogs = $false",
          "$script:VssAgentVersion = @{",
          "\"Major\" = 0;",
          "\"Minor\" = 0;",
          "\"Patch\" = 0;",
          "}",
          "$script:TRACE_INFORMATION =",
          "@(",
          "@{",
          "Name = \"vss\";",
          "TraceFile = $script:VSS_TRACE_FILE;",
          "Guid = \"{9138500e-3648-4edb-aa4c-859e9f7b7c38}\";",
          "ExtraSettings = \"-nb 4 512 -bs 512\";",
          "FlagsAndLevels = \"0xfff 170\"",
          "},",
          "@{",
          "Name = \"TraceEc2VssSoftwareProvider\";",
          "TraceFile = $script:EC2VSSPROVIDER_TRACE_FILE;",
          "Guid = \"{bd65044a-d8ac-5ab5-e9b7-28546d6f9847}\";",
          "ExtraSettings = \"\";",
          "FlagsAndLevels = \"\"",
          "}",
          ")",
          "$script:aggregatedCode = 0;",
          "$TIMEOUT_ERROR_STRINGS = @{",
          "\"0\" = \"Application consistent snapshots were taken successfully.\";",
          "\"1\" = \"Timestamps indicate more than 9000ms elapsed between freeze and thaw. Kernel hold on I/O has expired, indicating snapshots are not application-consistent.\";",
          "\"2\" = \"Failed to connect to Thaw pipe, indicating snapshots are not application-consistent.\";",
          "\"3\" = \"Thaw pipe read failed, indicating snapshots are not application-consistent.\";",
          "\"4\" = \"Received unexpected message from VSS Provider on Thaw pipe, indicating snapshots are not application-consistent.\";",
          "\"5\" = \"Provider gave timeout message, indicating kernel hold on I/O expired and snapshots are not application-consistent.\";",
          "\"6\" = \"Snapshots in AMI have timestamps after thaw, indicating snapshots are not application-consistent.\"",
          "}",
          "$POST_SNAPSHOT_ERROR_STRINGS = @{",
          "\"0\" = \"\";",
          "\"1\" = \" Failed to tag snapshots\";",
          "\"2\" = \" Failed to tag AMI\";",
          "\"3\" = \" Failed to tag AMI and snapshots\";",
          "}",
          "$ERROR_CODES = @{",
          "\"1001\" = \"The CreateAMI option is not compatible with ExcludeBootVolume.\";",
          "\"1002\" = \"Unable to locate AWS PowerShell tools\";",
          "\"1003\" = \"ec2-vss-agent.exe is not installed. To install, run command AWS-ConfigureAWSPackage with package AwsVssComponents\";",
          "\"1004\" = \"Failed to find EC2 instance-id. This must run on an EC2 Instance as an SSM document\";",
          "\"1005\" = \"OS version not supported\";",
          "\"1006\" = \"No mounted EBS drives detected to snapshot. Check ExcludeBootVolume flag and number of volumes seen by Windows using disk management\";",
          "\"1007\" = \"Error parsing tags, tags need to be in the format Name=tag-key,Values=tag-value\";",
          "\"1009\" = \"The Windows volume configuration is not compatible with ExcludeBootVolume. A Windows volume spans across multiple EBS volumes including the boot volume\";",
          "\"1010\" = \"SaveVssMetadata should not be specified as TRUE for ec2-vss-agent of versions prior to 2.4.0\";",
          "\"1011\" = \"SaveVssMetadata option is not compatible with NoWriters\";",
          "\"2001\" = \"Failed to create named pipe for communicating VSS Freeze\";",
          "\"2002\" = \"Failed to create named pipe for communicating VSS Thaw\";",
          "\"2003\" = \"ec2-vss-agent is already running, a snapshot is already in progress.\";",
          "\"2004\" = \"Failed to create VSS requester process\";",
          "\"2005\" = \"Timed out waiting for VSS freeze. Consider increasing the executionTimeout parameter.\";",
          "\"2006\" = \"Freeze pipe read failed\";",
          "\"2007\" = \"Received unexpected message from VSS Provider on Freeze pipe\";",
          "\"2008\" = \"Failed to connect to Thaw pipe\";",
          "\"2009\" = \"Thaw pipe read failed\";",
          "\"2010\" = \"Received unexpected message from VSS Provider on Thaw pipe\";",
          "\"2011\" = \"VSS Agent exited before Freeze pipe is connected\";",
          "\"2012\" = \"Freeze pipe read timed out\";",
          "\"2101\" = \"Failed to send context to Provider\";",
          "\"2102\" = \"Failed to read results from Provider\";",
          "\"2103\" = \"Vss Provider closed the Freeze pipe before sending the response.\";",
          "\"2104\" = \"Failed to convert response from json\";",
          "\"2105\" = \"Vss Provider failed to send back results before timeout\";",
          "\"3001\" = \"Call to Get-EC2Instance threw an Exception\";",
          "\"3002\" = \"Call to Get-EC2InstanceAttribute threw an Exception\";",
          "\"3003\" = \"No permission to call Get-EC2InstanceAttribute\";",
          "\"3011\" = \"Call to New-EC2Image threw an Exception\";",
          "\"3021\" = \"Call to Get-EC2Image threw an Exception\";",
          "\"3022\" = \"Unable to find snapshots in the created AMI\";",
          "\"3031\" = \"Call to New-EC2Snapshot threw an Exception\";",
          "\"3041\" = \"Call to Get-EC2Snapshot threw an Exception\";",
          "\"4001\" = \"Script indicated failure but no other errors logged\";",
          "\"4002\" = \"Exception caught creating AMI\";",
          "\"4003\" = \"Exception caught in Invoke-VssSnapshot\";",
          "\"4004\" = \"Unhandled exception in Invoke-VssSnapshot\";",
          "\"4005\" = \"Exception in Initialize-VssOperationChannel\";",
          "\"5001\" = \"Provider returned an error.\";",
          "\"6001\" = \"Exception caught when writing diagnostic information\";",
          "\"6002\" = \"Failed to create diagnostic zip file\";",
          "\"6003\" = \"Exception occurred while printing diagnostic information\";",
          "\"6004\" = \"Failed to create diagnostic folder\";",
          "\"6005\" = \"Failed to start Vss or Ec2VssProvider trace\";",
          "\"6006\" = \"Failed to stop Vss or Ec2VssProvider trace\";",
          "\"7001\" = \"Failed to obtain the path to save the metadata files\";",
          "\"7002\" = \"Failed to save the Backup Components Document\";",
          "\"7003\" = \"Failed to save the SQL Server Writer Metadata\";",
          "\"7004\" = \"Timed out waiting for ec2-vss-agent to save the metadata files\";",
          "}",
          "$script:FREEZE_NAMED_PIPE = '01C0026F-7357-49CD-BD74-657EAF079673'",
          "$script:THAW_NAMED_PIPE = '8EF5C9E5-9C84-43EB-A8F7-C60B0EFD7B72'",
          "$script:VSS_V1_MESSAGE = \"Freeze\"",
          "$script:CREATE_SNAPSHOT = 0",
          "$script:NO_SNAPSHOT = 1",
          "$script:SEND_CONTEXT = 100",
          "$script:freezePipeServer = $null",
          "$script:thawPipeClient = $null",
          "$script:freezePipeReader = $null",
          "$script:thawPipeReader = $null",
          "$script:freezePipeWaitTask = $null",
          "$script:PipeList = @(",
          "\"freezePipeServer\",",
          "\"thawPipeClient\",",
          "\"freezePipeWaitTask\",",
          "\"freezePipeReader\",",
          "\"thawPipeReader\"",
          ")",
          "$script:freezeStartTime = $null",
          "[hashtable[]]$script:diagnosticBuffer = @()",
          "[hashtable[]]$script:errorBuffer = @()",
          "[hashtable]$script:outputInformation = @{",
          "\"Error\" = 0;",
          "}",
          "[hashtable[]]$script:logBuffer = @()",
          "[bool]$script:BufferOutput = $false",
          "function Set-OutputMode {",
          "param(",
          "[Parameter(Mandatory=$true,",
          "ParameterSetName=\"Buffered\")]",
          "[switch]$Buffered,",
          "[Parameter(Mandatory=$true,",
          "ParameterSetName=\"UnBuffered\")]",
          "[switch]$UnBuffered",
          ")",
          "if ($script:VssAgentVersion.Major -ne 1) {",
          "return",
          "}",
          "if ($Buffered) {",
          "$script:BufferOutput = $true",
          "}",
          "else {",
          "$script:BufferOutput = $false",
          "Write-BufferedLog",
          "}",
          "}",
          "function Write-Diagnostics {",
          "[CmdletBinding()]",
          "param(",
          "[Parameter(Position=0,",
          "Mandatory=$true,",
          "ValueFromPipeline=$true)]",
          "$message,",
          "[string]$fileName,",
          "[switch]$stderr",
          ")",
          "if ($script:CollectDiagnosticLogs) {",
          "try {",
          "Write-Output $message | Add-Content -Path \"$script:DIAGNOSTIC_FOLDER_PATH\\$fileName\"",
          "}",
          "catch {",
          "Write-Host \"Failed to write message to a diagnostic file: $fileName\"",
          "Write-Host $_.Exception.Message",
          "}",
          "}",
          "Write-Host $message",
          "}",
          "function Write-Log {",
          "[CmdletBinding()]",
          "param(",
          "[Parameter(Position = 0,",
          "Mandatory=$true,",
          "ValueFromPipeline=$true)]",
          "$message",
          ")",
          "$lineInfo = @{Message=$message;Stream=\"Success\"}",
          "if ($script:BufferOutput) {",
          "$script:logBuffer += $lineInfo",
          "}",
          "else {",
          "Write-Diagnostics ($($lineInfo.Message)) -fileName $script:STDOUT_FILE",
          "}",
          "}",
          "function Write-ErrorLog {",
          "[CmdletBinding()]",
          "param(",
          "[Parameter(Position=0,",
          "Mandatory=$true,",
          "ValueFromPipeline=$true)]",
          "$message",
          ")",
          "$message = \"Error: $message\"",
          "$lineInfo = @{",
          "Message=$message;",
          "Stream=\"Error\"}",
          "if ($script:BufferOutput) {",
          "$script:logBuffer += $lineInfo",
          "}",
          "else {",
          "Write-Diagnostics $($lineInfo.Message) -fileName $script:STDERR_FILE -stderr",
          "}",
          "}",
          "function Format-Timestamp {",
          "Param (",
          "$line",
          ")",
          "$ts = $line.Timestamp",
          "$timeArray = @($ts.Month, $ts.Day, $ts.Hour, $ts.Minute, $ts.Second, $ts.Millisecond)",
          "$timestring = \"[{0:d2}/{1:d2} {2:d2}:{3:d2}:{4:d2}.{5:d3}]\" -f $timeArray",
          "$message = \"$timestring $($line.Message)\"",
          "return $message",
          "}",
          "function Write-BufferedLog {",
          "foreach ($line in $script:logBuffer) {",
          "switch ($line.Stream)",
          "{",
          "\"Success\" { Write-Diagnostics $line.Message -fileName $script:STDOUT_FILE; break; }",
          "\"Error\" { Write-Diagnostics $line.Message -fileName $script:STDERR_FILE -stderr; break; }",
          "Default { Write-Diagnostics $line.Message -fileName $script:STDOUT_FILE; break; }",
          "}",
          "}",
          "$script:logBuffer = @()",
          "}",
          "function Write-DiagnosticLog {",
          "[CmdletBinding()]",
          "param(",
          "[Parameter(Position=0,",
          "Mandatory=$true,",
          "ValueFromPipeline=$true)]",
          "$message",
          ")",
          "$script:diagnosticBuffer += @{Timestamp=(Get-Date); Message=$message}",
          "}",
          "function Write-DiagnosticLogOut {",
          "foreach ($line in $script:diagnosticBuffer) {",
          "Write-Diagnostics (Format-Timestamp $line) -fileName $script:DIAGNOSTIC_LOG_FILE",
          "}",
          "$script:diagnosticBuffer = @()",
          "}",
          "function Write-ErrorEvent {",
          "param(",
          "[Parameter(Mandatory=$false)]",
          "[int]$ErrorCode=0,",
          "[Parameter(Position=0,Mandatory=$false)]",
          "[String]$ErrorMessage=\"\"",
          ")",
          "$errEvt = @{ErrorCode=[String]$ErrorCode; ErrorMessage=$ErrorMessage}",
          "Write-ErrorLog (Get-ErrorString $errEvt)",
          "if ($ErrorCode -gt 0 -and $ErrorCode -lt 1000) {",
          "[int]$script:aggregatedCode += $ErrorCode",
          "} else {",
          "$script:errorBuffer += $errEvt",
          "}",
          "}",
          "function Get-ErrorString {",
          "param(",
          "[Parameter(Mandatory=$true)]",
          "[hashtable]$ErrorEvent",
          ")",
          "if ($ErrorEvent.ErrorMessage -ne \"\") {",
          "return $ErrorEvent.ErrorMessage",
          "}",
          "if ($ERROR_CODES.Keys -contains $ErrorEvent.ErrorCode) {",
          "return $ERROR_CODES[[String]$ErrorEvent.ErrorCode]",
          "}",
          "if ([int]$ErrorEvent.ErrorCode -gt 0 -and [int]$ErrorEvent.ErrorCode -lt 100) {",
          "$tens = [int]($ErrorEvent.ErrorCode/10)",
          "$ones = [int]($ErrorEvent.ErrorCode%10)",
          "if ($TIMEOUT_ERROR_STRINGS.Keys -contains $tens) {",
          "$errorString = $TIMEOUT_ERROR_STRINGS[[String]$tens]",
          "} else {",
          "return \"Unknown error: $($ErrorEvent.ErrorCode)\"",
          "}",
          "if( $POST_SNAPSHOT_ERROR_STRINGS.Keys -contains $ones) {",
          "$errorString += $POST_SNAPSHOT_ERROR_STRINGS[[String]$ones]",
          "} else {",
          "return \"Unknown error: $($ErrorEvent.ErrorCode)\"",
          "}",
          "return $errorString",
          "} else {",
          "return \"Unknown error: $($ErrorEvent.ErrorCode)\"",
          "}",
          "}",
          "function Write-UnexpectedMessageFromProviderError {",
          "param(",
          "[Parameter(Mandatory=$true)]",
          "[string]$Message",
          ")",
          "Write-ErrorEvent -ErrorCode 2007",
          "Write-ErrorEvent \"Message: $Message\"",
          "}",
          "function Write-ReturnInformation {",
          "param(",
          "[Parameter(Mandatory=$true)]",
          "$Success",
          ")",
          "if ($script:aggregatedCode -ne 0) {",
          "$errEvt = @{ErrorCode=[String]$script:aggregatedCode; ErrorMessage=\"\"}",
          "$script:errorBuffer += $errEvt",
          "Write-ErrorLog (Get-ErrorString $errEvt)",
          "}",
          "if ($script:errorBuffer.Count -eq 0 -and (-not $Success)) {",
          "Write-ErrorEvent -ErrorCode 4001",
          "}",
          "if ($script:errorBuffer.Count -ge 1) {",
          "[String[]]$script:outputInformation[\"Failures\"] = @()",
          "foreach ($err in $script:errorBuffer) {",
          "if (($script:outputInformation[\"Error\"] -eq 0 -or $script:outputInformation[\"Error\"] -eq 1) -and ($err[\"ErrorCode\"] -ne 0)) {",
          "$script:outputInformation[\"Error\"] = $err[\"ErrorCode\"]",
          "}",
          "[String[]]$script:outputInformation[\"Failures\"] += Get-ErrorString -ErrorEvent $err",
          "}",
          "}",
          "Write-Diagnostics ($script:outputInformation | ConvertTo-Json -Compress) -fileName $script:STDOUT_FILE",
          "}",
          "Function Get-VssEventLogs {",
          "Param(",
          "[System.DateTime]$After",
          ")",
          "$EventViewerMessageFilters = @(",
          "@{",
          "LogName = \"Application\"",
          "ProviderName = \"Ec2VssSoftwareProvider\"",
          "StartTime = $After",
          "},",
          "@{",
          "LogName = \"Application\"",
          "ProviderName = \"VSS\"",
          "StartTime = $After",
          "},",
          "@{",
          "LogName = \"System\"",
          "ProviderName = \"Service Control Manager\"",
          "matchText = \"(Volume Shadow Copy|Ec2VssSoftwareProvider)\"",
          "StartTime = $After",
          "},",
          "@{",
          "LogName = \"Application\"",
          "ProviderName = \"Application Error\"",
          "EntryType = \"Error\"",
          "matchText = \"(vssvc.exe|Ec2VssProvider.dll)\"",
          "StartTime = $After",
          "}",
          ")",
          "$foundMessages = New-Object 'System.Collections.Generic.List[String]'",
          "foreach ($filter in $EventViewerMessageFilters) {",
          "try {",
          "$matchText = if($filter.ContainsKey(\"MatchText\")) { $filter.MatchText } else { \"\" }",
          "$filter.Remove(\"MatchText\")",
          "$FilteredEvents = (Get-WinEvent -FilterHashtable @($filter) -ErrorAction Stop)",
          "if (-not $FilteredEvents) {",
          "continue",
          "}",
          "$matchingEvents = @($FilteredEvents | Where-Object {$_.Message -match $matchText})",
          "foreach ($matchingEvent in $matchingEvents) {",
          "$ts = $matchingEvent.TimeCreated",
          "$timestring = \"[{0:d2}:{1:d2}:{2:d2}]\" -f @($ts.Hour, $ts.Minute, $ts.Second)",
          "$message = $matchingEvent.Message -replace \"[`n`r]+\", \"; \"",
          "$message = \"$timestring $message\"",
          "$foundMessages.Add($message)",
          "}",
          "}",
          "catch [Exception]",
          "{",
          "$message = $_.Exception -replace \"[`n`r]+\", \"; \"",
          "$name = $filter.ProviderName",
          "$message = \"Caught exception reading event log for provider ${name}: $message\"",
          "$foundMessages.Add($message)",
          "}",
          "}",
          "return ($foundMessages | Sort-Object)",
          "}",
          "function Write-DiagnosticInformation {",
          "Write-Diagnostics \"Begin diagnostic information.\" -fileName $script:DIAGNOSTIC_LOG_FILE",
          "Write-Diagnostics \"Script execution began $($script:START_TIME).\" -fileName $script:START_INFO_FILE",
          "@(",
          "{",
          "Write-Diagnostics \"Diagnostic log:\" -fileName $script:DIAGNOSTIC_LOG_FILE",
          "Write-DiagnosticLogOut",
          "},",
          "{",
          "Write-Diagnostics \"Current pipe states:\" -fileName $script:PIPE_INFO_FILE",
          "foreach ($pipe in $script:PipeList) {",
          "if (Get-Variable -Name $pipe -ErrorAction SilentlyContinue) {",
          "if ($null -eq (Get-Variable -Name $pipe -ValueOnly)) {",
          "Write-Diagnostics \"Pipe $pipe is uninitialized or has been disposed.\" -fileName $script:PIPE_INFO_FILE",
          "}",
          "else {",
          "Write-Diagnostics \"Pipe $pipe is active.\" -fileName $script:PIPE_INFO_FILE",
          "}",
          "}",
          "else {",
          "Write-Diagnostics \"Pipe variable $pipe does not exist.\" -fileName $script:PIPE_INFO_FILE",
          "}",
          "}",
          "},",
          "{",
          "$eventLogMessages = (Get-VssEventLogs -After $script:START_TIME)",
          "if ($eventLogMessages) {",
          "Write-Diagnostics \"VSS entries in the Event Log:\" -fileName $script:VSS_LOG_FILE",
          "foreach ($eventLogMessage in $eventLogMessages) {",
          "Write-Diagnostics $eventLogMessage -fileName $script:VSS_LOG_FILE",
          "}",
          "}",
          "else {",
          "Write-Diagnostics \"No VSS entries in the Event Log since the start of script execution.\" -fileName $script:VSS_LOG_FILE",
          "}",
          "},",
          "{",
          "Write-Diagnostics \"Listing VSS Providers\" -fileName $script:VSS_WRITERS_PROVIDERS_FILE",
          "Write-Diagnostics (vssadmin list providers) -fileName $script:VSS_WRITERS_PROVIDERS_FILE",
          "Write-Diagnostics \"Listing VSS Writers\" -fileName $script:VSS_WRITERS_PROVIDERS_FILE",
          "Write-Diagnostics (vssadmin list writers) -fileName $script:VSS_WRITERS_PROVIDERS_FILE",
          "Write-Diagnostics \"Listing VSS Volumes\" -fileName $script:VSS_WRITERS_PROVIDERS_FILE",
          "Write-Diagnostics (vssadmin list volumes) -fileName $script:VSS_WRITERS_PROVIDERS_FILE",
          "},",
          "{",
          "if ($null -ne (Get-Process -Name \"ec2-vss-agent\" -ea SilentlyContinue)) {",
          "Write-Diagnostics \"ec2-vss-agent is running.\" -fileName $script:VSS_AGENT_FILE",
          "}",
          "else {",
          "Write-Diagnostics \"ec2-vss-agent is not running.\" -fileName $script:VSS_AGENT_FILE",
          "}",
          "},",
          "{",
          "Write-Diagnostics \"Running tasklist /m ec2vssprovider.dll\" -fileName $script:VSS_PROVIDER_FILE",
          "Write-Diagnostics (tasklist /m ec2vssprovider.dll) -fileName $script:VSS_PROVIDER_FILE",
          "},",
          "{",
          "$vssAgentVersion = Get-VssAgentVersion",
          "if ($vssAgentVersion) {",
          "Write-Diagnostics \"EC2 VSS Agent Version: $vssAgentVersion\" -fileName $script:VSS_AGENT_FILE",
          "}",
          "else {",
          "Write-Diagnostics \"EC2 VSS Agent not found.\" -fileName $script:VSS_AGENT_FILE",
          "}",
          "},",
          "{",
          "$vssProviderDllVersion = Get-VssProviderDllVersion",
          "if ($vssProviderDllVersion) {",
          "Write-Diagnostics \"EC2 VSS Provider DLL Version: $vssProviderDllVersion\" -fileName $script:VSS_PROVIDER_FILE",
          "}",
          "else {",
          "Write-Diagnostics \"EC2 VSS Provider DLL not found.\" -fileName $script:VSS_PROVIDER_FILE",
          "}",
          "},",
          "{",
          "Write-Diagnostics \"PowerShell version:\" -fileName $script:POWERSHELL_VERSION_FILE",
          "Write-Diagnostics $PSVersionTable.PSVersion -fileName $script:POWERSHELL_VERSION_FILE",
          "if (Get-Command -Name Get-AWSPowerShellVersion -ErrorAction SilentlyContinue) {",
          "Write-Diagnostics \"Active AWSPowerShell version:\" -fileName $script:POWERSHELL_VERSION_FILE",
          "Write-Diagnostics (Get-AWSPowerShellVersion) -fileName $script:POWERSHELL_VERSION_FILE",
          "}",
          "else {",
          "Write-Diagnostics \"Get-AWSPowerShellVersion not found.\" -fileName $script:POWERSHELL_VERSION_FILE",
          "}",
          "Write-Diagnostics \"All available PowerShell Modules matching AWS*:\" -fileName $script:POWERSHELL_VERSION_FILE",
          "if ($null -ne (Get-Module \"AWS*\")) {",
          "Write-Diagnostics (Get-Module \"AWS*\" | Select-Object Name, Version) -fileName $script:POWERSHELL_VERSION_FILE",
          "}",
          "},",
          "{",
          "if ($script:CollectDiagnosticLogs) {",
          "Write-Diagnostics \"DiskDrives:\" -fileName $script:DIAGNOSTIC_LOG_FILE",
          "Write-Diagnostics \"$(Get-CimInstance -ClassName Win32_DiskDrive | Format-List * | Out-String)\" -fileName $script:DIAGNOSTIC_LOG_FILE",
          "Write-Diagnostics \"DiskPartitions:\" -fileName $script:DIAGNOSTIC_LOG_FILE",
          "Write-Diagnostics \"$(Get-CimInstance -ClassName Win32_DiskPartition | Format-List * | Out-String)\" -fileName $script:DIAGNOSTIC_LOG_FILE",
          "Write-Diagnostics \"LogicalDisks:\" -fileName $script:DIAGNOSTIC_LOG_FILE",
          "Write-Diagnostics \"$(Get-CimInstance -ClassName Win32_LogicalDisk | Format-List * | Out-String)\" -fileName $script:DIAGNOSTIC_LOG_FILE",
          "}",
          "},",
          "\t",
          "{",
          "if ($script:CollectDiagnosticLogs) {",
          "Write-Diagnostics \"Copying Vss Agent logs\" -fileName $script:DIAGNOSTIC_LOG_FILE",
          "if (Test-Path $script:VSS_STDERR) {",
          "Copy-Item $script:VSS_STDERR $script:DIAGNOSTIC_FOLDER_PATH",
          "}",
          "if (Test-Path $script:VSS_STDOUT) {",
          "Copy-Item $script:VSS_STDOUT $script:DIAGNOSTIC_FOLDER_PATH",
          "}",
          "}",
          "},",
          "{",
          "if ($script:CollectDiagnosticLogs) {",
          "Write-Diagnostics \"Collecting SSM Agent logs\" -fileName $script:DIAGNOSTIC_LOG_FILE",
          "New-Item -ItemType \"directory\" -Path $script:DIAGNOSTIC_SSM_LOG_PATH | Out-Null",
          "$SsmLogFolder = \"$env:ProgramData\\Amazon\\SSM\\Logs\"",
          "Copy-Item \"$SsmLogFolder\\amazon-ssm-agent.log\" $script:DIAGNOSTIC_SSM_LOG_PATH",
          "Copy-Item \"$SsmLogFolder\\errors.log\" $script:DIAGNOSTIC_SSM_LOG_PATH",
          "Copy-Item \"$SsmLogFolder\\ssm-agent-worker.log\" $script:DIAGNOSTIC_SSM_LOG_PATH",
          "Copy-Item \"$SsmLogFolder\\ssm-document-worker.log\" $script:DIAGNOSTIC_SSM_LOG_PATH",
          "$auditFile = (Get-ChildItem \"$SsmLogFolder\\audits\" -File)[0].Name",
          "Copy-Item \"$SsmLogFolder\\audits\\$auditFile\" $script:DIAGNOSTIC_SSM_LOG_PATH",
          "}",
          "},",
          "{",
          "if ($script:CollectDiagnosticLogs) {",
          "foreach ($trace in $script:TRACE_INFORMATION) {",
          "try {",
          "Write-Diagnostics \"Stopping $($trace.Name) trace\" -fileName $script:DIAGNOSTIC_LOG_FILE",
          "Invoke-Expression \"logman stop $($trace.Name) -ets\" | Out-Null",
          "}",
          "catch {",
          "Write-Diagnostics \"Exception occurred while stopping $($trace.Name) trace:\" -fileName $script:DIAGNOSTIC_LOG_FILE",
          "Write-ErrorEvent -ErrorCode 6006",
          "Write-ErrorEvent $_.Exception.Message",
          "}",
          "}",
          "}",
          "}",
          ") | ForEach-Object {",
          "try {",
          "Invoke-Expression $_",
          "}",
          "catch {",
          "Write-ErrorEvent -ErrorCode 6001",
          "Write-ErrorEvent $_.Exception.Message",
          "}",
          "}",
          "Write-Diagnostics \"End diagnostic information.\" -fileName $script:DIAGNOSTIC_LOG_FILE",
          "}",
          "function Compress-Directory {",
          "param(",
          "[string]$Path,",
          "[string]$Dest",
          ")",
          "Add-Type -Assembly System.IO.Compression.FileSystem",
          "[System.IO.Compression.ZipFile]::CreateFromDirectory($Path, $Dest)",
          "}",
          "function Save-DiagnosticZip {",
          "$maxRetryAttempts = 5",
          "$maxRetryEndTime = $script:START_TIME.AddSeconds($script:waitForFreezeTimeout)",
          "$retryAttepts = 0",
          "do {",
          "try {",
          "if (Test-Path $script:DIAGNOSTIC_ZIP) {",
          "Remove-Item $script:DIAGNOSTIC_ZIP -Force",
          "}",
          "Compress-Directory -Path $script:DIAGNOSTIC_FOLDER_PATH -Dest $script:DIAGNOSTIC_ZIP",
          "return",
          "}catch {",
          "$exception = $_",
          "$retryAttepts += 1",
          "Start-Sleep -Seconds 10",
          "}",
          "} while ($retryAttepts -lt $maxRetryAttempts -and ((Get-Date) -lt $maxRetryEndTime))",
          "Write-ErrorEvent -ErrorCode 6002",
          "Write-ErrorEvent $exception.Exception.Message",
          "Write-ReturnInformation -Success $false",
          "}",
          "function PrintVssAgentOutput($process) {",
          "$exited = $process.WaitForExit(30 * 1000)",
          "if (-not $exited) {",
          "Write-Log \"VSS Requester did not exit after 30 seconds, stopping.\"",
          "Stop-Process -InputObject $process",
          "}",
          "$out = Get-Content $script:VSS_STDOUT",
          "if ($out) {",
          "$out = [string]::join(\"`n\", $out)",
          "Write-Log $out",
          "}",
          "$out = Get-Content $script:VSS_STDERR",
          "if ($out) {",
          "$out = [string]::join(\"`n\", $out)",
          "Write-Log $out",
          "}",
          "}",
          "function PrintTimeoutTroubleshootingBanner {",
          "Write-Log \"EC2 Images or Snapshots created may not be application-consistent\"",
          "Write-Log \"This is probably due to activity on a volume by an application or service slowing/preventing VSS from progressing,\"",
          "Write-Log \" or in calls to New-EC2Snapshot/New-EC2Image taking longer than expected to complete.\"",
          "Write-Log \"Windows VSS has a non-configurable 10 second period in which snapshots must complete to be guaranteed as Application-Consistent.\"",
          "Write-Log \"\"",
          "Write-Log \"Please consider trying this command again, or attempting snapshots again when the activity on the instance is reduced.\"",
          "}",
          "function Initialize-VssOperationChannel {",
          "param (",
          "[DateTime] $startTime",
          ")",
          "if ($null -ne (Get-Process -Name \"ec2-vss-agent\" -ea SilentlyContinue)) {",
          "Write-ErrorEvent -ErrorCode 2003",
          "return $false",
          "}",
          "Write-Log \"Starting Initialize Vss Operation Channel at $($(New-Timespan $startTime $(Get-Date)).TotalMilliseconds) ms\"",
          "try {",
          "$script:freezePipeServer = New-Object System.IO.Pipes.NamedPipeServerStream($script:FREEZE_NAMED_PIPE,",
          "[System.IO.Pipes.PipeDirection]::InOut,",
          "1,",
          "[System.IO.Pipes.PipeTransmissionMode]::Byte,",
          "[System.IO.Pipes.PipeOptions]::Asynchronous,",
          "0,",
          "256)",
          "Write-DiagnosticLog \"Named pipe server stream for freeze messages created at $($(New-Timespan $startTime $(Get-Date)).TotalMilliseconds) ms\"",
          "$script:waitTaskCancellationToken = New-Object System.Threading.CancellationTokenSource",
          "$script:freezePipeWaitTask = $script:freezePipeServer.WaitForConnectionAsync($script:waitTaskCancellationToken.Token)",
          "Write-DiagnosticLog \"Named pipe server stream waiting for connections at $($(New-Timespan $startTime $(Get-Date)).TotalMilliseconds) ms\"",
          "if (($script:VssAgentVersion.Major) -eq 1) {",
          "$script:thawPipeClient = New-Object System.IO.Pipes.NamedPipeClientStream(\".\",",
          "$script:THAW_NAMED_PIPE,",
          "[System.IO.Pipes.PipeDirection]::In,",
          "[System.IO.Pipes.PipeOptions]::Asynchronous)",
          "Write-DiagnosticLog \"Named pipe client stream for thaw messages created at $($(New-Timespan $startTime $(Get-Date)).TotalMilliseconds) ms\"",
          "}",
          "}",
          "catch {",
          "$initException = $_",
          "Write-DiagnosticLog \"Creating named pipes for VSS messages failed at $($(New-Timespan $startTime $(Get-Date)).TotalMilliseconds) ms with exception \"",
          "Write-DiagnosticLog ($initException.Exception | Out-String)",
          "Write-DiagnosticLog ($initException.InvocationInfo | Out-String)",
          "if ($null -eq $script:freezePipeServer) {",
          "Write-ErrorEvent -ErrorCode 2001",
          "} elseif (($null -eq $script:thawPipeClient) -and ($script:VssAgentVersion.Major -eq 1)) {",
          "Write-ErrorEvent -ErrorCode 2002",
          "} else {",
          "Write-ErrorEvent -ErrorCode 4005",
          "}",
          "return $false",
          "}",
          "return $true",
          "}",
          "function Close-VssOperationChannel {",
          "param (",
          "[DateTime] $startTime",
          ")",
          "Write-Log \"Disposing pipes at $($(New-Timespan $startTime $(Get-Date)).TotalMilliseconds) ms\"",
          "if ($null -ne $script:freezePipeWaitTask) {",
          "if (-not $script:freezePipeWaitTask.IsCompleted) {",
          "$script:waitTaskCancellationToken.Cancel()",
          "}",
          "try {",
          "$script:freezePipeWaitTask.Dispose()",
          "} catch {",
          "Write-Log \"Disposing of freezePipe read task failed: $($_.Exception.Message)\"",
          "}",
          "}",
          "if ($null -ne $script:freezePipeReader) {",
          "$script:freezePipeReader.Dispose()",
          "}",
          "if ($null -ne $script:freezePipeServer) {",
          "$script:freezePipeServer.Dispose()",
          "}",
          "if ($null -ne $script:thawPipeReader) {",
          "$script:thawPipeReader.Dispose()",
          "}",
          "if ($null -ne $script:thawPipeClient) {",
          "$script:thawPipeClient.Dispose()",
          "}",
          "$script:thawPipeClient = $null",
          "$script:freezePipeReader = $null",
          "$script:thawPipeReader = $null",
          "$script:freezePipeServer = $null",
          "$script:freezePipeWaitTask = $null",
          "}",
          "function Wait-ForVssFreezeMessage {",
          "param (",
          "[DateTime] $startTime,",
          "[string]$agentParams",
          ")",
          "$script:processHandleCache = $null",
          "Write-Log \"Starting VSS Agent at $($(New-Timespan $startTime $(Get-Date)).TotalMilliseconds) ms\"",
          "Set-OutputMode -Buffered",
          "$script:agentProcess = Start-Process $script:VSS_AGENT_PATH $agentParams -PassThru -RedirectStandardError $script:VSS_STDERR -RedirectStandardOutput $script:VSS_STDOUT",
          "if ($null -eq $script:agentProcess) {",
          "Write-ErrorEvent -ErrorCode 2004",
          "return $null",
          "}",
          "$script:processHandleCache = $script:agentProcess.Handle",
          "try {",
          "Write-Log \"Waiting for Freeze pipe at $($(New-Timespan $startTime $(Get-Date)).TotalMilliseconds) ms\"",
          "$script:maxFreezePipeWaitTime = (Get-Date).AddSeconds($script:waitForFreezeTimeout)",
          "while ((Get-Date) -lt $script:maxFreezePipeWaitTime) {",
          "if ($script:freezePipeWaitTask.Wait(5*1000)){",
          "$script:freezeStartTime = $(Get-Date)",
          "Write-Log \"Freeze pipe connected at $($(New-Timespan $startTime $script:freezeStartTime).TotalMilliseconds) ms\"",
          "break",
          "}",
          "if ($script:agentProcess.HasExited) {",
          "Write-Log \"VSS Agent has exited unexpectedly at $($(New-Timespan $startTime $($script:agentProcess.ExitTime)).TotalMilliseconds) ms\"",
          "PrintVssAgentOutput $script:agentProcess",
          "Write-ErrorEvent -ErrorCode 2011",
          "return $null",
          "}",
          "}",
          "if (-not $script:freezePipeServer.IsConnected) {",
          "PrintVssAgentOutput $script:agentProcess",
          "Write-ErrorEvent -ErrorCode 2005",
          "return $null",
          "}",
          "$script:freezePipeReader = New-Object System.IO.StreamReader($script:freezePipeServer)",
          "$freezePipeReadTask = $script:freezePipeReader.ReadLineAsync()",
          "if (-not $freezePipeReadTask.Wait(($script:maxFreezePipeWaitTime-(Get-Date)).TotalMilliseconds)) {",
          "PrintVssAgentOutput $script:agentProcess",
          "Write-ErrorEvent -ErrorCode 2012",
          "return $null",
          "}",
          "$message = $freezePipeReadTask.GetAwaiter().GetResult()",
          "Write-Log \"Received EBS snapshot Freeze message: $message at $($(New-Timespan $startTime $(Get-Date)).TotalMilliseconds)\"",
          "} catch {",
          "Write-ErrorEvent -ErrorCode 2006",
          "Write-ErrorEvent $_.Exception.Message",
          "return $null",
          "}",
          "return @{",
          "Process=$script:agentProcess;",
          "Message=$message",
          "}",
          "}",
          "function Wait-ForVssThawMessage {",
          "param (",
          "[DateTime] $startTime",
          ")",
          "$thawStartTime = $(Get-Date)",
          "$thawStartTimeMS = $($(New-Timespan $startTime $thawStartTime)).TotalMilliseconds",
          "$errorCode = 0",
          "Write-Log \"Thaw pipe waiting for connection at $thawStartTimeMS ms\"",
          "try {",
          "$script:thawPipeClient.Connect(10000)",
          "} catch {",
          "Write-Log \"Thaw pipe connection failed at $($(New-Timespan $startTime $(Get-Date)).TotalMilliseconds) ms\"",
          "if ((New-TimeSpan $script:freezeStartTime $thawStartTime).TotalMilliseconds -gt 9000) {",
          "$errorCode = 10",
          "} else {",
          "$errorCode = 20",
          "}",
          "Write-ErrorEvent $_.Exception.Message",
          "return @{",
          "ErrorCode=$errorCode;",
          "Message=$null",
          "}",
          "}",
          "Write-Log \"Thaw pipe connected at $($(New-Timespan $startTime $(Get-Date)).TotalMilliseconds) ms\"",
          "try {",
          "$script:thawPipeReader = New-Object System.IO.StreamReader($script:thawPipeClient)",
          "$string = $script:thawPipeReader.ReadLine()",
          "} catch {",
          "$errorCode = 30",
          "Write-ErrorEvent $_.Exception.Message",
          "return @{",
          "ErrorCode=$errorCode;",
          "Message=$null",
          "}",
          "}",
          "$script:outputInformation[\"FreezeTimeInMS\"] = [int](New-Timespan $script:freezeStartTime $(Get-Date)).TotalMilliseconds",
          "Write-Log \"Pipe message read at $($(New-Timespan $startTime $(Get-Date)).TotalMilliseconds) ms\"",
          "return @{",
          "ErrorCode=$errorCode;",
          "Message=$string",
          "}",
          "}",
          "function EbsVssFreeze {",
          "param (",
          "[string]$driveLetter,",
          "[DateTime]$startTime,",
          "[boolean]$copyOnly,",
          "[boolean]$noWriters",
          ")",
          "$params = $driveLetter",
          "if ($copyOnly) {",
          "Write-Log \"Copy only option selected\"",
          "$params = \"-copy \" + $params",
          "}",
          "if ($noWriters) {",
          "Write-Log \"No writers option selected\"",
          "$params = \"-nw \" + $params",
          "}",
          "if ($script:SaveVssMetadata) {",
          "Write-Log \"Save Vss Metadata option selected\"",
          "$params = \"-saveMetadata \" + $params",
          "}",
          "$FreezeInfo = Wait-ForVssFreezeMessage -StartTime $startTime -agentParams $params",
          "return $FreezeInfo",
          "}",
          "function EbsVssThaw {",
          "param (",
          "[System.DateTime] $startTime = $(Get-Date)",
          ")",
          "$thawResult = Wait-ForVssThawMessage -StartTime $startTime",
          "Set-OutputMode -UnBuffered",
          "if ($thawResult.Message -like 'EBS done') {",
          "Write-Log \"Pipe message read at $($(New-Timespan $startTime $(Get-Date)).TotalMilliseconds) ms\"",
          "return 0",
          "} else {",
          "if ($thawResult.Message -like 'EBS timeout') {",
          "return 50",
          "} elseif ($thawResult.ErrorCode -eq 0) {",
          "Write-ErrorEvent \"Message: $($thawResult.Message)\"",
          "return 40",
          "}",
          "return $thawResult.ErrorCode",
          "}",
          "}",
          "function Get-EC2InstanceId {",
          "return $env:AWS_SSM_INSTANCE_ID",
          "}",
          "$script:BlockDeviceMappings = $null",
          "function Get-BlockDeviceMappings {",
          "if ($null -ne $script:BlockDeviceMappings) {",
          "return $script:BlockDeviceMappings",
          "}",
          "$instanceId = Get-EC2InstanceId",
          "if (-not $instanceId) {",
          "Write-ErrorEvent -ErrorCode 1004",
          "throw \"Failed to get instance-id\"",
          "}",
          "try {",
          "$script:BlockDeviceMappings = (Get-EC2InstanceAttribute -InstanceId $instanceId -Attribute BlockDeviceMapping).BlockDeviceMappings",
          "if ($null -ne $script:BlockDeviceMappings) {",
          "return $script:BlockDeviceMappings",
          "}",
          "} catch {",
          "$describeAttributeException = $_.Exception",
          "}",
          "try {",
          "$script:BlockDeviceMappings = (Get-EC2Instance -Instance $instanceId).Instances.BlockDeviceMappings",
          "if ($null -ne $script:BlockDeviceMappings) {",
          "return $script:BlockDeviceMappings",
          "}",
          "} catch {",
          "$describeInstancesException = $_.Exception",
          "}",
          "$describeAttributeNoPerm = $describeAttributeException.ToString().Contains(\"not authorized\")",
          "$describeInstancesNoPerm = $describeInstancesException.ToString().Contains(\"not authorized\")",
          "Write-Log \"First option DescribeInstanceAttribute failed due to $($describeAttributeException.Message)\"",
          "Write-Log \"Fallback option DescribeInstances failed due to $($describeInstancesException.Message)\"",
          "if ($describeAttributeNoPerm -and $describeInstancesNoPerm) {",
          "Write-ErrorEvent -ErrorCode 3003",
          "Write-ErrorEvent \"Verify that the attached instance role has DescribeInstanceAttribute permission\"",
          "throw $describeAttributeException.Message",
          "}",
          "elseif ($describeAttributeNoPerm -and -not $describeInstancesNoPerm) {",
          "Write-ErrorEvent -ErrorCode 3001",
          "throw $describeInstancesException.Message",
          "}",
          "else {",
          "Write-ErrorEvent -ErrorCode 3002",
          "throw $describeAttributeException.Message",
          "}",
          "}",
          "function Convert-SCSITargetIdToDeviceName {",
          "param([int]$SCSITargetId)",
          "If ($SCSITargetId -eq 0) {",
          "return '/dev/sda1'",
          "}",
          "$deviceName = 'xvd'",
          "If ($SCSITargetId -gt 25) {",
          "$deviceName += [char](0x60 + [int]($SCSITargetId / 26))",
          "}",
          "$deviceName += [char](0x61 + $SCSITargetId % 26)",
          "return $deviceName",
          "}",
          "function Get-DynamicDiskPartitionsOnEBSVolumes {",
          "$BlockDeviceMappings = Get-BlockDeviceMappings",
          "$diskList = Get-WmiObject -Class Win32_DiskDrive | ForEach-Object {",
          "$DiskDrive = $_",
          "$LogicalDiskManagerPartitions = Get-WmiObject -Query \"ASSOCIATORS OF {Win32_DiskDrive.DeviceID='$($DiskDrive.DeviceID)'} WHERE AssocClass=Win32_DiskDriveToDiskPartition\" | Where-Object {$_.Type -match \"Logical Disk Manager\"}",
          "if (-not $LogicalDiskManagerPartitions) {",
          "return",
          "}",
          "$Volumes = $LogicalDiskManagerPartitions | ForEach-Object {",
          "$DiskPartition = $_",
          "Get-WmiObject -Query \"ASSOCIATORS OF {Win32_DiskPartition.DeviceID='$($DiskPartition.DeviceID)'} WHERE AssocClass=Win32_LogicalDiskToPartition\"",
          "}",
          "$volumeNumber = $DiskDrive.SerialNumber | Select-String $script:EBS_VOLUME_MATCH | % { $_.Matches } | % { $_.Value }",
          "if ($null -eq $volumeNumber) {",
          "$volumeNumber = $DiskDrive.SerialNumber | Select-String $script:EBS_VOLUME_MATCH2 | % { $_.Matches } | % { $_.Value }",
          "}",
          "if ($null -ne $volumeNumber) {",
          "$ebsVolumeId = \"vol-$volumeNumber\"",
          "$BlockDevice = $BlockDeviceMappings | Where-Object { $_.Ebs.VolumeId -eq $ebsVolumeId }",
          "if ($null -ne $BlockDevice) {",
          "$BlockDeviceName = $BlockDevice.DeviceName",
          "}",
          "}",
          "elseif ($DiskDrive.PNPDeviceID -like \"*PROD_PVDISK*\") {",
          "$BlockDeviceName = Convert-SCSITargetIdToDeviceName($DiskDrive.SCSITargetId)",
          "$BlockDevice = $BlockDeviceMappings | Where-Object { $_.DeviceName -like (\"*\" + $BlockDeviceName) }",
          "}",
          "else {",
          "$BlockDeviceName = $null",
          "$BlockDevice = $null",
          "}",
          "$foundWriteableVolume = $false",
          "foreach ($volume in $Volumes) {",
          "if ($volume.Access -ne 1) {",
          "$foundWriteableVolume = $true",
          "}",
          "}",
          "if ($null -ne $BlockDevice -and $null -ne $BlockDevice.Ebs) {",
          "New-Object PSObject -Property @{",
          "Disk = $DiskDrive.Index;",
          "Partitions = $DiskDrive.Partitions;",
          "AccessPath = If ($null -eq $Volumes) { $null } Else { $Volumes.DeviceID };",
          "EbsVolumeId = If ($null -eq $BlockDevice) { $null } Else { $BlockDevice.Ebs.VolumeId };",
          "Device = If ($null -eq $BlockDeviceName) { $null } Else { $BlockDeviceName };",
          "VolumeName = If ($null -eq $Volumes) { $null } Else { $Volumes.VolumeName };",
          "IsReadOnly = If (-not $foundWriteableVolume) { $true } Else { $false };",
          "}",
          "}",
          "} | Sort-Object Disk",
          "return $diskList",
          "}",
          "function Get-AwsNvmeStorageSpacesEbsDiskMapping {",
          "$disklist = @()",
          "$physicalDisks = @()",
          "$physicalDisks += Get-PhysicalDisk | Where-Object {",
          "(($_.Manufacturer -match 'NVMe') -and ($_.Model -match 'Amazon') -and",
          "($_.SerialNumber -match $script:EBS_VOLUME_MATCH)) -or",
          "((Get-Member -InputObject $_ -Name \"AdapterSerialNumber\") -and ($_.AdapterSerialNumber -match $script:EBS_VOLUME_MATCH2))",
          "}",
          "if (!$physicalDisks -or ($physicalDisks.Count -eq 0)) {",
          "return $null",
          "}",
          "$BlockDeviceMappings = Get-BlockDeviceMappings",
          "foreach ($pd in $physicalDisks) {",
          "$pool1 = Get-StoragePool -PhysicalDisk $pd -IsPrimordial $False -ErrorAction SilentlyContinue",
          "$volumeNumber = $pd.SerialNumber | Select-String $script:EBS_VOLUME_MATCH | % { $_.Matches } | % { $_.Value }",
          "if ($null -eq $volumeNumber) {",
          "$volumeNumber = $pd.AdapterSerialNumber | Select-String $script:EBS_VOLUME_MATCH2 | % { $_.Matches } | % { $_.Value }",
          "}",
          "$ebsVolumeId = \"vol-$volumeNumber\"",
          "$matchingBlockDevice = $BlockDeviceMappings | Where-Object {($null -ne $_.Ebs) -and ($_.Ebs.VolumeId -eq $ebsVolumeId)}",
          "foreach ($vd in Get-VirtualDisk) {",
          "$pool2 = Get-StoragePool -VirtualDisk $vd",
          "if (($pool1 -like $pool2) -and ($null -ne $volumeNumber)) {",
          "$disk = ($vd | Get-Disk)",
          "$parts = @($disk | Get-Partition | Where-Object -Property Type -NE Reserved | Where-Object -Property Type -NE \"XINT13 Extended\")",
          "foreach ($part in $parts) {",
          "$vol = ($part | Get-Volume)",
          "$isReadOnly = ($pool2.IsReadOnly -or $disk.IsReadOnly -or $part.IsReadOnly)",
          "$diskList += New-Object PSObject -Property @{",
          "Disk = If ($null -eq $pd) { $null } Else { $pd.DeviceId };",
          "Partitions = 0;",
          "AccessPath = If ($null -ne $vol -and $vol.DriveLetter) { ($vol.DriveLetter + ':') } elseif ($part.AccessPaths) { $part.AccessPaths[0] } else { $null };",
          "EbsVolumeId = If ($null -eq $pd) { $null } Else { $ebsVolumeId };",
          "Device = If ($null -eq $matchingBlockDevice) { $pd.FriendlyName } Else { $matchingBlockDevice.DeviceName };",
          "VolumeName = If ($null -eq $vol) { $null } Else { $vol.FileSystemLabel };",
          "IsReadOnly = $isReadOnly;",
          "}",
          "}",
          "}",
          "}",
          "}",
          "return $disklist",
          "}",
          "function Get-XenStorageSpacesEbsDiskMapping {",
          "$disklist = @()",
          "$physicalDisks = @()",
          "$ATTACHMENT_ORDER_MATCH = '^(\\d{4})$'",
          "$physicalDisks += Get-PhysicalDisk | Where-Object {",
          "($_.SerialNumber -match $ATTACHMENT_ORDER_MATCH -and $_.SerialNumber -ne '0000') -or",
          "(($_.SerialNumber -match $script:EBS_VOLUME_MATCH2) -and",
          "($_.Manufacturer -match 'AWS' -and $_.Model -match 'PVDISK'))",
          "}",
          "if (!$physicalDisks -or ($physicalDisks.Count -eq 0)) {",
          "return $null",
          "}",
          "$BlockDeviceMappings = Get-BlockDeviceMappings",
          "foreach ($pd in $physicalDisks) {",
          "$volumeNumber = $pd.SerialNumber | Select-String $script:EBS_VOLUME_MATCH2 | % { $_.Matches } | % { $_.Value }",
          "if ($null -ne $volumeNumber) {",
          "$ebsVolumeId = \"vol-$volumeNumber\"",
          "$device = $BlockDeviceMappings | Where-Object { $_.Ebs.VolumeId -eq $ebsVolumeId }",
          "if ($null -ne $device) {",
          "$BlockDeviceName = $device.DeviceName",
          "}",
          "else {",
          "Write-Log \"Found disk with unrecognized volume id: $ebsVolumeId. Ignoring as instance store\"",
          "$BlockDeviceName = $null",
          "$ebsVolumeId = $null",
          "}",
          "}",
          "elseif ($pd.SerialNumber -match $ATTACHMENT_ORDER_MATCH) {",
          "$BlockDeviceName = Convert-SCSITargetIdToDeviceName $pd.SerialNumber",
          "$device = $BlockDeviceMappings | Where-Object {$_.DeviceName -like (\"*\" + $BlockDeviceName)}",
          "if ($null -ne $device) {",
          "$ebsVolumeId = $device.Ebs.VolumeId",
          "}",
          "else {",
          "Write-Log \"Found disk with unrecognized block device: $BlockDeviceName. Ignoring as instance store\"",
          "$ebsVolumeId = $null",
          "}",
          "}",
          "else {",
          "Write-Log \"Found disk with unrecognized serial number: $($pd.SerialNumber). Will ignore.\"",
          "$BlockDeviceName = $null",
          "$ebsVolumeId = $null",
          "}",
          "$pool1 = Get-StoragePool -PhysicalDisk $pd -IsPrimordial $False -ErrorAction SilentlyContinue",
          "foreach ($vd in Get-VirtualDisk) {",
          "$pool2 = Get-StoragePool -VirtualDisk $vd",
          "if (($pool1 -like $pool2) -and ($null -ne $ebsVolumeId)) {",
          "$disk = ($vd | Get-Disk)",
          "$parts = @($disk | Get-Partition | Where-Object -Property Type -NE Reserved | Where-Object -Property Type -NE \"XINT13 Extended\")",
          "foreach ($part in $parts) {",
          "$vol = ($part | Get-Volume)",
          "$isReadOnly = ($pool2.IsReadOnly -or $disk.IsReadOnly -or $part.IsReadOnly)",
          "$diskList += New-Object PSObject -Property @{",
          "Disk = If ($null -eq $pd) { $null } Else { $pd.DeviceId };",
          "Partitions = 0;",
          "AccessPath = If ($null -ne $vol -and $vol.DriveLetter) { ($vol.DriveLetter + ':') } elseif ($part.AccessPaths) { $part.AccessPaths[0] } else { $null };",
          "EbsVolumeId = If ($null -eq $pd) { $null } Else { $ebsVolumeId };",
          "Device = If ($null -eq $pd) { $null } Else { $BlockDeviceName };",
          "VolumeName = If ($null -eq $vol) { $null } Else { $vol.FileSystemLabel };",
          "IsReadOnly = $isReadOnly;",
          "}",
          "}",
          "}",
          "}",
          "}",
          "return $disklist",
          "}",
          "function Get-EbsDiskMappingFromWMI {",
          "$disklist = @()",
          "$physicalDisks = @()",
          "$ATTACHMENT_ORDER_MATCH = '^(\\d{4})$'",
          "$physicalDisks += Get-CimInstance -ClassName Win32_DiskDrive | Where-Object {",
          "($_.SerialNumber -match $ATTACHMENT_ORDER_MATCH) -or",
          "($_.SerialNumber -match $script:EBS_VOLUME_MATCH2 -and $_.Model -match 'AWS PVDISK') -or",
          "($_.SerialNumber -match $script:EBS_VOLUME_MATCH)",
          "}",
          "if (-not $physicalDisks -or ($physicalDisks.Count -eq 0)) {",
          "return $null",
          "}",
          "$BlockDeviceMappings = Get-BlockDeviceMappings",
          "foreach ($pd in $physicalDisks) {",
          "Write-Log \"Checking physical disk $($pd.SerialNumber) ...\"",
          "$volumeNumber = $pd.SerialNumber | Select-String $script:EBS_VOLUME_MATCH | % { $_.Matches } | % { $_.Value }",
          "if ($null -eq $volumeNumber) {",
          "$volumeNumber = $pd.SerialNumber | Select-String $script:EBS_VOLUME_MATCH2 | % { $_.Matches } | % { $_.Value }",
          "}",
          "if ($null -ne $volumeNumber) {",
          "$ebsVolumeId = \"vol-$volumeNumber\"",
          "$device = $BlockDeviceMappings | Where-Object { $_.Ebs.VolumeId -eq $ebsVolumeId }",
          "if ($null -ne $device) {",
          "$BlockDeviceName = $device.DeviceName",
          "}",
          "else {",
          "Write-Log \"Found disk with unrecognized volume id: $ebsVolumeId. Ignoring as instance store\"",
          "continue",
          "}",
          "}",
          "elseif ($pd.SerialNumber -match $ATTACHMENT_ORDER_MATCH) {",
          "$BlockDeviceName = Convert-SCSITargetIdToDeviceName $pd.SerialNumber",
          "$device = $BlockDeviceMappings | Where-Object {$_.DeviceName -like (\"*\" + $BlockDeviceName)}",
          "if ($null -ne $device) {",
          "$ebsVolumeId = $device.Ebs.VolumeId",
          "}",
          "else {",
          "Write-Log \"Found disk with unrecognized block device: $BlockDeviceName. Ignoring as instance store\"",
          "continue",
          "}",
          "}",
          "else {",
          "Write-Log \"Found disk with unrecognized serial number: $($pd.SerialNumber). Will ignore.\"",
          "continue",
          "}",
          "Write-Log \"EBS volume id: $ebsVolumeId\"",
          "Write-Log \"Device name: $BlockDeviceName\"",
          "$partitions = $pd | Get-CimAssociatedInstance -Association Win32_diskdriveToDiskPartition",
          "foreach ($partition in $partitions) {",
          "Write-Log \"Checking physical disk's partition $($partition.DeviceId) ...\"",
          "if ($partition.Type -eq 'GPT: Basic Data' -or $partition.Type -eq 'Installable File System') {",
          "$volume = $partition | Get-CimAssociatedInstance -Association Win32_LogicalDiskToPartition | Select-Object -First 1",
          "if ($volume) {",
          "Write-Log \"Found volume $($volume.DeviceID)\"",
          "$diskInfo = New-Object PSObject -Property @{",
          "Disk = $pd.DeviceID",
          "Partitions = 0",
          "AccessPath = $volume.DeviceID",
          "EbsVolumeId = $ebsVolumeId",
          "Device = $BlockDeviceName",
          "VolumeName = $volume.VolumeName",
          "IsReadOnly = $volume.Access -eq 1 ",
          "}",
          "$diskList += $diskInfo",
          "}",
          "else {",
          "Write-Log \"No volume found for partition $($partition.DeviceID) on physical disk $($pd.DeviceID)\"",
          "}",
          "}",
          "}",
          "}",
          "return $disklist",
          "}",
          "function Get-EbsDiskMapping {",
          "$disklist = @()",
          "$physicalDisks = @()",
          "$ATTACHMENT_ORDER_MATCH = '^(\\d{4})$'",
          "$physicalDisks += Get-PhysicalDisk | Where-Object {",
          "($_.SerialNumber -match $ATTACHMENT_ORDER_MATCH) -or",
          "(($_.SerialNumber -match $script:EBS_VOLUME_MATCH2) -and",
          "($_.Manufacturer -match 'AWS' -and $_.Model -match 'PVDISK')) -or",
          "($_.SerialNumber -match $script:EBS_VOLUME_MATCH)",
          "}",
          "if (!$physicalDisks -or ($physicalDisks.Count -eq 0)) {",
          "return $null",
          "}",
          "$BlockDeviceMappings = Get-BlockDeviceMappings",
          "foreach ($pd in $physicalDisks) {",
          "$volumeNumber = $pd.SerialNumber | Select-String $script:EBS_VOLUME_MATCH | % { $_.Matches } | % { $_.Value }",
          "if ($null -eq $volumeNumber) {",
          "$volumeNumber = $pd.SerialNumber | Select-String $script:EBS_VOLUME_MATCH2 | % { $_.Matches } | % { $_.Value }",
          "}",
          "if ($null -ne $volumeNumber) {",
          "$ebsVolumeId = \"vol-$volumeNumber\"",
          "$device = $BlockDeviceMappings | Where-Object { $_.Ebs.VolumeId -eq $ebsVolumeId }",
          "if ($null -ne $device) {",
          "$BlockDeviceName = $device.DeviceName",
          "}",
          "else {",
          "Write-Log \"Found disk with unrecognized volume id: $ebsVolumeId. Ignoring as instance store\"",
          "$BlockDeviceName = $null",
          "$ebsVolumeId = $null",
          "}",
          "}",
          "elseif ($pd.SerialNumber -match $ATTACHMENT_ORDER_MATCH) {",
          "$BlockDeviceName = Convert-SCSITargetIdToDeviceName $pd.SerialNumber",
          "$device = $BlockDeviceMappings | Where-Object {$_.DeviceName -like (\"*\" + $BlockDeviceName)}",
          "if ($null -ne $device) {",
          "$ebsVolumeId = $device.Ebs.VolumeId",
          "}",
          "else {",
          "Write-Log \"Found disk with unrecognized block device: $BlockDeviceName. Ignoring as instance store\"",
          "$ebsVolumeId = $null",
          "}",
          "}",
          "else {",
          "Write-Log \"Found disk with unrecognized serial number: $($pd.SerialNumber). Will ignore.\"",
          "$BlockDeviceName = $null",
          "$ebsVolumeId = $null",
          "}",
          "$disk = ($pd | Get-Disk -ErrorAction Ignore) ",
          "$parts = @($disk | Get-Partition | Where-Object -Property Type -NE Reserved | Where-Object -Property Type -NE \"XINT13 Extended\")",
          "foreach ($part in $parts) {",
          "$vol = ($part | Get-Volume)",
          "$isReadOnly = ($disk.IsReadOnly -or $part.IsReadOnly)",
          "$diskList += New-Object PSObject -Property @{",
          "Disk = If ($null -eq $pd) { $null } Else { $pd.DeviceId };",
          "Partitions = 0;",
          "AccessPath = If ($null -ne $vol -and $vol.DriveLetter) { ($vol.DriveLetter + ':') } elseif ($part.AccessPaths) { $part.AccessPaths[0] } else { $null };",
          "EbsVolumeId = If ($null -eq $pd) { $null } Else { $ebsVolumeId };",
          "Device = If ($null -eq $pd) { $null } Else { $BlockDeviceName };",
          "VolumeName = If ($null -eq $vol) { $null } Else { $vol.FileSystemLabel };",
          "IsReadOnly = $isReadOnly;",
          "}",
          "}",
          "}",
          "return $disklist",
          "}",
          "function Get-EbsConnectedVolume",
          "{",
          "$diskList = @()",
          "$disks = Get-EbsDiskMapping",
          "if ($disks) {",
          "Write-DiagnosticLog \"Mapped simple volumes with Get-Disk:\"",
          "Write-DiagnosticLog ($disks | ConvertTo-Json -Compress)",
          "$diskList += $disks",
          "}",
          "$disks = Get-EbsDiskMappingFromWMI",
          "if ($disks) {",
          "Write-DiagnosticLog \"Mapped simple volumes with Get-CimInstance:\"",
          "Write-DiagnosticLog ($disks | ConvertTo-Json -Compress)",
          "$diskList += $disks",
          "}",
          "$disks = Get-XenStorageSpacesEbsDiskMapping",
          "if ($disks) {",
          "Write-DiagnosticLog \"Mapped Xen Storage Spaces volumes:\"",
          "Write-DiagnosticLog ($disks | ConvertTo-Json -Compress)",
          "$diskList += $disks",
          "}",
          "$disks = Get-AwsNvmeStorageSpacesEbsDiskMapping",
          "if ($disks) {",
          "Write-DiagnosticLog \"Mapped NVMe Storage Spaces volumes:\"",
          "Write-DiagnosticLog ($disks | ConvertTo-Json -Compress)",
          "$diskList += $disks",
          "}",
          "$disks = Get-DynamicDiskPartitionsOnEBSVolumes",
          "if ($disks) {",
          "Write-DiagnosticLog \"Mapped Dynamic Disk volumes:\"",
          "Write-DiagnosticLog ($disks | ConvertTo-Json -Compress)",
          "$diskList += $disks",
          "}",
          "return $diskList",
          "}",
          "function New-TagSpecification {",
          "param(",
          "[string]$resourceType,",
          "[Amazon.EC2.Model.Tag[]]$Tags",
          ")",
          "$tagSpec = New-Object Amazon.EC2.Model.TagSpecification",
          "$tagSpec.ResourceType = $resourceType",
          "$tagSpec.Tags = $Tags",
          "return $tagSpec",
          "}",
          "function Tag-Snapshots {",
          "param(",
          "[System.Object[]]$SnapshotsData,",
          "[System.Object]$AmiData,",
          "[boolean]$AppConsistent,",
          "[Parameter(Mandatory = $false)][Amazon.EC2.Model.Tag[]]$Tags",
          ")",
          "$Tag = New-Object Amazon.EC2.Model.Tag",
          "$Tag.Key = \"AppConsistent\"",
          "$Tag.Value = \"$AppConsistent\"",
          "$Tags += $Tag",
          "$tagSuccess = $true",
          "if ($AmiData) {",
          "try {",
          "New-EC2Tag -Resources $AmiData.ImageId -Tags $Tags",
          "} catch {",
          "Write-ErrorEvent -ErrorCode 2",
          "Write-ErrorEvent $_.Exception.Message",
          "$tagSuccess = $false",
          "}",
          "}",
          "foreach ($SnapshotData in $SnapshotsData) {",
          "$Tag = New-Object Amazon.EC2.Model.Tag",
          "$Tag.Key = \"Device\"",
          "$Tag.Value = $SnapshotData.Device",
          "$AllTags = $Tags + $Tag",
          "try {",
          "New-EC2Tag -Resources $SnapshotData.SnapshotId -Tags $AllTags",
          "} catch {",
          "Write-ErrorEvent -ErrorCode 1",
          "Write-ErrorEvent $_.Exception.Message",
          "$tagSuccess = $false",
          "break;",
          "}",
          "}",
          "return $tagSuccess",
          "}",
          "function Get-OSVersionNumber {",
          "return ([Decimal]([environment]::OSVersion.Version).Major + [Decimal]([environment]::OSVersion.Version).Minor * .1)",
          "}",
          "function Get-VssAgentVersion {",
          "if (-not (Test-Path $script:VSS_AGENT_PATH )) {",
          "return 0",
          "}",
          "$vssAgentFileInfo = Get-Item $script:VSS_AGENT_PATH",
          "$vssAgentFileVersion = $vssAgentFileInfo.VersionInfo.FileVersion",
          "$script:VssAgentVersion.Major = [int]$vssAgentFileVersion.Split('.')[0]",
          "$script:VssAgentVersion.Minor = [int]$vssAgentFileVersion.Split('.')[1]",
          "$script:VssAgentVersion.Patch = [int]$vssAgentFileVersion.Split('.')[2]",
          "return $vssAgentFileVersion",
          "}",
          "function Get-VssProviderDllVersion {",
          "if (-not (Test-Path $script:VSS_PROVIDER_PATH )) {",
          "return 0",
          "}",
          "return ((Get-Item $script:VSS_PROVIDER_PATH).VersionInfo.FileVersion)",
          "}",
          "function Send-VssContext {",
          "param (",
          "$context,",
          "[DateTime] $startTime",
          ")",
          "try {",
          "$contextString = ConvertTo-Json $context -Compress -Depth 2",
          "Write-DiagnosticLog \"ContextString: $contextString\"",
          "Write-Log \"Sending Context to Provider at $($(New-Timespan $startTime $(Get-Date)).TotalMilliseconds) ms\"",
          "$encoder = New-Object ([System.Text.Encoding]::UTF8)",
          "$contextInBytes = $encoder.GetBytes($contextString)",
          "$script:freezePipeServer.Write($contextInBytes, 0, $contextInBytes.Length)",
          "$script:freezePipeServer.Flush()",
          "}",
          "catch {",
          "Write-ErrorEvent -ErrorCode 2101",
          "Write-ErrorEvent $_.Exception.Message",
          "return $false",
          "}",
          "Write-Log \"Sent Context to Provider at $($(New-Timespan $startTime $(Get-Date)).TotalMilliseconds) ms\"",
          "return $true",
          "}",
          "function Wait-VssResult {",
          "param (",
          "[DateTime] $startTime",
          ")",
          "Write-Log \"Waiting for result from provider at $($(New-Timespan $startTime $(Get-Date)).TotalMilliseconds) ms\"",
          "$timeoutMS = $script:waitForFreezeTimeout * 1000",
          "try {",
          "$script:freezePipeReadAsyncHandle = $script:freezePipeReader.ReadLineAsync()",
          "$GotResult = $script:freezePipeReadAsyncHandle.Wait($timeoutMS)",
          "}",
          "catch {",
          "Write-ErrorEvent -ErrorCode 2102",
          "Write-ErrorEvent $_.Exception.Message",
          "return $null",
          "}",
          "if ($GotResult) {",
          "$JsonResponse = $script:freezePipeReadAsyncHandle.Result",
          "Write-DiagnosticLog \"Return Value from Provider: $JsonResponse\"",
          "if ($null -eq $JsonResponse) {",
          "Write-ErrorEvent -ErrorCode 2103",
          "return $null",
          "}",
          "Write-Log \"Got result at $($(New-Timespan $startTime $(Get-Date)).TotalMilliseconds) ms\"",
          "Set-OutputMode -UnBuffered",
          "try {",
          "$ResponseObject = ConvertFrom-Json $JsonResponse",
          "} catch {",
          "Write-ErrorEvent -ErrorCode 2104",
          "return $null",
          "}",
          "$ResponseHashtable = Read-VssResult $ResponseObject",
          "return $ResponseHashtable",
          "}",
          "else {",
          "Write-ErrorEvent -ErrorCode 2105",
          "return $null",
          "}",
          "}",
          "function Get-PropertyFromProviderResponse {",
          "param (",
          "[PSobject]$Object,",
          "[String]$Property",
          ")",
          "if ((($Object | Get-Member -MemberType \"NoteProperty\").Name) -contains $Property) {",
          "return $Object.$Property",
          "} else {",
          "Write-DiagnosticLog \"Provider response does not contain $Property for this object\"",
          "Write-DiagnosticLog ($SnapshotReponse | Format-List -Force | Out-String)",
          "return \"\"",
          "}",
          "}",
          "function Read-VssResult {",
          "param (",
          "$ProviderResponse",
          ")",
          "$properties = ($ProviderResponse | Get-Member -MemberType \"NoteProperty\").Name",
          "$result = @{}",
          "if ($properties -contains \"ResponseMessage\") {",
          "Write-Log $ProviderResponse.ResponseMessage",
          "$result[\"ResponseMessage\"] = $ProviderResponse.ResponseMessage",
          "}",
          "if ($properties -contains \"ResponseId\") {",
          "Write-Log \"Snapshot ResponseId: $($ProviderResponse.ResponseId)\"",
          "$result[\"ResponseId\"] = $ProviderResponse.ResponseId",
          "$result[\"AppConsistent\"] = $ProviderResponse.ResponseId -eq 0",
          "}",
          "else {",
          "Write-Log \"Vss Provider failed to return a ResponseId\"",
          "$result[\"ResponseId\"] = -1",
          "$result[\"AppConsistent\"] = $false",
          "}",
          "if ($properties -contains \"AmiId\") {",
          "$result[\"AmiId\"] = $ProviderResponse.AmiId",
          "} else {",
          "$result[\"AmiId\"] = ''",
          "}",
          "[Hashtable[]]$snapshotsArray = @()",
          "if ($properties -contains \"Snapshots\") {",
          "foreach ($snapshotReponse in $ProviderResponse.Snapshots) {",
          "$snapshotInfo = @{}",
          "$snapshotInfo[\"SnapshotId\"] = Get-PropertyFromProviderResponse -Object $snapshotReponse -Property \"SnapshotId\"",
          "$snapshotInfo[\"Device\"] = Get-PropertyFromProviderResponse -Object $snapshotReponse -Property \"Device\"",
          "$snapshotInfo[\"EbsVolumeId\"] = Get-PropertyFromProviderResponse -Object $snapshotReponse -Property \"EbsVolumeId\"",
          "$snapshotsArray += $snapshotInfo",
          "}",
          "}",
          "$result[\"Snapshots\"] = $snapshotsArray",
          "if ($properties -contains \"VssSnapshotSetId\") {",
          "Write-Log \"VssSnapshotSetId: $($ProviderResponse.VssSnapshotSetId)\"",
          "$result['VssSnapshotSetId'] = $ProviderResponse.VssSnapshotSetId",
          "$script:outputInformation['VssSnapshotSetId'] = $ProviderResponse.VssSnapshotSetId",
          "}",
          "if ($properties -contains \"FreezeTimeInMS\") {",
          "$script:outputInformation[\"FreezeTimeInMS\"] = $($ProviderResponse.FreezeTimeInMS)",
          "Write-DiagnosticLog \"FreezeTimeInMS: $($ProviderResponse.FreezeTimeInMS)\"",
          "}",
          "if ($properties -contains \"FreezeStartTimestamp\") {",
          "Write-DiagnosticLog \"FreezeStartTimestamp: $($ProviderResponse.FreezeStartTimestamp)\"",
          "}",
          "if ($properties -contains \"Ec2ApiForSnapshotsInvokedTimestamp\") {",
          "Write-DiagnosticLog \"Ec2ApiForSnapshotsInvokedTimestamp: $($ProviderResponse.Ec2ApiForSnapshotsInvokedTimestamp)\"",
          "}",
          "if ($properties -contains \"Ec2AsyncCallbackReceivedTimestamp\") {",
          "Write-DiagnosticLog \"Ec2AsyncCallbackReceivedTimestamp: $($ProviderResponse.Ec2AsyncCallbackReceivedTimestamp)\"",
          "}",
          "return $result",
          "}",
          "function Validate-SnapshotStartTimes() {",
          "param(",
          "[DateTime]$TargetTime,",
          "[System.Array]$SnapshotData",
          ")",
          "$validationResult = $True",
          "Write-Log \"Validate Snapshot called with target time: $TargetTime\"",
          "try {",
          "foreach ($s in $SnapshotData) {",
          "$snapshotInfo = Get-EC2Snapshot -SnapshotId $s.SnapshotId",
          "$snapshotStartTime = [DateTime]$snapshotInfo.StartTime",
          "Write-Log \"Snapshot start time: $snapshotStartTime\"",
          "if ($snapshotStartTime -gt $TargetTime) {",
          "$validationResult = $False",
          "break;",
          "}",
          "}",
          "}",
          "catch {",
          "Write-ErrorEvent -ErrorCode 3041",
          "Write-ErrorEvent $_.Exception.Message",
          "$validationResult = $False",
          "}",
          "return $validationResult;",
          "}",
          "function Wait-ForAmiData() {",
          "param(",
          "[DateTime]$TargetTime,",
          "[string]$AmiId,",
          "[DateTime]$StartTime,",
          "[int32]$NumberOfAttachedEBSVolumes",
          ")",
          "$AmiCreationTime = $null",
          "$SnapshotData = @()",
          "$SnapshotsFound = $False",
          "while ((Get-Date) -lt $TargetTime) {",
          "try {",
          "$AmiData = Get-EC2Image -ImageId $AmiId",
          "if ($null -eq $AmiCreationTime) {",
          "$AmiCreationTime = [DateTime]$AmiData.CreationDate",
          "Write-Log \"AMI creation time: $AmiCreationTime\"",
          "}",
          "}",
          "catch {",
          "if ($_.Exception.InnerException.ErrorCode -eq \"InvalidAMIID.NotFound\") {",
          "$AmiData = $False",
          "}",
          "else {",
          "Write-ErrorEvent -ErrorCode 3021",
          "throw $_",
          "}",
          "}",
          "if ($AmiData -And ($AmiData.State -Like \"pending\" -Or $AmiData.State -Like \"available\")) {",
          "if ($AmiData.PSobject.Properties.name -match \"BlockDeviceMappings\") {",
          "$SnapshotData = @()",
          "foreach ($b in $AmiData.BlockDeviceMappings) {",
          "if ($b.PSobject.Properties.name -match \"Ebs\" -And",
          "$b.Ebs -And $b.Ebs.PSobject.Properties.name -match \"SnapshotId\" -And",
          "$b.PSobject.Properties.name -match \"DeviceName\" -And",
          "$b.Ebs.SnapshotId) {",
          "$SnapshotData += New-Object PSObject -Property @{",
          "Device = $b.DeviceName",
          "SnapshotId = $b.Ebs.SnapshotId",
          "}",
          "}",
          "}",
          "if ($SnapshotData.Count -eq $NumberOfAttachedEBSVolumes) {",
          "Write-Log \"Get-EC2Image contains all snapshot metadata at $($(New-Timespan $StartTime $(Get-Date)).TotalMilliseconds) ms\"",
          "$SnapshotsFound = $True",
          "break;",
          "}",
          "}",
          "}",
          "if ((New-TimeSpan $(Get-Date) $TargetTime).TotalMilliseconds -lt 1000) {",
          "break;",
          "}",
          "Start-Sleep -Seconds 1",
          "}",
          "$AmiInfo = New-Object PSObject -Property @{",
          "AmiCreationTime = $AmiCreationTime",
          "SnapshotsFound = $SnapshotsFound",
          "SnapshotData = $SnapshotData",
          "}",
          "return $AmiInfo;",
          "}",
          "function Process-VolumesToFreeze() {",
          "param(",
          "[PsCustomObject[]] $VolumesToFreeze",
          ")",
          "[PsCustomObject[]] $reducedInfo = @()",
          "if ($VolumesToFreeze.Count -ne 0) {",
          "$dedupedVolList = $VolumesToFreeze | Sort-Object -Unique -Property EbsVolumeId",
          "foreach($item in $dedupedVolList) {",
          "$reducedInfo += New-Object PSObject -Property @{Device = $item.Device; EbsVolumeId = $item.EbsVolumeId}",
          "}",
          "}",
          "return $reducedInfo",
          "}",
          "function Get-AllEbsVolumesToDeviceNameMapping {",
          "$deviceMapping = Get-BlockDeviceMappings | Where-Object { $_.Ebs }",
          "[PsCustomObject[]] $Volumes = @()",
          "foreach ($device in $deviceMapping) {",
          "$Volumes += [PSCustomObject]@{",
          "EbsVolumeId = $device.Ebs.VolumeId;",
          "Device = $device.DeviceName",
          "}",
          "}",
          "return $Volumes",
          "}",
          "function Invoke-VssSnapshot() {",
          "param(",
          "[boolean]$ExcludeBootVolume,",
          "[boolean]$CopyOnly,",
          "[boolean]$NoWriters,",
          "[boolean]$CreateAmi,",
          "[string]$AmiName,",
          "[string]$Description,",
          "[string]$Tags,",
          "[uint32]$waitForFreezeTimeout=180",
          ")",
          "$startTime = Get-Date",
          "[PsCustomObject[]] $VolumesToFreeze = @()",
          "$DrivesToFreeze = @()",
          "$tagSuccess = $false",
          "$instanceId = Get-Ec2InstanceId",
          "if (($null -eq $instanceId) -or ($instanceId -notlike 'i-*')) {",
          "Write-ErrorEvent -ErrorCode 1004",
          "return $false",
          "}",
          "if ($ExcludeBootVolume -and $CreateAmi) {",
          "Write-ErrorEvent -ErrorCode 1001",
          "return $false",
          "}",
          "if (!(Get-VssAgentVersion)) {",
          "Write-ErrorEvent -ErrorCode 1003",
          "return $false",
          "}",
          "if ($script:SaveVssMetadata) {",
          "if ($script:VssAgentVersion.Major -lt 2 -or ($script:VssAgentVersion.Major -eq 2 -and $script:VssAgentVersion.Minor -lt 4)) {",
          "Write-ErrorEvent -ErrorCode 1010",
          "return $false",
          "}",
          "if ($NoWriters) {",
          "Write-ErrorEvent -ErrorCode 1011",
          "return $false",
          "}",
          "}",
          "$toolsModuleName = $null",
          "if ($null -ne (Get-Module -ListAvailable -Name 'AWSPowerShell')) {",
          "$toolsModuleName = 'AWSPowerShell'",
          "}",
          "elseif ($null -ne (Get-Module -ListAvailable -Name 'AWS.Tools.EC2')) {",
          "$toolsModuleName = 'AWS.Tools.EC2'",
          "}",
          "elseif ($null -ne (Get-Module -ListAvailable -Name 'AWSPowerShell.NetCore')) {",
          "$toolsModuleName = 'AWSPowerShell.NetCore'",
          "}",
          "else {",
          "Write-ErrorEvent -ErrorCode 1002",
          "return $false",
          "}",
          "Import-Module -Name $toolsModuleName",
          "[Amazon.EC2.Model.Tag[]]$TagArray = @()",
          "$Tags -split \";\" | ForEach-Object {",
          "if (-not [string]::IsNullOrEmpty($_)) {",
          "$TagParts = ($_ -split \",\", 2)",
          "if ($TagParts.Count -ne 2) {",
          "Write-ErrorEvent -ErrorCode 1007",
          "return $false",
          "}",
          "$TagName, $TagValue = $TagParts",
          "$Tag = New-Object Amazon.EC2.Model.Tag",
          "$Tag.Key = ($TagName -split \"=\", 2)[1].Trim()",
          "$Tag.Value = ($TagValue -split \"=\", 2)[1].Trim()",
          "$TagArray += $Tag",
          "}",
          "}",
          "if (-not (Test-Path $script:VSS_LOG_PATH)) {",
          "New-Item -ItemType \"directory\" -Path $script:VSS_LOG_PATH | Out-Null",
          "}",
          "if (Test-Path $script:VSS_STDERR) {",
          "Remove-Item $script:VSS_STDERR",
          "}",
          "if (Test-Path $script:VSS_STDOUT) {",
          "Remove-Item $script:VSS_STDOUT",
          "}",
          "try {",
          "$NumberOfAttachedEBSVolumes = @(Get-BlockDeviceMappings).Count",
          "} catch {",
          "Write-ErrorEvent $_.Exception.Message",
          "return $false",
          "}",
          "$volumeList = Get-EbsConnectedVolume",
          "if ($ExcludeBootVolume) {",
          "$accessPathToDevice = @{} ",
          "foreach ($vol in $volumeList) {",
          "if ($null -eq $vol.AccessPath) {",
          "continue",
          "}",
          "foreach ($path in $vol.AccessPath) {",
          "if ($accessPathToDevice.ContainsKey($path) -and -not $accessPathToDevice[$path].Contains($vol.Device)) {",
          "$accessPathToDevice[$path] += $vol.Device",
          "} else {",
          "$accessPathToDevice[$path] = @($vol.Device)",
          "}",
          "}",
          "}",
          "foreach ($map in $accessPathToDevice.GetEnumerator()) {",
          "if ($map.Value.Contains(\"/dev/sda1\") -and $map.Value.Count -ge 2) {",
          "Write-Log \"Windows volume $($map.Key) is spanned across EBS volumes with the device names: $($map.Value)\"",
          "Write-ErrorEvent -ErrorCode 1009",
          "return $false",
          "}",
          "}",
          "}",
          "$foundWriteableVolume = $false",
          "foreach ($v in $volumeList) {",
          "if ( ($null -ne $v.AccessPath) -and ($null -ne $v.EbsVolumeId)) {",
          "if (($ExcludeBootVolume -eq $true) -and ($v.Device -eq \"/dev/sda1\")) {",
          "continue",
          "}",
          "if (-not $v.IsReadOnly) {",
          "$DrivesToFreeze += $v.AccessPath",
          "$foundWriteableVolume = $true",
          "} else {",
          "Write-Log \"Drive $($v.AccessPath) is read-only\"",
          "}",
          "$VolumesToFreeze += $v",
          "}",
          "}",
          "$VolumesToFreeze = @(Process-VolumesToFreeze $VolumesToFreeze)",
          "$script:outputInformation[\"VolumeCount\"] = $VolumesToFreeze.count",
          "if ($VolumesToFreeze.Count -eq 0) {",
          "Write-ErrorEvent -ErrorCode 1006",
          "return $false",
          "}",
          "if ($createAmi -And (-Not $amiName)) {",
          "$amiName = \"EC2_VSS_Backup_$($InstanceId)_$((Get-WMIObject win32_operatingsystem).Caption)_$(get-date -format yyyy-MM-ddTHH-mm-ss)\"",
          "$amiName = $amiName.replace(' ','')",
          "}",
          "$tagOnCreate = $false",
          "if ($TagArray.Count -ge 1) {",
          "if ($CreateAmi) {",
          "$tagOnCreate = (Get-Command New-EC2Image).ParameterSets.Parameters.Name -contains \"TagSpecification\"",
          "if ($tagOnCreate) {",
          "$tagSpecImage = New-TagSpecification -ResourceType \"Image\" -tags $TagArray",
          "}",
          "} else {",
          "$tagOnCreate = (Get-Command New-EC2Snapshot).ParameterSets.Parameters.Name -contains \"TagSpecification\"",
          "}",
          "if ($tagOnCreate) {",
          "$tagSpecSnapshot = New-TagSpecification -ResourceType \"Snapshot\" -tags $TagArray",
          "}",
          "}",
          "$amiId = ''",
          "$SnapshotData = @()",
          "try {",
          "if ($foundWriteableVolume) {",
          "$DrivesToFreezeString = \"`\"\" + ((($DrivesToFreeze | Sort-Object -Unique ) -replace '\\\\$','\\\\') -join \"`\" `\"\") + \"`\"\"",
          "Write-Log \"Beginning snapshot for drives $DrivesToFreezeString\"",
          "$initResult = Initialize-VssOperationChannel -startTime $startTime",
          "if ($false -eq $initResult) {",
          "return $false",
          "}",
          "$FreezeInfo = EbsVssFreeze $DrivesToFreezeString $startTime $CopyOnly $NoWriters",
          "if ($null -eq $FreezeInfo -or $null -eq $FreezeInfo.Process) {",
          "return $false",
          "}",
          "}",
          "$SnapshotData = @()",
          "$AmiData = $null",
          "$SnapshotInfo = $null",
          "if ($script:VssAgentVersion.Major -ge 2 -and $foundWriteableVolume) {",
          "$operationType = \"\"",
          "try {",
          "$providerOperationRequest = ConvertFrom-Json $FreezeInfo.Message",
          "$operationType = $providerOperationRequest.OperationType",
          "}",
          "catch {",
          "Write-UnexpectedMessageFromProviderError $($FreezeInfo.Message)",
          "return $false",
          "}",
          "$maxOperationDuration = [int32](New-TimeSpan (Get-Date) $script:START_TIME.AddSeconds($waitForFreezeTimeout)).TotalSeconds",
          "if ($operationType -eq $script:SEND_CONTEXT) {",
          "[PsCustomObject[]] $Volumes = @()",
          "[int] $VolumeCount = $NumberOfAttachedEBSVolumes",
          "if ($CreateAmi) {",
          "$Volumes = Get-AllEbsVolumesToDeviceNameMapping",
          "}",
          "else {",
          "$Volumes = $VolumesToFreeze",
          "$VolumeCount = $VolumesToFreeze.Count",
          "}",
          "$context = @{",
          "OperationType = $script:CREATE_SNAPSHOT;",
          "CreateAmi = $CreateAmi;",
          "AmiName = $AmiName;",
          "ExcludeBootVolume = $ExcludeBootVolume;",
          "Description = $Description;",
          "Tags = $TagArray;",
          "VolumesToFreeze = $Volumes;",
          "EbsVolumeCount = $VolumeCount;",
          "InstanceId = Get-Ec2InstanceId;",
          "MaxOperationDuration = $maxOperationDuration",
          "}",
          "$sentContext = Send-VssContext -Context $context -startTime $startTime",
          "if (-Not $sentContext) {",
          "return $false",
          "}",
          "$VssResult = Wait-VssResult -startTime $startTime",
          "if ($null -eq $VssResult) {",
          "return $false",
          "}",
          "$AppConsistent = $VssResult.AppConsistent",
          "$responseId = [int]$VssResult[\"ResponseId\"]",
          "$tagSuccess = ($responseId -eq 0 -or $responseId -eq 70)",
          "$amiId = $VssResult.AmiId",
          "$SnapshotData = $VssResult.Snapshots",
          "if ($responseId -ne 0) {",
          "Write-ErrorEvent -ErrorCode $responseId -ErrorMessage $VssResult[\"ResponseMessage\"]",
          "}",
          "}",
          "else {",
          "Write-UnexpectedMessageFromProviderError $($FreezeInfo.Message)",
          "return $false",
          "}",
          "}",
          "else {",
          "$script:SaveVssMetadata = $false",
          "if ($foundWriteableVolume) {",
          "if ($FreezeInfo.Message -eq $script:VSS_V1_MESSAGE) {",
          "Write-Log \"Freeze complete $($(New-Timespan $startTime $script:freezeStartTime).TotalMilliseconds) ms\"",
          "}",
          "else {",
          "Write-UnexpectedMessageFromProviderError $($FreezeInfo.Message)",
          "return $false",
          "}",
          "}",
          "else {",
          "Write-Log 'All volumes found are read-only or on a read-only disk or storage pool. Snapshotting without freezing IO.'",
          "}",
          "if ($createAmi) {",
          "try {",
          "$newImageArguments = @{",
          "InstanceId = $instanceId",
          "Name = $amiName",
          "Description = $Description",
          "NoReboot = $true",
          "}",
          "if ($tagOnCreate) {",
          "$newImageArguments += @{TagSpecification = $tagSpecSnapshot,$tagSpecImage}",
          "}",
          "$amiId = New-EC2Image @newImageArguments",
          "Write-Log \"New-EC2Image returned at $($(New-Timespan $startTime $(Get-Date)).TotalMilliseconds) ms\"",
          "$script:outputInformation[\"ImageId\"] = $amiId",
          "$expectedFreezeEndTime = $script:freezeStartTime.AddMilliSeconds(8900)",
          "$SnapshotInfo = Wait-ForAmiData -TargetTime $expectedFreezeEndTime -AmiId $amiId -StartTime $startTime -NumberOfAttachedEBSVolumes $NumberOfAttachedEBSVolumes",
          "$AmiData = @{",
          "ImageId = $amiId",
          "}",
          "$SnapshotData = $snapshotInfo.SnapshotData",
          "} catch {",
          "Write-ErrorEvent -ErrorCode 4002",
          "Write-ErrorEvent $_.Exception.Message",
          "return $false",
          "}",
          "} else {",
          "foreach ($v in $VolumesToFreeze) {",
          "try {",
          "$newSnapshotArguments = @{",
          "VolumeId = $v.EbsVolumeId",
          "Description = $Description",
          "}",
          "if ($tagOnCreate) {",
          "$newSnapshotArguments += @{TagSpecification = $tagSpecSnapshot}",
          "}",
          "$Snapshot = New-EC2Snapshot @newSnapshotArguments",
          "} catch {",
          "Write-ErrorEvent -ErrorCode 3031",
          "Write-ErrorEvent $_.Exception.Message",
          "return $false",
          "}",
          "$SnapshotData += New-Object PSObject -Property @{",
          "EbsVolumeId = $v.EbsVolumeId",
          "Device = $v.Device",
          "SnapshotId = $Snapshot.SnapshotId",
          "}",
          "}",
          "}",
          "if ($foundWriteableVolume) {",
          "Write-Log \"Starting Thaw at $($(New-Timespan $startTime $(Get-Date)).TotalMilliseconds) ms\"",
          "$ThawErrorCode = EbsVssThaw $startTime",
          "$ErrorCode = $ThawErrorCode",
          "$FreezeEndTime = $(Get-Date)",
          "if ($CreateAmi -and (-not ($ThawErrorCode -eq 0 -and $SnapshotInfo.SnapshotsFound))) {",
          "if (-not ($SnapshotInfo.SnapshotsFound)) {",
          "Write-Log \"Did not find Snapshots during freeze time - Waiting to see if snapshots were committed within freeze time\"",
          "$maxEndTime = $script:START_TIME.AddSeconds($waitForFreezeTimeout)",
          "$SnapshotInfo = Wait-ForAmiData -TargetTime $maxEndTime -AmiId $amiId -StartTime $startTime -NumberOfAttachedEBSVolumes $NumberOfAttachedEBSVolumes",
          "if (-not $SnapshotInfo.SnapshotsFound) {",
          "Write-ErrorEvent -ErrorCode 3022",
          "return $false",
          "}",
          "}",
          "$SnapshotData = $SnapshotInfo.SnapshotData",
          "$ValidateResult = Validate-SnapshotStartTimes -TargetTime $expectedFreezeEndTime -SnapshotData $SnapshotData",
          "if ($ThawErrorCode -eq 0 -and $ValidateResult -eq $false) {",
          "$ErrorCode = 60",
          "}",
          "elseif ($ValidateResult -eq $true) {",
          "$ErrorCode = 0",
          "}",
          "}",
          "if ($ErrorCode -ne 0) {",
          "Write-ErrorEvent -ErrorCode $ErrorCode",
          "if($ErrorCode -eq 10 -or $ErrorCode -eq 50) {",
          "PrintTimeoutTroubleshootingBanner",
          "}",
          "}",
          "$AppConsistent = $ErrorCode -eq 0",
          "if ($AppConsistent) {",
          "Write-Log \"Thaw successful at $($(New-Timespan $startTime $FreezeEndTime).TotalMilliseconds) ms\"",
          "} else {",
          "Write-Log \"Thaw unsuccessful, snapshots may not be app consistent, see event log for more details $($(New-Timespan $startTime $FreezeEndTime).TotalMilliseconds) ms\"",
          "}",
          "PrintVssAgentOutput $FreezeInfo.Process",
          "}",
          "else {",
          "$AppConsistent = $true",
          "Write-Log 'All volumes found are read-only or on a read-only disk or storage pool. Skipping VssThaw.'",
          "}",
          "if($tagOnCreate){",
          "$TagArray = @()",
          "}",
          "$tagSuccess = Tag-Snapshots -SnapshotsData $SnapshotData -AmiData $AmiData -AppConsistent $AppConsistent -Tags $TagArray",
          "}",
          "if ($amiId) {",
          "Write-Log \"AMI: $amiId\"",
          "$script:outputInformation[\"ImageId\"] = $amiId",
          "}",
          "if ($null -ne $SnapshotData) {",
          "foreach ($Snapshot in $SnapshotData) {",
          "Write-Log \"Snapshot: $($Snapshot.SnapshotId) DeviceName: $($Snapshot.Device)\"",
          "}",
          "[Object[]]$script:outputInformation[\"Snapshots\"] = $SnapshotData",
          "}",
          "}",
          "catch {",
          "Write-ErrorEvent -ErrorCode 4003",
          "Write-ErrorEvent $_.Exception.Message",
          "}",
          "finally {",
          "Set-OutputMode -UnBuffered",
          "Close-VssOperationChannel -startTime $startTime",
          "}",
          "return ($AppConsistent -and $tagSuccess)",
          "}",
          "function Initialize-DiagnosticLogging {",
          "try {",
          "New-Item -ItemType \"directory\" -Path $script:DIAGNOSTIC_FOLDER_PATH | Out-Null",
          "}",
          "catch {",
          "Write-DiagnosticLog \"Failed to create Diagnostic folder: $script:DIAGNOSTIC_FOLDER_PATH\"",
          "Write-ErrorEvent -ErrorCode 6004",
          "Write-ErrorEvent $_.Exception.Message",
          "return",
          "}",
          "foreach ($trace in $script:TRACE_INFORMATION) {",
          "try {",
          "Write-DiagnosticLog \"Starting $($trace.Name) trace.\"",
          "Invoke-Expression \"logman start $($trace.Name) $($trace.ExtraSettings) -o `\"$($trace.TraceFile)`\" -ets -p `\"$($trace.Guid)`\" $($trace.FlagsAndLevels)\" | Out-Null",
          "}",
          "catch {",
          "Write-DiagnosticLog \"Failed to start $($trace.Name) trace.\"",
          "Write-ErrorEvent -ErrorCode 6005",
          "Write-ErrorEvent $_.Exception.Message",
          "}",
          "}",
          "}",
          "function VssSnapshot() {",
          "param(",
          "[boolean]$ExcludeBootVolume,",
          "[boolean]$CopyOnly,",
          "[boolean]$NoWriters,",
          "[boolean]$CreateAmi,",
          "[string]$AmiName,",
          "[string]$Description,",
          "[string]$Tags,",
          "[uint32]$waitForFreezeTimeout=180,",
          "[boolean]$CollectDiagnosticLogs=$false,",
          "[boolean]$SaveVssMetadata=$false",
          ")",
          "try {",
          "$script:SaveVssMetadata = $SaveVssMetadata",
          "$script:waitForFreezeTimeout = $waitForFreezeTimeout",
          "$script:CollectDiagnosticLogs = $CollectDiagnosticLogs",
          "if ($script:CollectDiagnosticLogs) {",
          "Initialize-DiagnosticLogging",
          "}",
          "try {",
          "if ((Get-OSVersionNumber) -lt 6.2) {",
          "Write-Log \"Must be running on Windows Server 2012 or later. Please target an older version of this document.\"",
          "Write-Log \"For more details see: https://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/application-consistent-snapshots-prereqs.html\"",
          "Write-Log '{\"Error\": 1005}'",
          "return 1005",
          "}",
          "$success = Invoke-VssSnapshot @PSBoundParameters",
          "}",
          "catch {",
          "Write-ErrorEvent -ErrorCode 4004",
          "Write-ErrorEvent $_.Exception.Message",
          "$success = $false",
          "}",
          "if ($success -and $script:SaveVssMetadata) {",
          "while ((Get-Date) -lt $script:maxFreezePipeWaitTime -and -not $script:agentProcess.HasExited) {",
          "Write-Log \"Waiting for ec2-vss-agent to exit to verify metadata saving status\"",
          "Start-Sleep -Seconds 5",
          "}",
          "if ($script:agentProcess.HasExited) {",
          "$exitCode = $script:agentProcess.ExitCode",
          "if ($exitCode -gt 7000) {",
          "Write-ErrorEvent -ErrorCode $exitCode",
          "$success = $false",
          "} else {",
          "Write-Log \"ec2-vss-agent exited with status success\"",
          "}",
          "} else {",
          "Write-ErrorEvent -ErrorCode 7004",
          "$success = $false",
          "}",
          "}",
          "if ($success -and $script:SaveVssMetadata) {",
          "$files = Get-ChildItem -Path $script:VSS_METADATA_PATH -File | Where-Object {",
          "$_.Name.Contains($script:outputInformation[\"VssSnapshotSetId\"].ToLower())",
          "}",
          "Write-Log \"Saved VSS metadata file:\"",
          "foreach ($file in $files) {",
          "Write-Log \" - $($file.Name)\"",
          "}",
          "}",
          "if (-not $success -or $script:CollectDiagnosticLogs) {",
          "try {",
          "Write-DiagnosticInformation",
          "}",
          "catch {",
          "Write-ErrorEvent -ErrorCode 6003",
          "Write-ErrorEvent $_.Exception.Message",
          "}",
          "}",
          "}",
          "finally {",
          "Set-OutputMode -UnBuffered",
          "}",
          "Write-ReturnInformation -Success $success",
          "if ($script:CollectDiagnosticLogs) {",
          "Save-DiagnosticZip",
          "}",
          "return $script:outputInformation[\"Error\"]",
          "}",
          "",
          "[uint32]$executionTimeout = {{executionTimeout}}",
          "$VssSnapshotParameters = @{",
          "ExcludeBootVolume = [System.Convert]::ToBoolean(\"{{ExcludeBootVolume}}\")",
          "CopyOnly = [System.Convert]::ToBoolean(\"{{CopyOnly}}\")",
          "NoWriters = [System.Convert]::ToBoolean(\"{{NoWriters}}\")",
          "CreateAmi = [System.Convert]::ToBoolean(\"{{CreateAmi}}\")",
          "AmiName = @'",
          "{{AmiName}}",
          "'@",
          "description = @'",
          "{{description}}",
          "'@",
          "tags = @'",
          "{{tags}}",
          "'@",
          "waitForFreezeTimeout = $executionTimeout - 60",
          "CollectDiagnosticLogs = [System.Convert]::ToBoolean(\"{{CollectDiagnosticLogs}}\")",
          "SaveVssMetadata = [System.Convert]::ToBoolean(\"{{SaveVssMetadata}}\")",
          "}",
          "",
          "$ResponseCode = VssSnapshot @VssSnapshotParameters",
          "exit [int]$ResponseCode",
          ""
        ],
        "workingDirectory": "",
        "timeoutSeconds": "{{executionTimeout}}"
      }
    }
  ]
}
