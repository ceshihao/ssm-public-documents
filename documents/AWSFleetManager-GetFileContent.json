{
  "schemaVersion": "1.0",
  "description": "Document to retrieve a file's content",
  "sessionType": "InteractiveCommands",
  "parameters": {
    "Path": {
      "type": "String",
      "description": "The file path to process",
      "allowedPattern": "^\\w:$|^\\w:\\\\[^\"'|\\r\\n]*$|^\\/[^\"'|\\r\\n]*$|^([A-Za-z0-9-_\\/+]{4})*([A-Za-z0-9-_\\/+]{4}|[A-Za-z0-9-_\\/+]{3}=|[A-Za-z0-9-_\\/+]{2}==)$"
    },
    "TailFile": {
      "type": "String",
      "description": "(Optional) If set to 'Yes', the file's content will be continuously monitored.",
      "default": "No",
      "allowedValues": [
        "No",
        "Yes"
      ]
    },
    "NumberOfLinesToReturn": {
      "type": "String",
      "description": "(Optional) The number of lines to return when retrieving a files content. If set to '0' then all lines are returned. This parameter ignored when 'TailFile' is set to 'Yes'.",
      "default": "0",
      "allowedPattern": "^\\d*$"
    },
    "PrintInteractiveStatements": {
      "type": "String",
      "description": "(Optional) If set to 'No', the execution will not print text that indicates a keystoke is required to end execution.",
      "default": "Yes",
      "allowedValues": [
        "No",
        "Yes"
      ]
    }
  },
  "properties": {
    "windows": {
      "commands": "$ErrorActionPreference = 'Stop'\n\nFunction ParseInputParameter {\n    param (\n        [string]$Name,\n        [string]$Value,\n        [string]$Regex\n    )\n\n    $ValidParameterRegex = '^--%[ +{|{].*}( +)?$'\n    if ($Value -notmatch $ValidParameterRegex) {\n        ExitWithFailureMessage -Message \"Invalid syntax for the parameter $Name\"\n    }\n    $parameterValue = $Value.Substring(3)\n\n    $trimmedParameterValue = $parameterValue.TrimStart().TrimEnd()\n    $trimmedParameterValue = $trimmedParameterValue.Substring(1)\n    $trimmedParameterValue = $trimmedParameterValue.Substring(0, $trimmedParameterValue.Length - 1)\n\n    if ($Regex -and $trimmedParameterValue -notmatch $Regex) {\n        ExitWithFailureMessage -Message \"Invalid syntax for the parameter $Name\"\n    } else {\n        $trimmedParameterValue\n    }\n}\n\nfunction ExitWithFailureMessage {\n    param (\n        [string]$Message,\n        [string]$ExceptionMessage,\n        [Switch]$PrintJson\n    )\n    if ([string]::IsNullOrWhitespace($ExceptionMessage)) {\n        $errorMessage = $Message\n    } else {\n        $errorMessage = '{0} {1}' -f $Message, $ExceptionMessage\n    }\n    if ($PrintJson) {ConvertTo-Json -InputObject @{error = $errorMessage} -Compress}\n    WriteStandardError -Message $errorMessage\n    [System.Environment]::Exit(1)\n}\n\nfunction ExitWithFailureMessageAndExitCode {\n    param (\n        [string]$Message,\n        [string]$ExceptionMessage,\n        [int]$ExitCode,\n        [Switch]$PrintJson\n    )\n    if ([string]::IsNullOrWhitespace($ExceptionMessage)) {\n        $errorMessage = $Message\n    } else {\n        $errorMessage = '{0} {1}' -f $Message, $ExceptionMessage\n    }\n    if ($PSBoundParameters.ContainsKey('ExitCode') -eq $true) {\n        $exitCode = $ExitCode\n    } else {\n        $exitCode = 1\n    }\n    if ($PrintJson) {\n        $ErrorObject = @{\n            error = $errorMessage\n            exitCode = $exitCode\n        }\n        ConvertTo-Json -InputObject $ErrorObject -Compress\n    }\n    WriteStandardError -Message $errorMessage\n    [System.Environment]::Exit($exitCode)\n}\n\nfunction ExitWithSuccessMessage {\n    param (\n        [string]$Message\n    )\n    Write-Host $Message\n    [System.Environment]::Exit(0)\n}\n\nfunction WriteStandardError {\n    param (\n        [string]$Message\n    )\n    $Host.UI.WriteErrorLine($Message)\n}\n\n$Path = Write-Output --%{{{ Path }}}\n$Path = ParseInputParameter -Name 'Path' -Value $Path\n\n$TailFile = Write-Output --%{{{ TailFile }}}\n$TailFile = ParseInputParameter -Name 'TailFile' -Value $TailFile\n\n$NumberOfLinesToReturn = Write-Output --%{{{ NumberOfLinesToReturn }}}\n$NumberOfLinesToReturn = ParseInputParameter -Name 'NumberOfLinesToReturn' -Value $NumberOfLinesToReturn\n\n$PrintInteractiveStatements = Write-Output --%{{{ PrintInteractiveStatements }}}\n$PrintInteractiveStatements = ParseInputParameter -Name 'PrintInteractiveStatements' -Value $PrintInteractiveStatements\n\nfunction ConvertBase64ToString {\n    param (\n        [string]$Base64\n    )\n    $bytes = [System.Convert]::FromBase64String($Base64)\n    [System.Text.Encoding]::UTF8.GetString($bytes)\n}\n\n$base64Regex = '^([A-Za-z0-9-_\\/+]{4})*([A-Za-z0-9-_\\/+]{4}|[A-Za-z0-9-_\\/+]{3}=|[A-Za-z0-9-_\\/+]{2}==)$'\nif ($Path -match $base64Regex) {\n    $Path = ConvertBase64ToString -Base64 $Path\n}\n\nif (Test-Path -Path $Path -PathType 'Leaf') {\n    Write-Host \"Getting the file content for $Path\"\n    if ($TailFile -eq 'Yes') {\n        Get-Content -Path $Path -Tail 10 -Wait\n    } else {\n        if ($NumberOfLinesToReturn -eq 0) {\n            Get-Content -Path $Path -Raw\n        } else {\n            Get-Content -Path $Path | Select-Object -First $NumberOfLinesToReturn\n        }\n    }\n} else {\n    ExitWithFailureMessage -Message 'The specified path is invalid.' -PrintJson\n}\nif ($TailFile -ne 'Yes') {\n    # Pause execution to ensure all file content is returned through the session\n    if ($PrintInteractiveStatements -eq 'Yes') {\n        Write-Host \"\"\n        Pause\n    } else {\n        Read-Host\n    }\n}\n",
      "runAsElevated": true
    },
    "linux": {
      "commands": "#!/bin/bash\nset -e\n\nif [ -f /etc/os-release ]; then\n    . /etc/os-release\n    OS_RELEASE=\"$ID${VERSION_ID:+.${VERSION_ID}}\"\nelif [ -f /etc/centos-release ]; then\n    OS_RELEASE=\"centos.$(awk '{print $3}' /etc/centos-release)\"\nelif [ -f /etc/redhat-release ]; then\n    OS_RELEASE=\"rhel.$(lsb_release -r | awk '{print $2}')\"\nfi\n\ncase \"$OS_RELEASE\" in\n    amzn.2018.03|centos.6*|debian.9|rhel.6*|ubuntu.*)\n        command_path='/bin/'\n        ;;\n    amzn.2*|centos.*|debian.*|fedora.*|rhel.*|sles*)\n        command_path='/usr/bin/'\n        ;;\n    *)\n        # Catch all without the full path for untested platforms\n        command_path=''\nesac\n\nExitWithFailureMessage() {\n    MESSAGE=\"$1\"\n    JSON=\"$2\"\n    if [[ \"$JSON\" == \"PRINT_JSON\" ]]; then\n        \"${command_path}echo\" \"{\\\"error\\\":\\\"$MESSAGE\\\"}\"\n    fi\n    WriteStandardError \"$MESSAGE\"\n    exit 1\n}\n\n# exit codes. 0-100 are reserved exit codes. 101-150 codes are for linux, 151-200 are for macos and 200 onwards codes are for windows.\nExitWithFailureMessageAndExitCode() {\n    MESSAGE=\"$1\"\n    EXITCODE=\"$2\"\n    JSON=\"$3\"\n    if [[ \"$JSON\" == \"PRINT_JSON\" ]]; then\n        \"${command_path}echo\" \"{\\\"error\\\":\\\"$MESSAGE\\\",\\\"exitCode\\\":\\\"$EXITCODE\\\"}\"\n    fi\n    WriteStandardError \"$MESSAGE\"\n    exit \"$EXITCODE\"\n}\n\nExitWithSuccessMessage() {\n    \"${command_path}echo\" \"$1\"\n    exit 0\n}\n\nWriteStandardError() {\n    MESSAGE=\"$1\"\n    (>&2 \"${command_path}echo\" \"$MESSAGE\")\n}\n\nFILEPATH='{{ Path }}'\nTAILFILE='{{ TailFile }}'\nNUMBEROFLINESTORETURN='{{ NumberOfLinesToReturn }}'\nPRINTINTERACTIVESTATEMENTS='{{ PrintInteractiveStatements }}'\n\nConvertBase64ToString() {\n    \"${command_path}echo\" \"$1\" | /usr/bin/base64 --decode\n}\n\nbase64Regex='^(?!\\/)([A-Za-z0-9-_\\/+]{4})*([A-Za-z0-9-_\\/+]{4}|[A-Za-z0-9-_\\/+]{3}=|[A-Za-z0-9-_\\/+]{2}==)$'\nlinuxPathRegex='^\\/[^\"''|\\r\\n]*$'\n\nif [ $(\"${command_path}echo\" \"$FILEPATH\" | \"${command_path}grep\" -P \"$base64Regex\") ]; then\n    FILEPATH=$(ConvertBase64ToString \"$FILEPATH\")\nfi\n\nif [[ ! $(\"${command_path}echo\" \"$FILEPATH\" | \"${command_path}grep\" -P \"$linuxPathRegex\") ]]; then\n    ExitWithFailureMessage \"The specified path \"$FILEPATH\" is invalid.\" 'PRINT_JSON'\nfi\n\nif [ -f \"$FILEPATH\" ]; then\n    \"${command_path}echo\" \"Getting the file content for $FILEPATH\"\n    if [[ \"$TAILFILE\" == \"Yes\" ]]; then\n        /usr/bin/tail -f \"$FILEPATH\"\n    else\n        if [ \"$NUMBEROFLINESTORETURN\" == \"0\" ]; then\n            \"${command_path}cat\" \"$FILEPATH\"\n        else\n            /usr/bin/head -n \"$NUMBEROFLINESTORETURN\" \"$FILEPATH\"\n        fi\n    fi\nelse\n    ExitWithFailureMessage 'The specified path is invalid.'\nfi\nif [[ \"$TAILFILE\" != \"Yes\" ]]; then\n    if [[ \"$PRINTINTERACTIVESTATEMENTS\" == \"Yes\" ]]; then\n        \"${command_path}echo\" \"\"\n        \"${command_path}echo\" \"Press Enter to continue...:\"\n    fi\n    # Pause execution to ensure all file content is returned through the session\n    if [ -f /usr/bin/read ]; then\n        /usr/bin/read\n    else\n        read\n    fi\nfi\n",
      "runAsElevated": true
    },
    "macos": {
      "commands": "#!/bin/bash\nset -e\n\nExitWithFailureMessage() {\n    MESSAGE=\"$1\"\n    JSON=\"$2\"\n    if [[ \"$JSON\" == \"PRINT_JSON\" ]]; then\n        /bin/echo \"{\\\"error\\\":\\\"$MESSAGE\\\"}\"\n    fi\n    WriteStandardError \"$MESSAGE\"\n    exit 1\n}\n\nExitWithSuccessMessage() {\n    /bin/echo \"$1\"\n    exit 0\n}\n\nWriteStandardError() {\n    MESSAGE=\"$1\"\n    (>&2 /bin/echo \"$MESSAGE\")\n}\n\nFILEPATH='{{ Path }}'\nTAILFILE='{{ TailFile }}'\nNUMBEROFLINESTORETURN='{{ NumberOfLinesToReturn }}'\nPRINTINTERACTIVESTATEMENTS='{{ PrintInteractiveStatements }}'\n\nConvertBase64ToString() {\n    /bin/echo \"$1\" | /usr/bin/base64 --decode\n}\n\nbase64Regex='^(?!\\/)([A-Za-z0-9-_\\/+]{4})*([A-Za-z0-9-_\\/+]{4}|[A-Za-z0-9-_\\/+]{3}=|[A-Za-z0-9-_\\/+]{2}==)$'\npathRegex='^\\/[^\"''|\\r\\n]*$'\n\nif [ $(/bin/echo \"$FILEPATH\" | /usr/bin/perl -ne \"print if /$base64Regex/\") ]; then\n    FILEPATH=$(ConvertBase64ToString \"$FILEPATH\")\nfi\n\nif [[ ! $(\"${command_path}echo\" \"$FILEPATH\" | \"${command_path}grep\" -P \"$pathRegex\") ]]; then\n    ExitWithFailureMessage \"The specified path \"$FILEPATH\" is invalid.\" 'PRINT_JSON'\nfi\n\nif [ -f \"$FILEPATH\" ]; then\n    /bin/echo \"Getting the file content for $FILEPATH\"\n    if [[ \"$TAILFILE\" == \"Yes\" ]]; then\n        /usr/bin/tail -f \"$FILEPATH\"\n    else\n        if [ \"$NUMBEROFLINESTORETURN\" == \"0\" ]; then\n            /bin/cat \"$FILEPATH\"\n        else\n            /usr/bin/head -n \"$NUMBEROFLINESTORETURN\" \"$FILEPATH\"\n        fi\n    fi\nelse\n    ExitWithFailureMessage 'The specified path is invalid.'\nfi\nif [[ \"$TAILFILE\" != \"Yes\" ]]; then\n    if [[ \"$PRINTINTERACTIVESTATEMENTS\" == \"Yes\" ]]; then\n        /bin/echo \"\"\n        /bin/echo \"Press Enter to continue...:\"\n    fi\n    # Pause execution to ensure all file content is returned through the session\n    /usr/bin/read\nfi\n",
      "runAsElevated": true
    }
  }
}
