{
  "schemaVersion": "1.0",
  "description": "Document to retrieve a file's content",
  "sessionType": "InteractiveCommands",
  "parameters": {
    "Path": {
      "type": "String",
      "description": "The file path to process",
      "allowedPattern": "^\\w:$|^\\w:\\\\[^\"'|\\r\\n]*$|^\\/[^\"'|\\r\\n]*$|^([A-Za-z0-9-_\\/+]{4})*([A-Za-z0-9-_\\/+]{4}|[A-Za-z0-9-_\\/+]{3}=|[A-Za-z0-9-_\\/+]{2}==)$"
    },
    "TailFile": {
      "type": "String",
      "description": "(Optional) If set to 'Yes', the file's content will be continuously monitored.",
      "default": "No",
      "allowedValues": [
        "No",
        "Yes"
      ]
    },
    "NumberOfLinesToReturn": {
      "type": "String",
      "description": "(Optional) The number of lines to return when retrieving a files content. If set to '0' then all lines are returned. This parameter ignored when 'TailFile' is set to 'Yes'.",
      "default": "0",
      "allowedPattern": "^\\d*$"
    },
    "PrintInteractiveStatements": {
      "type": "String",
      "description": "(Optional) If set to 'No', the execution will not print text that indicates a keystoke is required to end execution.",
      "default": "Yes",
      "allowedValues": [
        "No",
        "Yes"
      ]
    }
  },
  "properties": {
    "windows": {
      "commands": "$ErrorActionPreference = 'Stop'\n\nFunction ParseInputParameter {\n    param (\n        [string]$Name,\n        [string]$Value,\n        [string]$Regex\n    )\n\n    $ValidParameterRegex = '^--%[ +{|{].*}( +)?$'\n    if ($Value -notmatch $ValidParameterRegex) {\n        ExitWithFailureMessage -Message \"Invalid syntax for the parameter $Name\"\n    }\n    $parameterValue = $Value.Substring(3)\n\n    $trimmedParameterValue = $parameterValue.TrimStart().TrimEnd()\n    $trimmedParameterValue = $trimmedParameterValue.Substring(1)\n    $trimmedParameterValue = $trimmedParameterValue.Substring(0, $trimmedParameterValue.Length - 1)\n\n    if ($Regex -and $trimmedParameterValue -notmatch $Regex) {\n        ExitWithFailureMessage -Message \"Invalid syntax for the parameter $Name\"\n    } else {\n        $trimmedParameterValue\n    }\n}\n\nfunction ExitWithFailureMessage {\n    param (\n        [string]$Message,\n        [string]$ExceptionMessage,\n        [Switch]$PrintJson\n    )\n    if ([string]::IsNullOrWhitespace($ExceptionMessage)) {\n        $errorMessage = $Message\n    } else {\n        $errorMessage = '{0} {1}' -f $Message, $ExceptionMessage\n    }\n    if ($PrintJson) {ConvertTo-Json -InputObject @{error = $errorMessage} -Compress}\n    WriteStandardError -Message $errorMessage\n    [System.Environment]::Exit(1)\n}\n\nfunction ExitWithFailureMessageAndExitCode {\n    param (\n        [string]$Message,\n        [string]$ExceptionMessage,\n        [int]$ExitCode,\n        [Switch]$PrintJson\n    )\n    if ([string]::IsNullOrWhitespace($ExceptionMessage)) {\n        $errorMessage = $Message\n    } else {\n        $errorMessage = '{0} {1}' -f $Message, $ExceptionMessage\n    }\n    if ($PSBoundParameters.ContainsKey('ExitCode') -eq $true) {\n        $exitCode = $ExitCode\n    } else {\n        $exitCode = 1\n    }\n    if ($PrintJson) {\n        $ErrorObject = @{\n            error = $errorMessage\n            exitCode = $exitCode\n        }\n        ConvertTo-Json -InputObject $ErrorObject -Compress\n    }\n    WriteStandardError -Message $errorMessage\n    [System.Environment]::Exit($exitCode)\n}\n\nfunction ExitWithSuccessMessage {\n    param (\n        [string]$Message\n    )\n    Write-Host $Message\n    [System.Environment]::Exit(0)\n}\n\nfunction WriteStandardError {\n    param (\n        [string]$Message\n    )\n    $Host.UI.WriteErrorLine($Message)\n}\n\n$Path = Write-Output --%{{{ Path }}}\n$Path = ParseInputParameter -Name 'Path' -Value $Path\n\n$TailFile = Write-Output --%{{{ TailFile }}}\n$TailFile = ParseInputParameter -Name 'TailFile' -Value $TailFile\n\n$NumberOfLinesToReturn = Write-Output --%{{{ NumberOfLinesToReturn }}}\n$NumberOfLinesToReturn = ParseInputParameter -Name 'NumberOfLinesToReturn' -Value $NumberOfLinesToReturn\n\n$PrintInteractiveStatements = Write-Output --%{{{ PrintInteractiveStatements }}}\n$PrintInteractiveStatements = ParseInputParameter -Name 'PrintInteractiveStatements' -Value $PrintInteractiveStatements\n\n$sb = New-Object -TypeName System.Text.StringBuilder;\n$null = $sb.AppendLine('using System;');\n$null = $sb.AppendLine('using System.IO;');\n$null = $sb.AppendLine('using System.Collections.Generic;');\n$null = $sb.AppendLine('using System.Threading.Tasks;');\n$null = $sb.AppendLine('');\n$null = $sb.AppendLine('public class FileReader');\n$null = $sb.AppendLine('{');\n$null = $sb.AppendLine('    public static void ReadAllText(string filePath)');\n$null = $sb.AppendLine('    {');\n$null = $sb.AppendLine('        using (FileStream fs = new FileStream(filePath, FileMode.Open, FileAccess.Read, FileShare.ReadWrite))');\n$null = $sb.AppendLine('        using (StreamReader reader = new StreamReader(fs))');\n$null = $sb.AppendLine('        {');\n$null = $sb.AppendLine('            Console.Write(reader.ReadToEnd());');\n$null = $sb.AppendLine('        }');\n$null = $sb.AppendLine('    }');\n$null = $sb.AppendLine('');\n$null = $sb.AppendLine('    public static void ReadFirstLines(string filePath, int lineCount)');\n$null = $sb.AppendLine('    {');\n$null = $sb.AppendLine('        using (FileStream fs = new FileStream(filePath, FileMode.Open, FileAccess.Read, FileShare.ReadWrite))');\n$null = $sb.AppendLine('        using (StreamReader reader = new StreamReader(fs))');\n$null = $sb.AppendLine('        {');\n$null = $sb.AppendLine('            for (int i = 0; i < lineCount && !reader.EndOfStream; i++)');\n$null = $sb.AppendLine('            {');\n$null = $sb.AppendLine('                Console.WriteLine(reader.ReadLine());');\n$null = $sb.AppendLine('            }');\n$null = $sb.AppendLine('        }');\n$null = $sb.AppendLine('    }');\n$null = $sb.AppendLine('');\n$null = $sb.AppendLine('    public static void TailFile(string filePath)');\n$null = $sb.AppendLine('    {');\n$null = $sb.AppendLine('        const int DEFAULT_LINES = 10;');\n$null = $sb.AppendLine('        TailFileLastLines(filePath, DEFAULT_LINES);');\n$null = $sb.AppendLine('    }');\n$null = $sb.AppendLine('');\n$null = $sb.AppendLine('    public static void TailFileLastLines(string filePath, int lines)');\n$null = $sb.AppendLine('    {');\n$null = $sb.AppendLine('        long fileOffset = 0;');\n$null = $sb.AppendLine('        long originalLength = 0;');\n$null = $sb.AppendLine('        bool stopping = false;');\n$null = $sb.AppendLine('');\n$null = $sb.AppendLine('        // Initial read - show last N lines');\n$null = $sb.AppendLine('        List<string> allLines = new List<string>();');\n$null = $sb.AppendLine('        using (FileStream fs = new FileStream(filePath, FileMode.Open, FileAccess.Read, FileShare.ReadWrite))');\n$null = $sb.AppendLine('        using (StreamReader reader = new StreamReader(fs))');\n$null = $sb.AppendLine('        {');\n$null = $sb.AppendLine('            string line;');\n$null = $sb.AppendLine('            while ((line = reader.ReadLine()) != null)');\n$null = $sb.AppendLine('            {');\n$null = $sb.AppendLine('                allLines.Add(line);');\n$null = $sb.AppendLine('            }');\n$null = $sb.AppendLine('            fileOffset = fs.Position;');\n$null = $sb.AppendLine('            originalLength = fs.Length;');\n$null = $sb.AppendLine('');\n$null = $sb.AppendLine('            int startIndex = Math.Max(0, allLines.Count - lines);');\n$null = $sb.AppendLine('            for (int i = startIndex; i < allLines.Count; i++)');\n$null = $sb.AppendLine('            {');\n$null = $sb.AppendLine('                Console.WriteLine(allLines[i]);');\n$null = $sb.AppendLine('            }');\n$null = $sb.AppendLine('        }');\n$null = $sb.AppendLine('');\n$null = $sb.AppendLine('        // Wait for changes (PowerShell''s exact approach)');\n$null = $sb.AppendLine('        while (!stopping)');\n$null = $sb.AppendLine('        {');\n$null = $sb.AppendLine('            bool changeDetected = false;');\n$null = $sb.AppendLine('');\n$null = $sb.AppendLine('            try');\n$null = $sb.AppendLine('            {');\n$null = $sb.AppendLine('                using (FileSystemWatcher watcher = new FileSystemWatcher(Path.GetDirectoryName(filePath), Path.GetFileName(filePath)))');\n$null = $sb.AppendLine('                {');\n$null = $sb.AppendLine('                    TaskCompletionSource<FileSystemEventArgs> tcs = new TaskCompletionSource<FileSystemEventArgs>();');\n$null = $sb.AppendLine('                    FileSystemEventHandler onChangedHandler = delegate(object source, FileSystemEventArgs e) { tcs.TrySetResult(e); };');\n$null = $sb.AppendLine('');\n$null = $sb.AppendLine('                    watcher.Changed += onChangedHandler;');\n$null = $sb.AppendLine('                    watcher.Created += onChangedHandler;');\n$null = $sb.AppendLine('                    watcher.Deleted += onChangedHandler;');\n$null = $sb.AppendLine('                    watcher.EnableRaisingEvents = true;');\n$null = $sb.AppendLine('');\n$null = $sb.AppendLine('                    // PowerShell''s exact pattern: Wait 500ms for event');\n$null = $sb.AppendLine('                    bool isTaskCompleted = tcs.Task.Wait(500);');\n$null = $sb.AppendLine('');\n$null = $sb.AppendLine('                    if (isTaskCompleted)');\n$null = $sb.AppendLine('                    {');\n$null = $sb.AppendLine('                        changeDetected = true;');\n$null = $sb.AppendLine('                    }');\n$null = $sb.AppendLine('                    else');\n$null = $sb.AppendLine('                    {');\n$null = $sb.AppendLine('                        // Fallback: check file size like PowerShell');\n$null = $sb.AppendLine('                        try');\n$null = $sb.AppendLine('                        {');\n$null = $sb.AppendLine('                            FileInfo fileInfo = new FileInfo(filePath);');\n$null = $sb.AppendLine('                            if (fileInfo.Length != originalLength)');\n$null = $sb.AppendLine('                            {');\n$null = $sb.AppendLine('                                changeDetected = true;');\n$null = $sb.AppendLine('                                originalLength = fileInfo.Length;');\n$null = $sb.AppendLine('                            }');\n$null = $sb.AppendLine('                        }');\n$null = $sb.AppendLine('                        catch { }');\n$null = $sb.AppendLine('                    }');\n$null = $sb.AppendLine('');\n$null = $sb.AppendLine('                    // Check for cancellation');\n$null = $sb.AppendLine('                    if (Console.KeyAvailable)');\n$null = $sb.AppendLine('                    {');\n$null = $sb.AppendLine('                        stopping = true;');\n$null = $sb.AppendLine('                    }');\n$null = $sb.AppendLine('                }');\n$null = $sb.AppendLine('');\n$null = $sb.AppendLine('                if (changeDetected && !stopping)');\n$null = $sb.AppendLine('                {');\n$null = $sb.AppendLine('                    System.Threading.Thread.Sleep(100); // Let change complete');\n$null = $sb.AppendLine('');\n$null = $sb.AppendLine('                    try');\n$null = $sb.AppendLine('                    {');\n$null = $sb.AppendLine('                        using (FileStream fs = new FileStream(filePath, FileMode.Open, FileAccess.Read, FileShare.ReadWrite))');\n$null = $sb.AppendLine('                        {');\n$null = $sb.AppendLine('                            if (fs.Length > fileOffset)');\n$null = $sb.AppendLine('                            {');\n$null = $sb.AppendLine('                                fs.Seek(fileOffset, SeekOrigin.Begin);');\n$null = $sb.AppendLine('                                using (StreamReader reader = new StreamReader(fs))');\n$null = $sb.AppendLine('                                {');\n$null = $sb.AppendLine('                                    string line;');\n$null = $sb.AppendLine('                                    while ((line = reader.ReadLine()) != null)');\n$null = $sb.AppendLine('                                    {');\n$null = $sb.AppendLine('                                        Console.WriteLine(line);');\n$null = $sb.AppendLine('                                    }');\n$null = $sb.AppendLine('                                }');\n$null = $sb.AppendLine('                                fileOffset = fs.Position;');\n$null = $sb.AppendLine('                            }');\n$null = $sb.AppendLine('                        }');\n$null = $sb.AppendLine('                    }');\n$null = $sb.AppendLine('                    catch { }');\n$null = $sb.AppendLine('                }');\n$null = $sb.AppendLine('            }');\n$null = $sb.AppendLine('            catch { }');\n$null = $sb.AppendLine('        }');\n$null = $sb.AppendLine('    }');\n$null = $sb.AppendLine('}');\n\nAdd-Type -TypeDefinition $sb.ToString();\n\nfunction ConvertBase64ToString {\n    param (\n        [string]$Base64\n    )\n    $bytes = [System.Convert]::FromBase64String($Base64);\n    [System.Text.Encoding]::UTF8.GetString($bytes);\n}\n\n$base64Regex = '^([A-Za-z0-9-_\\/+]{4})*([A-Za-z0-9-_\\/+]{4}|[A-Za-z0-9-_\\/+]{3}=|[A-Za-z0-9-_\\/+]{2}==)$';\nif ($Path -match $base64Regex) {\n    $Path = ConvertBase64ToString -Base64 $Path\n}\n\nif (Test-Path -Path $Path -PathType 'Leaf') {\n    Write-Host \"Getting the file content for $Path\"\n    if ($TailFile -eq 'Yes') {\n        if ($NumberOfLinesToReturn -gt 0) {\n            [FileReader]::TailFileLastLines($Path, $NumberOfLinesToReturn);\n        }\n        else {\n            [FileReader]::TailFile($Path);\n        }\n    } else {\n        if ($NumberOfLinesToReturn -gt 0) {\n            [FileReader]::ReadFirstLines($Path, $NumberOfLinesToReturn);\n        } else {\n            [FileReader]::ReadAllText($Path);\n        }\n    }\n} else {\n    ExitWithFailureMessage -Message 'The specified path is invalid.' -PrintJson\n}\nif ($TailFile -ne 'Yes') {\n    <# Pause execution to ensure all file content is returned through the session #>\n    if ($PrintInteractiveStatements -eq 'Yes') {\n        Write-Host \"\"\n        Pause\n    } else {\n        Read-Host\n    }\n}\n",
      "runAsElevated": true
    },
    "linux": {
      "commands": "#!/bin/bash\nset -e\n\nif [ -f /etc/os-release ]; then\n    . /etc/os-release\n    OS_RELEASE=\"$ID${VERSION_ID:+.${VERSION_ID}}\"\nelif [ -f /etc/centos-release ]; then\n    OS_RELEASE=\"centos.$(awk '{print $3}' /etc/centos-release)\"\nelif [ -f /etc/redhat-release ]; then\n    OS_RELEASE=\"rhel.$(lsb_release -r | awk '{print $2}')\"\nfi\n\ncase \"$OS_RELEASE\" in\n    amzn.2018.03|centos.6*|debian.9|rhel.6*|ubuntu.*)\n        command_path='/bin/'\n        ;;\n    amzn.2*|centos.*|debian.*|fedora.*|rhel.*|sles*)\n        command_path='/usr/bin/'\n        ;;\n    *)\n        # Catch all without the full path for untested platforms\n        command_path=''\nesac\n\nExitWithFailureMessage() {\n    MESSAGE=\"$1\"\n    JSON=\"$2\"\n    if [[ \"$JSON\" == \"PRINT_JSON\" ]]; then\n        \"${command_path}echo\" \"{\\\"error\\\":\\\"$MESSAGE\\\"}\"\n    fi\n    WriteStandardError \"$MESSAGE\"\n    exit 1\n}\n\n# exit codes. 0-100 are reserved exit codes. 101-150 codes are for linux, 151-200 are for macos and 200 onwards codes are for windows.\nExitWithFailureMessageAndExitCode() {\n    MESSAGE=\"$1\"\n    EXITCODE=\"$2\"\n    JSON=\"$3\"\n    if [[ \"$JSON\" == \"PRINT_JSON\" ]]; then\n        \"${command_path}echo\" \"{\\\"error\\\":\\\"$MESSAGE\\\",\\\"exitCode\\\":\\\"$EXITCODE\\\"}\"\n    fi\n    WriteStandardError \"$MESSAGE\"\n    exit \"$EXITCODE\"\n}\n\nExitWithSuccessMessage() {\n    \"${command_path}echo\" \"$1\"\n    exit 0\n}\n\nWriteStandardError() {\n    MESSAGE=\"$1\"\n    (>&2 \"${command_path}echo\" \"$MESSAGE\")\n}\n\nFILEPATH='{{ Path }}'\nTAILFILE='{{ TailFile }}'\nNUMBEROFLINESTORETURN='{{ NumberOfLinesToReturn }}'\nPRINTINTERACTIVESTATEMENTS='{{ PrintInteractiveStatements }}'\n\nConvertBase64ToString() {\n    \"${command_path}echo\" \"$1\" | /usr/bin/base64 --decode\n}\n\nbase64Regex='^(?!\\/)([A-Za-z0-9-_\\/+]{4})*([A-Za-z0-9-_\\/+]{4}|[A-Za-z0-9-_\\/+]{3}=|[A-Za-z0-9-_\\/+]{2}==)$'\nlinuxPathRegex='^\\/[^\"''|\\r\\n]*$'\n\nif [ $(\"${command_path}echo\" \"$FILEPATH\" | \"${command_path}grep\" -P \"$base64Regex\") ]; then\n    FILEPATH=$(ConvertBase64ToString \"$FILEPATH\")\nfi\n\nif [[ ! $(\"${command_path}echo\" \"$FILEPATH\" | \"${command_path}grep\" -P \"$linuxPathRegex\") ]]; then\n    ExitWithFailureMessage \"The specified path \"$FILEPATH\" is invalid.\" 'PRINT_JSON'\nfi\n\nif [ -f \"$FILEPATH\" ]; then\n    \"${command_path}echo\" \"Getting the file content for $FILEPATH\"\n    if [[ \"$TAILFILE\" == \"Yes\" ]]; then\n        /usr/bin/tail -f \"$FILEPATH\"\n    else\n        if [ \"$NUMBEROFLINESTORETURN\" == \"0\" ]; then\n            \"${command_path}cat\" \"$FILEPATH\"\n        else\n            /usr/bin/head -n \"$NUMBEROFLINESTORETURN\" \"$FILEPATH\"\n        fi\n    fi\nelse\n    ExitWithFailureMessage 'The specified path is invalid.'\nfi\nif [[ \"$TAILFILE\" != \"Yes\" ]]; then\n    if [[ \"$PRINTINTERACTIVESTATEMENTS\" == \"Yes\" ]]; then\n        \"${command_path}echo\" \"\"\n        \"${command_path}echo\" \"Press Enter to continue...:\"\n    fi\n    # Pause execution to ensure all file content is returned through the session\n    if [ -f /usr/bin/read ]; then\n        /usr/bin/read\n    else\n        read\n    fi\nfi\n",
      "runAsElevated": true
    },
    "macos": {
      "commands": "#!/bin/bash\nset -e\n\nExitWithFailureMessage() {\n    MESSAGE=\"$1\"\n    JSON=\"$2\"\n    if [[ \"$JSON\" == \"PRINT_JSON\" ]]; then\n        /bin/echo \"{\\\"error\\\":\\\"$MESSAGE\\\"}\"\n    fi\n    WriteStandardError \"$MESSAGE\"\n    exit 1\n}\n\nExitWithSuccessMessage() {\n    /bin/echo \"$1\"\n    exit 0\n}\n\nWriteStandardError() {\n    MESSAGE=\"$1\"\n    (>&2 /bin/echo \"$MESSAGE\")\n}\n\nFILEPATH='{{ Path }}'\nTAILFILE='{{ TailFile }}'\nNUMBEROFLINESTORETURN='{{ NumberOfLinesToReturn }}'\nPRINTINTERACTIVESTATEMENTS='{{ PrintInteractiveStatements }}'\n\nConvertBase64ToString() {\n    /bin/echo \"$1\" | /usr/bin/base64 --decode\n}\n\nbase64Regex='^(?!\\/)([A-Za-z0-9-_\\/+]{4})*([A-Za-z0-9-_\\/+]{4}|[A-Za-z0-9-_\\/+]{3}=|[A-Za-z0-9-_\\/+]{2}==)$'\npathRegex='^\\/[^\"''|\\r\\n]*$'\n\nif [ $(/bin/echo \"$FILEPATH\" | /usr/bin/perl -ne \"print if /$base64Regex/\") ]; then\n    FILEPATH=$(ConvertBase64ToString \"$FILEPATH\")\nfi\n\nif [[ ! $(\"${command_path}echo\" \"$FILEPATH\" | \"${command_path}grep\" -P \"$pathRegex\") ]]; then\n    ExitWithFailureMessage \"The specified path \"$FILEPATH\" is invalid.\" 'PRINT_JSON'\nfi\n\nif [ -f \"$FILEPATH\" ]; then\n    /bin/echo \"Getting the file content for $FILEPATH\"\n    if [[ \"$TAILFILE\" == \"Yes\" ]]; then\n        /usr/bin/tail -f \"$FILEPATH\"\n    else\n        if [ \"$NUMBEROFLINESTORETURN\" == \"0\" ]; then\n            /bin/cat \"$FILEPATH\"\n        else\n            /usr/bin/head -n \"$NUMBEROFLINESTORETURN\" \"$FILEPATH\"\n        fi\n    fi\nelse\n    ExitWithFailureMessage 'The specified path is invalid.'\nfi\nif [[ \"$TAILFILE\" != \"Yes\" ]]; then\n    if [[ \"$PRINTINTERACTIVESTATEMENTS\" == \"Yes\" ]]; then\n        /bin/echo \"\"\n        /bin/echo \"Press Enter to continue...:\"\n    fi\n    # Pause execution to ensure all file content is returned through the session\n    /usr/bin/read\nfi\n",
      "runAsElevated": true
    }
  }
}
