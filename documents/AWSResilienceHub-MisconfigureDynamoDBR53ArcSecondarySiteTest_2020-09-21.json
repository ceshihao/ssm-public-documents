{
  "description": "## Id\nAWSResilienceHub-MisconfigureDynamoDBR53ArcSecondarySiteTest_2020-09-21\n\n## Intent\nTest Amazon Route53 Application Recovery Controller behavior when Amazon DynamoDB tables deployed into two regions do not pass the ReadinessCheck\n\n## Type\nTEST\n\n## Risk\nHIGH\n\n## Requirements\n  * A stack set of 2 stacks in different regions with the same Amazon DynamoDB tables\n  * Application Recovery Controller contains all the resources (Cells, ResourceSet, ReadinessCheck, RecoveryGroup) needed to monitor the Amazon DynamoDB tables\n\n## Permissions required for AutomationAssumeRole\n  * 'dynamodb:DescribeTable'\n  * 'dynamodb:UpdateTable'\n  * 'route53-recovery-readiness:ListResourceSets'\n  * 'route53-recovery-readiness:GetReadinessCheckResourceStatus'\n  * 'ssm:GetAutomationExecution'\n  * 'ssm:StartAutomationExecution'\n  * 'ssm:GetParameters'\n  * 'iam:PassRole'\n\n## Supports Rollback\nYes. Restores (enable/disable) the original Amazon DynamoDb stream\n\n## Cancellation behavior\nRestores (enable/disable) the original Amazon DynamoDb stream\n\n## Inputs\n### (Required) ResourceSetArn\n  * type: String\n  * description:  The ARN of the Amazon Route53 Application Recovery Controller resourse set.\n### (Required) AutomationAssumeRole\n  * type: String\n  * description: ARN of the IAM role with permissions listed above\n### (Required) ReadinessCheckName\n  * type: String\n  * description: Amazon Route53 Application Recovery Controller ReadinessCheck which should become NOT_READY after injection of the failure and READY after the rollback process in the end of the test.\n### (Optional) IsRollback\n  * type: String\n  * description: Run rollback step of the given previous execution (parameter `PreviousExecutionId`). Can be either true or false.\n  * default: false\n### (Optional) PreviousExecutionId\n  * type: String\n  * description:Previous execution id for which resources need to be cleaned up.\n  * default:\n\n## Details\nThe document injects failure in one of the Amazon DynamoDb table by changing the value of the DynamoDb stream.\n\n## Steps executed in normal flow\n  * CheckIsRollback\n  * BackupCurrentExecution\n  * AssertReadinessCheckToBeReadyBeforeTest\n  * InjectFailure\n  * AssertReadinessCheckToBeNotReady\n  * RollbackCurrentExecution\n  * AssertReadinessCheckToBeReady\n\n## Steps executed in rollback flow\n  * CheckIsRollback\n  * GetInputsFromPreviousExecution\n  * AssertResourceSetArn\n  * PrepareRollbackOfPreviousExecution\n  * RollbackPreviousExecution\n\n## Outputs\nNone",
  "schemaVersion": "0.3",
  "assumeRole": "{{ AutomationAssumeRole }}",
  "parameters": {
    "ResourceSetArn": {
      "type": "String",
      "description": "(Required) The ARN of the Amazon Route53 Application Recovery Controller resourse set."
    },
    "AutomationAssumeRole": {
      "type": "String",
      "description": "(Required) The ARN of the role that allows Automation to perform the actions on your behalf."
    },
    "ReadinessCheckName": {
      "type": "String",
      "description": "(Required) Amazon Route53 Application Recovery Controller ReadinessCheck which should become NOT_READY after injection of the failure and READY after the rollback process in the end of the test."
    },
    "IsRollback": {
      "type": "String",
      "description": "(Optional) Run rollback step of the given previous execution (parameter `PreviousExecutionId`). Can be either true or false.",
      "default": "false"
    },
    "PreviousExecutionId": {
      "type": "String",
      "description": "(Optional) Previous execution id for which resources need to be cleaned up.",
      "default": ""
    }
  },
  "mainSteps": [
    {
      "name": "CheckIsRollback",
      "description": "Check if document should be executed in rollback mode",
      "action": "aws:branch",
      "inputs": {
        "Choices": [
          {
            "NextStep": "GetInputsFromPreviousExecution",
            "Variable": "{{IsRollback}}",
            "StringEquals": "true"
          }
        ],
        "Default": "BackupCurrentExecution"
      }
    },
    {
      "name": "GetInputsFromPreviousExecution",
      "description": "Get input from previous execution. This will be used to validate that rollback is executed with the same input",
      "action": "aws:executeScript",
      "outputs": [
        {
          "Name": "ResourceSetArn",
          "Selector": "$.Payload.ResourceSetArn[0]",
          "Type": "String"
        }
      ],
      "inputs": {
        "Runtime": "python3.8",
        "Handler": "get_inputs_from_ssm_execution",
        "InputPayload": {
          "ExecutionId": "{{ PreviousExecutionId }}"
        },
        "Script": "import json\n\nimport boto3\nfrom botocore.config import Config\n\n\n\ndef get_inputs_from_ssm_execution(events, context):\n    output = {}\n    config = Config(retries={'max_attempts': 20, 'mode': 'standard'})\n    ssm = boto3.client('ssm', config=config)\n\n    if 'ExecutionId' not in events:\n        raise KeyError('Requires ExecutionId')\n\n    if not events['ExecutionId']:\n        raise KeyError('Requires not empty ExecutionId')\n\n    response = ssm.get_automation_execution(AutomationExecutionId=events['ExecutionId'])\n    response_parameters = response['AutomationExecution']['Parameters']\n    # TODO DIG-853\n    for parameter in response_parameters:\n        output[parameter] = response_parameters[parameter]\n\n    return output"
      }
    },
    {
      "name": "AssertResourceSetArn",
      "description": "Validate that rollback is executed with the same input",
      "action": "aws:branch",
      "inputs": {
        "Choices": [
          {
            "NextStep": "PrepareRollbackOfPreviousExecution",
            "Variable": "{{ GetInputsFromPreviousExecution.ResourceSetArn }}",
            "StringEquals": "{{ ResourceSetArn }}"
          }
        ]
      },
      "isEnd": true
    },
    {
      "name": "PrepareRollbackOfPreviousExecution",
      "description": "Get Table Arn for rollback",
      "action": "aws:executeScript",
      "outputs": [
        {
          "Name": "TableArn",
          "Selector": "$.Payload.TableArn[0]",
          "Type": "String"
        },
        {
          "Name": "DynamoDbBillingMode",
          "Selector": "$.Payload.OriginalBillingMode[0]",
          "Type": "String"
        },
        {
          "Name": "DynamoDbReadCapacityUnits",
          "Selector": "$.Payload.OriginalReadCapacityUnits[0]",
          "Type": "Integer"
        },
        {
          "Name": "DynamoDbWriteCapacityUnits",
          "Selector": "$.Payload.OriginalWriteCapacityUnits[0]",
          "Type": "Integer"
        }
      ],
      "inputs": {
        "Runtime": "python3.8",
        "Handler": "get_output_from_ssm_step_execution",
        "InputPayload": {
          "ExecutionId": "{{ PreviousExecutionId }}",
          "StepName": "BackupCurrentExecution",
          "ResponseField": "TableArn,OriginalBillingMode,OriginalReadCapacityUnits,OriginalWriteCapacityUnits"
        },
        "Script": "import json\n\nimport boto3\nfrom botocore.config import Config\n\n\n\n\ndef get_output_from_ssm_step_execution(events, context):\n    config = Config(retries={'max_attempts': 20, 'mode': 'standard'})\n    ssm = boto3.client('ssm', config=config)\n\n    if 'ExecutionId' not in events or 'StepName' not in events or 'ResponseField' not in events:\n        raise KeyError('Requires ExecutionId, StepName and ResponseField in events')\n\n    ssm_response = ssm.get_automation_execution(AutomationExecutionId=events['ExecutionId'])\n    for step in ssm_response['AutomationExecution']['StepExecutions']:\n        if step['StepName'] == events['StepName']:\n            response_fields = events['ResponseField'].split(',')\n            output = {}\n            for response_field in response_fields:\n                if response_field in step['Outputs']:\n                    # Sets values in string type regardless of what is the original value type. In order to set\n                    # values with original types please use 'get_typed_output_from_ssm_step_execution'.\n                    output[response_field] = step['Outputs'][response_field]\n                else:\n                    \"\"\"\n                    By default SSM ignores empty values when encodes API outputs to JSON. It may result in\n                    a situation when an empty value is a valid value but step output completely misses it.\n                    Usually happens with SQS queue policies, default policy is returned by API as an empty value\n                    and executeApi step output ignores it. As a result, further steps in rollback execution will fail.\n                    Instead of ignoring this value we should use a default empty value in rollback, i.e. empty string\n                    represents a default sqs policy\n                    \"\"\"\n                    output[response_field] = ['']\n            return output\n\n    # Could not find step name\n    raise Exception('Can not find step name % in ssm execution response', events['StepName'])"
      }
    },
    {
      "name": "RollbackPreviousExecution",
      "description": "Revert original DynamoDb stream value from the previous execution",
      "action": "aws:executeScript",
      "inputs": {
        "Runtime": "python3.8",
        "Handler": "rollback_billing_mode",
        "InputPayload": {
          "TableArn": "{{PrepareRollbackOfPreviousExecution.TableArn}}",
          "DynamoDbBillingMode": "{{PrepareRollbackOfPreviousExecution.DynamoDbBillingMode}}",
          "DynamoDbReadCapacityUnits": "{{PrepareRollbackOfPreviousExecution.DynamoDbReadCapacityUnits}}",
          "DynamoDbWriteCapacityUnits": "{{PrepareRollbackOfPreviousExecution.DynamoDbWriteCapacityUnits}}"
        },
        "Script": "import logging\nimport random\nimport time\nfrom typing import Any, Callable, Iterator, List\n\nimport boto3\nfrom botocore.config import Config\n\nboto3_config = Config(retries={'max_attempts': 20, 'mode': 'standard'})\nlogger = logging.getLogger()\nlogger.setLevel(logging.INFO)\n\nENABLED_INSIGHTS_STATUSES = ['ENABLING', 'ENABLED']\nGLOBAL_TABLE_ACTIVE_STATUSES = ['ACTIVE']\n\n\n\ndef check_required_params(required_params: List[str], events: dict) -> None:\n    \"\"\"\n    Check for required parameters in events. Allow empty, None or 0 values.\n    :param required_params: List of required parameters\n    :param events: input parameters in event\n    :return:\n    \"\"\"\n    for key in required_params:\n        if key not in events:\n            raise KeyError(f'Requires {key} in events')\n\n\n\ndef get_dynamodb_billing_mode(table_name: str, dynamodb_client: boto3.client) -> str:\n    \"\"\"\n    Get current value of the DynamoDB capacity mode\n    :param table_name: table's name\n    :param dynamodb_client: boto3 ddb client\n    :return:\n    \"\"\"\n\n    response = dynamodb_client.describe_table(\n        TableName=table_name\n    )\n    return response['Table'].get('BillingModeSummary', {}).get(\n        'BillingMode', '')\n\n\n\ndef get_dynamodb_read_capacity_units(table_name: str, dynamodb_client: boto3.client) -> int:\n    \"\"\"\n    Get current value of the DynamoDB read capacity units\n    :param table_name: table's name\n    :param dynamodb_client: boto3 ddb client\n    :return:\n    \"\"\"\n    response = dynamodb_client.describe_table(TableName=table_name)\n    return response['Table'].get('ProvisionedThroughput', {}).get('ReadCapacityUnits', 0)\n\n\n\ndef get_dynamodb_write_capacity_units(table_name: str, dynamodb_client: boto3.client) -> int:\n    \"\"\"\n      Get current value of the DynamoDB read capacity units\n      :param table_name: table's name\n      :param dynamodb_client: boto3 ddb client\n      :return:\n      \"\"\"\n\n    response = dynamodb_client.describe_table(\n        TableName=table_name\n    )\n    return response['Table'].get('ProvisionedThroughput', {}).get(\n        'WriteCapacityUnits', 0)\n\ndef set_on_demand_capacity_mode(table_name: str, dynamodb_client: boto3.client):\n    \"\"\"\n    Set the given DynamoDB table capacity mode to on-demand\n    :param table_name: the table name\n    :param dynamodb_client: the boto3 client\n    \"\"\"\n    dynamodb_client.update_table(\n        TableName=table_name,\n        BillingMode='PAY_PER_REQUEST',\n    )\n\n\n\ndef set_provisioned_capacity_mode(table_name: str, dynamodb_client: boto3.client,\n                                  read_capacity_units: int, write_capacity_units: int):\n    \"\"\"\n    Set the given DynamoDB table capacity mode to provisioned, with read/write\n    capacity unites.\n    :param table_name: the table name\n    :param dynamodb_client: the boto3 client\n    :param read_capacity_units: Read capacity units\n    :param write_capacity_units: Write capacity units\n    :return:\n    \"\"\"\n    dynamodb_client.update_table(\n        TableName=table_name,\n        BillingMode='PROVISIONED',\n        ProvisionedThroughput={\n            'ReadCapacityUnits': read_capacity_units,\n            'WriteCapacityUnits': write_capacity_units\n        },\n    )\n\n\n\ndef rollback_billing_mode(events: dict, context: dict) -> None:\n    \"\"\"\n     Rollback the current execution by changing DynamoDB BillingMode\n     :param events: The dictionary that supposed to have the following keys:\n     * `TableArn` - The source table arn\n     * `DynamoDbBillingMode` - PAR_PER_REQUEST or PROVISIONED\n     :param context: context\n     :return:\n     \"\"\"\n    required_params = [\n        'TableArn',\n        'DynamoDbBillingMode',\n        'DynamoDbReadCapacityUnits',\n        'DynamoDbWriteCapacityUnits'\n    ]\n\n    check_required_params(required_params, events)\n    region = events['TableArn'].split(\":\")[3]\n    table_name = events['TableArn'].split(\"/\")[1]\n    billing_mode = events['DynamoDbBillingMode']\n    read_capacity_units = events['DynamoDbReadCapacityUnits']\n    write_capacity_units = events['DynamoDbWriteCapacityUnits']\n\n    dynamodb_config = Config(\n        region_name=region,\n        retries={\n            'max_attempts': 20,\n            'mode': 'standard'\n        }\n    )\n    dynamodb_client = boto3.client('dynamodb', config=dynamodb_config)\n\n    response = dynamodb_client.describe_table(\n        TableName=table_name\n    )\n\n    current_dynamodb_billing_mode = response['Table'].get('BillingModeSummary', {}).get(\n        'BillingMode', '')\n    if not current_dynamodb_billing_mode or current_dynamodb_billing_mode == \"PROVISIONED\":\n        set_on_demand_capacity_mode(table_name, dynamodb_client)\n    else:\n        set_provisioned_capacity_mode(table_name, dynamodb_client, read_capacity_units, write_capacity_units)\n    logger.info(f'DynamoDb stream value for the table {table_name} was '\n                f'successfully rolled back from {current_dynamodb_billing_mode} to {billing_mode}.')"
      },
      "isEnd": true
    },
    {
      "name": "BackupCurrentExecution",
      "description": "Backup DynamoDb table parameters for rollback",
      "action": "aws:executeScript",
      "onFailure": "Abort",
      "outputs": [
        {
          "Name": "TableArn",
          "Selector": "$.Payload.TableArn",
          "Type": "String"
        },
        {
          "Name": "OriginalBillingMode",
          "Selector": "$.Payload.DynamoDbBillingMode",
          "Type": "String"
        },
        {
          "Name": "OriginalReadCapacityUnits",
          "Selector": "$.Payload.DynamoDbReadCapacityUnits",
          "Type": "Integer"
        },
        {
          "Name": "OriginalWriteCapacityUnits",
          "Selector": "$.Payload.DynamoDbWriteCapacityUnits",
          "Type": "Integer"
        }
      ],
      "inputs": {
        "Runtime": "python3.8",
        "Handler": "backup_dynamodb_table_params",
        "InputPayload": {
          "ResourceSetArn": "{{ ResourceSetArn }}"
        },
        "Script": "import logging\nimport random\nimport time\nfrom typing import Any, Callable, Iterator, List\n\nimport boto3\nfrom botocore.config import Config\n\nboto3_config = Config(retries={'max_attempts': 20, 'mode': 'standard'})\nlogger = logging.getLogger()\nlogger.setLevel(logging.INFO)\n\nENABLED_INSIGHTS_STATUSES = ['ENABLING', 'ENABLED']\nGLOBAL_TABLE_ACTIVE_STATUSES = ['ACTIVE']\n\n\n\ndef check_required_params(required_params: List[str], events: dict) -> None:\n    \"\"\"\n    Check for required parameters in events. Allow empty, None or 0 values.\n    :param required_params: List of required parameters\n    :param events: input parameters in event\n    :return:\n    \"\"\"\n    for key in required_params:\n        if key not in events:\n            raise KeyError(f'Requires {key} in events')\n\n\n\ndef get_random_resource_arn(resource_set_arn: str, resource_set_type: str) -> str:\n    \"\"\"\n    Get random Resource Arn from the Resource Set\n    :param resource_set_arn: The resource set arn\n    :param resource_set_type: The resource set type\n    :return: Arn of the Random resource\n    \"\"\"\n    # Route52-recovery-readiness api working only at us-west-2\n    r53arc_config = Config(\n        region_name='us-west-2',\n        retries={\n            'max_attempts': 20,\n            'mode': 'standard'\n        }\n    )\n    client = boto3.client('route53-recovery-readiness', config=r53arc_config)\n    response = client.list_resource_sets()\n\n    resource_sets = response['ResourceSets']\n    while 'NextToken' in response:\n        response = client.list_resource_sets(NextToken=response['NextToken'])\n        resource_sets.extend(response['ResourceSets'])\n\n    resource_set = [item for item in resource_sets if item['ResourceSetArn'] == resource_set_arn][0]\n    if resource_set['ResourceSetType'] != resource_set_type:\n        raise ValueError(f'Resource has not expected type: {resource_set[\"ResourceSetType\"]}.')\n\n    resources = [item['ResourceArn'] for item in resource_set['Resources']]\n    if not resources:\n        raise ValueError(f'Resource set {resource_set[\"ResourceSetArn\"]} does not contain resources')\n\n    random_resource = random.choice(resources)\n    logger.info(f'Random resource: {random_resource}')\n    return random_resource\n\n\n\ndef backup_dynamodb_table_params(events: dict, context: dict) -> dict:\n    \"\"\"\n    Backup DynamoDb parameters\n    :param events: The dictionary that supposed to have the following keys:\n    * `ResourceSetArn` - The resource set arn\n    :param context: context\n    :return: Parameters: 'TableArn', 'DynamoDbStreamStatus', 'DynamoDbStreamViewType'\n    \"\"\"\n    required_params = ['ResourceSetArn']\n    check_required_params(required_params, events)\n\n    resource_set_arn = events['ResourceSetArn']\n\n    dynamodb_table_arn = get_random_resource_arn(resource_set_arn, 'AWS::DynamoDB::Table')\n    table_region = dynamodb_table_arn.split(\":\")[3]\n    table_name = dynamodb_table_arn.split(\"/\")[1]\n\n    logger.info(f'DynamoDb Table with name {table_name}. '\n                f'table_region: {table_region}. '\n                f'table_arn: {dynamodb_table_arn}')\n\n    dynamodb_config = Config(\n        region_name=table_region,\n        retries={\n            'max_attempts': 20,\n            'mode': 'standard'\n        }\n    )\n    dynamodb_client = boto3.client('dynamodb', config=dynamodb_config)\n    response = dynamodb_client.describe_table(\n        TableName=table_name\n    )\n\n    dynamodb_stream_status = response['Table'].get('StreamSpecification', {}).get('StreamEnabled', )\n    stream_view_type = response['Table'].get('StreamSpecification', {}).get('StreamViewType', '')\n    billing_mode = response['Table'].get('BillingModeSummary', {}).get('BillingMode', '')\n    read_capacity = response['Table'].get('ProvisionedThroughput', {}).get('ReadCapacityUnits', 0)\n    write_capacity = response['Table'].get('ProvisionedThroughput', {}).get('WriteCapacityUnits', 0)\n    backup_params = {\n        'DynamoDbStreamStatus': dynamodb_stream_status,\n        'DynamoDbStreamViewType': stream_view_type,\n        'TableArn': dynamodb_table_arn,\n        'DynamoDbBillingMode': billing_mode,\n        'DynamoDbReadCapacityUnits': read_capacity,\n        'DynamoDbWriteCapacityUnits': write_capacity\n    }\n    return backup_params"
      }
    },
    {
      "name": "AssertReadinessCheckToBeReadyBeforeTest",
      "description": "Ensure ReadinessCheck is READY before starting test. Fail if ReadinessCheck is not READY within expected time.",
      "action": "aws:executeScript",
      "onFailure": "Abort",
      "inputs": {
        "Runtime": "python3.8",
        "Handler": "assert_readiness_check_state",
        "Script": "import logging\nimport random\nimport time\n\nimport boto3\nfrom botocore.config import Config\nfrom botocore.exceptions import ClientError\n\nlogger = logging.getLogger(__name__)\nlogger.setLevel(logging.INFO)\n\n\n\ndef check_required_params(required_params, events):\n    \"\"\"\n    Check for required parameters in events.\n    \"\"\"\n    for key in required_params:\n        if not events.get(key):\n            raise KeyError(f'Requires {key} in events')\n\n\n\ndef assert_readiness_check_state(events, context):\n    \"\"\"\n    Assert ReadinessCheck state\n    \"\"\"\n    required_params = ['ReadinessCheckName', 'DesiredValue', 'Timeout']\n    check_required_params(required_params, events)\n    # Route52-recovery-readiness api working only at us-west-2\n    r53arc_config = Config(\n        region_name='us-west-2',\n        signature_version='v4',\n        retries={\n            'max_attempts': 10,\n            'mode': 'standard'\n        }\n    )\n    client = boto3.client('route53-recovery-readiness', config=r53arc_config)\n    passed = 0\n    iteration = 1\n    time_to_wait = events['Timeout']\n    start = time.time()\n    while passed < time_to_wait:\n        response = client.get_readiness_check_status(\n            ReadinessCheckName=events['ReadinessCheckName']\n        )\n        readiness_check_status = response['Readiness']\n        if readiness_check_status == events['DesiredValue']:\n            logging.info(f'#{iteration}; ReadinessCheck has the expected state: {readiness_check_status} '\n                         f'Elapsed: {passed} sec;')\n            return\n        logging.info(f'#{iteration}; ReadinessCheck has not changed the state: {readiness_check_status} '\n                     f'Elapsed: {passed} sec; Sleep for 10 seconds')\n        time.sleep(10)\n        end = time.time()\n        passed = end - start\n        iteration += 1\n\n    raise TimeoutError(f\"Waiting for ReadinessCheck {events['ReadinessCheckName']} \"\n                       f\"to change state to {events['DesiredValue']}\")",
        "InputPayload": {
          "ReadinessCheckName": "{{ ReadinessCheckName }}",
          "ResourceIdentifier": "{{ BackupCurrentExecution.TableArn }}",
          "DesiredValue": "READY",
          "Timeout": 1200
        }
      }
    },
    {
      "name": "InjectFailure",
      "description": "Inject failure by changing the value of the DynamoDb stream in one of the DynamoDb Tables in the stackset",
      "action": "aws:executeScript",
      "onFailure": "step:RollbackCurrentExecution",
      "onCancel": "step:TriggerRollback",
      "inputs": {
        "Runtime": "python3.8",
        "Handler": "inject_failure",
        "InputPayload": {
          "TableArn": "{{ BackupCurrentExecution.TableArn }}",
          "DynamoDbBillingMode": "{{ BackupCurrentExecution.OriginalBillingMode }}",
          "DynamoDbReadCapacityUnits": "{{ BackupCurrentExecution.OriginalReadCapacityUnits }}",
          "DynamoDbWriteCapacityUnits": "{{ BackupCurrentExecution.OriginalWriteCapacityUnits }}"
        },
        "Script": "import logging\nimport random\nimport time\nfrom typing import Any, Callable, Iterator, List\n\nimport boto3\nfrom botocore.config import Config\n\nboto3_config = Config(retries={'max_attempts': 20, 'mode': 'standard'})\nlogger = logging.getLogger()\nlogger.setLevel(logging.INFO)\n\nENABLED_INSIGHTS_STATUSES = ['ENABLING', 'ENABLED']\nGLOBAL_TABLE_ACTIVE_STATUSES = ['ACTIVE']\n\n\n\ndef check_required_params(required_params: List[str], events: dict) -> None:\n    \"\"\"\n    Check for required parameters in events. Allow empty, None or 0 values.\n    :param required_params: List of required parameters\n    :param events: input parameters in event\n    :return:\n    \"\"\"\n    for key in required_params:\n        if key not in events:\n            raise KeyError(f'Requires {key} in events')\n\n\n\ndef get_dynamodb_billing_mode(table_name: str, dynamodb_client: boto3.client) -> str:\n    \"\"\"\n    Get current value of the DynamoDB capacity mode\n    :param table_name: table's name\n    :param dynamodb_client: boto3 ddb client\n    :return:\n    \"\"\"\n\n    response = dynamodb_client.describe_table(\n        TableName=table_name\n    )\n    return response['Table'].get('BillingModeSummary', {}).get(\n        'BillingMode', '')\n\n\n\ndef get_dynamodb_read_capacity_units(table_name: str, dynamodb_client: boto3.client) -> int:\n    \"\"\"\n    Get current value of the DynamoDB read capacity units\n    :param table_name: table's name\n    :param dynamodb_client: boto3 ddb client\n    :return:\n    \"\"\"\n    response = dynamodb_client.describe_table(TableName=table_name)\n    return response['Table'].get('ProvisionedThroughput', {}).get('ReadCapacityUnits', 0)\n\n\n\ndef get_dynamodb_write_capacity_units(table_name: str, dynamodb_client: boto3.client) -> int:\n    \"\"\"\n      Get current value of the DynamoDB read capacity units\n      :param table_name: table's name\n      :param dynamodb_client: boto3 ddb client\n      :return:\n      \"\"\"\n\n    response = dynamodb_client.describe_table(\n        TableName=table_name\n    )\n    return response['Table'].get('ProvisionedThroughput', {}).get(\n        'WriteCapacityUnits', 0)\n\ndef set_on_demand_capacity_mode(table_name: str, dynamodb_client: boto3.client):\n    \"\"\"\n    Set the given DynamoDB table capacity mode to on-demand\n    :param table_name: the table name\n    :param dynamodb_client: the boto3 client\n    \"\"\"\n    dynamodb_client.update_table(\n        TableName=table_name,\n        BillingMode='PAY_PER_REQUEST',\n    )\n\n\n\ndef set_provisioned_capacity_mode(table_name: str, dynamodb_client: boto3.client,\n                                  read_capacity_units: int, write_capacity_units: int):\n    \"\"\"\n    Set the given DynamoDB table capacity mode to provisioned, with read/write\n    capacity unites.\n    :param table_name: the table name\n    :param dynamodb_client: the boto3 client\n    :param read_capacity_units: Read capacity units\n    :param write_capacity_units: Write capacity units\n    :return:\n    \"\"\"\n    dynamodb_client.update_table(\n        TableName=table_name,\n        BillingMode='PROVISIONED',\n        ProvisionedThroughput={\n            'ReadCapacityUnits': read_capacity_units,\n            'WriteCapacityUnits': write_capacity_units\n        },\n    )\n\n\n\ndef inject_failure(events: dict, context: dict) -> None:\n    \"\"\"\n    Inject failure by updating DynamoDb billing mode\n    :param events: The dictionary that supposed to have the following keys:\n    * `TableArn` - The source table arn\n    * `DynamoDbStreamStatus` - the DynamoDb stream value (True or False/None)\n    * `DynamoDbStreamViewType` - value for the StreamViewType parameter if StreamEnabled = True\n    :param context: context\n    :return:\n    \"\"\"\n    required_params = [\n        'TableArn',\n        'DynamoDbBillingMode',\n        'DynamoDbReadCapacityUnits',\n        'DynamoDbWriteCapacityUnits'\n    ]\n    check_required_params(required_params, events)\n    table_arn = events['TableArn']\n    region = table_arn.split(\":\")[3]\n    table_name = table_arn.split(\"/\")[1]\n    billing_mode = events['DynamoDbBillingMode']\n\n    logger.info(f'DynamoDb billing mode:  {billing_mode} ')\n\n    dynamodb_config = Config(\n        region_name=region,\n        retries={\n            'max_attempts': 20,\n            'mode': 'standard'\n        }\n    )\n    dynamodb_client = boto3.client('dynamodb', config=dynamodb_config)\n\n    if not billing_mode or billing_mode == \"PROVISIONED\":\n        set_on_demand_capacity_mode(table_name, dynamodb_client)\n    else:\n        DEFAULT_CAPACITY = 5\n        set_provisioned_capacity_mode(table_name, dynamodb_client, DEFAULT_CAPACITY, DEFAULT_CAPACITY)\n\n    new_dynamodb_billing_mode = get_dynamodb_billing_mode(table_name, dynamodb_client)\n    logger.info(f'DynamoDb Stream for the table {table_name} was '\n                f'successfully updated from {billing_mode} to {new_dynamodb_billing_mode}.')"
      }
    },
    {
      "name": "AssertReadinessCheckToBeNotReady",
      "description": "Wait for expected ReadinessCheck to become NOT_READY after failure is injected",
      "action": "aws:executeScript",
      "onFailure": "step:RollbackCurrentExecution",
      "onCancel": "step:TriggerRollback",
      "inputs": {
        "Runtime": "python3.8",
        "Handler": "assert_readiness_check_state",
        "Script": "import logging\nimport random\nimport time\n\nimport boto3\nfrom botocore.config import Config\nfrom botocore.exceptions import ClientError\n\nlogger = logging.getLogger(__name__)\nlogger.setLevel(logging.INFO)\n\n\n\ndef check_required_params(required_params, events):\n    \"\"\"\n    Check for required parameters in events.\n    \"\"\"\n    for key in required_params:\n        if not events.get(key):\n            raise KeyError(f'Requires {key} in events')\n\n\n\ndef assert_readiness_check_state(events, context):\n    \"\"\"\n    Assert ReadinessCheck state\n    \"\"\"\n    required_params = ['ReadinessCheckName', 'DesiredValue', 'Timeout']\n    check_required_params(required_params, events)\n    # Route52-recovery-readiness api working only at us-west-2\n    r53arc_config = Config(\n        region_name='us-west-2',\n        signature_version='v4',\n        retries={\n            'max_attempts': 10,\n            'mode': 'standard'\n        }\n    )\n    client = boto3.client('route53-recovery-readiness', config=r53arc_config)\n    passed = 0\n    iteration = 1\n    time_to_wait = events['Timeout']\n    start = time.time()\n    while passed < time_to_wait:\n        response = client.get_readiness_check_status(\n            ReadinessCheckName=events['ReadinessCheckName']\n        )\n        readiness_check_status = response['Readiness']\n        if readiness_check_status == events['DesiredValue']:\n            logging.info(f'#{iteration}; ReadinessCheck has the expected state: {readiness_check_status} '\n                         f'Elapsed: {passed} sec;')\n            return\n        logging.info(f'#{iteration}; ReadinessCheck has not changed the state: {readiness_check_status} '\n                     f'Elapsed: {passed} sec; Sleep for 10 seconds')\n        time.sleep(10)\n        end = time.time()\n        passed = end - start\n        iteration += 1\n\n    raise TimeoutError(f\"Waiting for ReadinessCheck {events['ReadinessCheckName']} \"\n                       f\"to change state to {events['DesiredValue']}\")",
        "InputPayload": {
          "ReadinessCheckName": "{{ ReadinessCheckName }}",
          "ResourceIdentifier": "{{ BackupCurrentExecution.TableArn }}",
          "DesiredValue": "NOT_READY",
          "Timeout": 1200
        }
      }
    },
    {
      "name": "RollbackCurrentExecution",
      "description": "Revert original value of the DynamoDb stream",
      "action": "aws:executeScript",
      "maxAttempts": 5,
      "onCancel": "step:TriggerRollback",
      "inputs": {
        "Runtime": "python3.8",
        "Handler": "rollback_billing_mode",
        "InputPayload": {
          "TableArn": "{{ BackupCurrentExecution.TableArn }}",
          "DynamoDbBillingMode": "{{ BackupCurrentExecution.OriginalBillingMode }}",
          "DynamoDbReadCapacityUnits": "{{ BackupCurrentExecution.OriginalReadCapacityUnits }}",
          "DynamoDbWriteCapacityUnits": "{{ BackupCurrentExecution.OriginalWriteCapacityUnits }}"
        },
        "Script": "import logging\nimport random\nimport time\nfrom typing import Any, Callable, Iterator, List\n\nimport boto3\nfrom botocore.config import Config\n\nboto3_config = Config(retries={'max_attempts': 20, 'mode': 'standard'})\nlogger = logging.getLogger()\nlogger.setLevel(logging.INFO)\n\nENABLED_INSIGHTS_STATUSES = ['ENABLING', 'ENABLED']\nGLOBAL_TABLE_ACTIVE_STATUSES = ['ACTIVE']\n\n\n\ndef check_required_params(required_params: List[str], events: dict) -> None:\n    \"\"\"\n    Check for required parameters in events. Allow empty, None or 0 values.\n    :param required_params: List of required parameters\n    :param events: input parameters in event\n    :return:\n    \"\"\"\n    for key in required_params:\n        if key not in events:\n            raise KeyError(f'Requires {key} in events')\n\n\n\ndef get_dynamodb_billing_mode(table_name: str, dynamodb_client: boto3.client) -> str:\n    \"\"\"\n    Get current value of the DynamoDB capacity mode\n    :param table_name: table's name\n    :param dynamodb_client: boto3 ddb client\n    :return:\n    \"\"\"\n\n    response = dynamodb_client.describe_table(\n        TableName=table_name\n    )\n    return response['Table'].get('BillingModeSummary', {}).get(\n        'BillingMode', '')\n\n\n\ndef get_dynamodb_read_capacity_units(table_name: str, dynamodb_client: boto3.client) -> int:\n    \"\"\"\n    Get current value of the DynamoDB read capacity units\n    :param table_name: table's name\n    :param dynamodb_client: boto3 ddb client\n    :return:\n    \"\"\"\n    response = dynamodb_client.describe_table(TableName=table_name)\n    return response['Table'].get('ProvisionedThroughput', {}).get('ReadCapacityUnits', 0)\n\n\n\ndef get_dynamodb_write_capacity_units(table_name: str, dynamodb_client: boto3.client) -> int:\n    \"\"\"\n      Get current value of the DynamoDB read capacity units\n      :param table_name: table's name\n      :param dynamodb_client: boto3 ddb client\n      :return:\n      \"\"\"\n\n    response = dynamodb_client.describe_table(\n        TableName=table_name\n    )\n    return response['Table'].get('ProvisionedThroughput', {}).get(\n        'WriteCapacityUnits', 0)\n\ndef set_on_demand_capacity_mode(table_name: str, dynamodb_client: boto3.client):\n    \"\"\"\n    Set the given DynamoDB table capacity mode to on-demand\n    :param table_name: the table name\n    :param dynamodb_client: the boto3 client\n    \"\"\"\n    dynamodb_client.update_table(\n        TableName=table_name,\n        BillingMode='PAY_PER_REQUEST',\n    )\n\n\n\ndef set_provisioned_capacity_mode(table_name: str, dynamodb_client: boto3.client,\n                                  read_capacity_units: int, write_capacity_units: int):\n    \"\"\"\n    Set the given DynamoDB table capacity mode to provisioned, with read/write\n    capacity unites.\n    :param table_name: the table name\n    :param dynamodb_client: the boto3 client\n    :param read_capacity_units: Read capacity units\n    :param write_capacity_units: Write capacity units\n    :return:\n    \"\"\"\n    dynamodb_client.update_table(\n        TableName=table_name,\n        BillingMode='PROVISIONED',\n        ProvisionedThroughput={\n            'ReadCapacityUnits': read_capacity_units,\n            'WriteCapacityUnits': write_capacity_units\n        },\n    )\n\n\n\ndef rollback_billing_mode(events: dict, context: dict) -> None:\n    \"\"\"\n     Rollback the current execution by changing DynamoDB BillingMode\n     :param events: The dictionary that supposed to have the following keys:\n     * `TableArn` - The source table arn\n     * `DynamoDbBillingMode` - PAR_PER_REQUEST or PROVISIONED\n     :param context: context\n     :return:\n     \"\"\"\n    required_params = [\n        'TableArn',\n        'DynamoDbBillingMode',\n        'DynamoDbReadCapacityUnits',\n        'DynamoDbWriteCapacityUnits'\n    ]\n\n    check_required_params(required_params, events)\n    region = events['TableArn'].split(\":\")[3]\n    table_name = events['TableArn'].split(\"/\")[1]\n    billing_mode = events['DynamoDbBillingMode']\n    read_capacity_units = events['DynamoDbReadCapacityUnits']\n    write_capacity_units = events['DynamoDbWriteCapacityUnits']\n\n    dynamodb_config = Config(\n        region_name=region,\n        retries={\n            'max_attempts': 20,\n            'mode': 'standard'\n        }\n    )\n    dynamodb_client = boto3.client('dynamodb', config=dynamodb_config)\n\n    response = dynamodb_client.describe_table(\n        TableName=table_name\n    )\n\n    current_dynamodb_billing_mode = response['Table'].get('BillingModeSummary', {}).get(\n        'BillingMode', '')\n    if not current_dynamodb_billing_mode or current_dynamodb_billing_mode == \"PROVISIONED\":\n        set_on_demand_capacity_mode(table_name, dynamodb_client)\n    else:\n        set_provisioned_capacity_mode(table_name, dynamodb_client, read_capacity_units, write_capacity_units)\n    logger.info(f'DynamoDb stream value for the table {table_name} was '\n                f'successfully rolled back from {current_dynamodb_billing_mode} to {billing_mode}.')"
      }
    },
    {
      "name": "AssertReadinessCheckToBeReady",
      "description": "Wait for the ReadinessCheck to become READY after test is complete",
      "action": "aws:executeScript",
      "inputs": {
        "Runtime": "python3.8",
        "Handler": "assert_readiness_check_state",
        "Script": "import logging\nimport random\nimport time\n\nimport boto3\nfrom botocore.config import Config\nfrom botocore.exceptions import ClientError\n\nlogger = logging.getLogger(__name__)\nlogger.setLevel(logging.INFO)\n\n\n\ndef check_required_params(required_params, events):\n    \"\"\"\n    Check for required parameters in events.\n    \"\"\"\n    for key in required_params:\n        if not events.get(key):\n            raise KeyError(f'Requires {key} in events')\n\n\n\ndef assert_readiness_check_state(events, context):\n    \"\"\"\n    Assert ReadinessCheck state\n    \"\"\"\n    required_params = ['ReadinessCheckName', 'DesiredValue', 'Timeout']\n    check_required_params(required_params, events)\n    # Route52-recovery-readiness api working only at us-west-2\n    r53arc_config = Config(\n        region_name='us-west-2',\n        signature_version='v4',\n        retries={\n            'max_attempts': 10,\n            'mode': 'standard'\n        }\n    )\n    client = boto3.client('route53-recovery-readiness', config=r53arc_config)\n    passed = 0\n    iteration = 1\n    time_to_wait = events['Timeout']\n    start = time.time()\n    while passed < time_to_wait:\n        response = client.get_readiness_check_status(\n            ReadinessCheckName=events['ReadinessCheckName']\n        )\n        readiness_check_status = response['Readiness']\n        if readiness_check_status == events['DesiredValue']:\n            logging.info(f'#{iteration}; ReadinessCheck has the expected state: {readiness_check_status} '\n                         f'Elapsed: {passed} sec;')\n            return\n        logging.info(f'#{iteration}; ReadinessCheck has not changed the state: {readiness_check_status} '\n                     f'Elapsed: {passed} sec; Sleep for 10 seconds')\n        time.sleep(10)\n        end = time.time()\n        passed = end - start\n        iteration += 1\n\n    raise TimeoutError(f\"Waiting for ReadinessCheck {events['ReadinessCheckName']} \"\n                       f\"to change state to {events['DesiredValue']}\")",
        "InputPayload": {
          "ReadinessCheckName": "{{ ReadinessCheckName }}",
          "ResourceIdentifier": "{{ BackupCurrentExecution.TableArn }}",
          "DesiredValue": "READY",
          "Timeout": 1200
        }
      },
      "isEnd": true
    },
    {
      "name": "TriggerRollback",
      "description": "This step is executed when ssm document is cancelled while it was in progress. This step starts a new execution of document in rollback mode to rollback the changes made as part of normal execution",
      "action": "aws:executeScript",
      "onFailure": "Abort",
      "outputs": [
        {
          "Name": "RollbackExecutionId",
          "Selector": "$.Payload.RollbackExecutionId",
          "Type": "String"
        }
      ],
      "inputs": {
        "Runtime": "python3.8",
        "Handler": "start_rollback_execution",
        "InputPayload": {
          "ExecutionId": "{{automation:EXECUTION_ID}}"
        },
        "Script": "import json\n\nimport boto3\nfrom botocore.config import Config\n\n\n\ndef start_rollback_execution(events, context):\n    output = {}\n    config = Config(retries={'max_attempts': 20, 'mode': 'standard'})\n    ssm = boto3.client('ssm', config=config)\n\n    if 'ExecutionId' not in events or not events['ExecutionId']:\n        raise KeyError('Requires not empty ExecutionId')\n\n    response = ssm.get_automation_execution(AutomationExecutionId=events['ExecutionId'])\n\n    # Get parameters for current execution and add IsRollback and PreviousExecutionId\n    response_parameters = response['AutomationExecution']['Parameters']\n    response_parameters['IsRollback'] = ['true']\n    response_parameters['PreviousExecutionId'] = [events['ExecutionId']]\n\n    rollback_execution_response = ssm.start_automation_execution(\n        DocumentName=response['AutomationExecution']['DocumentName'],\n        DocumentVersion=response['AutomationExecution']['DocumentVersion'],\n        Parameters=response_parameters\n    )\n    output['RollbackExecutionId'] = rollback_execution_response['AutomationExecutionId']\n    return output"
      },
      "isEnd": true
    }
  ]
}
