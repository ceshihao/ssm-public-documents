{
  "description": "The **AWSSupport-ResetLinuxUserPassword** runbook allows you to set or reset the password of a local user. The user and password can be used for serial console access to troubleshoot boot, network configuration, and other issues on Nitro instances. For more information please review [Configure access to the EC2 Serial Console](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/configure-access-to-serial-console.html). The runbook creates a temporary Amazon Elastic Compute Cloud (Amazon EC2) instance in your account and an AWS Identity and Access Management (IAM) role that is attached to the temporary EC2 instance with permissions to retrieve the AWS Secrets Manager secret value containing the password. The runbook stops the target EC2 instance, detaches the root volume, and attach it to the temporary instance where a script is executed using AWS Systems Manager Run Command to set the user password. Then the volume is attached back to your instance. The runbook requires you to provide an AWS Secrets Manager *plaintext* secret containing the password. In case of failure, the runbook creates a new volume from the snapshot and attach it to the target Amazon EC2 Instance if you have selected the option to create a snapshot.\n\n## Important:\n\nThe helper EC2 instance subnet must allow access to the AWS Systems Manager and AWS Secrets Manager endpoints (`ec2messages`, `ssmmessages`, and `secretsmanager`) via Virtual Private Cloud (VPC) interface endpoints or Internet. For more details refer to: https://docs.aws.amazon.com/systems-manager/latest/userguide/systems-manager-setting-up-ec2.html\n\n## AWS Secrets Manager setup:\n\nThe script retrieves and encrypts the password with a runtime call to Secrets Manager. Follow these steps to create a new AWS Secrets Manager secret:\n\n1. Open the Secrets Manager console at https://console.aws.amazon.com/secretsmanager/\n1. Choose **Store a new secret**.\n1. On the **Choose secret type** page, choose **Other type of secret**\n1. In Key/value pairs choose the **Plaintext** tab and enter the password (We recommend setting a password that adheres to a strong password policy).\n1. For **Encryption key**, choose **aws/secretsmanager** to use the AWS managed key for Secrets Manager.\n1. On the **Configure secret** page, enter a descriptive **Secret name** and **Description**. Click **Next**\n1. On the **Configure rotation** page, you can choose to turn on automatic rotation. You can also keep rotation off for now and then turn it on later. Click **Next**\n1. On the **Review** page, review your secret details, and then choose **Store**.\n1. Take note of the **Secret ARN**. You will use this value in the ```SecretArn``` runbook parameter.\n\nFor more details refer to [Create an AWS Secrets Manager secret](https://docs.aws.amazon.com/secretsmanager/latest/userguide/create_secret.html). Please refer to [Authentication and access control for AWS Secrets Manager](https://docs.aws.amazon.com/secretsmanager/latest/userguide/auth-and-access.html) for information about to secure access to secrets.\n\n\n### Important:\n\n> * Changing the local user password requires the runbook to **stop** your EC2 instance. When the instance is stopped, any data stored in the RAM or the instance store volumes is lost, and the automatic public IPv4 address is released. For more information please review [Stop and start your instance](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Stop_Start.html#instance_stop).\n> * It is a good practice to make regular backups of your persistent disk data. Consider taking a snapshot of your EBS volumes before running this runbook or set the ```CreateSnapshot``` parameter as ```Yes```.\n> * If your EC2 instance EBS volumes are encrypted with a customer managed AWS Key Management Service (KMS) key, make sure the KMS key is not **deleted** or **disabled** or your instance will fail to start.\nThe temporary instance type is `t3.small` or `t4g.small` if the target instance is powered by Arm-based Amazon Graviton2.\n\n\n### Supported Operating Systems:\n\n> * Amazon Linux 2, and Amazon Linux 2023.\n> * Ubuntu Server 18.04 LTS, 20.04 LTS, and Ubuntu 22.04 LTS.\n> * SUSE Linux Enterprise Server 15.\n> * Debian 11, and 12.",
  "schemaVersion": "0.3",
  "assumeRole": "{{ AutomationAssumeRole }}",
  "parameters": {
    "InstanceId": {
      "type": "AWS::EC2::Instance::Id",
      "description": "(Required) The EC2 instance ID of the target instance on which the Linux user password should be set or reset."
    },
    "SecretArn": {
      "type": "String",
      "description": "(Required) The Amazon Resource Name (ARN) of your Secrets Manager secret containing the password. The AWS CloudFormation stack creates a temporary instance with permissions to perform the GetSecretValue operation to this ARN. Make sure that the password is stored as plaintext.",
      "allowedPattern": "^arn:(aws|aws-cn|aws-us-gov|aws-iso|aws-iso-b):secretsmanager:[a-z0-9-]{2,20}:[0-9]{12}:secret:[a-zA-Z0-9]{1}[a-zA-Z0-9\\/_+=.@-]{1,256}$"
    },
    "LinuxUserName": {
      "type": "String",
      "description": "(Optional) The username for which you want to reset the password. Defaults to 'ec2-user'. Please refer to [Manage user accounts on your Linux instance](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/managing-users.html) to see a list of the default user names for Linux Amazon Machine Images (AMIs) provided by AWS.",
      "default": "ec2-user",
      "allowedPattern": "^[a-zA-Z0-9\\\\_.@-]{1,32}$"
    },
    "AutomationAssumeRole": {
      "type": "AWS::IAM::Role::Arn",
      "description": "(Optional) The Amazon Resource Name (ARN) of the AWS Identity and Access Management (IAM) role that allows Systems Manager Automation to perform the actions on your behalf. If no role is specified, Systems Manager Automation uses the permissions of the user that starts this runbook.",
      "default": ""
    },
    "SecurityGroupId": {
      "type": "String",
      "description": "(Optional) The security group ID that will be associated to the temporary EC2 instance. If not provided, the default VPC security group is used. Note: The helper instance security group must allow HTTPS (port 443) outbound traffic to the Secrets Manager and Systems Manager endpoints.",
      "allowedPattern": "^$|sg\\-[a-z0-9]{8,17}$",
      "default": ""
    },
    "SubnetId": {
      "type": "String",
      "description": "(Optional) The subnet ID for the EC2 helper instance. By default, the same subnet where the provided instance resides is used. Important: If you provide a custom subnet, it must be in the same Availability Zone as `InstanceId`. The helper instance subnet must allow access to the Secrets Manager and Systems Manager endpoints via VPC endpoints or Internet.",
      "allowedPattern": "^$|^subnet\\-[a-z0-9]{8,17}$",
      "default": ""
    },
    "CreateSnapshot": {
      "type": "String",
      "description": "(Required) Select `Yes` or `No` to create a snapshot of the target instance root EBS volume before running this automation.",
      "allowedValues": [
        "Yes",
        "No"
      ]
    },
    "StopConsent": {
      "type": "String",
      "description": "(Required) Select `Yes` if you acknowledge that this runbook will stop and start your EC2 instance if it was running in order to detach its root EBS volume. When the instance is stopped, any data stored in the RAM or the instance store volumes is lost, and the automatic public IPv4 address is released. For more information please review [Stop and start your instance](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Stop_Start.html#instance_stop).",
      "allowedValues": [
        "Yes",
        "No"
      ]
    }
  },
  "outputs": [
    "SetPasswordForLinuxUser.Output"
  ],
  "mainSteps": [
    {
      "name": "BranchOnStopConsent",
      "action": "aws:branch",
      "description": "Branches on explicit consent for stopping the target Amazon EC2 instance.",
      "onFailure": "Abort",
      "isEnd": true,
      "inputs": {
        "Choices": [
          {
            "NextStep": "AssertInitialState",
            "Variable": "{{ StopConsent }}",
            "StringEquals": "Yes"
          }
        ]
      }
    },
    {
      "name": "AssertInitialState",
      "action": "aws:assertAwsResourceProperty",
      "description": "Ensures the EC2 instance status is in `running` or `stopped` state; otherwise the automation ends.",
      "nextStep": "GetInstanceProperties",
      "onFailure": "Abort",
      "inputs": {
        "Service": "ec2",
        "Api": "DescribeInstances",
        "InstanceIds": [
          "{{ InstanceId }}"
        ],
        "PropertySelector": "Reservations[0].Instances[0].State.Name",
        "DesiredValues": [
          "running",
          "stopped"
        ]
      }
    },
    {
      "name": "GetInstanceProperties",
      "action": "aws:executeAwsApi",
      "description": "Gets the target EC2 instance properties.",
      "onFailure": "Abort",
      "nextStep": "GetInstanceRootVolume",
      "inputs": {
        "Service": "ec2",
        "Api": "DescribeInstances",
        "InstanceIds": [
          "{{ InstanceId }}"
        ]
      },
      "outputs": [
        {
          "Name": "RootDeviceName",
          "Selector": "$.Reservations[0].Instances[0].RootDeviceName",
          "Type": "String"
        },
        {
          "Name": "Architecture",
          "Selector": "$.Reservations[0].Instances[0].Architecture",
          "Type": "String"
        },
        {
          "Name": "SecurityGroupIds",
          "Selector": "$.Reservations[0].Instances[0].SecurityGroups..GroupId",
          "Type": "StringList"
        },
        {
          "Name": "State",
          "Selector": "$.Reservations[0].Instances[0].State.Name",
          "Type": "String"
        },
        {
          "Name": "SubnetId",
          "Selector": "$.Reservations[0].Instances[0].NetworkInterfaces[0].SubnetId",
          "Type": "String"
        },
        {
          "Name": "Platform",
          "Selector": "$.Reservations[0].Instances[0].Platform",
          "Type": "String"
        },
        {
          "Name": "AvailabilityZone",
          "Selector": "$.Reservations[0].Instances[0].Placement.AvailabilityZone",
          "Type": "String"
        },
        {
          "Name": "InstanceLifecycle",
          "Selector": "$.Reservations[0].Instances[0].InstanceLifecycle",
          "Type": "String"
        }
      ]
    },
    {
      "name": "GetInstanceRootVolume",
      "description": "Gets the EC2 instance root volume properties.",
      "action": "aws:executeAwsApi",
      "nextStep": "BranchOnSubnetId",
      "onFailure": "Abort",
      "inputs": {
        "Service": "ec2",
        "Api": "DescribeVolumes",
        "Filters": [
          {
            "Name": "attachment.instance-id",
            "Values": [
              "{{ InstanceId }}"
            ]
          },
          {
            "Name": "attachment.device",
            "Values": [
              "{{ GetInstanceProperties.RootDeviceName }}"
            ]
          }
        ]
      },
      "outputs": [
        {
          "Name": "RootDeviceVolumeId",
          "Selector": "$.Volumes[0].Attachments[0].VolumeId",
          "Type": "String"
        },
        {
          "Name": "RootDeviceDeleteOnTermination",
          "Selector": "$.Volumes[0].Attachments[0].DeleteOnTermination",
          "Type": "Boolean"
        }
      ]
    },
    {
      "name": "BranchOnSubnetId",
      "description": "Branches the automation depending on whether an custom subnet ID for the temporary EC2 instance was provided or not.",
      "action": "aws:branch",
      "nextStep": "AssertCustomSubnetIsInSameAZAsInstance",
      "inputs": {
        "Choices": [
          {
            "NextStep": "AssertInstanceRootVolumeIsEbs",
            "Variable": "{{ SubnetId }}",
            "StringEquals": ""
          }
        ],
        "Default": "AssertCustomSubnetIsInSameAZAsInstance"
      }
    },
    {
      "name": "AssertCustomSubnetIsInSameAZAsInstance",
      "action": "aws:assertAwsResourceProperty",
      "description": "Ensures the custom subnet is in the same availability zone as the target EC2 instance.",
      "nextStep": "AssertInstanceRootVolumeIsEbs",
      "onFailure": "Abort",
      "inputs": {
        "Service": "ec2",
        "Api": "DescribeSubnets",
        "SubnetIds": [
          "{{ SubnetId }}"
        ],
        "PropertySelector": "$.Subnets[0].AvailabilityZone",
        "DesiredValues": [
          "{{ GetInstanceProperties.AvailabilityZone }}"
        ]
      }
    },
    {
      "name": "AssertInstanceRootVolumeIsEbs",
      "description": "Ensures the target EC2 instance root volume is EBS.",
      "action": "aws:assertAwsResourceProperty",
      "nextStep": "AssertInstanceArchitecture",
      "onFailure": "Abort",
      "inputs": {
        "Service": "ec2",
        "Api": "DescribeInstances",
        "InstanceIds": [
          "{{ InstanceId }}"
        ],
        "PropertySelector": "$.Reservations[0].Instances[0].RootDeviceType",
        "DesiredValues": [
          "ebs"
        ]
      }
    },
    {
      "name": "AssertInstanceArchitecture",
      "action": "aws:assertAwsResourceProperty",
      "description": "Ensures the target EC2 instance architecture is `arm64` or `x86_64`.",
      "nextStep": "AssertInstanceStopBehaviorIsStop",
      "onFailure": "Abort",
      "inputs": {
        "Service": "ec2",
        "Api": "DescribeInstances",
        "InstanceIds": [
          "{{ InstanceId }}"
        ],
        "PropertySelector": "$.Reservations[0].Instances[0].Architecture",
        "DesiredValues": [
          "arm64",
          "x86_64"
        ]
      }
    },
    {
      "name": "AssertInstanceStopBehaviorIsStop",
      "action": "aws:assertAwsResourceProperty",
      "description": "Ensures the target EC2 instance shutdown behavior is `stop` and not `terminate`.",
      "nextStep": "BranchOnInstanceLifecycleIsNotSpot",
      "onFailure": "Abort",
      "inputs": {
        "Service": "ec2",
        "Api": "DescribeInstanceAttribute",
        "InstanceId": "{{ InstanceId }}",
        "Attribute": "instanceInitiatedShutdownBehavior",
        "PropertySelector": "$.InstanceInitiatedShutdownBehavior.Value",
        "DesiredValues": [
          "stop"
        ]
      }
    },
    {
      "name": "BranchOnInstanceLifecycleIsNotSpot",
      "action": "aws:branch",
      "description": "Ensures the target EC2 instance Lifecycle is not `Spot`; otherwise the automation ends.",
      "onFailure": "Abort",
      "isEnd": true,
      "inputs": {
        "Choices": [
          {
            "NextStep": "AssertNotPartOfAutoScalingGroup",
            "Not": {
              "Variable": "{{ GetInstanceProperties.InstanceLifecycle }}",
              "StringEquals": "spot"
            }
          }
        ]
      }
    },
    {
      "name": "AssertNotPartOfAutoScalingGroup",
      "action": "aws:executeScript",
      "description": "Ensures the target EC2 instance is not part of an Amazon EC2 Auto Scaling group by calling the `DescribeAutoScalingInstances` API. If the instance is part of an Amazon EC2 Auto Scaling group, ensures the EC2 instance is in 'Standby' lifecycle state.",
      "nextStep": "CreateEc2HelperInstance",
      "onFailure": "Abort",
      "timeoutSeconds": 600,
      "inputs": {
        "InputPayload": {
          "InstanceId": "{{ InstanceId }}"
        },
        "Handler": "check_autoscaling.check_autoscaling_resource",
        "Runtime": "python3.11",
        "Attachment": "attachment.zip"
      }
    },
    {
      "name": "CreateEc2HelperInstance",
      "action": "aws:createStack",
      "description": "Creates a temporary EC2 instance to be used for resetting the user password using AWS CloudFormation.",
      "nextStep": "WaitForEc2HelperInstanceCreation",
      "onFailure": "step:DescribeCloudFormationErrorFromStackEvents",
      "isCritical": true,
      "onCancel": "step:DescribeCloudFormationErrorFromStackEvents",
      "maxAttempts": 1,
      "inputs": {
        "Capabilities": [
          "CAPABILITY_IAM"
        ],
        "StackName": "AWSSupport-ResetLinuxUserPassword-{{ automation:EXECUTION_ID }}",
        "OnFailure": "DELETE",
        "ClientRequestToken": "AWSSupport-ResetLinuxUserPassword-{{ automation:EXECUTION_ID }}",
        "TimeoutInMinutes": 10,
        "Parameters": [
          {
            "ParameterKey": "CustomSecurityGroupId",
            "ParameterValue": "{{ SecurityGroupId }}"
          },
          {
            "ParameterKey": "CustomSubnetId",
            "ParameterValue": "{{ SubnetId }}"
          },
          {
            "ParameterKey": "InstanceSubnetId",
            "ParameterValue": "{{ GetInstanceProperties.SubnetId }}"
          },
          {
            "ParameterKey": "Architecture",
            "ParameterValue": "{{ GetInstanceProperties.Architecture }}"
          },
          {
            "ParameterKey": "SecretArn",
            "ParameterValue": "{{ SecretArn }}"
          },
          {
            "ParameterKey": "ExecutionId",
            "ParameterValue": "{{ automation:EXECUTION_ID }}"
          }
        ],
        "TemplateBody": "# Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n# SPDX-License-Identifier: LicenseRef-.amazon.com.-AmznSL-1.0\n# Licensed under the Amazon Software License  http://aws.amazon.com/asl/\n\nAWSTemplateFormatVersion: 2010-09-09\nDescription: Deploy Single EC2 Linux Instance with IAM Instance profile\nParameters:\n  CustomSecurityGroupId:\n    Type: String\n    Default: ''\n  CustomSubnetId:\n    Type: String\n    Default: ''\n  InstanceSubnetId:\n    Type: String\n    Default: ''\n  Architecture:\n    Type: String\n    AllowedValues:\n      - arm64\n      - x86_64\n  SecretArn:\n    Type: String\n  ExecutionId:\n    Type: String\n    Default: 00000000-0000-0000-0000-000000000000\n  AmiId:\n    Type: 'AWS::SSM::Parameter::Value<AWS::EC2::Image::Id>'\n    Default: /aws/service/ami-amazon-linux-latest/amzn2-ami-kernel-5.10-hvm-x86_64-gp2\n  AmiIdARM:\n    Type: 'AWS::SSM::Parameter::Value<AWS::EC2::Image::Id>'\n    Default: /aws/service/ami-amazon-linux-latest/amzn2-ami-kernel-5.10-hvm-arm64-gp2\nConditions:\n  IsArchitectureARM: !Equals\n    - !Ref Architecture\n    - arm64\n  UseCustomSecurityGroup: !Not\n    - !Equals\n      - !Ref CustomSecurityGroupId\n      - ''\n  UseCustomSubnet: !Not\n    - !Equals\n      - !Ref CustomSubnetId\n      - ''\n  IsIsoPartition: !Or\n    - !Equals \n      - !Sub '${AWS::Partition}'\n      - 'aws-iso'\n    - !Equals \n      - !Sub '${AWS::Partition}'\n      - 'aws-iso-b'\n    - !Equals \n      - !Sub '${AWS::Partition}'\n      - 'aws-iso-e'\n    - !Equals \n      - !Sub '${AWS::Partition}'\n      - 'aws-iso-f'\nResources:\n  HelperIamInstanceProfileRole:\n    Type: 'AWS::IAM::Role'\n    Properties:\n      AssumeRolePolicyDocument:\n        Version: 2012-10-17\n        Statement:\n          - Effect: Allow\n            Principal:\n              Service:\n                - ec2.amazonaws.com\n            Action:\n              - 'sts:AssumeRole'\n      ManagedPolicyArns:\n        - !Sub 'arn:${AWS::Partition}:iam::aws:policy/AmazonSSMManagedInstanceCore'\n        - !Sub 'arn:${AWS::Partition}:iam::aws:policy/AmazonSSMPatchAssociation'\n      Policies:\n        - PolicyName: AllowSecretsManagerAccess\n          PolicyDocument:\n            Version: 2012-10-17\n            Statement:\n              - Effect: Allow\n                Action:\n                  - 'secretsmanager:GetSecretValue'\n                Resource: !Ref SecretArn\n              - Effect: Allow\n                Action:\n                  - 'kms:Decrypt'\n                  - 'kms:DescribeKey'\n                Resource: '*'\n                Condition:\n                  StringEquals:\n                    'kms:CallerAccount': !Sub '${AWS::AccountId}'\n                    'kms:ViaService': !Sub 'secretsmanager.${AWS::Region}.amazonaws.com'\n                  StringLike:\n                    'kms:EncryptionContext:SecretARN': !Ref SecretArn\n  HelperIamInstanceProfile:\n    Type: 'AWS::IAM::InstanceProfile'\n    Properties:\n      Roles:\n        - !Ref HelperIamInstanceProfileRole\n  HelperEc2InstanceLaunchTemplate:\n    Type: AWS::EC2::LaunchTemplate\n    Properties:\n      LaunchTemplateData:\n        MetadataOptions:\n          HttpEndpoint: enabled\n          HttpTokens: required\n          HttpPutResponseHopLimit: 1\n  HelperEc2Instance:\n    Type: 'AWS::EC2::Instance'\n    Properties:\n      IamInstanceProfile: !Ref HelperIamInstanceProfile\n      Tags:\n        - Key: Name\n          Value: !Sub 'AWSSupport-ResetLinuxUserPassword-${ExecutionId}'\n      ImageId: !If\n        - IsArchitectureARM\n        - !Ref AmiIdARM\n        - !Ref AmiId\n      LaunchTemplate:\n        LaunchTemplateId: !Ref HelperEc2InstanceLaunchTemplate\n        Version: !GetAtt HelperEc2InstanceLaunchTemplate.LatestVersionNumber\n      InstanceType: !If\n        - IsArchitectureARM\n        - !If\n          - IsIsoPartition\n          - m6g.medium\n          - t4g.small\n        - t3.small\n      PropagateTagsToVolumeOnCreation: true\n      BlockDeviceMappings:\n        - DeviceName: /dev/xvda\n          Ebs:\n            VolumeSize: 8\n            Encrypted: true\n            VolumeType: gp3\n            DeleteOnTermination: true\n      NetworkInterfaces:\n        - DeleteOnTermination: true\n          AssociatePublicIpAddress: true\n          DeviceIndex: '0'\n          GroupSet:\n            - !If\n              - UseCustomSecurityGroup\n              - !Ref CustomSecurityGroupId\n              - Ref: AWS::NoValue\n          SubnetId: !If\n            - UseCustomSubnet\n            - !Ref CustomSubnetId\n            - !Ref InstanceSubnetId\nOutputs:\n  HelperInstanceId:\n    Description: The Instance ID\n    Value: !Ref HelperEc2Instance",
        "Tags": [
          {
            "Key": "Name",
            "Value": "AWSSupport-ResetLinuxUserPassword-{{ automation:EXECUTION_ID }}"
          },
          {
            "Key": "AWSSupport-ResetLinuxUserPassword-AutomationExecution",
            "Value": "{{ automation:EXECUTION_ID }}"
          }
        ]
      },
      "outputs": [
        {
          "Name": "CloudformationStackId",
          "Selector": "$.StackId",
          "Type": "String"
        },
        {
          "Name": "CloudformationStackStatus",
          "Selector": "$.StackStatus",
          "Type": "String"
        }
      ]
    },
    {
      "name": "WaitForEc2HelperInstanceCreation",
      "action": "aws:waitForAwsResourceProperty",
      "description": "Waits until the Amazon EC2 instance created by the AWS CloudFormation is in `running` state.",
      "nextStep": "FindEc2HelperInstanceId",
      "onFailure": "step:DescribeCloudFormationErrorFromStackEvents",
      "onCancel": "step:DescribeCloudFormationErrorFromStackEvents",
      "isCritical": true,
      "maxAttempts": 10,
      "timeoutSeconds": 150,
      "inputs": {
        "Service": "cloudformation",
        "Api": "DescribeStacks",
        "StackName": "{{ CreateEc2HelperInstance.CloudformationStackId }}",
        "PropertySelector": "$.Stacks[0].StackStatus",
        "DesiredValues": [
          "UPDATE_COMPLETE",
          "CREATE_COMPLETE"
        ]
      }
    },
    {
      "name": "FindEc2HelperInstanceId",
      "action": "aws:executeAwsApi",
      "description": "Gets the ID of the EC2 helper instance created by AWS CloudFormation.",
      "nextStep": "WaitForHelperInstanceToBeSsmManaged",
      "isCritical": true,
      "onFailure": "step:DescribeCloudFormationErrorFromStackEvents",
      "onCancel": "step:DescribeCloudFormationErrorFromStackEvents",
      "inputs": {
        "Service": "cloudformation",
        "Api": "DescribeStackResource",
        "StackName": "{{ CreateEc2HelperInstance.CloudformationStackId }}",
        "LogicalResourceId": "HelperEc2Instance"
      },
      "outputs": [
        {
          "Name": "HelperInstanceId",
          "Selector": "$.StackResourceDetail.PhysicalResourceId",
          "Type": "String"
        }
      ]
    },
    {
      "name": "WaitForHelperInstanceToBeSsmManaged",
      "action": "aws:waitForAwsResourceProperty",
      "description": "Waits for the temporary EC2 helper instance to become managed by Systems Manager.",
      "nextStep": "StopInstance",
      "isCritical": true,
      "onFailure": "step:DescribeCloudFormationErrorFromStackEvents",
      "onCancel": "step:DescribeCloudFormationErrorFromStackEvents",
      "timeoutSeconds": 600,
      "inputs": {
        "Service": "ssm",
        "Api": "DescribeInstanceInformation",
        "InstanceInformationFilterList": [
          {
            "key": "InstanceIds",
            "valueSet": [
              "{{ FindEc2HelperInstanceId.HelperInstanceId }}"
            ]
          }
        ],
        "PropertySelector": "$.InstanceInformationList[0].PingStatus",
        "DesiredValues": [
          "Online"
        ]
      }
    },
    {
      "name": "StopInstance",
      "action": "aws:changeInstanceState",
      "description": "Stops the target EC2 instance.",
      "nextStep": "BranchOnCreateSnapshot",
      "isCritical": false,
      "onFailure": "step:ForceStopInstance",
      "onCancel": "step:BranchOnPreviousInstanceState",
      "maxAttempts": 3,
      "timeoutSeconds": 300,
      "inputs": {
        "InstanceIds": [
          "{{ InstanceId }}"
        ],
        "CheckStateOnly": false,
        "DesiredState": "stopped",
        "Force": false
      }
    },
    {
      "name": "ForceStopInstance",
      "action": "aws:changeInstanceState",
      "description": "Forces the target EC2 instance to stop in case it gets stuck in stopping state.",
      "nextStep": "BranchOnCreateSnapshot",
      "isCritical": true,
      "onFailure": "step:BranchOnPreviousInstanceState",
      "onCancel": "step:BranchOnPreviousInstanceState",
      "maxAttempts": 3,
      "timeoutSeconds": 300,
      "inputs": {
        "InstanceIds": [
          "{{ InstanceId }}"
        ],
        "CheckStateOnly": false,
        "DesiredState": "stopped",
        "Force": true
      }
    },
    {
      "name": "BranchOnCreateSnapshot",
      "action": "aws:branch",
      "description": "Branches the automation depending on whether an snapshot of the target EC2 instance EBS root volume was requested or not.",
      "isEnd": true,
      "inputs": {
        "Choices": [
          {
            "NextStep": "CreateSnapshot",
            "Variable": "{{ CreateSnapshot }}",
            "StringEquals": "Yes"
          },
          {
            "NextStep": "DetachRootEbsVolumeFromInstance",
            "Variable": "{{ CreateSnapshot }}",
            "StringEquals": "No"
          }
        ]
      }
    },
    {
      "name": "CreateSnapshot",
      "action": "aws:executeAwsApi",
      "description": "Creates an snapshot of the target EC2 instance root EBS volume.",
      "nextStep": "WaitForSnapshotCompleted",
      "isCritical": true,
      "onFailure": "step:BranchOnPreviousInstanceState",
      "onCancel": "step:BranchOnPreviousInstanceState",
      "maxAttempts": 3,
      "inputs": {
        "Service": "ec2",
        "Api": "CreateSnapshot",
        "VolumeId": "{{ GetInstanceRootVolume.RootDeviceVolumeId }}"
      },
      "outputs": [
        {
          "Name": "SnapshotId",
          "Selector": "SnapshotId",
          "Type": "String"
        }
      ]
    },
    {
      "name": "WaitForSnapshotCompleted",
      "action": "aws:waitForAwsResourceProperty",
      "description": "Waits for the snapshot to be in `completed` state.",
      "nextStep": "DetachRootEbsVolumeFromInstance",
      "isCritical": true,
      "onFailure": "step:BranchOnPreviousInstanceState",
      "onCancel": "step:BranchOnPreviousInstanceState",
      "maxAttempts": 3,
      "inputs": {
        "Service": "ec2",
        "Api": "DescribeSnapshots",
        "SnapshotIds": [
          "{{ CreateSnapshot.SnapshotId }}"
        ],
        "PropertySelector": "$.Snapshots[0].State",
        "DesiredValues": [
          "completed"
        ]
      }
    },
    {
      "name": "DetachRootEbsVolumeFromInstance",
      "action": "aws:executeAwsApi",
      "description": "Detaches the EBS root volume from the target EC2 instance.",
      "nextStep": "WaitForInstanceRootVolumeToBeDetached",
      "isCritical": true,
      "onFailure": "step:AttachRootEbsVolumeBackToInstance",
      "onCancel": "step:AttachRootEbsVolumeBackToInstance",
      "maxAttempts": 3,
      "inputs": {
        "Service": "ec2",
        "Api": "DetachVolume",
        "VolumeId": "{{ GetInstanceRootVolume.RootDeviceVolumeId }}"
      }
    },
    {
      "name": "WaitForInstanceRootVolumeToBeDetached",
      "description": "Waits for the EBS root volume to be detached from the target EC2 instance.",
      "nextStep": "AttachRootEbsVolumeToHelperInstance",
      "action": "aws:waitForAwsResourceProperty",
      "isCritical": true,
      "onFailure": "step:AttachRootEbsVolumeBackToInstance",
      "onCancel": "step:AttachRootEbsVolumeBackToInstance",
      "timeoutSeconds": 180,
      "inputs": {
        "Service": "ec2",
        "Api": "DescribeVolumes",
        "VolumeIds": [
          "{{ GetInstanceRootVolume.RootDeviceVolumeId }}"
        ],
        "PropertySelector": "$.Volumes[0].State",
        "DesiredValues": [
          "available"
        ]
      }
    },
    {
      "name": "AttachRootEbsVolumeToHelperInstance",
      "action": "aws:executeAwsApi",
      "description": "Attaches the root EBS volume to the helper EC2 instance.",
      "nextStep": "WaitForInstanceRootVolumeToBeAttachedToHelperInstance",
      "isCritical": true,
      "onFailure": "step:AttachRootEbsVolumeBackToInstance",
      "onCancel": "step:AttachRootEbsVolumeBackToInstance",
      "maxAttempts": 3,
      "inputs": {
        "Service": "ec2",
        "Api": "AttachVolume",
        "Device": "/dev/xvdbf",
        "InstanceId": "{{ FindEc2HelperInstanceId.HelperInstanceId }}",
        "VolumeId": "{{ GetInstanceRootVolume.RootDeviceVolumeId }}"
      }
    },
    {
      "name": "WaitForInstanceRootVolumeToBeAttachedToHelperInstance",
      "description": "Waits for the EBS root volume to be attached to the helper EC2 instance.",
      "nextStep": "WaitBeforeRunningScript",
      "isCritical": true,
      "action": "aws:waitForAwsResourceProperty",
      "onFailure": "step:AttachRootEbsVolumeBackToInstance",
      "onCancel": "step:AttachRootEbsVolumeBackToInstance",
      "timeoutSeconds": 180,
      "inputs": {
        "Service": "ec2",
        "Api": "DescribeVolumes",
        "VolumeIds": [
          "{{ GetInstanceRootVolume.RootDeviceVolumeId }}"
        ],
        "PropertySelector": "$.Volumes[0].State",
        "DesiredValues": [
          "in-use"
        ]
      }
    },
    {
      "name": "WaitBeforeRunningScript",
      "action": "aws:sleep",
      "description": "Sleeps for 30 seconds before running the set password script.",
      "onFailure": "Continue",
      "nextStep": "SetPasswordForLinuxUser",
      "inputs": {
        "Duration": "PT30S"
      },
      "isCritical": false
    },
    {
      "name": "SetPasswordForLinuxUser",
      "action": "aws:runCommand",
      "description": "Resets the target user password by running a shell script using Systems Manager Run Command on the helper EC2 instance.",
      "nextStep": "DetachEbsRootVolumeFromHelperInstance",
      "onFailure": "step:DetachEbsRootVolumeFromHelperInstanceAfterError",
      "onCancel": "step:AttachRootEbsVolumeBackToInstance",
      "isCritical": true,
      "inputs": {
        "DocumentName": "AWS-RunShellScript",
        "InstanceIds": [
          "{{ FindEc2HelperInstanceId.HelperInstanceId }}"
        ],
        "Parameters": {
          "commands": [
            "#!/bin/sh",
            "# Copyright 2023 Amazon.com, Inc. or its affiliates. All Rights Reserved.",
            "# SPDX-License-Identifier: LicenseRef-.amazon.com.-AmznSL-1.0",
            "# Licensed under the Amazon Software License  http://aws.amazon.com/asl/",
            "",
            "unset HISTFILE",
            "",
            "throw()",
            "{",
            "    echo \"Name=$(grep \"^NAME=\" \"/etc/os-release\")\"",
            "    echo \"Version=$(grep \"^VERSION_ID=\" \"/etc/os-release\")\"",
            "    echo \"Uname: $(uname -r)\"",
            "    echo \"Block devices: $(lsblk)\"",
            "    echo \"Partitions: $(fdisk -l)\"",
            "    echo \"Error: $1\" >&2 # Send message to stderr.",
            "    exit 1",
            "}",
            "",
            "# Create variables for input parameters",
            "user_name=\"{{LinuxUserName}}\"",
            "secret_arn=\"{{SecretArn}}\"",
            "volume_id=\"{{GetInstanceRootVolume.RootDeviceVolumeId}}\"",
            "region=\"{{global:REGION}}\"",
            "",
            "# If the user name is empty, defaults to \"ec2-user\"",
            "if [ -z $user_name ]; then user_name=\"ec2-user\"; fi",
            "",
            "# Create mount folder",
            "mount_dir=\"/awssupport\"; mkdir -p $mount_dir",
            "",
            "partition=\"\"",
            "# Device name used to attach the volume to the instance (See thr 'AttachRootEbsVolumeToHelperInstance' step)",
            "disk=\"/dev/xvdbf\"",
            "if [ \"$(fdisk -l \"$disk\" 2>/dev/null)\" ] ; then",
            "  partition=$(fdisk -l \"$disk\" | awk \"/Device/,EOF\" | grep \"/dev/xvd.*Linux\" | grep -v  boot | cut -d \" \" -f 1)",
            "else",
            "  disk=\"\"",
            "  for device in /sys/devices/pci*/*/nvme/nvme*/serial; do",
            "    vol=$(echo \"$volume_id\" | sed 's/-//g')",
            "    if grep \"$vol\" \"$device\" >/dev/null 2>&1; then",
            "      parentdir=\"$(dirname \"$device\")/uevent\"",
            "      disk=\"$(grep \"DEVNAME\" \"$parentdir\" | cut -d \"=\" -f 2)\"",
            "    fi",
            "  done",
            "  partition=$(fdisk -l \"$disk\" | awk \"/Device/,EOF\" | grep \"/dev/nvme.*Linux\" | grep -v  boot | cut -d \" \" -f 1)",
            "fi",
            "echo \"Found partition $partition for disk $volume_id\"",
            "",
            "",
            "[ -z \"$partition\" ] && throw \"An error occurred when trying to find the partition for disk $disk\"",
            "",
            "# Mount the target instance Amazon EBS root volume",
            "mount \"$partition\" $mount_dir >/dev/null 2>&1 || {",
            "  mount -o nouuid \"$partition\" $mount_dir >/dev/null 2>&1 || throw \"An error occurred when trying to mount the attached volume $volume_id\"",
            "}",
            "echo \"Attached volume $volume_id with partition $partition mounted successfully\"",
            "",
            "# Try to get the Secrets Manager secret ARN to test access to the secret",
            "aws secretsmanager get-secret-value --secret-id $secret_arn --region $region --output text --query ARN >/dev/null 2>&1 || throw \"An error occurred when trying to get $secret_arn\"",
            "",
            "# Change the use password using chpasswd",
            "if echo $user_name:$(aws secretsmanager get-secret-value --secret-id $secret_arn --region $region --output text --query SecretString) | chroot $mount_dir /usr/sbin/chpasswd; then",
            "  echo \"Password successfully set for $user_name\"",
            "  # Unmount the target instance Amazon EBS root volume",
            "  umount $mount_dir >/dev/null 2>&1 || throw \"An error occurred when trying to unmount the attached volume $volume_id\"",
            "  echo \"Attached volume $volume_id unmounted successfully\"",
            "  exit 0",
            "else",
            "  echo \"An error occurred when trying to set the password for $user_name\"",
            "  # Unmount the target instance Amazon EBS root volume",
            "  umount $mount_dir >/dev/null 2>&1 || throw \"An error occurred when trying to unmount the attached volume $volume_id\"",
            "  exit 1",
            "fi"
          ]
        },
        "TimeoutSeconds": 180
      }
    },
    {
      "name": "DetachEbsRootVolumeFromHelperInstance",
      "action": "aws:executeAwsApi",
      "description": "Detaches the EBS root volume from the helper EC2 instance.",
      "nextStep": "WaitForInstanceRootVolumeToBeDetachedFromHelperInstance",
      "isCritical": true,
      "onFailure": "step:BranchOnRestoreRootVolumeIfSnapshot",
      "onCancel": "step:AttachRootEbsVolumeBackToInstance",
      "maxAttempts": 3,
      "inputs": {
        "Service": "ec2",
        "Api": "DetachVolume",
        "VolumeId": "{{ GetInstanceRootVolume.RootDeviceVolumeId }}"
      }
    },
    {
      "name": "WaitForInstanceRootVolumeToBeDetachedFromHelperInstance",
      "description": "Waits for the EBS root volume to be detached from the helper EC2 instance.",
      "action": "aws:waitForAwsResourceProperty",
      "isCritical": true,
      "onCancel": "step:AttachRootEbsVolumeBackToInstance",
      "onFailure": "step:BranchOnRestoreRootVolumeIfSnapshot",
      "nextStep": "AttachRootEbsVolumeBackToInstance",
      "timeoutSeconds": 180,
      "inputs": {
        "Service": "ec2",
        "Api": "DescribeVolumes",
        "VolumeIds": [
          "{{ GetInstanceRootVolume.RootDeviceVolumeId }}"
        ],
        "PropertySelector": "$.Volumes[0].State",
        "DesiredValues": [
          "available"
        ]
      }
    },
    {
      "name": "DetachEbsRootVolumeFromHelperInstanceAfterError",
      "action": "aws:executeAwsApi",
      "description": "Detaches the EBS root volume from the helper EC2 instance after an error.",
      "nextStep": "WaitForInstanceRootVolumeToBeDetachedFromHelperInstanceAfterError",
      "isCritical": true,
      "onFailure": "step:BranchOnRestoreRootVolumeIfSnapshot",
      "onCancel": "step:AttachRootEbsVolumeBackToInstance",
      "maxAttempts": 3,
      "inputs": {
        "Service": "ec2",
        "Api": "DetachVolume",
        "VolumeId": "{{ GetInstanceRootVolume.RootDeviceVolumeId }}"
      }
    },
    {
      "name": "WaitForInstanceRootVolumeToBeDetachedFromHelperInstanceAfterError",
      "description": "Waits for the EBS root volume to be detached from the helper EC2 instance after an error.",
      "action": "aws:waitForAwsResourceProperty",
      "isCritical": true,
      "nextStep": "BranchOnRestoreRootVolumeIfSnapshot",
      "onFailure": "step:BranchOnRestoreRootVolumeIfSnapshot",
      "onCancel": "step:AttachRootEbsVolumeBackToInstance",
      "timeoutSeconds": 180,
      "inputs": {
        "Service": "ec2",
        "Api": "DescribeVolumes",
        "VolumeIds": [
          "{{ GetInstanceRootVolume.RootDeviceVolumeId }}"
        ],
        "PropertySelector": "$.Volumes[0].State",
        "DesiredValues": [
          "available"
        ]
      }
    },
    {
      "name": "BranchOnRestoreRootVolumeIfSnapshot",
      "action": "aws:branch",
      "nextStep": "AttachRootEbsVolumeBackToInstance",
      "description": "Branches the automation depending on whether a snapshot of the root volume was requested to determine the recovery path in case of failure.",
      "onFailure": "Continue",
      "isCritical": true,
      "inputs": {
        "Choices": [
          {
            "NextStep": "CreateNewRootVolumeFromSnapshot",
            "Variable": "{{ CreateSnapshot }}",
            "StringEquals": "Yes"
          },
          {
            "NextStep": "AttachRootEbsVolumeBackToInstance",
            "Variable": "{{ CreateSnapshot }}",
            "StringEquals": "No"
          }
        ],
        "Default": "AttachRootEbsVolumeBackToInstance"
      }
    },
    {
      "name": "AttachRootEbsVolumeBackToInstance",
      "action": "aws:executeAwsApi",
      "description": "Attaches the root EBS volume back to target EC2 instance.",
      "nextStep": "WaitForAttachRootEbsVolumeBackToInstance",
      "isCritical": true,
      "onFailure": "step:BranchOnPreviousInstanceState",
      "onCancel": "step:BranchOnPreviousInstanceState",
      "maxAttempts": 3,
      "inputs": {
        "Service": "ec2",
        "Api": "AttachVolume",
        "Device": "{{ GetInstanceProperties.RootDeviceName }}",
        "VolumeId": "{{ GetInstanceRootVolume.RootDeviceVolumeId }}",
        "InstanceId": "{{ InstanceId }}"
      }
    },
    {
      "name": "WaitForAttachRootEbsVolumeBackToInstance",
      "description": "Waits for the EBS root volume to be attached to the target EC2 instance.",
      "action": "aws:waitForAwsResourceProperty",
      "nextStep": "BranchOnPreviousInstanceState",
      "isCritical": true,
      "onFailure": "step:BranchOnPreviousInstanceState",
      "onCancel": "step:BranchOnPreviousInstanceState",
      "timeoutSeconds": 180,
      "inputs": {
        "Service": "ec2",
        "Api": "DescribeVolumes",
        "VolumeIds": [
          "{{ GetInstanceRootVolume.RootDeviceVolumeId }}"
        ],
        "PropertySelector": "$.Volumes[0].State",
        "DesiredValues": [
          "in-use"
        ]
      }
    },
    {
      "name": "CreateNewRootVolumeFromSnapshot",
      "action": "aws:executeAwsApi",
      "nextStep": "WaitForVolumeAvailable",
      "description": "Creates a new EBS volume from the target EC2 instance root volume snapshot.",
      "isCritical": true,
      "onFailure": "step:WaitCloudFormationStackRollback",
      "onCancel": "step:WaitCloudFormationStackRollback",
      "maxAttempts": 3,
      "inputs": {
        "Service": "ec2",
        "Api": "CreateVolume",
        "AvailabilityZone": "{{ GetInstanceProperties.AvailabilityZone }}",
        "SnapshotId": "{{ CreateSnapshot.SnapshotId }}"
      },
      "outputs": [
        {
          "Name": "NewRootVolumeId",
          "Selector": "$.VolumeId",
          "Type": "String"
        }
      ]
    },
    {
      "name": "WaitForVolumeAvailable",
      "action": "aws:waitForAwsResourceProperty",
      "description": "Waits until the new EBS volume is in `available` state",
      "nextStep": "AttachNewRootVolumeFromSnapshot",
      "isCritical": true,
      "onFailure": "step:WaitCloudFormationStackRollback",
      "onCancel": "step:WaitCloudFormationStackRollback",
      "timeoutSeconds": 180,
      "maxAttempts": 3,
      "inputs": {
        "Service": "ec2",
        "Api": "DescribeVolumes",
        "PropertySelector": "Volumes[0].State",
        "DesiredValues": [
          "available"
        ],
        "VolumeIds": [
          "{{ CreateNewRootVolumeFromSnapshot.NewRootVolumeId }}"
        ]
      }
    },
    {
      "name": "AttachNewRootVolumeFromSnapshot",
      "action": "aws:executeAwsApi",
      "description": "Attaches the new EBS volume to the target instance as root volume.",
      "nextStep": "VerifyNewRootVolumeAttached",
      "isCritical": true,
      "onFailure": "step:WaitCloudFormationStackRollback",
      "onCancel": "step:WaitCloudFormationStackRollback",
      "maxAttempts": 3,
      "inputs": {
        "Service": "ec2",
        "Api": "AttachVolume",
        "Device": "{{ GetInstanceProperties.RootDeviceName }}",
        "VolumeId": "{{ CreateNewRootVolumeFromSnapshot.NewRootVolumeId }}",
        "InstanceId": "{{ InstanceId }}"
      }
    },
    {
      "name": "VerifyNewRootVolumeAttached",
      "action": "aws:waitForAwsResourceProperty",
      "description": "Waits for the EBS volume to be in `attached` state.",
      "onFailure": "step:WaitCloudFormationStackRollback",
      "onCancel": "step:WaitCloudFormationStackRollback",
      "nextStep": "BranchOnPreviousInstanceState",
      "isCritical": true,
      "timeoutSeconds": 180,
      "maxAttempts": 3,
      "inputs": {
        "Service": "ec2",
        "Api": "DescribeVolumes",
        "PropertySelector": "$.Volumes[0].Attachments[0].State",
        "DesiredValues": [
          "attached"
        ],
        "VolumeIds": [
          "{{ CreateNewRootVolumeFromSnapshot.NewRootVolumeId }}"
        ]
      }
    },
    {
      "name": "DescribeCloudFormationErrorFromStackEvents",
      "description": "Describes the AWS CloudFormation stack events if the runbooks fails to create or update the AWS CloudFormation stack.",
      "onCancel": "step:WaitCloudFormationStackRollback",
      "onFailure": "step:WaitCloudFormationStackRollback",
      "nextStep": "WaitCloudFormationStackRollback",
      "action": "aws:executeAwsApi",
      "maxAttempts": 3,
      "inputs": {
        "Service": "cloudformation",
        "Api": "DescribeStackEvents",
        "StackName": "{{ CreateEc2HelperInstance.CloudformationStackId }}"
      },
      "outputs": [
        {
          "Name": "Events",
          "Selector": "$.StackEvents..ResourceStatusReason",
          "Type": "StringList"
        }
      ],
      "isCritical": false
    },
    {
      "name": "BranchOnPreviousInstanceState",
      "action": "aws:branch",
      "description": "Branches the automation depending on the previous EC2 instance state; if it was `running`, starts it again; if it was in `stopped` state, the automation continues.",
      "isEnd": true,
      "inputs": {
        "Choices": [
          {
            "NextStep": "StartInstance",
            "Variable": "{{ GetInstanceProperties.State }}",
            "StringEquals": "running"
          }
        ],
        "Default": "WaitCloudFormationStackRollback"
      }
    },
    {
      "name": "StartInstance",
      "action": "aws:changeInstanceState",
      "description": "Starts the target EC2 instance.",
      "nextStep": "WaitCloudFormationStackRollback",
      "onCancel": "step:WaitCloudFormationStackRollback",
      "isCritical": true,
      "onFailure": "Continue",
      "maxAttempts": 3,
      "timeoutSeconds": 360,
      "inputs": {
        "InstanceIds": [
          "{{ InstanceId }}"
        ],
        "CheckStateOnly": false,
        "DesiredState": "running"
      }
    },
    {
      "name": "WaitCloudFormationStackRollback",
      "action": "aws:waitForAwsResourceProperty",
      "description": "Waits until the AWS CloudFormation stack is in a terminal status before is deleted.",
      "nextStep": "DeleteCloudFormationStack",
      "onFailure": "step:DeleteCloudFormationStack",
      "onCancel": "step:DeleteCloudFormationStack",
      "timeoutSeconds": 600,
      "maxAttempts": 3,
      "inputs": {
        "Service": "cloudformation",
        "Api": "DescribeStacks",
        "StackName": "{{ CreateEc2HelperInstance.CloudformationStackId }}",
        "PropertySelector": "$.Stacks[0].StackStatus",
        "DesiredValues": [
          "UPDATE_COMPLETE",
          "CREATE_COMPLETE",
          "ROLLBACK_FAILED",
          "ROLLBACK_COMPLETE",
          "DELETE_COMPLETE",
          "CREATE_FAILED",
          "DELETE_FAILED",
          "UPDATE_ROLLBACK_FAILED",
          "UPDATE_ROLLBACK_COMPLETE"
        ]
      },
      "isCritical": false
    },
    {
      "name": "DeleteCloudFormationStack",
      "action": "aws:executeAwsApi",
      "description": "Deletes the AWS CloudFormation stack including the temporary EC2 helper instance.",
      "maxAttempts": 5,
      "inputs": {
        "Service": "cloudformation",
        "Api": "DeleteStack",
        "StackName": "{{ CreateEc2HelperInstance.CloudformationStackId }}"
      },
      "isCritical": true,
      "onFailure": "Abort",
      "isEnd": true
    }
  ],
  "files": {
    "attachment.zip": {
      "checksums": {
        "SHA256": "b80b6abec12c123c7580a253d0c9e1634ae2f3cade0967fdffd25cddfee4648e"
      }
    }
  }
}
