{
  "description": "### Document name - AWSQuickSetupType-PropagateJustInTimeNodeAccessPolicies\n\n## What does this runbook do?\nThe AWSQuickSetupType-PropagateJustInTimeNodeAccessPolicies Automation runbook handles cross-account and cross-region sharing of\nSSM Just In Time Access policies.\nThis runbook can only be run from the Delegated Admin account in the home region used for SSM Just In Time Access\n\nThis runbook performs two main functions:\n1. Policy Replication - using the home region as the source of truth, the runbook will copy the SSM-JustInTimeAccessDenyAccessOrgPolicy document\nfrom the home region into each target region.  Any changes made to the deny-only policy document in a non-home region will be overwritten.\n2. Policy Sharing - the SSM-JustInTimeAccessDenyAccessOrgPolicy document will be shared with the OUs specified in the Just In Time Access configuration\nin QuickSetup.  The runbook will create a resource share in AWS Resource Access Manager (RAM) titled \"SSMJustInTimeAccessManagedResourceShare\".\nThis resource share will include a resource association for the SSM-JustInTimeAccessDenyAccessOrgPolicy document and principal associations for each target OU.\nThe runbook will create a copy of the RAM resource share in each target region.\n\n## Input Parameters\n* AutomationAssumeRole: (Optional) The Amazon Resource Name (ARN) of the role that allows SSM Automation to perform the actions on your behalf.\n\n## Output parameters\nNone",
  "schemaVersion": "0.3",
  "assumeRole": "{{AutomationAssumeRole}}",
  "parameters": {
    "AutomationAssumeRole": {
      "type": "AWS::IAM::Role::Arn",
      "description": "(Optional) The Amazon Resource Name (ARN) of the role that allows SSM Automation to perform the actions on your behalf.",
      "default": ""
    }
  },
  "mainSteps": [
    {
      "description": "## PropagateJustInTimeNodeAccessPolicies\nThis step performs the Just In Time Access policy propagation workflow.\n1. Fetch QuickSetup configuration to verify that the execution is running in the home region of the DA account.\n2. Automatically share the SSM-JustInTimeAccessDenyAccessOrgPolicy document from the home region with the target OUs.\n3. Synchronize the SSM-JustInTimeAccessDenyAccessOrgPolicy content from the home region to each target region.\n4. Automatically share the SSM-JustInTimeAccessDenyAccessOrgPolicy document from the target regions with the target OUs.\n\n## Input Parameters\nNone\n\n## Output parameters\nNone\n",
      "name": "PropagateJustInTimeNodeAccessPolicies",
      "action": "aws:executeScript",
      "timeoutSeconds": 600,
      "isCritical": true,
      "isEnd": true,
      "onFailure": "Abort",
      "inputs": {
        "Runtime": "python3.11",
        "Handler": "propagate_just_in_time_node_access_policies_handler",
        "Script": "import json\nimport re\nimport sys\nimport subprocess\nboto_modules = []\nfor m in sys.modules.keys():\n  if m.startswith('boto'):\n    boto_modules.append(m)\nfor m in boto_modules:\n  del(sys.modules[m])\n\nsubprocess.check_call([sys.executable, \"-m\", \"pip\", \"install\", \"boto3\", \"-t\", \"/tmp/\"])\nsys.path.insert(0, '/tmp/')\nimport boto3\nimport botocore\n\nDENY_ONLY_POLICY_NAME = 'SSM-JustInTimeAccessDenyAccessOrgPolicy'\nRESOURCE_SHARE_NAME = 'SSMJustInTimeNodeAccessManagedResourceShare'\nREPLICA_TAG_KEY = 'SystemsManagerJustInTimeNodeAccessManaged'\nREPLICA_TAG_VALUE = 'true'\n\ndef propagate_just_in_time_node_access_policies_handler(input, context):\n    target_regions, target_ou_ids = get_configuration(context)\n    target_principals = get_principal_arns(target_ou_ids)\n\n    home_region = context['global:REGION']\n    partition = context['global:AWS_PARTITION']\n    account_id = context['global:ACCOUNT_ID']\n\n    ssm_client_home_region = boto3.client('ssm')\n    target_policies = [DENY_ONLY_POLICY_NAME]\n    try:\n        home_region_document_info = ssm_client_home_region.describe_document(Name = DENY_ONLY_POLICY_NAME, DocumentVersion = '$LATEST')['Document']\n        home_region_document_content = ssm_client_home_region.get_document(Name = DENY_ONLY_POLICY_NAME, DocumentVersion = '$LATEST')['Content']\n    except (ssm_client_home_region.exceptions.InvalidDocument, botocore.exceptions.ClientError) as ex:\n        home_region_document_info = None\n        home_region_document_content = None\n        target_policies = []\n\n    for target_region in target_regions:\n        ssm_client_target_region = boto3.client('ssm', region_name=target_region)\n        reconcile_document(DENY_ONLY_POLICY_NAME, home_region_document_info, home_region_document_content, ssm_client_target_region)\n\n    for region in [home_region] + target_regions:\n        ram_client = boto3.client('ram', region_name=region)\n        resource_share = get_resource_share(ram_client)\n        reconcile_resource_share(ram_client, resource_share, target_policies, target_principals, partition, region, account_id)\n\ndef get_configuration(context):\n    quick_setup_client = boto3.client('ssm-quicksetup')\n    jitna_configurations = quick_setup_client.list_configuration_managers(Filters = [{ 'Key': 'ConfigurationType', 'Values': ['AWSQuickSetupType-JITNA']}])['ConfigurationManagersList']\n    if len(jitna_configurations) != 1:\n        raise Exception('Cannot determine QuickSetup configuration')\n\n    jitna_configuration = quick_setup_client.get_configuration_manager(ManagerArn = jitna_configurations[0]['ManagerArn'])\n    jitna_configuration_parameters = jitna_configuration['ConfigurationDefinitions'][0]['Parameters']\n\n    home_region = jitna_configuration_parameters['HomeRegion']\n    da_account = jitna_configuration_parameters['DelegatedAccountId']\n\n    if (context['global:REGION'] != home_region):\n        raise Exception('This document can only be executed in the home region')\n    elif context['global:ACCOUNT_ID'] != da_account:\n        raise Exception('This document can only be executed by the Delegated Administrator account')\n\n    target_regions = list(filter(lambda region: region != home_region, jitna_configuration_parameters['TargetRegions'].split(',')))\n    target_ous = jitna_configuration_parameters['TargetOrganizationalUnits'].split(',')\n\n    return target_regions, target_ous\n\ndef get_principal_arns(target_ou_ids):\n    principals = []\n    root_regex = \"^r-[0-9a-z]{4,32}$\"\n    organizations_client = boto3.client('organizations')\n\n    for ou in target_ou_ids:\n        if re.search(root_regex, ou) is not None:\n            principals.append(organizations_client.describe_organization()['Organization']['Arn'])\n        else:\n            principals.append(organizations_client.describe_organizational_unit(OrganizationalUnitId = ou)['OrganizationalUnit']['Arn'])\n\n    return principals\n\ndef get_resource_share(ram_client):\n    next_token = None\n    resource_shares = []\n    while True:\n        get_resource_shares_response = ram_client.get_resource_shares(resourceOwner = 'SELF', name = RESOURCE_SHARE_NAME) \\\n                if next_token is None \\\n                else ram_client.get_resource_shares(resourceOwner = 'SELF', name = RESOURCE_SHARE_NAME, nextToken = next_token)\n        resource_shares += list(filter(lambda share: share['status'] not in ['DELETING', 'DELETED'], get_resource_shares_response['resourceShares']))\n        if 'nextToken' not in get_resource_shares_response:\n            break\n        next_token = get_resource_shares_response['nextToken']\n    if len(resource_shares) > 1:\n        raise Exception('There should only be one SSM-managed resource share. Please delete any other resource shares with the same name.')\n    elif len(resource_shares) == 0:\n        return None\n    else:\n        return resource_shares[0]\n\ndef get_resource_share_associations(ram_client, resource_share, association_type):\n    next_token = None\n    resource_share_associations = []\n    while True:\n        get_resource_share_associations_response = ram_client.get_resource_share_associations(resourceShareArns = [resource_share['resourceShareArn']], associationType = association_type) \\\n                if next_token is None \\\n                else ram_client.get_resource_share_associations(resourceShareArns = [resource_share['resourceShareArn']], associationType = association_type, nextToken = next_token)\n        resource_share_associations += list(filter(lambda association: association['status'] not in ['DISASSOCIATING', 'DISASSOCIATED'], get_resource_share_associations_response['resourceShareAssociations']))\n        if 'nextToken' not in get_resource_share_associations_response:\n            return resource_share_associations\n        next_token = get_resource_share_associations_response['nextToken']\n\ndef reconcile_resource_share(ram_client, resource_share, documents, target_principals, partition, region, account_id):\n    print(f'Reconciling resource share in region {region}')\n\n    document_arns = list(map(lambda doc: format_document_arn(partition, region, account_id, doc), documents))\n    if resource_share is None:\n        if len(documents) == 0:\n            return\n        ram_client.create_resource_share(name = RESOURCE_SHARE_NAME, resourceArns = document_arns, principals = target_principals, tags = [{'key': REPLICA_TAG_KEY, 'value': REPLICA_TAG_VALUE}])\n    else:\n        resource_share_principal_associations = get_resource_share_associations(ram_client, resource_share, 'PRINCIPAL')\n        resource_share_principals = list(map(lambda association: association['associatedEntity'], resource_share_principal_associations))\n\n        resource_share_resource_associations = get_resource_share_associations(ram_client, resource_share, 'RESOURCE')\n        resource_share_resources = list(map(lambda association: association['associatedEntity'], resource_share_resource_associations))\n\n        principals_to_add = list(filter(lambda principal: principal not in resource_share_principals, target_principals))\n        principals_to_remove = list(filter(lambda principal: principal not in target_principals, resource_share_principals))\n        resources_to_add = list(filter(lambda resource: resource not in resource_share_resources, document_arns))\n        resources_to_remove = list(filter(lambda resource: resource not in document_arns, resource_share_resources))\n\n        if len(principals_to_add) > 0 or len(resources_to_add) > 0:\n            ram_client.associate_resource_share(resourceShareArn = resource_share['resourceShareArn'], principals = principals_to_add, resourceArns = resources_to_add)\n        if len(principals_to_remove) > 0 or len(resources_to_remove) > 0:\n            ram_client.disassociate_resource_share(resourceShareArn = resource_share['resourceShareArn'], principals = principals_to_remove, resourceArns = resources_to_remove)\n\ndef reconcile_document(document_name, home_region_document_info, home_region_document_content, ssm_client_target_region):\n    print(f'Reconciling document {document_name} in region {ssm_client_target_region.meta.region_name}')\n\n    if home_region_document_info is None:\n        try:\n            ssm_client_target_region.describe_document(Name = document_name, DocumentVersion = '$LATEST')\n            ssm_client_target_region.delete_document(Name = document_name)\n            print(f'Deleted {document_name} in region {ssm_client_target_region.meta.region_name}')\n        except (ssm_client_target_region.exceptions.InvalidDocument, botocore.exceptions.ClientError) as ex:\n            print(f'Document {document_name} does not exist in region {ssm_client_target_region.meta.region_name}')\n        return\n\n    try:\n        target_region_document_latest_version_info = ssm_client_target_region.describe_document(Name = document_name, DocumentVersion = '$LATEST')['Document']\n        if (target_region_document_latest_version_info['Hash'] != home_region_document_info['Hash']):\n            ssm_client_target_region.update_document(Name = document_name, Content = home_region_document_content, DocumentVersion = '$LATEST', DocumentFormat = home_region_document_info['DocumentFormat'])\n    except (ssm_client_target_region.exceptions.InvalidDocument, botocore.exceptions.ClientError) as ex:\n        ssm_client_target_region.create_document(Name = document_name, Content = home_region_document_content, DocumentType = 'AutoApprovalPolicy', DocumentFormat = home_region_document_info['DocumentFormat'], Tags=[{'Key': REPLICA_TAG_KEY, 'Value': REPLICA_TAG_VALUE}])\n\n    target_region_document_info = ssm_client_target_region.describe_document(Name = document_name, DocumentVersion = '$LATEST')['Document']\n    reconcile_document_tags(home_region_document_info, target_region_document_info, ssm_client_target_region)\n\ndef reconcile_document_tags(home_region_document_info, target_region_document_info, ssm_client_target_region):\n    document_name = home_region_document_info['Name']\n    print(f'Reconciling document tags for {document_name} in region {ssm_client_target_region.meta.region_name}')\n\n    home_region_tags = home_region_document_info['Tags'] if 'Tags' in home_region_document_info else []\n    target_region_tags = target_region_document_info['Tags'] if 'Tags' in target_region_document_info else []\n    tags_to_add = []\n    tags_to_remove = []\n    for home_region_tag in home_region_tags:\n        if not any(tag['Key'] == home_region_tag['Key'] and tag['Value'] == home_region_tag['Value'] for tag in target_region_tags):\n            tags_to_add.append(home_region_tag)\n    for target_region_tag in target_region_tags:\n        if not any(tag['Key'] == target_region_tag['Key'] for tag in home_region_tags) and target_region_tag['Key'] != REPLICA_TAG_KEY:\n            tags_to_remove.append(target_region_tag['Key'])\n\n    if len(tags_to_add) > 0:\n        ssm_client_target_region.add_tags_to_resource(ResourceType = 'Document', ResourceId = document_name, Tags = tags_to_add)\n    if len(tags_to_remove) > 0:\n        ssm_client_target_region.remove_tags_from_resource(ResourceType = 'Document', ResourceId = document_name, TagKeys = tags_to_remove)\n\ndef format_document_arn(partition, region, account_id, document_name):\n    return f'arn:{partition}:ssm:{region}:{account_id}:document/{document_name}'"
      }
    }
  ]
}
