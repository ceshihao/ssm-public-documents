{
  "description": "## Id\nAWSResilienceHub-ForceSQSCapacityFailureTest_2021-03-13\n\n## Intent\nTest SQS behaviour after sending a message close to maximum allowed size. Wait for alarm for metric SentMessageSize to trigger when message size is higher than threshold which should be slightly less than 256kb\n\n## Type\nTEST\n\n## Risk\nMedium\n\n## Requirements:\n  * SQS queue\n  * Amazon CloudWatch alarm is setup for [SentMessageSize](https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/sqs-available-cloudwatch-metrics.html) metric. Should trigger when size of sent messages sent is above threshold that is slightly less than 256kb\n\n## Permissions required for AutomationAssumeRole\n  * cloudwatch:DescribeAlarms\n  * sqs:SendMessage\n  * sqs:ReceiveMessage\n  * sqs:DeleteMessage\n  * ssm:GetParameters\n  * ssm:GetAutomationExecution\n  * ssm:StartAutomationExecution\n  * iam:PassRole\n\n##### In case queues are encrypted with a KMS key\n  * kms:GenerateDataKey\n  * kms:Decrypt\n  * kms:Encrypt\n\n## Supports Rollback\nYes. The document removes message which triggers the alarm\n\n## Cancellation behavior\nThe document removes message which triggers the alarm\n\n## Inputs\n### (Required) AutomationAssumeRole\n  * type: String\n  * description: ARN of the IAM role with permissions listed above\n\n### (Required) QueueUrl\n  * type: String\n  * description: The URL of the SQS queue\n\n### (Required) SentMessageSizeAlarmName\n  * type: String\n  * description: Amazon CloudWatch alarm for [SentMessageSize](https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/sqs-available-cloudwatch-metrics.html) metric. Should trigger when queue has messages higher than threshold that is slightly less than 256kb\n\n### (Optional) IsRollback\n  * type: String\n  * description: Run the rollback steps of the document. True or False. If True, the parameter PreviousExecutionId should also be specified\n  * default: false\n\n### (Optional) PreviousExecutionId\n  * type: String\n  * description: SSM execution ID of the previous execution of this document for which resources need to be cleaned up\n\n## Details\nThe document injects failure by sending a message with a size above threshold of the specified alarm.\nIn case of issues users should manually remove the message.\n\n## Steps executed in normal flow\n  * CheckIsRollback\n  * AssertAlarmToBeGreenBeforeTest\n  * GetAlarmThreshold\n  * SendCapacityFailureMessage\n  * AssertAlarmToBeRed\n  * RollbackCurrentExecution\n  * AssertAlarmToBeGreen\n\n## Steps executed in rollback flow\n  * CheckIsRollback\n  * GetInputsFromPreviousExecution\n  * AssertInputsFromPreviousExecution\n  * PrepareRemoveOfFailureMessage\n  * RemovePreviousExecutionFailureMessage\n\n## Outputs\nNone",
  "schemaVersion": "0.3",
  "assumeRole": "{{ AutomationAssumeRole }}",
  "parameters": {
    "AutomationAssumeRole": {
      "type": "String",
      "description": "(Required) The ARN of the role that allows Automation to perform the actions on your behalf."
    },
    "QueueUrl": {
      "type": "String",
      "description": "(Required) The Url of the queue"
    },
    "SentMessageSizeAlarmName": {
      "type": "String",
      "description": "(Required) Alarm which should be red after injection of the failure and green after the rollback process in the end of the test."
    },
    "IsRollback": {
      "type": "String",
      "description": "(Optional) Run the rollback steps of the document. True or False. If True, the parameter PreviousExecutionId should also be specified",
      "default": "false"
    },
    "PreviousExecutionId": {
      "type": "String",
      "description": "(Optional) SSM execution ID of the previous execution of this document for which resources need to be cleaned up",
      "default": ""
    }
  },
  "mainSteps": [
    {
      "name": "CheckIsRollback",
      "description": "Check if document should be executed in rollback mode",
      "action": "aws:branch",
      "inputs": {
        "Choices": [
          {
            "NextStep": "GetInputsFromPreviousExecution",
            "Variable": "{{IsRollback}}",
            "StringEquals": "true"
          }
        ],
        "Default": "AssertAlarmToBeGreenBeforeTest"
      }
    },
    {
      "name": "GetInputsFromPreviousExecution",
      "description": "Get input from previous execution. This will be used to validate that rollback is executed with the same input",
      "action": "aws:executeScript",
      "outputs": [
        {
          "Name": "QueueUrl",
          "Selector": "$.Payload.QueueUrl[0]",
          "Type": "String"
        }
      ],
      "inputs": {
        "Runtime": "python3.7",
        "Handler": "get_inputs_from_ssm_execution",
        "InputPayload": {
          "ExecutionId": "{{ PreviousExecutionId }}"
        },
        "Script": "import json\nimport boto3\nfrom botocore.config import Config\n\n\n\n\ndef get_inputs_from_ssm_execution(events, context):\n    output = {}\n    config = Config(retries={'max_attempts': 20, 'mode': 'standard'})\n    ssm = boto3.client('ssm', config=config)\n\n    if 'ExecutionId' not in events:\n        raise KeyError('Requires ExecutionId')\n\n    if not events['ExecutionId']:\n        raise KeyError('Requires not empty ExecutionId')\n\n    response = ssm.get_automation_execution(AutomationExecutionId=events['ExecutionId'])\n    response_parameters = response['AutomationExecution']['Parameters']\n    # TODO DIG-853\n    for parameter in response_parameters:\n        output[parameter] = response_parameters[parameter]\n\n    return output"
      }
    },
    {
      "name": "AssertInputsFromPreviousExecution",
      "description": "Validate that rollback is executed with the same input",
      "action": "aws:branch",
      "inputs": {
        "Choices": [
          {
            "NextStep": "PrepareRemoveOfFailureMessage",
            "Variable": "{{ GetInputsFromPreviousExecution.QueueUrl }}",
            "StringEquals": "{{ QueueUrl }}"
          }
        ]
      },
      "isEnd": true
    },
    {
      "name": "PrepareRemoveOfFailureMessage",
      "description": "Get message id of the injected message",
      "action": "aws:executeScript",
      "outputs": [
        {
          "Name": "MessageId",
          "Selector": "$.Payload.MessageId[0]",
          "Type": "String"
        }
      ],
      "inputs": {
        "Runtime": "python3.6",
        "Handler": "get_output_from_ssm_step_execution",
        "InputPayload": {
          "ExecutionId": "{{PreviousExecutionId}}",
          "StepName": "SendCapacityFailureMessage",
          "ResponseField": "MessageId"
        },
        "Script": "import json\nimport boto3\nfrom botocore.config import Config\n\n\n\ndef get_output_from_ssm_step_execution(events, context):\n    config = Config(retries={'max_attempts': 20, 'mode': 'standard'})\n    ssm = boto3.client('ssm', config=config)\n\n    if 'ExecutionId' not in events or 'StepName' not in events or 'ResponseField' not in events:\n        raise KeyError('Requires ExecutionId, StepName and ResponseField in events')\n\n    ssm_response = ssm.get_automation_execution(AutomationExecutionId=events['ExecutionId'])\n    for step in ssm_response['AutomationExecution']['StepExecutions']:\n        if step['StepName'] == events['StepName']:\n            response_fields = events['ResponseField'].split(',')\n            output = {}\n            for response_field in response_fields:\n                if response_field in step['Outputs']:\n                    output[response_field] = step['Outputs'][response_field]\n                else:\n                    \"\"\"\n                    By default SSM ignores empty values when encodes API outputs to JSON. It may result in\n                    a situation when an empty value is a valid value but step output completely misses it.\n                    Usually happens with SQS queue policies, default policy is returned by API as an empty value\n                    and executeApi step output ignores it. As a result, further steps in rollback execution will fail.\n                    Instead of ignoring this value we should use a default empty value in rollback, i.e. empty string\n                    represents a default sqs policy\n                    \"\"\"\n                    output[response_field] = ['']\n            return output\n\n    # Could not find step name\n    raise Exception('Can not find step name % in ssm execution response', events['StepName'])"
      }
    },
    {
      "name": "RemovePreviousExecutionFailureMessage",
      "description": "Delete injected message",
      "action": "aws:executeScript",
      "inputs": {
        "Runtime": "python3.6",
        "Handler": "delete_message_by_id",
        "InputPayload": {
          "QueueUrl": "{{QueueUrl}}",
          "MessageId": "{{PrepareRemoveOfFailureMessage.MessageId}}",
          "TimeOut": "300"
        },
        "Script": "import json\nimport logging\nimport time\nimport uuid\nimport boto3\nfrom datetime import datetime\nfrom typing import List, Callable, Optional\nfrom botocore.exceptions import ClientError\nfrom botocore.config import Config\n\nlogger = logging.getLogger()\nlogger.setLevel(logging.INFO)\n\n\n\ndef get_message_receipt_handle(queue_url: str, message_id: str, timeout: int):\n    \"\"\"\n    Loop through all messages on SQS queue, find message by ID and return its ReceiptHandle\n    :param queue_url The URL of the queue\n    :param message_id The message ID\n    :param timeout Max time to wait until message found\n    :return ReceiptHandle of the message\n    \"\"\"\n    config = Config(retries={'max_attempts': 20, 'mode': 'standard'})\n    sqs_client = boto3.client(\"sqs\", config=config)\n    start = datetime.now()\n\n    while True:\n        response = sqs_client.receive_message(\n            QueueUrl=queue_url,\n            MaxNumberOfMessages=10\n        )\n\n        if 'Messages' in response and len(response['Messages']):\n            for message in response['Messages']:\n                if message['MessageId'] == message_id:\n                    return message['ReceiptHandle']\n\n        if (datetime.now() - start).total_seconds() > timeout:\n            raise Exception(f'Message {message_id} not found before timeout')\n\n\n\ndef delete_message_by_id(event, context):\n    \"\"\"\n    Delete message by its ID\n    \"\"\"\n    config = Config(retries={'max_attempts': 20, 'mode': 'standard'})\n    sqs_client = boto3.client(\"sqs\", config=config)\n    queue_url = event['QueueUrl']\n    message_id = event['MessageId']\n    timeout = int(event.get('TimeOut', 100))\n    receipt_handle = get_message_receipt_handle(queue_url, message_id, timeout)\n    response = sqs_client.delete_message(QueueUrl=queue_url, ReceiptHandle=receipt_handle)\n    return response"
      },
      "isEnd": true
    },
    {
      "name": "AssertAlarmToBeGreenBeforeTest",
      "description": "Ensure alarm is green before starting test. Fail if alarm is not green within expected time",
      "action": "aws:waitForAwsResourceProperty",
      "timeoutSeconds": 1200,
      "inputs": {
        "Service": "cloudwatch",
        "Api": "DescribeAlarms",
        "AlarmNames": [
          "{{SentMessageSizeAlarmName}}"
        ],
        "PropertySelector": "$.MetricAlarms[0].StateValue",
        "DesiredValues": [
          "OK"
        ]
      }
    },
    {
      "name": "GetAlarmThreshold",
      "description": "Get the provided alarm's threshold that to set message size higher than the threshold",
      "action": "aws:executeScript",
      "outputs": [
        {
          "Name": "SizeAboveThreshold",
          "Selector": "$.Payload.ValueAboveThreshold",
          "Type": "Integer"
        }
      ],
      "inputs": {
        "Runtime": "python3.6",
        "Handler": "get_metric_alarm_threshold_values",
        "InputPayload": {
          "AlarmName": "{{SentMessageSizeAlarmName}}"
        },
        "Script": "import boto3\nimport logging\nimport time\nfrom botocore.config import Config\nfrom datetime import datetime, timedelta\nfrom typing import Any, Callable, Iterator, List\n\nboto3_config = Config(retries={'max_attempts': 20, 'mode': 'standard'})\n\nPUT_METRIC_ALARM_PARAMS = ['AlarmName', 'AlarmDescription', 'ActionsEnabled', 'OKActions',\n                           'AlarmActions', 'InsufficientDataActions', 'MetricName', 'Namespace', 'Statistic',\n                           'ExtendedStatistic',\n                           'Dimensions', 'Period', 'Unit', 'EvaluationPeriods', 'DatapointsToAlarm',\n                           'Threshold', 'ComparisonOperator', 'TreatMissingData', 'EvaluateLowSampleCountPercentile',\n                           'Metrics', 'Tags', 'ThresholdMetricId']\n\n\n\ndef get_metric_alarm_threshold_values(event, context):\n    \"\"\"\n    Get alarm threshold and return values above and below\n    \"\"\"\n    alarm_name = event['AlarmName']\n    cw = boto3.client('cloudwatch', config=boto3_config)\n    response = cw.describe_alarms(\n        AlarmNames=[alarm_name],\n        AlarmTypes=['MetricAlarm']\n    )\n    metric_alarms = response.get('MetricAlarms')\n    if not metric_alarms:\n        raise Exception(\"MetricAlarm [{}] does not exist.\".format(alarm_name))\n    threshold = metric_alarms[0]['Threshold']\n    if threshold == 0:\n        raise Exception(\"MetricAlarm [{}] has no threshold set.\".format(alarm_name))\n\n    value_above_threshold = threshold + 1\n    value_below_threshold = threshold - 1\n\n    return {\n        'Threshold': int(threshold),\n        'ValueAboveThreshold': int(value_above_threshold),\n        'ValueBelowThreshold': int(value_below_threshold)\n    }"
      }
    },
    {
      "name": "SendCapacityFailureMessage",
      "description": "Send message to queue with a payload size bigger than the provided alarm's threshold",
      "action": "aws:executeScript",
      "onFailure": "step:RollbackCurrentExecution",
      "onCancel": "step:TriggerRollback",
      "outputs": [
        {
          "Name": "MessageId",
          "Selector": "$.Payload.MessageId",
          "Type": "String"
        }
      ],
      "inputs": {
        "Runtime": "python3.6",
        "Handler": "send_message_of_size",
        "InputPayload": {
          "QueueUrl": "{{QueueUrl}}",
          "MessageSize": "{{GetAlarmThreshold.SizeAboveThreshold}}",
          "MessageDeduplicationId": "{{global:DATE_TIME}}"
        },
        "Script": "import json\nimport logging\nimport time\nimport uuid\nimport boto3\nfrom datetime import datetime\nfrom typing import List, Callable, Optional\nfrom botocore.exceptions import ClientError\nfrom botocore.config import Config\n\nlogger = logging.getLogger()\nlogger.setLevel(logging.INFO)\n\n\n\ndef send_message_of_size(events, context):\n    \"\"\"\n    Sends a message of given size in bytes. Character u'a' is equal to one byte\n    \"\"\"\n    config = Config(retries={'max_attempts': 20, 'mode': 'standard'})\n    sqs_client = boto3.client(\"sqs\", config=config)\n    queue_url = events['QueueUrl']\n    message_size = events['MessageSize']\n    message_body = 'a' * message_size\n\n    is_fifo = queue_url[-5:] == '.fifo'\n    if is_fifo:\n        message_deduplication_id = events['MessageDeduplicationId']\n        message_group_id = 'awsresiliencehub-capacity-failure-test'\n        response = sqs_client.send_message(\n            QueueUrl=queue_url,\n            MessageBody=message_body,\n            MessageGroupId=message_group_id,\n            MessageDeduplicationId=message_deduplication_id\n        )\n    else:\n        response = sqs_client.send_message(\n            QueueUrl=queue_url,\n            MessageBody=message_body\n        )\n    return response"
      }
    },
    {
      "name": "AssertAlarmToBeRed",
      "description": "Wait for expected alarm to be red after failure is injected",
      "action": "aws:waitForAwsResourceProperty",
      "timeoutSeconds": 1200,
      "onFailure": "step:RollbackCurrentExecution",
      "onCancel": "step:TriggerRollback",
      "inputs": {
        "Service": "cloudwatch",
        "Api": "DescribeAlarms",
        "AlarmNames": [
          "{{SentMessageSizeAlarmName}}"
        ],
        "PropertySelector": "$.MetricAlarms[0].StateValue",
        "DesiredValues": [
          "ALARM"
        ]
      }
    },
    {
      "name": "RollbackCurrentExecution",
      "description": "Revert queue policy to initial state",
      "action": "aws:executeScript",
      "onCancel": "step:TriggerRollback",
      "inputs": {
        "Runtime": "python3.6",
        "Handler": "delete_message_by_id",
        "InputPayload": {
          "QueueUrl": "{{QueueUrl}}",
          "MessageId": "{{SendCapacityFailureMessage.MessageId}}",
          "TimeOut": "300"
        },
        "Script": "import json\nimport logging\nimport time\nimport uuid\nimport boto3\nfrom datetime import datetime\nfrom typing import List, Callable, Optional\nfrom botocore.exceptions import ClientError\nfrom botocore.config import Config\n\nlogger = logging.getLogger()\nlogger.setLevel(logging.INFO)\n\n\n\ndef get_message_receipt_handle(queue_url: str, message_id: str, timeout: int):\n    \"\"\"\n    Loop through all messages on SQS queue, find message by ID and return its ReceiptHandle\n    :param queue_url The URL of the queue\n    :param message_id The message ID\n    :param timeout Max time to wait until message found\n    :return ReceiptHandle of the message\n    \"\"\"\n    config = Config(retries={'max_attempts': 20, 'mode': 'standard'})\n    sqs_client = boto3.client(\"sqs\", config=config)\n    start = datetime.now()\n\n    while True:\n        response = sqs_client.receive_message(\n            QueueUrl=queue_url,\n            MaxNumberOfMessages=10\n        )\n\n        if 'Messages' in response and len(response['Messages']):\n            for message in response['Messages']:\n                if message['MessageId'] == message_id:\n                    return message['ReceiptHandle']\n\n        if (datetime.now() - start).total_seconds() > timeout:\n            raise Exception(f'Message {message_id} not found before timeout')\n\n\n\ndef delete_message_by_id(event, context):\n    \"\"\"\n    Delete message by its ID\n    \"\"\"\n    config = Config(retries={'max_attempts': 20, 'mode': 'standard'})\n    sqs_client = boto3.client(\"sqs\", config=config)\n    queue_url = event['QueueUrl']\n    message_id = event['MessageId']\n    timeout = int(event.get('TimeOut', 100))\n    receipt_handle = get_message_receipt_handle(queue_url, message_id, timeout)\n    response = sqs_client.delete_message(QueueUrl=queue_url, ReceiptHandle=receipt_handle)\n    return response"
      }
    },
    {
      "name": "AssertAlarmToBeGreen",
      "description": "Wait for the alarm to be green after test is complete",
      "action": "aws:waitForAwsResourceProperty",
      "timeoutSeconds": 1200,
      "inputs": {
        "Service": "cloudwatch",
        "Api": "DescribeAlarms",
        "AlarmNames": [
          "{{SentMessageSizeAlarmName}}"
        ],
        "PropertySelector": "$.MetricAlarms[0].StateValue",
        "DesiredValues": [
          "OK"
        ]
      },
      "isEnd": true
    },
    {
      "name": "TriggerRollback",
      "description": "This step is executed when ssm document is cancelled while it was in progress. This step starts a new execution of document in rollback mode to rollback the changes made as part of normal execution",
      "action": "aws:executeScript",
      "onFailure": "Abort",
      "outputs": [
        {
          "Name": "RollbackExecutionId",
          "Selector": "$.Payload.RollbackExecutionId",
          "Type": "String"
        }
      ],
      "inputs": {
        "Runtime": "python3.6",
        "Handler": "start_rollback_execution",
        "InputPayload": {
          "ExecutionId": "{{automation:EXECUTION_ID}}"
        },
        "Script": "import json\nimport boto3\nfrom botocore.config import Config\n\n\n\n\ndef start_rollback_execution(events, context):\n    output = {}\n    config = Config(retries={'max_attempts': 20, 'mode': 'standard'})\n    ssm = boto3.client('ssm', config=config)\n\n    if 'ExecutionId' not in events or not events['ExecutionId']:\n        raise KeyError('Requires not empty ExecutionId')\n\n    response = ssm.get_automation_execution(AutomationExecutionId=events['ExecutionId'])\n\n    # Get parameters for current execution and add IsRollback and PreviousExecutionId\n    response_parameters = response['AutomationExecution']['Parameters']\n    response_parameters['IsRollback'] = ['true']\n    response_parameters['PreviousExecutionId'] = [events['ExecutionId']]\n\n    rollback_execution_response = ssm.start_automation_execution(\n        DocumentName=response['AutomationExecution']['DocumentName'],\n        DocumentVersion=response['AutomationExecution']['DocumentVersion'],\n        Parameters=response_parameters\n    )\n    output['RollbackExecutionId'] = rollback_execution_response['AutomationExecutionId']\n    return output"
      },
      "isEnd": true
    }
  ]
}
