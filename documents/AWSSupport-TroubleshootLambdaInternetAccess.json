{
  "description": "*This document will Troubleshoot internet access for lambda when launched in VPC",
  "schemaVersion": "0.3",
  "assumeRole": "{{ AutomationAssumeRole }}",
  "outputs": [
    "checkVpc.vpc",
    "checkVpc.subnet",
    "checkVpc.securityGroups",
    "checkSubnet.subnets",
    "checkSecurityGroups.secgrps",
    "checkNACL.NACL"
  ],
  "parameters": {
    "AutomationAssumeRole": {
      "type": "String",
      "description": "(Optional) The ARN of the role that allows Automation to perform the actions on your behalf.",
      "allowedPattern": "^$|^arn:(aws|aws-cn|aws-us-gov|aws-iso(-[a-z])?):iam::\\d{12}:role/[\\w+=/,.@-]+$",
      "default": ""
    },
    "FunctionName": {
      "type": "String",
      "description": "(Required) The function name whose connectivity needs to be validated.",
      "allowedPattern": "^(arn:(aws[a-zA-Z-]*)?:lambda:)?([a-z]{2}(-gov)?-[a-z]+-\\d{1}:)?(\\d{12}:)?(function:)?([a-zA-Z0-9-_\\.]+)(:(\\$LATEST|[a-zA-Z0-9-_]+))?$",
      "default": ""
    },
    "destinationIp": {
      "type": "String",
      "description": "(Required) The destination Ip where you  want to initiate an outbound internet access.",
      "default": "",
      "allowedPattern": "\\b((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)(\\.|$)){4}\\b"
    },
    "destinationPort": {
      "type": "String",
      "description": "(Optional) The destination port where you want to initiate an outbound internet access.",
      "default": "443",
      "allowedPattern": "^([0-9]{1,4}|[1-5][0-9]{4}|6[0-4][0-9]{3}|65[0-4][0-9]{2}|655[0-2][0-9]|6553[0-5])$"
    }
  },
  "mainSteps": [
    {
      "name": "checkVpc",
      "action": "aws:executeScript",
      "inputs": {
        "Runtime": "python3.8",
        "Handler": "checkVpc",
        "Script": "import boto3\ndef checkVpc(events,context):\n  client=boto3.client('lambda')\n  response = client.get_function(FunctionName=events['FunctionName'])\n  if 'VpcConfig' in response['Configuration'] and response['Configuration']['VpcConfig']['VpcId'] != \"\":\n    return response['Configuration']['VpcConfig']\n  else:\n    return {\"VpcId\":\"Your Lambda is not associated to any VPC\"}\n",
        "InputPayload": {
          "FunctionName": "{{FunctionName}}"
        }
      },
      "outputs": [
        {
          "Name": "vpc",
          "Selector": "$.Payload.VpcId",
          "Type": "String"
        },
        {
          "Name": "subnet",
          "Selector": "$.Payload.SubnetIds",
          "Type": "StringList"
        },
        {
          "Name": "securityGroups",
          "Selector": "$.Payload.SecurityGroupIds",
          "Type": "StringList"
        },
        {
          "Name": "vpcflag",
          "Selector": "$.Payload.vpcflag",
          "Type": "String"
        }
      ],
      "description": "#### Verify if the VPC is configured for your Lambda function"
    },
    {
      "name": "vpcFlag",
      "action": "aws:branch",
      "inputs": {
        "Choices": [
          {
            "Not": {
              "Variable": "{{checkVpc.vpc}}",
              "StringEquals": "Your Lambda is not associated to any VPC"
            },
            "NextStep": "checkSubnet"
          }
        ]
      },
      "isEnd": true
    },
    {
      "name": "checkSubnet",
      "action": "aws:executeScript",
      "inputs": {
        "Runtime": "python3.8",
        "Handler": "checkSubnet",
        "Script": "import boto3\nfrom ipaddress import ip_network,ip_address\nclient=boto3.client('ec2')\n\ndef getMainRTmap(mainRt,subnetWithMainRouteTable,destination):\n  response = client.describe_route_tables(RouteTableIds=[mainRt])['RouteTables'][0]['Routes']\n  routeTableSubnetMap={}\n  RouteTableToTarget={}\n  destination = ip_address(destination)\n  subnetToNat={}\n\n  for subnet in subnetWithMainRouteTable:\n    routeTableSubnetMap[subnet]=mainRt\n\n  most_specific = -1\n  next_hop={}  \n\n  for route in response:\n    if route.get('DestinationCidrBlock'):\n      mask = int(route['DestinationCidrBlock'].split('/')[1])\n      if not 'DestinationPrefixListId' in str(route) and destination in ip_network(route['DestinationCidrBlock'], strict=False) and mask > most_specific:\n        most_specific = mask\n        state=route['State']\n        next_hop = route\n\n  RouteTableToTarget[mainRt]={}\n  RouteTableToTarget[mainRt]['Route']=next_hop\n\n  \n  if 'GatewayId' in next_hop:\n    if next_hop['GatewayId'] == 'local':\n      RouteTableToTarget[mainRt][\"Analysis\"]=\"This Route Table has a local route for your given destination IP\"\n    else:\n      RouteTableToTarget[mainRt][\"Analysis\"]=\"This Route Table has an internet gateway route for your destination. However, route should be pointed to NAT gateway. Correct this route entry to NAT gateway.\"\n  elif 'NatGatewayId' in next_hop:\n    for subnet in subnetWithMainRouteTable:\n      subnetToNat[subnet]=next_hop['NatGatewayId']\n    RouteTableToTarget[mainRt][\"Analysis\"]=\"This Route Table has an NAT gateway route for your destination. Check whether this NAT gateway is launched in public subnet or if it exists (check for blackhole routes).\"  \n  elif next_hop:\n    RouteTableToTarget[mainRt][\"Analysis\"]=\"This Route table has a route for given destination IP which is other than internet gateway, NAT or local route\" \n  else:\n    RouteTableToTarget[mainRt][\"Analysis\"]=\"This Route Table does not have an NAT gateway route for your destination. Please have a NAT Gateway as a target for this route.\"\n    RouteTableToTarget[mainRt]['MainRouteTable']=\"yes\"\n  return RouteTableToTarget,routeTableSubnetMap,subnetToNat\n\ndef getLambdaEni(subnet,sec_grp):\n  sec_grp.sort()\n  try:\n    response = client.describe_network_interfaces(\n              Filters=[\n                {'Name': 'attachment.instance-owner-id','Values': ['amazon-aws']},\n                {'Name': 'group-id','Values': sec_grp},\n                {'Name': 'subnet-id','Values': [subnet]}\n                      ]\n                      )\n  except e as Exception:\n      print(\"Error occured as \"+str(e))\n\n  for eni in response['NetworkInterfaces']:\n    enisecGrp=[]\n    for group in eni['Groups']:\n      enisecGrp.append(group['GroupId'])\n      enisecGrp.sort()\n    \n    if sec_grp == enisecGrp:\n      return eni['PrivateIpAddress']\n\n\ndef checkPath(response,destination_ip,subnetIds,vpcId):\n  routeTableSubnetMap={}\n  RouteTableToTarget={}\n  destination = ip_address(destination_ip)\n  subnetToNat={}\n  \n  for routeTables in response['RouteTables']:\n    subnetFlag=[]\n    for AssociationState in routeTables['Associations']:\n      if 'SubnetId' in AssociationState:\n        if AssociationState['SubnetId'] in subnetIds:\n          routeTableSubnetMap[AssociationState['SubnetId']]=AssociationState['RouteTableId']\n          subnetFlag.append(AssociationState['SubnetId'])\n\n    most_specific = -1\n    next_hop={}\n\n    for route in routeTables['Routes']:\n      if 'DestinationCidrBlock' in route:\n        mask = int(route['DestinationCidrBlock'].split('/')[1])\n        if not 'DestinationPrefixListId' in str(route) and destination in ip_network(route['DestinationCidrBlock']) and mask > most_specific:\n          most_specific = mask\n          state=route['State']\n          next_hop = route\n\n    RouteTableToTarget[routeTables['RouteTableId']]={}\n    RouteTableToTarget[routeTables['RouteTableId']]['Route']=next_hop      \n    if 'GatewayId' in next_hop:  \n      if next_hop['GatewayId'] == 'local':\n        RouteTableToTarget[routeTables['RouteTableId']][\"Analysis\"]=\"This Route Table has a local route for your given destination IP\"\n      else:  \n        RouteTableToTarget[routeTables['RouteTableId']][\"Analysis\"]=\"This Route Table has an internet gateway route for your destination. However, route should be pointed to NAT gateway. Correct this route entry to NAT gateway.\"\n    elif 'NatGatewayId' in next_hop:\n      for subnet in subnetFlag:\n        subnetToNat[subnet]=next_hop['NatGatewayId']\n      RouteTableToTarget[routeTables['RouteTableId']][\"Analysis\"]=\"This Route Table has an NAT gateway route for your destination. Check whether this NAT gateway is launched in public subnet or if it exists (blackhole routes).\"\n    elif next_hop:\n      RouteTableToTarget[routeTables['RouteTableId']][\"Analysis\"]=\"This Route table has a route for given destination IP which is other than internet gateway, NAT or local route\"\n    else:\n      RouteTableToTarget[routeTables['RouteTableId']][\"Analysis\"]=\"This Route Table does not have an NAT gateway route or any other route for your destination. Please have a NAT Gateway as a target for this route.\"\n\n  subnetWithMainRouteTable=list(set(subnetIds) - set(routeTableSubnetMap.keys()))\n\n  if subnetWithMainRouteTable:\n    mainRt=\"\"\n    response = client.describe_route_tables(Filters=[{'Name': 'vpc-id','Values': [vpcId]}])\n    for routeTable in response['RouteTables']:\n      for association in routeTable['Associations']:\n        if association['Main'] == True:\n          mainRt=association['RouteTableId']\n    RouteTableToTarget1,routeTableSubnetMap1,subnetToNat1=getMainRTmap(mainRt,subnetWithMainRouteTable,destination)      \n    subnetToNat.update(subnetToNat1)\n    routeTableSubnetMap.update(routeTableSubnetMap1)\n    RouteTableToTarget.update(RouteTableToTarget1)\n    return RouteTableToTarget,routeTableSubnetMap,subnetToNat\n  \n  else:   \n    return RouteTableToTarget,routeTableSubnetMap,subnetToNat        \n\n\ndef checkSubnet(events,context):\n\n  client=boto3.client('ec2')\n  subnetIds=events['subnet']\n  secgrps=events['secgrps'] \n  vpcId=events['vpcId']\n  response = client.describe_route_tables(Filters=[{'Name': 'association.subnet-id','Values': subnetIds}])\n  RouteTableToTarget,routeTableSubnetMap,subnetToNat=checkPath(response,events['destinationIp'],subnetIds,vpcId)\n\n  natList=[]\n  natMap={}\n\n  for k,v in RouteTableToTarget.items():\n    if 'NatGatewayId' in v['Route'] and v['Route']['State'] == 'active':\n      subnetId = client.describe_nat_gateways(NatGatewayIds=[v['Route']['NatGatewayId']])['NatGateways'][0]['SubnetId']\n      natList.append(subnetId)\n      natMap[v['Route']['NatGatewayId']]=subnetId\n      response = client.describe_route_tables(Filters=[{'Name': 'association.subnet-id','Values': [subnetId]}])\n      result=checkPath(response,events['destinationIp'],[subnetId],vpcId)[0]\n\n      for k1,v1 in result.items():\n        if v1['Route'] == {}:\n          v['Analysis']=\"NAT Gateway does not have any route for the destination IP\"\n        elif 'GatewayId' in v1['Route']:\n          v['Analysis']=\"This Route Table has an active NAT gateway path. Also, The NAT gateway is launched in public subnet\"\n        else:\n          v['Analysis']=\"This Route Table has an active NAT gateway path. However, The NAT gateway is not launched in public subnet. The NAT Subnet does not have any internet gateway routing path for your destination ip\"\n\n  result={'subnet':{},'LambdaSubnetIpToNatSubnet':{}}\n\n  for subnet,routeTable in routeTableSubnetMap.items():\n    result['subnet'][subnet]=RouteTableToTarget[routeTable]\n    result['subnet'][subnet]['RouteTable']=routeTable\n\n  LambdaSubnetIpToNatSubnet={}\n  for subnet, nat in subnetToNat.items():\n    lambdaIp=getLambdaEni(subnet,secgrps)\n    if nat in natMap:\n      LambdaSubnetIpToNatSubnet[lambdaIp]=natMap[nat]\n    else:\n      pass  \n\n  result['LambdaSubnetIpToNatSubnet']=LambdaSubnetIpToNatSubnet\n  result['NAT_Gateway_subnets']=list(set(natList))\n\n  return result\n",
        "InputPayload": {
          "vpcId": "{{checkVpc.vpc}}",
          "subnet": "{{checkVpc.subnet}}",
          "destinationIp": "{{destinationIp}}",
          "secgrps": "{{checkVpc.securityGroups}}"
        }
      },
      "outputs": [
        {
          "Name": "subnets",
          "Selector": "$.Payload.subnet",
          "Type": "StringMap"
        },
        {
          "Name": "Natsubnets",
          "Selector": "$.Payload.NAT_Gateway_subnets",
          "Type": "StringList"
        },
        {
          "Name": "LambdaSubnetIpToNatSubnet",
          "Selector": "$.Payload.LambdaSubnetIpToNatSubnet",
          "Type": "StringMap"
        }
      ]
    },
    {
      "name": "checkSecurityGroups",
      "action": "aws:executeScript",
      "inputs": {
        "Runtime": "python3.8",
        "Handler": "checkSecurityGroups",
        "Script": "import boto3\nfrom ipaddress import ip_network,ip_address\n\ndef checkSecurityGroups(events,context):\n\n  destinationIp=ip_address(events['destinationIp'])\n  allowedPorts=int(events['destinationPort'])\n  \n  client=boto3.client('ec2')\n  response = client.describe_security_groups(GroupIds=events['secgrps'])\n\n  result={}\n  \n  for securityGroup in response['SecurityGroups']:\n    result[securityGroup['GroupId']]=''\n    for rule in securityGroup['IpPermissionsEgress']:\n      if rule['IpProtocol'] == '-1' or (rule['FromPort'] == allowedPorts and rule['ToPort'] == allowedPorts) or (allowedPorts in range(rule['FromPort'],rule['ToPort']+1)):\n        for cidr in rule['IpRanges']:\n          if destinationIp in ip_network(cidr['CidrIp']):\n            result[securityGroup['GroupId']] = {\"Status\":\"Allowed\"}\n            result[securityGroup['GroupId']]['Analysis']=\"This security group has allowed destintion IP and port in its outbuond rule.\"\n            break\n    if\t'Status' not in result[securityGroup['GroupId']]:\n        result[securityGroup['GroupId']] = {\"Status\":\"notAllowed\"}\n        result[securityGroup['GroupId']]['Analysis']=\"This security group does not have an outbound rule for your destination IP or destination port. Please allow them in the outbound rule.\"\n\n  return result\n",
        "InputPayload": {
          "destinationIp": "{{destinationIp}}",
          "destinationPort": "{{destinationPort}}",
          "secgrps": "{{checkVpc.securityGroups}}"
        }
      },
      "outputs": [
        {
          "Name": "secgrps",
          "Selector": "$.Payload",
          "Type": "StringMap"
        }
      ]
    },
    {
      "name": "checkNACL",
      "action": "aws:executeScript",
      "inputs": {
        "Runtime": "python3.8",
        "Handler": "checkNACL",
        "Script": "import boto3\nfrom ipaddress import ip_network,ip_address\n\ndef echeck(entries,destinationIp,allowedPorts,ipcheck):\n  for entry in entries:\n    if 'CidrBlock' in entry:\n      if  destinationIp in ip_network(entry['CidrBlock']):\n        if ipcheck == \"destinationIp\":\n          if entry['Egress'] == True and (entry['Protocol'] == '-1' or ((allowedPorts in range(entry['PortRange']['From'],entry['PortRange']['To']+1)) if 'PortRange' in entry else False)):\n            if entry['RuleAction'] == 'deny':\n              return 'notAllowed'\n            if entry['RuleAction'] == 'allow':\n              return 'Allowed'\n        else:\n          if entry['Egress'] == True and (entry['Protocol'] == '-1' or ( (set(range(1024,65535)).issubset(range(entry['PortRange']['From'],entry['PortRange']['To'] +1))) if 'PortRange' in entry else False)):\n            if entry['RuleAction'] == 'deny':\n              return 'notAllowed'\n            if entry['RuleAction'] == 'allow':\n              return 'Allowed'\n\ndef icheck(entries,destinationIp,allowedPorts,ipcheck):\n  for entry in entries:\n    if 'CidrBlock' in entry:\n      if  destinationIp in ip_network(entry['CidrBlock']):\n        if ipcheck == \"destinationIp\":\n          if entry['Egress'] == False and (entry['Protocol'] == '-1' or ( (set(range(1024,65535)).issubset(range(entry['PortRange']['From'],entry['PortRange']['To'] +1))) if 'PortRange' in entry else False)):\n            if entry['RuleAction'] == 'deny':\n              return 'notAllowed'\n            if entry['RuleAction'] == 'allow':\n              return 'Allowed'\n        else:\n          if entry['Egress'] == False and (entry['Protocol'] == '-1' or ((allowedPorts in range(entry['PortRange']['From'],entry['PortRange']['To']+1)) if 'PortRange' in entry else False)):\n            if entry['RuleAction'] == 'deny':\n              return 'notAllowed'\n            if entry['RuleAction'] == 'allow':\n              return 'Allowed'\n\ndef checkNACL(events,context):\n  print(\"printing all the events\")\n  print(events)\n  natsubList=events['natSubnets']\n  destinationIp=ip_address(events['destinationIp'])\n  allowedPorts=int(events['destinationPort'])\n  LambdaIptoNatSubnet=events['LambdaSubnetIpToNatSubnet']\n  natSubnets=events['natSubnets']\n  TotalSubs=events['lambdaSubnets']\n  TotalSubs.extend(natsubList)\n  print(TotalSubs)\n  subnetNacl={}\n\n  client=boto3.client('ec2')    \n  response = client.describe_network_acls(Filters=[{'Name': 'association.subnet-id','Values': TotalSubs}])\n  print(response)\n  for NetworkAcl in response['NetworkAcls']:\n    subnetFlag={}\n    for association in NetworkAcl['Associations']:\n      if association['SubnetId'] in TotalSubs and association['SubnetId'] not in natsubList:\n        subnetFlag[association['SubnetId']]='LambdaSubnet'\n        subnetNacl[association['SubnetId']]\t= {}\n        subnetNacl[association['SubnetId']]['NACL'] = association['NetworkAclId']\n      if association['SubnetId'] in TotalSubs and association['SubnetId'] in natsubList:\n        subnetFlag[association['SubnetId']]='NatSubnet'\n        subnetNacl[association['SubnetId']]\t= {}\n        subnetNacl[association['SubnetId']]['NACL'] = association['NetworkAclId']\n\n      \n\n    tempE='notAllowed'\n    tempI='notAllowed'\n\n    tempE=echeck(NetworkAcl['Entries'],destinationIp,allowedPorts,\"destinationIp\")\n    tempI=icheck(NetworkAcl['Entries'],destinationIp,allowedPorts,\"destinationIp\")\n\n    if tempE == tempI == 'notAllowed':  \n      Analysis=\"There is no ingress or egress rule allowed in your NACL for your desired destination and ports. Please allow them in NACL egress and ingress rules\"\n    elif tempE == \"notAllowed\" and tempI == \"Allowed\":\n      Analysis=\"This NACL has an allow rule for Ingress traffic but there is no Egress rule. Please allow the destination IP / destionation port in Egress rule\"\n    elif tempE == \"Allowed\" and tempI == \"notAllowed\":\n      Analysis=\"This NACL has an allow rule for Egress traffic but there is no Ingress rule. Please allow the destination IP / destionation port in Ingress rule\"    \n    else:\n      Analysis=\"This NACL has both Egress and Ingress rule allowing your desired destination IP / destionation port\"\n\n    \n    for k,v in subnetFlag.items():\n      subnetNacl[k]['destinationIp_Egress'] = tempE\n      subnetNacl[k]['destinationIp_Ingress'] = tempI\n      subnetNacl[k]['Analysis'] = Analysis\n\n      if v == 'NatSubnet':\n        subnetNacl[k]['LambdaIpRules']={}\n        for k1,v1 in LambdaIptoNatSubnet.items():\n          if v1 == k:\n            tempE=echeck(NetworkAcl['Entries'],ip_address(k1),allowedPorts,\"LambdaIpCheck\")\n            tempI=icheck(NetworkAcl['Entries'],ip_address(k1),allowedPorts,\"LambdaIpCheck\")\n\n          if tempE == tempI == 'notAllowed':\n            analysis=\"This is a NAT subnet NACL. It does not have ingress or egress rule allowed in it for Lambda's corresponding private ip \" +str(k1) +\" Please allow this IP in your egress and ingress NACL rules\"\n\n          elif tempE == \"notAllowed\" and tempI == \"Allowed\":\n            analysis=\"This is a NAT subnet NACL. It does not have egress rule allowed in it for Lambda's corresponding private ip \" +str(k1) +\" Please allow this IP in your egress NACL rules\"\n          elif tempE == \"Allowed\" and tempI == \"notAllowed\":\n            analysis=\"This is a NAT subnet NACL. It does not have ingress rule allowed in it for Lambda's corresponding private ip \" +str(k1) +\" Please allow this IP in your ingress NACL rules\"\n          else:\n            analysis=\"This NACL has both Egress and Ingress rule allowing the Lambda's corresponding private ip \" +str(k1)\n\n\n          subnetNacl[k]['LambdaIpRules'][k1]={}\n          subnetNacl[k]['LambdaIpRules'][k1]['Egress']=tempE\n          subnetNacl[k]['LambdaIpRules'][k1]['Ingress']=tempI\n          subnetNacl[k]['LambdaIpRules'][k1]['Analysis']=analysis\n\n  return subnetNacl\n",
        "InputPayload": {
          "destinationIp": "{{destinationIp}}",
          "destinationPort": "{{destinationPort}}",
          "natSubnets": "{{checkSubnet.Natsubnets}}",
          "lambdaSubnets": "{{checkVpc.subnet}}",
          "LambdaSubnetIpToNatSubnet": "{{checkSubnet.LambdaSubnetIpToNatSubnet}}"
        }
      },
      "outputs": [
        {
          "Name": "NACL",
          "Selector": "$.Payload",
          "Type": "StringMap"
        }
      ]
    }
  ]
}
