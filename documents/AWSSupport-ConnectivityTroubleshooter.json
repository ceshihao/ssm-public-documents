{
  "description": "This document helps to troubleshoot connectivity across two resource using their IP addresses as input. This document supports IPv4 only.",
  "schemaVersion": "0.3",
  "assumeRole": "{{AutomationAssumeRole}}",
  "parameters": {
    "AutomationAssumeRole": {
      "type": "String",
      "description": "(Optional) The ARN of the role that allows Automation to perform the actions on your behalf. If no role is specified, Systems Manager Automation uses the permissions of the user that executes this document.",
      "default": "",
      "allowedPattern": "^$|^arn:aws:iam::[0-9]*:role/[/\\w+=,.@-]+$"
    },
    "SourceIP": {
      "type": "String",
      "description": "(Required) Private IPv4 address of a VPC resource.",
      "allowedPattern": "\\b((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)(\\.|$)){4}\\b"
    },
    "DestinationIP": {
      "type": "String",
      "description": "(Required) IPv4 address of the destination resource.",
      "allowedPattern": "\\b((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)(\\.|$)){4}\\b"
    },
    "DestinationPort": {
      "type": "String",
      "description": "(Required) Destination Server port the source is trying to connect. For e.g 22 for SSH, 80 for HTTP, 443 for HTTPS, 3389 for RDP",
      "allowedPattern": "^(6553[0-5]|655[0-2]\\d|65[0-4]\\d\\d|6[0-4]\\d{3}|[1-5]\\d{4}|[1-9]\\d{0,3}|0)$"
    },
    "SourceVpc": {
      "type": "String",
      "description": "(Optional) VPC Id of the source Amazon VPC",
      "allowedPattern": "^$|^(?:vpc-[0-9a-f]{8}|vpc-[0-9a-f]{17}|)$",
      "default": ""
    },
    "DestinationVpc": {
      "type": "String",
      "description": "(Optional) VPC Id of the destination Amazon VPC",
      "allowedPattern": "^$|^(?:vpc-[0-9a-f]{8}|vpc-[0-9a-f]{17}|)$",
      "default": ""
    },
    "SourcePortRange": {
      "type": "String",
      "description": "(Optional) Source port range used by source resource. For e.g. if the source port is fixed- 123-123 or if source ports uses a defined range- 32000-65000",
      "allowedPattern": "^(6553[0-5]|655[0-2]\\d|65[0-4]\\d\\d|6[0-4]\\d{3}|[1-5]\\d{4}|[1-9]\\d{0,3}|0)-(6553[0-5]|655[0-2]\\d|65[0-4]\\d\\d|6[0-4]\\d{3}|[1-5]\\d{4}|[1-9]\\d{0,3}|0)$",
      "default": "0-65535"
    }
  },
  "mainSteps": [
    {
      "name": "getSourceDetails",
      "action": "aws:executeScript",
      "outputs": [
        {
          "Name": "SrcNetworkInterface",
          "Selector": "$.Payload.SrcNetworkInterface",
          "Type": "StringMap"
        },
        {
          "Name": "SrcSecurityGroups",
          "Selector": "$.Payload.SrcSecurityGroups",
          "Type": "StringList"
        },
        {
          "Name": "SrcSubnetId",
          "Selector": "$.Payload.SrcSubnetId",
          "Type": "String"
        },
        {
          "Name": "SrcVpcId",
          "Type": "String",
          "Selector": "$.Payload.SrcVpcId"
        },
        {
          "Name": "Routes",
          "Selector": "$.Payload.Routes",
          "Type": "MapList"
        }
      ],
      "inputs": {
        "Runtime": "python3.8",
        "Handler": "get_source_details",
        "Script": "def get_source_details(events, context):\n    src_ip = events['SourceIP']\n    src_vpc = events['SourceVpc']\n    dst_ip = events['DestinationIP']\n\n    if src_ip == dst_ip:\n        raise Exception('Input parameters SourceIP and DestinationIP are same, kindly provide different input parameters')\n\n    import boto3\n\n    ec2_client = boto3.client('ec2')\n\n    filters = [\n        {\n            'Name': 'addresses.private-ip-address',\n            'Values': [\n                src_ip\n            ]\n        }\n    ]\n    if src_vpc != '':\n        filters.append(\n                {\n                    'Name': 'vpc-id',\n                    'Values': [\n                        src_vpc\n                    ]\n                }\n        )\n\n    network_interface = ec2_client.describe_network_interfaces(Filters=filters)\n\n    if len(network_interface['NetworkInterfaces']) > 0:\n        network_interface = network_interface['NetworkInterfaces'][0]\n        if 'AttachTime' in str(network_interface):\n            network_interface['Attachment']['AttachTime'] = str(network_interface['Attachment']['AttachTime'])\n    else:\n        raise Exception('Kindly check the SourceIP and SourceVpc input parameters, no network interface found')\n    \n    output = {\n        'SrcNetworkInterface': network_interface\n    }\n    output['SrcVpcId'] = network_interface['VpcId']\n    output['SrcSubnetId'] = network_interface['SubnetId']\n    output['SrcSecurityGroups'] = [group['GroupId'] for group in network_interface['Groups']]            \n    \n    routes = ec2_client.describe_route_tables(\n        Filters=[\n        {\n            'Name': 'association.subnet-id',\n            'Values': [\n                network_interface['SubnetId']\n            ]\n        }\n    ]\n    )\n\n    if len(routes['RouteTables']) > 0:\n        routes = routes['RouteTables'][0]['Routes']\n    # if RouteTable is not returned, this indicates association of subnet with main route table\n    else:\n        try:\n            routes = ec2_client.describe_route_tables(\n                Filters=[\n                    {\n                        'Name': 'association.main',\n                        'Values': [\n                            'true'\n                        ]\n                    },\n                    {\n                        'Name': 'vpc-id',\n                        'Values': [\n                            network_interface['VpcId']\n                        ]\n                    }                    \n                ]\n            )['RouteTables'][0]['Routes']\n        except Exception as e:\n            raise Exception('Could not find route table for input SourceIP')\n    \n    output['Routes'] = routes\n    return output\n",
        "InputPayload": {
          "SourceVpc": "{{SourceVpc}}",
          "SourceIP": "{{SourceIP}}",
          "DestinationIP": "{{DestinationIP}}"
        }
      },
      "isCritical": true,
      "timeoutSeconds": 30,
      "onFailure": "Abort",
      "nextStep": "getNextHop",
      "isEnd": false
    },
    {
      "name": "getNextHop",
      "action": "aws:executeScript",
      "outputs": [
        {
          "Name": "NextHop",
          "Selector": "$.Payload",
          "Type": "String"
        }
      ],
      "inputs": {
        "Runtime": "python3.8",
        "Handler": "get_next_hop",
        "Script": "def get_next_hop(events, context):\n    from ipaddress import ip_network,ip_address\n    routes = events['Routes'] \n    destination = ip_address(events['DestinationIP'])        \n    most_specific = -1\n\n    AWS_DOC = '\\nWorking with route tables - https://docs.aws.amazon.com/vpc/latest/userguide/WorkWithRouteTables.html'\n    for route in routes:\n        if route.get('DestinationCidrBlock'):\n            mask = int(route['DestinationCidrBlock'].split('/')[1])\n            if not 'DestinationPrefixListId' in str(route) and destination in ip_network(route['DestinationCidrBlock'], strict=False) and mask > most_specific:\n                if route['State'] != 'blackhole':\n                    most_specific = mask\n                    next_hop = route\n    #0.0.0.0/0\n    if most_specific >= 0:\n        return next_hop.get('EgressOnlyInternetGatewayId') or next_hop.get('GatewayId') or next_hop.get('InstanceId') or next_hop.get('NetworkInterfaceId') or next_hop.get('LocalGatewayId') or next_hop.get('NatGatewayId') or next_hop.get('TransitGatewayId') or next_hop.get('VpcPeeringConnectionId')\n    raise Exception('No route found for destination: ' + events['DestinationIP'] + AWS_DOC)      \n",
        "InputPayload": {
          "Routes": "{{getSourceDetails.Routes}}",
          "DestinationIP": "{{DestinationIP}}"
        }
      },
      "isCritical": true,
      "timeoutSeconds": 30,
      "onFailure": "Abort",
      "nextStep": "branchByNextHopType",
      "isEnd": false
    },
    {
      "name": "branchByNextHopType",
      "action": "aws:branch",
      "inputs": {
        "Choices": [
          {
            "NextStep": "localDestination",
            "Variable": "{{getNextHop.NextHop}}",
            "StringEquals": "local"
          },
          {
            "NextStep": "peeringDestination",
            "Variable": "{{getNextHop.NextHop}}",
            "StartsWith": "pcx-"
          },
          {
            "NextStep": "natDestination",
            "Variable": "{{getNextHop.NextHop}}",
            "StartsWith": "nat-"
          },
          {
            "NextStep": "igwDestination",
            "Variable": "{{getNextHop.NextHop}}",
            "StartsWith": "igw-"
          }
        ]
      },
      "isCritical": true,
      "timeoutSeconds": 30,
      "onFailure": "Abort",
      "nextStep": "hopTypeNotSupported",
      "isEnd": false
    },
    {
      "name": "localDestination",
      "action": "aws:executeAwsApi",
      "outputs": [
        {
          "Name": "DstSecurityGroups",
          "Selector": "$.NetworkInterfaces[0].Groups..GroupId",
          "Type": "StringList"
        },
        {
          "Name": "DstSubnetId",
          "Selector": "$.NetworkInterfaces[0].SubnetId",
          "Type": "String"
        },
        {
          "Name": "DstVpcId",
          "Selector": "$.NetworkInterfaces[0].VpcId",
          "Type": "String"
        }
      ],
      "inputs": {
        "Service": "ec2",
        "Api": "DescribeNetworkInterfaces",
        "Filters": [
          {
            "Name": "addresses.private-ip-address",
            "Values": [
              "{{DestinationIP}}"
            ]
          }
        ]
      },
      "isCritical": true,
      "timeoutSeconds": 30,
      "onFailure": "Abort",
      "nextStep": "checkDestinationVpcId",
      "isEnd": false
    },
    {
      "name": "checkDestinationVpcId",
      "action": "aws:executeScript",
      "inputs": {
        "Runtime": "python3.8",
        "Handler": "check_destination_vpcid",
        "Script": "def check_destination_vpcid(events, context):\n    dst_vpc_from_input = events['InputDstVpc']\n    dst_vpc_from_route = events['RouteDstVpc']\n\n    AWS_DOC = '\\nWorking with route tables - https://docs.aws.amazon.com/vpc/latest/userguide/WorkWithRouteTables.html'\n\n    # ensure that dst_vpc is not blank, as it's an optinal parameter\n    if dst_vpc_from_input != '':\n        if dst_vpc_from_input == dst_vpc_from_route:\n            return True\n        else:\n            raise Exception('Kindly check the source route table to ensure a more specific route is present towards required destination VPC' + AWS_DOC)\n",
        "InputPayload": {
          "InputDstVpc": "{{DestinationVpc}}",
          "RouteDstVpc": "{{localDestination.DstVpcId}}"
        }
      },
      "isCritical": true,
      "timeoutSeconds": 30,
      "onFailure": "Continue",
      "nextStep": "getSecurityGroupDetails",
      "isEnd": false
    },
    {
      "name": "getSecurityGroupDetails",
      "action": "aws:executeAwsApi",
      "inputs": {
        "Service": "ec2",
        "Api": "DescribeSecurityGroups",
        "GroupIds": [
          "{{getSourceDetails.SrcSecurityGroups}}",
          "{{localDestination.DstSecurityGroups}}"
        ]
      },
      "outputs": [
        {
          "Name": "SecurityGroups",
          "Selector": "$",
          "Type": "StringMap"
        }
      ],
      "nextStep": "evalSecurityGroups",
      "isCritical": true,
      "timeoutSeconds": 30,
      "onFailure": "Continue",
      "isEnd": false
    },
    {
      "name": "evalSecurityGroups",
      "action": "aws:executeScript",
      "inputs": {
        "Runtime": "python3.8",
        "Handler": "eval_sg_rules",
        "Script": "def eval_sg_rules(events, context):\n    from ipaddress import ip_network,ip_address\n    src_security_groups = events['SrcSecurityGroups']\n    dst_security_groups = events['DstSecurityGroups']\n    security_group_details = events['SecurityGroups']\n    src_ip = ip_address(events['SourceIP'])\n    dst_ip = ip_address(events['DestinationIP'])        \n    dst_port = int(events['DestinationPort'])    \n\n    AWS_DOC = '\\nSecurity groups for your VPC - Working with security groups - https://docs.aws.amazon.com/vpc/latest/userguide/VPC_SecurityGroups.html#WorkingWithSecurityGroups'      \n\n    def eval_src_egress_rules():                    \n        for src_security_group in src_security_groups:\n            sg = [group for group in security_group_details['SecurityGroups'] if group['GroupId'] == src_security_group][0]\n            for rule in sg['IpPermissionsEgress']:\n                if ((rule.get('IpProtocol') == '-1') or (rule.get('FromPort') == -1 and rule.get('ToPort') == -1) or (dst_port in range(rule.get('FromPort'), rule.get('ToPort') +1))):\n                    for cidr in rule['IpRanges']:\n                        if dst_ip in ip_network(cidr['CidrIp'], strict=False):\n                            return True\n                    else:\n                        for group in rule['UserIdGroupPairs']:\n                            if any(sg in group['GroupId'] for sg in dst_security_groups) :\n                                return True\n        raise Exception('Egress rules on source do not allow traffic towards destination: ' + events['DestinationIP'] + ':' + str(dst_port) + AWS_DOC)               \n\n    def eval_dst_ingress_rules():\n        for dst_security_group in dst_security_groups:\n            sg = [group for group in security_group_details['SecurityGroups'] if group['GroupId'] == dst_security_group][0]\n            for rule in sg['IpPermissions']:\n                if ((rule.get('IpProtocol') == '-1') or (rule.get('FromPort') == -1 and rule.get('ToPort') == -1) or (dst_port in range(rule.get('FromPort'), rule.get('ToPort') +1))):\n                    for cidr in rule['IpRanges']:\n                        if src_ip in ip_network(cidr['CidrIp'], strict=False):\n                            return True\n                    else:\n                        for group in rule['UserIdGroupPairs']:\n                            if any(sg in group['GroupId'] for sg in src_security_groups):\n                                return True\n        raise Exception('Ingress rules on destination do not allow traffic from source: ' + events['SourceIP'] + ' towards destination port ' + str(dst_port) + AWS_DOC)\n\n    eval_src_egress_rules()        \n    eval_dst_ingress_rules()         \n\n    return True\n",
        "InputPayload": {
          "SrcSecurityGroups": "{{getSourceDetails.SrcSecurityGroups}}",
          "DstSecurityGroups": "{{localDestination.DstSecurityGroups}}",
          "SecurityGroups": "{{getSecurityGroupDetails.SecurityGroups}}",
          "SourceIP": "{{SourceIP}}",
          "DestinationIP": "{{DestinationIP}}",
          "DestinationPort": "{{DestinationPort}}"
        }
      },
      "isCritical": true,
      "timeoutSeconds": 30,
      "onFailure": "Continue",
      "isEnd": false,
      "nextStep": "getNaclDetails"
    },
    {
      "name": "getNaclDetails",
      "action": "aws:executeAwsApi",
      "inputs": {
        "Service": "ec2",
        "Api": "DescribeNetworkAcls",
        "Filters": [
          {
            "Name": "association.subnet-id",
            "Values": [
              "{{getSourceDetails.SrcSubnetId}}",
              "{{localDestination.DstSubnetId}}"
            ]
          }
        ]
      },
      "outputs": [
        {
          "Name": "NetworkAcls",
          "Selector": "$.NetworkAcls",
          "Type": "MapList"
        }
      ],
      "nextStep": "evalNacls",
      "isCritical": true,
      "timeoutSeconds": 30,
      "onFailure": "Continue",
      "isEnd": false
    },
    {
      "name": "evalNacls",
      "action": "aws:executeScript",
      "inputs": {
        "Runtime": "python3.8",
        "Handler": "eval_nacls",
        "Script": "def eval_nacls(events, context):\n    from ipaddress import ip_network,ip_address\n    src_subnet_id = events['SrcSubnetId']\n    dst_subnet_id = events['DstSubnetId']\n    src_port_range = events['SourcePortRange']\n    src_port_from = int(src_port_range.split('-')[0])\n    src_port_to = int(src_port_range.split('-')[1])\n\n    AWS_DOC = '\\nNetwork ACLs - Working with network ACLs - https://docs.aws.amazon.com/vpc/latest/userguide/vpc-network-acls.html#nacl-tasks'\n\n    if src_subnet_id == dst_subnet_id:\n        return True\n\n    src_ip = ip_address(events['SourceIP'])        \n    dst_ip = ip_address(events['DestinationIP'])        \n    dst_port = int(events['DestinationPort'])\n\n    src_acls = [acl['Entries'] for acl in events['NetworkAcls'] if src_subnet_id in str(acl['Associations'])][0]\n    dst_acls = [acl['Entries'] for acl in events['NetworkAcls'] if dst_subnet_id in str(acl['Associations'])][0]\n\n    def eval_src_nacls(acls):                    \n    \n        def check_egress_acls(acls, dst_ip, dst_port):\n            for acl in acls:\n                # check ipv4 acl rule only\n                if acl.get('CidrBlock'):\n                    #Check IP\n                    if dst_ip in ip_network(acl['CidrBlock'], strict=False):\n                        #Check Port\n                        if ((acl.get('Protocol') == '-1') or (dst_port in range(acl['PortRange']['From'], acl['PortRange']['To'] +1))):\n                            #Check Action\n                            if acl['RuleAction'] == 'allow':\n                                return True\n                            else: raise Exception('Source Subnet Network Acl Egress Rules do not allow outbound traffic to destination: ' + events['DestinationIP'] + ':' + str(events['DestinationPort']) + AWS_DOC)\n            else:\n                raise Exception('Source Subnet Network Acl Egress Rules do not allow outbound traffic to destination: ' + events['DestinationIP'] + ':' + str(events['DestinationPort']) + AWS_DOC)\n            \n        def check_ingress_acls(acls, src_ip):\n            for acl in acls:\n                # check ipv4 acl rule only\n                if acl.get('CidrBlock'):\n                    #Check IP\n                    if src_ip in ip_network(acl['CidrBlock'], strict=False):\n                        #Check Port\n                        if ((acl.get('Protocol') == '-1') or (set(range(src_port_from, src_port_to)).issubset(range(acl['PortRange']['From'], acl['PortRange']['To'] +1)))):\n                            #Check Action\n                            if acl['RuleAction'] == 'allow':\n                                return True\n                            else: raise Exception('Source Subnet Network Acl Ingress Rules do not allow inbound traffic from destination: ' + events['DestinationIP'] + AWS_DOC)            \n            else:\n                raise Exception('Source Subnet Network Acl Ingress Rules do not allow inbound traffic from destination: ' + events['DestinationIP'] + AWS_DOC)            \n        \n        egress_acls = [acl for acl in acls if acl['Egress']]                                \n        ingress_acls = [acl for acl in acls if not acl['Egress']]\n\n        src_egress_check_pass = check_egress_acls(egress_acls, dst_ip, dst_port)\n        src_ingress_check_pass= check_ingress_acls(ingress_acls, dst_ip) \n\n        if src_ingress_check_pass and src_egress_check_pass: \n            return True\n\n    def eval_dst_nacls(acls):                                    \n        def check_egress_acls(acls, dst_ip):\n            for acl in acls:\n                # check ipv4 acl rule only\n                if acl.get('CidrBlock'):\n                    #Check IP\n                    if dst_ip in ip_network(acl['CidrBlock'], strict=False):\n                        #Check Port\n                        if ((acl.get('Protocol') == '-1') or (set(range(src_port_from,src_port_to)).issubset(range(acl['PortRange']['From'], acl['PortRange']['To'] +1)))):\n                            #Check Action\n                            if acl['RuleAction'] == 'allow':\n                                return True\n                            else: raise Exception('Destination Subnet Network Acl Egress Rules do not allow outbound traffic to source: ' + events['SourceIP'] + AWS_DOC)\n            else:\n                raise Exception('Destination Subnet Network Acl Egress Rules do not allow outbound traffic to source: ' + events['SourceIP'] + AWS_DOC)\n    \n        def check_ingress_acls(acls, src_ip, dst_port):            \n            for acl in acls:\n                # check ipv4 acl rule only\n                if acl.get('CidrBlock'):\n                    #Check IP\n                    if src_ip in ip_network(acl['CidrBlock'], strict=False):\n                        #Check Port\n                        if ((acl.get('Protocol') == '-1') or (dst_port in range(acl['PortRange']['From'], acl['PortRange']['To'] +1))):\n                            #Check Action\n                            if acl['RuleAction'] == 'allow':\n                                return True\n                            else: raise Exception('Destination Subnet Network Acl Ingress Rules do not allow inbound traffic from source: ' + events['SourceIP'] + ' towards destination port ' + str(events['DestinationPort']) + AWS_DOC)\n            else:\n                raise Exception('Destination Subnet Network Acl Ingress Rules do not allow inbound traffic from source: ' + events['SourceIP'] + ' towards destination port ' + str(events['DestinationPort']) + AWS_DOC)            \n            \n        egress_acls = [acl for acl in acls if acl['Egress']]                                \n        ingress_acls = [acl for acl in acls if not acl['Egress']]\n\n        dst_ingress_check_pass= check_ingress_acls(ingress_acls, src_ip, dst_port) \n        dst_egress_check_pass = check_egress_acls(egress_acls, src_ip)\n        \n        if dst_ingress_check_pass and dst_egress_check_pass: \n            return True\n    \n    eval_src_nacls(src_acls)\n    eval_dst_nacls(dst_acls)\n\n    return True\n",
        "InputPayload": {
          "NetworkAcls": "{{getNaclDetails.NetworkAcls}}",
          "SourceIP": "{{SourceIP}}",
          "DestinationIP": "{{DestinationIP}}",
          "DestinationPort": "{{DestinationPort}}",
          "SrcSubnetId": "{{getSourceDetails.SrcSubnetId}}",
          "DstSubnetId": "{{localDestination.DstSubnetId}}",
          "SourcePortRange": "{{SourcePortRange}}"
        }
      },
      "isCritical": true,
      "timeoutSeconds": 30,
      "onFailure": "Abort",
      "isEnd": true
    },
    {
      "name": "igwDestination",
      "action": "aws:executeScript",
      "inputs": {
        "Runtime": "python3.8",
        "Handler": "eval_src_public_ip",
        "Script": "def eval_src_public_ip(events, context):\n    src_network_interface = events['SrcNetworkInterface']\n    private_ips = src_network_interface['PrivateIpAddresses']\n    src_ip = events['SourceIP']\n    src_next_hop = events['SourceNextHop']\n    AWS_DOC = '\\nAmazon EC2 instance IP addressing - Working with IP addresses for your instance - https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-instance-addressing.html#working-with-ip-addresses'\n\n    if src_next_hop and str(src_next_hop).startswith('nat-'):\n        return True\n    \n    for private_ip in private_ips:\n        if private_ip['PrivateIpAddress'] == src_ip:\n            if 'PublicIp' in str(private_ip):\n                return True\n\n    raise Exception('A public IP or Elastic IP is required at source to connect to a public destination' + AWS_DOC)\n",
        "InputPayload": {
          "SrcNetworkInterface": "{{getSourceDetails.SrcNetworkInterface}}",
          "SourceIP": "{{SourceIP}}",
          "SourceNextHop": "{{getNextHop.NextHop}}"
        }
      },
      "isCritical": true,
      "timeoutSeconds": 30,
      "onFailure": "Continue",
      "isEnd": false,
      "nextStep": "getSrcSecurityGroupDetails"
    },
    {
      "name": "getSrcSecurityGroupDetails",
      "action": "aws:executeAwsApi",
      "inputs": {
        "Service": "ec2",
        "Api": "DescribeSecurityGroups",
        "GroupIds": [
          "{{getSourceDetails.SrcSecurityGroups}}"
        ]
      },
      "outputs": [
        {
          "Name": "SrcSecurityGroups",
          "Selector": "$",
          "Type": "StringMap"
        }
      ],
      "nextStep": "evalSrcSecurityGroups",
      "isCritical": true,
      "timeoutSeconds": 30,
      "onFailure": "Continue",
      "isEnd": false
    },
    {
      "name": "evalSrcSecurityGroups",
      "action": "aws:executeScript",
      "inputs": {
        "Runtime": "python3.8",
        "Handler": "eval_src_egress_rules",
        "Script": "def eval_src_egress_rules(events, context):  \n    from ipaddress import ip_network,ip_address\n    src_security_groups = events['SrcSecurityGroups']['SecurityGroups']\n    dst_ip = ip_address(events['DestinationIP'])        \n    dst_port = int(events['DestinationPort'])      \n\n    AWS_DOC = '\\nSecurity groups for your VPC - Working with security groups - https://docs.aws.amazon.com/vpc/latest/userguide/VPC_SecurityGroups.html#WorkingWithSecurityGroups'      \n\n    for sg in src_security_groups:\n        for rule in sg['IpPermissionsEgress']:\n            if ((rule.get('IpProtocol') == '-1') or (rule.get('FromPort') == -1 and rule.get('ToPort') == -1) or (dst_port in range(rule.get('FromPort'), rule.get('ToPort') +1))):\n                for cidr in rule['IpRanges']:\n                    if dst_ip in ip_network(cidr['CidrIp'], strict=False):\n                        return True\n    raise Exception('Egress rules on source do not allow traffic towards destination: ' + events['DestinationIP'] + ':' + str(dst_port) + AWS_DOC)            \n",
        "InputPayload": {
          "SrcSecurityGroups": "{{getSrcSecurityGroupDetails.SrcSecurityGroups}}",
          "DestinationIP": "{{DestinationIP}}",
          "DestinationPort": "{{DestinationPort}}"
        }
      },
      "isCritical": true,
      "timeoutSeconds": 30,
      "onFailure": "Continue",
      "isEnd": false,
      "nextStep": "getSrcNaclDetails"
    },
    {
      "name": "getSrcNaclDetails",
      "action": "aws:executeAwsApi",
      "inputs": {
        "Service": "ec2",
        "Api": "DescribeNetworkAcls",
        "Filters": [
          {
            "Name": "association.subnet-id",
            "Values": [
              "{{getSourceDetails.SrcSubnetId}}"
            ]
          }
        ]
      },
      "outputs": [
        {
          "Name": "SrcNetworkAcls",
          "Selector": "$.NetworkAcls",
          "Type": "MapList"
        }
      ],
      "nextStep": "evalSrcNacls",
      "isCritical": true,
      "timeoutSeconds": 30,
      "onFailure": "Continue",
      "isEnd": false
    },
    {
      "name": "evalSrcNacls",
      "action": "aws:executeScript",
      "inputs": {
        "Runtime": "python3.8",
        "Handler": "eval_src_nacls",
        "Script": "def eval_src_nacls(events, context):\n    from ipaddress import ip_network,ip_address   \n    \n    src_port_range = events['SourcePortRange']\n    src_port_from = int(src_port_range.split('-')[0])\n    src_port_to = int(src_port_range.split('-')[1])         \n    \n    AWS_DOC = '\\nNetwork ACLs - Working with network ACLs - https://docs.aws.amazon.com/vpc/latest/userguide/vpc-network-acls.html#nacl-tasks'\n\n    def check_egress_acls(acls, dst_ip, dst_port):\n        for acl in acls:\n            # check ipv4 acl rule only\n            if acl.get('CidrBlock'):\n                #Check IP\n                if dst_ip in ip_network(acl['CidrBlock'], strict=False):\n                    #Check Port\n                    if ((acl.get('Protocol') == '-1') or (dst_port in range(acl['PortRange']['From'], acl['PortRange']['To'] +1))):\n                        #Check Action\n                        if acl['RuleAction'] == 'allow':\n                            return True\n                        else: raise Exception('Source Subnet ' + events['SrcSubnetId'] + ' Network Acl Egress Rules do not allow outbound traffic to destination: ' + events['DestinationIP'] + ':' + str(events['DestinationPort']) + AWS_DOC)\n        else:\n            raise Exception('Source Subnet ' + events['SrcSubnetId'] + ' Network Acl Egress Rules do not allow outbound traffic to destination: ' + events['DestinationIP'] + ':' + str(events['DestinationPort']) + AWS_DOC)\n    \n    def check_ingress_acls(acls, src_ip):\n        for acl in acls:\n            # check ipv4 acl rule only\n            if acl.get('CidrBlock'):\n                #Check IP\n                if src_ip in ip_network(acl['CidrBlock'], strict=False):\n                    #Check Port\n                    if ((acl.get('Protocol') == '-1') or (set(range(src_port_from,src_port_to)).issubset(range(acl['PortRange']['From'], acl['PortRange']['To'] +1)))):\n                        #Check Action\n                        if acl['RuleAction'] == 'allow':\n                            return True\n                        else: raise Exception('Source Subnet ' + events['SrcSubnetId'] + ' Network Acl Ingress Rules do not allow inbound traffic from destination: ' + events['DestinationIP'] + AWS_DOC)            \n        else:\n            raise Exception('Source Subnet ' + events['SrcSubnetId'] + ' Network Acl Ingress Rules do not allow inbound traffic from destination: ' + events['DestinationIP'] + AWS_DOC)            \n    \n    dst_ip = ip_address(events['DestinationIP'])        \n    dst_port = int(events['DestinationPort'])\n\n    src_acls = events['SrcNetworkAcls'][0]['Entries']\n    egress_acls = [acl for acl in src_acls if acl['Egress']]                                \n    ingress_acls = [acl for acl in src_acls if not acl['Egress']]\n\n    src_egress_check_pass = check_egress_acls(egress_acls, dst_ip, dst_port)\n    src_ingress_check_pass= check_ingress_acls(ingress_acls, dst_ip) \n\n    if src_ingress_check_pass and src_egress_check_pass: \n        return True\n    \n    raise Exception('NetworkAcls do not allow traffic' + AWS_DOC)\n",
        "InputPayload": {
          "SrcNetworkAcls": "{{getSrcNaclDetails.SrcNetworkAcls}}",
          "SrcSubnetId": "{{getSourceDetails.SrcSubnetId}}",
          "DestinationIP": "{{DestinationIP}}",
          "DestinationPort": "{{DestinationPort}}",
          "SourcePortRange": "{{SourcePortRange}}"
        }
      },
      "isCritical": true,
      "timeoutSeconds": 30,
      "onFailure": "Abort",
      "isEnd": true
    },
    {
      "name": "natDestination",
      "action": "aws:executeAwsApi",
      "inputs": {
        "Service": "ec2",
        "Api": "DescribeNatGateways",
        "Filters": [
          {
            "Name": "nat-gateway-id",
            "Values": [
              "{{getNextHop.NextHop}}"
            ]
          }
        ]
      },
      "outputs": [
        {
          "Name": "NatSubnetId",
          "Selector": "$.NatGateways[0]['SubnetId']",
          "Type": "String"
        },
        {
          "Name": "NatVpcId",
          "Selector": "$.NatGateways[0]['VpcId']",
          "Type": "String"
        }
      ],
      "nextStep": "getNatSubnetAcls",
      "isCritical": true,
      "timeoutSeconds": 30,
      "onFailure": "Continue",
      "isEnd": false
    },
    {
      "name": "getNatSubnetAcls",
      "action": "aws:executeAwsApi",
      "inputs": {
        "Service": "ec2",
        "Api": "DescribeNetworkAcls",
        "Filters": [
          {
            "Name": "association.subnet-id",
            "Values": [
              "{{natDestination.NatSubnetId}}"
            ]
          }
        ]
      },
      "outputs": [
        {
          "Name": "NatNetworkAcls",
          "Selector": "$.NetworkAcls",
          "Type": "MapList"
        }
      ],
      "nextStep": "evalNatNacls",
      "isCritical": true,
      "timeoutSeconds": 30,
      "onFailure": "Continue",
      "isEnd": false
    },
    {
      "name": "evalNatNacls",
      "action": "aws:executeScript",
      "inputs": {
        "Runtime": "python3.8",
        "Handler": "eval_nat_nacls",
        "Script": "def eval_nat_nacls(events, context):\n    from ipaddress import ip_network,ip_address\n    src_subnet_id = events['SrcSubnetId']\n    nat_subnet_id = events['NatSubnetId']\n\n    src_ip = ip_address(events['SourceIP'])        \n    dst_ip = ip_address(events['DestinationIP'])        \n    dst_port = int(events['DestinationPort'])\n    src_port_range = events['SourcePortRange']\n    src_port_from = int(src_port_range.split('-')[0])\n    src_port_to = int(src_port_range.split('-')[1])\n\n    nat_acls = events['NatNetworkAcls'][0]['Entries']\n    egress_acls = [acl for acl in nat_acls if acl['Egress']]                                \n    ingress_acls = [acl for acl in nat_acls if not acl['Egress']]\n    \n    AWS_DOC = '\\nNetwork ACLs - Working with network ACLs - https://docs.aws.amazon.com/vpc/latest/userguide/vpc-network-acls.html#nacl-tasks'\n\n    def check_egress_towards_dst(acls, dst_ip, dst_port):            \n        for acl in acls:\n            # check ipv4 acl rule only\n            if acl.get('CidrBlock'):\n                #Check IP\n                if dst_ip in ip_network(acl['CidrBlock'], strict=False):\n                    #Check Port\n                    if ((acl.get('Protocol') == '-1') or (dst_port in range(acl['PortRange']['From'], acl['PortRange']['To'] +1))):\n                        #Check Action\n                        if acl['RuleAction'] == 'allow':\n                            return True\n                        else: raise Exception('NatGateway Subnet ' + events['SrcSubnetId'] + ' Network Acl Egress Rules do not allow outbound traffic to destination: ' + events['DestinationIP'] + ':' + str(events['DestinationPort']) + AWS_DOC)\n        else:\n            raise Exception('NatGateway Subnet ' + events['SrcSubnetId'] + ' Network Acl Egress Rules do not allow outbound traffic to destination: ' + events['DestinationIP'] + ':' + str(events['DestinationPort']) + AWS_DOC)\n        \n    def check_ingress_from_dst(acls, src_ip):\n        for acl in acls:\n            # check ipv4 acl rule only\n            if acl.get('CidrBlock'):\n                #Check IP\n                if src_ip in ip_network(acl['CidrBlock'], strict=False):\n                    #Check Port\n                    if ((acl.get('Protocol') == '-1') or (set(range(src_port_from,src_port_to)).issubset(range(acl['PortRange']['From'], acl['PortRange']['To'] +1)))):\n                        #Check Action\n                        if acl['RuleAction'] == 'allow':\n                            return True\n                        else: raise Exception('NatGateway Subnet ' + events['SrcSubnetId'] + ' Network Acl Ingress Rules do not allow inbound traffic from destination: ' + events['DestinationIP'] + AWS_DOC)\n        else:\n            raise Exception('NatGateway Subnet ' + events['SrcSubnetId'] + ' Network Acl Ingress Rules do not allow inbound traffic from destination: ' + events['DestinationIP'] + AWS_DOC)\n\n    def check_ingress_from_src(acls, src_ip, dst_port):\n        for acl in acls:\n            # check ipv4 acl rule only\n            if acl.get('CidrBlock'):\n                #Check IP\n                if src_ip in ip_network(acl['CidrBlock'], strict=False):\n                    #Check Port\n                    if ((acl.get('Protocol') == '-1') or (dst_port in range(acl['PortRange']['From'], acl['PortRange']['To'] +1))):\n                        #Check Action\n                        if acl['RuleAction'] == 'allow':\n                            return True\n                        else: raise Exception('NatGateway Subnet Network Acl Ingress Rules do not allow inbound traffic from source: ' + events['SourceIP'] + ' towards destination port ' + str(events['DestinationPort']) + AWS_DOC)\n        else:\n            raise Exception('NatGateway Subnet Network Acl Ingress Rules do not allow inbound traffic from source: ' + events['SourceIP'] + ' towards destination port ' + str(events['DestinationPort']) + AWS_DOC)\n\n    def check_egress_towards_src(acls, dst_ip):\n        for acl in acls:\n            # check ipv4 acl rule only\n            if acl.get('CidrBlock'):\n                #Check IP\n                if dst_ip in ip_network(acl['CidrBlock'], strict=False):\n                    #Check Port\n                    if ((acl.get('Protocol') == '-1') or (set(range(src_port_from,src_port_to)).issubset(range(acl['PortRange']['From'], acl['PortRange']['To'] +1)))):\n                        #Check Action\n                        if acl['RuleAction'] == 'allow':\n                            return True\n                        else: raise Exception('NatGateway Subnet Network Acl Egress Rules do not allow outbound traffic to source: ' + events['SourceIP'] + AWS_DOC)\n        else:\n            raise Exception('NatGateway Subnet Network Acl Egress Rules do not allow outbound traffic to source: ' + events['SourceIP'] + AWS_DOC)\n\n    check_egress_towards_dst(egress_acls, dst_ip, dst_port)\n    check_ingress_from_dst(ingress_acls, dst_ip)\n    \n    if src_subnet_id == nat_subnet_id:\n        return True\n    \n    check_ingress_from_src(ingress_acls, src_ip, dst_port)\n    check_egress_towards_src(egress_acls, src_ip)\n\n    return True\n",
        "InputPayload": {
          "NatNetworkAcls": "{{getNatSubnetAcls.NatNetworkAcls}}",
          "SourceIP": "{{SourceIP}}",
          "DestinationIP": "{{DestinationIP}}",
          "DestinationPort": "{{DestinationPort}}",
          "SrcSubnetId": "{{getSourceDetails.SrcSubnetId}}",
          "NatSubnetId": "{{natDestination.NatSubnetId}}",
          "SourcePortRange": "{{SourcePortRange}}"
        }
      },
      "isCritical": true,
      "timeoutSeconds": 30,
      "onFailure": "Continue",
      "isEnd": false,
      "nextStep": "getNatRouteDetails"
    },
    {
      "name": "getNatRouteDetails",
      "action": "aws:executeScript",
      "outputs": [
        {
          "Name": "NatRoutes",
          "Selector": "$.Payload.NatRoutes",
          "Type": "MapList"
        }
      ],
      "inputs": {
        "Runtime": "python3.8",
        "Handler": "get_nat_route_details",
        "Script": "def get_nat_route_details(events, context):\n    output = {}\n    import boto3\n    ec2_client = boto3.client('ec2')\n    routes = ec2_client.describe_route_tables(\n        Filters=[\n        {\n            'Name': 'association.subnet-id',\n            'Values': [\n                events['NatSubnetId']\n            ]\n        }\n    ]\n    )\n\n    if len(routes['RouteTables']) > 0:\n        routes = routes['RouteTables'][0]['Routes']\n    # if RouteTable is not returned, this indicates association of subnet with main route table\n    else:\n        try:\n            routes = ec2_client.describe_route_tables(\n                Filters=[\n                    {\n                        'Name': 'association.main',\n                        'Values': [\n                            'true'\n                        ]\n                    },\n                    {\n                        'Name': 'vpc-id',\n                        'Values': [\n                            events['NatVpcId']\n                        ]\n                    }                    \n                ]\n            )['RouteTables'][0]['Routes']\n        except Exception as e:\n            raise Exception('Could not find route table for NAT Gateway')\n    \n    output['NatRoutes'] = routes\n    return output\n",
        "InputPayload": {
          "NatSubnetId": "{{natDestination.NatSubnetId}}",
          "NatVpcId": "{{natDestination.NatVpcId}}"
        }
      },
      "isCritical": true,
      "timeoutSeconds": 30,
      "onFailure": "Continue",
      "isEnd": false,
      "nextStep": "getNatNextHop"
    },
    {
      "name": "getNatNextHop",
      "action": "aws:executeScript",
      "inputs": {
        "Runtime": "python3.8",
        "Handler": "get_nat_next_hop",
        "Script": "def get_nat_next_hop(events, context):\n    from ipaddress import ip_network,ip_address\n    src_subnet_id = events['SrcSubnetId']\n    nat_subnet_id = events['NatSubnetId']\n\n    AWS_DOC = '\\nNAT gateways - Working with NAT gateways - https://docs.aws.amazon.com/vpc/latest/userguide/vpc-nat-gateway.html#nat-gateway-working-with'\n\n    if src_subnet_id == nat_subnet_id:\n        raise Exception('NatGateway and Source cannot be placed in the same subnet, NatGateway should be in a public subnet' + AWS_DOC)\n    \n    routes = events['NatRoutes'] \n    destination = ip_address(events['DestinationIP'])        \n    most_specific = -1       \n\n    for route in routes:\n        if route.get('DestinationCidrBlock'):\n            mask = int(route['DestinationCidrBlock'].split('/')[1])\n            if not 'DestinationPrefixListId' in str(route) and destination in ip_network(route['DestinationCidrBlock'], strict=False) and mask > most_specific:\n                if route['State']  != 'blackhole':\n                    most_specific = mask\n                    next_hop = route\n    #0.0.0.0/0\n    if most_specific >= 0 and 'igw-' in str(next_hop):\n        return True\n    raise Exception('No Internet Gateway route found for destination: ' + events['DestinationIP'] + AWS_DOC)\n\n",
        "InputPayload": {
          "NatRoutes": "{{getNatRouteDetails.NatRoutes}}",
          "DestinationIP": "{{DestinationIP}}",
          "NatSubnetId": "{{natDestination.NatSubnetId}}",
          "SrcSubnetId": "{{getSourceDetails.SrcSubnetId}}"
        }
      },
      "isCritical": true,
      "timeoutSeconds": 30,
      "onFailure": "Continue",
      "isEnd": false,
      "nextStep": "igwDestination"
    },
    {
      "name": "peeringDestination",
      "action": "aws:executeAwsApi",
      "outputs": [
        {
          "Name": "VpcPeeringConnection",
          "Selector": "$.VpcPeeringConnections[0]",
          "Type": "StringMap"
        }
      ],
      "inputs": {
        "Service": "ec2",
        "Api": "DescribeVpcPeeringConnections",
        "Filters": [
          {
            "Name": "vpc-peering-connection-id",
            "Values": [
              "{{getNextHop.NextHop}}"
            ]
          }
        ]
      },
      "isCritical": true,
      "timeoutSeconds": 30,
      "onFailure": "Continue",
      "isEnd": false,
      "nextStep": "checkVpcPeeringConnection"
    },
    {
      "name": "checkVpcPeeringConnection",
      "action": "aws:executeScript",
      "inputs": {
        "Runtime": "python3.8",
        "Handler": "check_vpc_peering_connection",
        "Script": "def check_vpc_peering_connection(events, context):\n    vpc_peering_connection = events['VpcPeeringConnection']\n    dst_vpc = events['DestinationVpc']\n    AWS_DOC = 'https://docs.aws.amazon.com/vpc/latest/peering/working-with-vpc-peering.html'\n    if vpc_peering_connection['AccepterVpcInfo']['Region'] == vpc_peering_connection['RequesterVpcInfo']['Region']:\n        pass\n    else:\n        raise Exception('Troubleshooting Cross Region peering connection is not yet supported')\n    if dst_vpc != '':\n        if dst_vpc in str(vpc_peering_connection):\n            pass\n        else:\n            raise Exception('Kindly check the VPC peering route in route table at the source resource subnet, it does not match the expected destination VPC\\n' + AWS_DOC)\n\n    return True\n",
        "InputPayload": {
          "VpcPeeringConnection": "{{peeringDestination.VpcPeeringConnection}}",
          "DestinationVpc": "{{DestinationVpc}}"
        }
      },
      "isCritical": true,
      "timeoutSeconds": 30,
      "onFailure": "Abort",
      "isEnd": false,
      "nextStep": "getDestinationPeerDetails"
    },
    {
      "name": "getDestinationPeerDetails",
      "action": "aws:executeAwsApi",
      "outputs": [
        {
          "Name": "DstPeerSubnetId",
          "Selector": "$.NetworkInterfaces[0].SubnetId",
          "Type": "String"
        },
        {
          "Name": "DstPeerVpcId",
          "Selector": "$.NetworkInterfaces[0].VpcId",
          "Type": "String"
        }
      ],
      "inputs": {
        "Service": "ec2",
        "Api": "DescribeNetworkInterfaces",
        "Filters": [
          {
            "Name": "addresses.private-ip-address",
            "Values": [
              "{{DestinationIP}}"
            ]
          }
        ]
      },
      "isCritical": true,
      "timeoutSeconds": 30,
      "onFailure": "Continue",
      "isEnd": false,
      "nextStep": "getDstPeerRouteDetails"
    },
    {
      "name": "getDstPeerRouteDetails",
      "action": "aws:executeScript",
      "outputs": [
        {
          "Name": "Routes",
          "Selector": "$.Payload.PeerRoutes",
          "Type": "MapList"
        }
      ],
      "inputs": {
        "Runtime": "python3.8",
        "Handler": "get_dst_peer_route_details",
        "Script": "def get_dst_peer_route_details(events, context):\n    output = {}\n    import boto3\n    ec2_client = boto3.client('ec2')\n    routes = ec2_client.describe_route_tables(\n        Filters=[\n        {\n            'Name': 'association.subnet-id',\n            'Values': [\n                events['PeerSubnetId']\n            ]\n        }\n    ]\n    )\n\n    if len(routes['RouteTables']) > 0:\n        routes = routes['RouteTables'][0]['Routes']\n    # if RouteTable is not returned, this indicates association of subnet with main route table\n    else:\n        try:\n            routes = ec2_client.describe_route_tables(\n                Filters=[\n                    {\n                        'Name': 'association.main',\n                        'Values': [\n                            'true'\n                        ]\n                    },\n                    {\n                        'Name': 'vpc-id',\n                        'Values': [\n                            events['PeerVpcId']\n                        ]\n                    }                    \n                ]\n            )['RouteTables'][0]['Routes']\n        except Exception as e:\n            raise Exception('Could not find route table for VPC Peering Connection')\n    \n    output['PeerRoutes'] = routes\n    return output\n",
        "InputPayload": {
          "PeerSubnetId": "{{getDestinationPeerDetails.DstPeerSubnetId}}",
          "PeerVpcId": "{{getDestinationPeerDetails.DstPeerVpcId}}"
        }
      },
      "isCritical": true,
      "timeoutSeconds": 30,
      "onFailure": "Continue",
      "nextStep": "evalPeerRouteTable",
      "isEnd": false
    },
    {
      "name": "evalPeerRouteTable",
      "action": "aws:executeScript",
      "inputs": {
        "Runtime": "python3.8",
        "Handler": "eval_peer_route_table",
        "Script": "def eval_peer_route_table(events, context):\n    from ipaddress import ip_network,ip_address\n    routes = events['Routes'] \n    src_ip = ip_address(events['SourceIP']) \n    peering_id = events['PeeringId']       \n    most_specific = -1 \n    next_hop = {}\n\n    AWS_DOC = '\\nWorking with VPC peering connections - https://docs.aws.amazon.com/vpc/latest/peering/working-with-vpc-peering.html'\n    for route in routes:\n        if route.get('DestinationCidrBlock'):\n            mask = int(route['DestinationCidrBlock'].split('/')[1])\n            if not 'DestinationPrefixListId' in str(route) and src_ip in ip_network(route['DestinationCidrBlock'], strict=False) and mask > most_specific:\n                if route['State'] != 'blackhole':\n                    most_specific = mask\n                    next_hop = route\n    if next_hop.get('VpcPeeringConnectionId') == peering_id:\n        return True\n    else:\n        raise Exception('Destination Subnet route table does not contain a valid peering route for source: ' + events['SourceIP'] + AWS_DOC)\n",
        "InputPayload": {
          "Routes": "{{getDstPeerRouteDetails.Routes}}",
          "SourceIP": "{{SourceIP}}",
          "PeeringId": "{{getNextHop.NextHop}}"
        }
      },
      "isCritical": true,
      "timeoutSeconds": 30,
      "onFailure": "Continue",
      "nextStep": "localDestination",
      "isEnd": false
    },
    {
      "name": "hopTypeNotSupported",
      "action": "aws:executeScript",
      "inputs": {
        "Runtime": "python3.8",
        "Handler": "hop_type_not_supported",
        "Script": "def hop_type_not_supported(events, context):\n    nexthop = events['NextHop']\n    raise Exception('Automation detected next hop as ' + nexthop + '. Currently, This document supports troubleshooting destinations via local, InternetGateway, NatGateway & VPC Peering only. This document will now perform source side checks only.')\n",
        "InputPayload": {
          "NextHop": "{{getNextHop.NextHop}}"
        }
      },
      "isCritical": true,
      "timeoutSeconds": 30,
      "onFailure": "Continue",
      "nextStep": "getSrcSecurityGroupDetails",
      "isEnd": false
    }
  ]
}
