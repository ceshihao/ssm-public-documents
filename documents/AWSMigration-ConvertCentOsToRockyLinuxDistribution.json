{
  "schemaVersion": "2.2",
  "description": "This action will convert the operating system of instances running CentOS Linux to Rocky Linux distribution.",
  "mainSteps": [
    {
      "precondition": {
        "StringEquals": [
          "platformType",
          "Linux"
        ]
      },
      "action": "aws:runShellScript",
      "name": "InvokeLinuxScript",
      "inputs": {
        "timeoutSeconds": "3600",
        "runCommand": [
          "#!/bin/bash\nset -e\n\nif [ -f /etc/os-release ]; then\n    . /etc/os-release\n    OS_RELEASE=\"$ID${VERSION_ID:+.${VERSION_ID}}\"\nelif [ -f /etc/centos-release ]; then\n    OS_RELEASE=\"centos.$(awk '{print $3}' /etc/centos-release)\"\nelif [ -f /etc/redhat-release ]; then\n    OS_RELEASE=\"rhel.$(lsb_release -r | awk '{print $2}')\"\nfi\n\ncase \"$OS_RELEASE\" in\n    amzn.2|centos.7*|centos.8*|fedora.*|rhel.7*|rhel.8*|sles*)\n        command_path='/usr/bin/'\n        ;;\n    amzn.2018.03|centos.6*|debian.*|rhel.6*|ubuntu.16*|ubuntu.18*|ubuntu.20*)\n        command_path='/bin/'\n        ;;\n    *)\n        # Catch all without the full path for untested platforms\n        command_path=''\nesac\n\nExitWithFailureMessage() {\n    MESSAGE=\"$1\"\n    JSON=\"$2\"\n    if [[ \"$JSON\" == \"PRINT_JSON\" ]]; then\n        \"${command_path}echo\" \"{\\\"error\\\":\\\"$MESSAGE\\\"}\"\n    fi\n    WriteStandardError \"$MESSAGE\"\n    exit 1\n}\n\n# exit codes. 0-100 are reserved exit codes. 101-150 codes are for linux, 151-200 are for macos and 200 onwards codes are for windows.\nExitWithFailureMessageAndExitCode() {\n    MESSAGE=\"$1\"\n    EXITCODE=\"$2\"\n    JSON=\"$3\"\n    if [[ \"$JSON\" == \"PRINT_JSON\" ]]; then\n        \"${command_path}echo\" \"{\\\"error\\\":\\\"$MESSAGE\\\",\\\"exitCode\\\":\\\"$EXITCODE\\\"}\"\n    fi\n    WriteStandardError \"$MESSAGE\"\n    exit \"$EXITCODE\"\n}\n\nExitWithSuccessMessage() {\n    \"${command_path}echo\" \"$1\"\n    exit 0\n}\n\nWriteStandardError() {\n    MESSAGE=\"$1\"\n    (>&2 \"${command_path}echo\" \"$MESSAGE\")\n}\n\nTestPerformAction() {\n    if [[ \"$1\" != \"Yes\" ]]; then\n        ExitWithFailureMessage \"No action was taken because the PerformAction parameter is set to $1. To make the desired change, set this parameter to Yes.\"\n    fi\n}\n\n# migrate2rocky - Migrate another CentOS 8 distribution to RockyLinux 8.\n# By: Amazon Web Services, Inc.\n# Adapted from: https://github.com/rocky-linux/rocky-tools\n#\n# Adapted from centos2rocky.sh by label <label@rockylinux.org>\n#\n# The latest version of this script can be found at:\n# https://github.com/rocky-linux/rocky-tools\n#\n# Copyright (c) 2021 Rocky Enterprise Software Foundation\n#\n# Permission is hereby granted, free of charge, to any person obtaining a copy\n# of this software and associated documentation files (the \"Software\"), to deal\n# in the Software without restriction, including without limitation the rights\n# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n# copies of the Software, and to permit persons to whom the Software is\n# furnished to do so, subject to the following conditions:\n#\n# The above copyright notice and this permission notice (including the next\n# paragraph) shall be included in all copies or substantial portions of the\n# Software.\n#\n# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n# SOFTWARE.\n#\n\n## Using this script means you accept all risks of system instability.\n\n# These checks need to be right at the top because we start with bash-isms right\n# away in this script.\n\nif [ -n \"$POSIXLY_CORRECT\" ] || [ -z \"$BASH_VERSION\" ]; then\n    printf '%s\\n' \"bash >= 4.2 is required for this script.\" >&2\n    exit 1\nfi\n\n# We need bash version >= 4.2 for associative arrays and other features.\nif (( BASH_VERSINFO[0]*100 + BASH_VERSINFO[1] < 402 )); then\n    printf '%s\\n' \"bash >= 4.2 is required for this script.\" >&2\n    exit 1\nfi\n\nshopt -s extglob\n\n# Make sure we're root.\nif (( EUID != 0 )); then\n    printf '%s\\n' \\\n        \"You must run this script as root.  Either use sudo or 'su -c ${0}'\" >&2\n    exit 1\nfi\n\n\n# Path to logfile\nlogfile=/var/log/migrate2rocky.log\n\n# Rotate old logs\nnumlogs=5\nif [[ -e $logfile ]]; then\n    # Here we use mv before bin_check, so simply check the exit status to see if\n    # it worked.\n    if ! mv -f \"$logfile\" \"$logfile.0\"; then\n        printf '%s\\n' \"Unable to rotate logfiles, continuing without rotation.\" >&2\n    else\n        for ((i=numlogs;i>0;i--)); do\n            if [[ -e \"$logfile.$((i-1))\" ]]; then\n                if ! mv -f \"$logfile.$((i-1))\" \"$logfile.$i\"; then\n                    printf '%s\\n' \\\n\"Unable to rotate logfiles, continuing without rotation.\"\n                    break\n                fi\n            fi\n        done\n    fi\nfi\n\n# Send all output to the logfile as well as stdout.\n# After the following we get:\n# Output to 1 goes to stdout and the logfile.\n# Output to 2 goes to stderr and the logfile.\n# Output to 3 just goes to stdout.\n# Output to 4 just goes to stderr.\n# Output to 5 just goes to the logfile.\n\n# shellcheck disable=SC2094\nexec \\\n    3>&1 \\\n    4>&2 \\\n    5>> \"$logfile\" \\\n    > >(tee -a \"$logfile\") \\\n    2> >(tee -a \"$logfile\" >&2)\n\n# Single arg just gets returned verbatim, multi arg gets formatted via printf.\n# First arg is the name of a variable to store the results.\nmsg_format () {\n    local _var\n    _var=\"$1\"\n    shift\n    if (( $# > 1 )); then\n        # shellcheck disable=SC2059\n        printf -v \"$_var\" \"$@\"\n    else\n        printf -v \"$_var\" \"%s\" \"$1\"\n    fi\n}\n\n# Send an info message to the log file and stdout (with color)\ninfomsg () {\n    local msg\n    msg_format msg \"$@\"\n    printf '%s' \"$msg\" >&5\n    printf '%s' \"$msg\" >&3\n}\n\n# Send an error message to the log file and stderr (with color)\nerrmsg () {\n    local msg\n    msg_format msg \"$@\"\n    printf '%s' \"$msg\" >&5\n    printf '%s' \"$msg\" >&4\n}\n\ninfomsg 'migrate2rocky - Begin logging at %(%c)T.\\n\\n' -1\n\nexport LC_ALL=C.UTF-8\nunset LANGUAGE\nshopt -s nullglob\n\nSUPPORTED_MAJOR=\"8\"\nSUPPORTED_ID=\"centos\"\nARCH=$(arch)\n\ngpg_key_url=\"https://dl.rockylinux.org/pub/rocky/RPM-GPG-KEY-rockyofficial\"\ngpg_key_sha512=\"88fe66cf0a68648c2371120d56eb509835266d9efdf7c8b9ac8fc101bdf1f0e0197030d3ea65f4b5be89dc9d1ef08581adb068815c88d7b1dc40aa1c32990f6a\"\n\nsm_ca_dir=/etc/rhsm/ca\nunset tmp_sm_ca_dir\n\n# all repos must be signed with the same key given in $gpg_key_url\ndeclare -A repo_urls\nrepo_urls=(\n    [rockybaseos]=\"https://dl.rockylinux.org/pub/rocky/${SUPPORTED_MAJOR}/BaseOS/$ARCH/os/\"\n    [rockyappstream]=\"https://dl.rockylinux.org/pub/rocky/${SUPPORTED_MAJOR}/AppStream/$ARCH/os/\"\n)\n\n# These are additional packages that should always be installed.\n# (currently blank, but we add to it for an EFI boot system).\nalways_install=()\n\n# The repos package for CentOS stream requires special handling.\ndeclare -g -A stream_repos_pkgs\nstream_repos_pkgs=(\n    [rocky-repos]=centos-stream-repos\n    [epel-release]=epel-next-release\n)\n\n# Map for package name suffix for shim/grub2-efi\n# on x86_64: grub2-efi-x64, shim-x64\n# on aarch64: grub2-efi-aa64, shim-aa64\ndeclare -A cpu_arch_suffix_map=(\n    [x86_64]=x64\n    [aarch64]=aa64\n)\n\n# Prefix to add to CentOS stream repo names when renaming them.\nstream_prefix=stream-\n\n# Always replace these stream packages with their Rocky Linux equivalents.\nstream_always_replace=(\n    fwupdate\\*\n    grub2-\\*\n    shim-\\*\n    kernel\n    kernel-\\*\n)\n\n# Directory to required space in MiB\ndeclare -A dir_space_map\ndir_space_map=(\n    [/usr]=250\n    [/var]=1536\n    [/boot]=50\n)\n\nunset CDPATH\n\nexit_message() {\n  errmsg $'\\n'\"$1\"$'\\n\\n'\n  final_message\n  exit 1\n}\n\nexit_message_skipped() {\n  infomsg $'\\n'\"$1\"$'\\n\\n'\n  exit 0\n}\n\nfinal_message() {\n    errmsg '%s ' \\\n        \"An error occurred while we were attempting to convert your system to\" \\\n        \"Rocky Linux. Your system may be unstable. Script will now exit to\" \\\n        \"prevent possible damage.\"$'\\n\\n'\n    logmessage\n}\n\nlogmessage(){\n    printf '%s\\n' \\\n        \"A log of this installation can be found at $logfile\" >&3\n}\n\n# This just grabs a field from os-release and returns it.\nos-release () (\n    # shellcheck source=/dev/null\n    . /etc/os-release\n    if ! [[ ${!1} ]]; then\n        return 1\n    fi\n    printf '%s\\n' \"${!1}\"\n)\n\n# Check the version of a package against a supplied version number.  Note that\n# this uses sort -V to compare the versions which isn't perfect for rpm package\n# versions, but to do a proper comparison we would need to use rpmdev-vercmp in\n# the rpmdevtools package which we don't want to force-install.  sort -V should\n# be adequate for our needs here.\npkg_ver() (\n    ver=$(rpm -q --qf '%{VERSION}\\n' \"$1\") || return 2\n    if [[ $(sort -V <<<\"$ver\"$'\\n'\"$2\" | head -1) != \"$2\" ]]; then\n        return 1\n    fi\n    return 0\n)\n\nplatform_check () {\n    # Check the platform.\n    if [ $(os-release ID) != \"$SUPPORTED_ID\" ] || [ $(os-release PLATFORM_ID) != \"platform:el$SUPPORTED_MAJOR\" ]; then\n          # shellcheck disable=SC2026\n          exit_message_skipped 'This script must be run on a CentOS8 distribution. Migration from other distributions is not supported.'\n    fi\n}\n\n# Set up a temporary directory.\npre_setup () {\n    if ! tmp_dir=$(mktemp -d) || [[ ! -d \"$tmp_dir\" ]]; then\n        exit_message \"Error creating temp dir\"\n    fi\n    # failglob makes pathname expansion fail if empty, dotglob adds files\n    # starting with . to pathname expansion\n    if ( shopt -s failglob dotglob; : \"$tmp_dir\"/* ) 2>/dev/null ; then\n        exit_message \"Temp dir not empty\"\n    fi\n}\n\n# Remove dnf duplicates\nremove_dnf_duplicates () {\n  dnf -y check --duplicates || dnf -y remove --duplicates\n}\n\n# Cleanup function gets rid of the temporary directory.\nexit_clean () {\n    if [[ -d \"$tmp_dir\" ]]; then\n        rm -rf \"$tmp_dir\"\n    fi\n    if [[ -f \"$container_macros\" ]]; then\n        rm -f \"$container_macros\"\n    fi\n}\n\npre_check () {\n    if [[ -e /etc/rhsm/ca/katello-server-ca.pem ]]; then\n# shellcheck disable=SC2026\n        exit_message \\\n'Migration from Katello-modified systems is not supported by migrate2rocky. '\\\n'See the README file for details.'\n    fi\n    if [[ -e /etc/salt/minion.d/susemanager.conf ]]; then\n# shellcheck disable=SC2026\n        exit_message \\\n'Migration from Uyuni/SUSE Manager-modified systems is not supported by '\\\n'migrate2rocky. See the README file for details.'\n    fi\n\n    dnf -y check || exit_message \\\n'Errors found in dnf/rpm database.  Please correct before running '\\\n'migrate2rocky.'\n\n    # Get available space to compare to requirements.\n    # If the stock kernel is not installed we don't require space in /boot\n    if ! rpm -q --quiet kernel; then\n\tdir_space_map[/boot]=0\n    fi\n    local -a errs dirs=(\"${!dir_space_map[@]}\")\n    local dir mount avail i=0\n    local -A mount_avail_map mount_space_map\n    while read -r mount avail; do\n\tif [[ $mount == 'Filesystem' ]]; then\n\t    continue\n\tfi\n\n\tdir=${dirs[$((i++))]}\n\n\tmount_avail_map[$mount]=${avail%M}\n\t(( mount_space_map[$mount]+=dir_space_map[$dir] ))\n    done < <(df -BM --output=source,avail \"${dirs[@]}\")\n\n    for mount in \"${!mount_space_map[@]}\"; do\n\t(( avail = mount_avail_map[$mount]*95/100 ))\n\tif (( avail < mount_space_map[$mount] )); then\n\t    errs+=(\"Not enough space in $mount, ${mount_space_map[$mount]}M required, ${avail}M available.\")\n\tfi\n    done\n\n    if (( ${#errs[@]} )); then\n\tIFS=$'\\n'\n\texit_message \"${errs[*]}\"\n    fi\n}\n\n# All of the binaries used by this script are available in a EL8 minimal install\n# and are in /bin, so we should not encounter a system where the script doesn't\n# work unless it's severely broken.  This is just a simple check that will cause\n# the script to bail if any expected system utilities are missing.\nbin_check() {\n    local -a missing bins\n    bins=(\n        rpm dnf awk column tee tput mkdir cat arch sort uniq rmdir df\n        rm head curl sha512sum mktemp systemd-detect-virt sed grep\n    )\n    if [[ $update_efi ]]; then\n        bins+=(findmnt grub2-mkconfig efibootmgr mokutil lsblk)\n    fi\n    for bin in \"${bins[@]}\"; do\n        if ! type \"$bin\" >/dev/null 2>&1; then\n            missing+=(\"$bin\")\n        fi\n    done\n\n    local -A pkgs\n    pkgs=(\n        [dnf]=4.2\n        [dnf-plugins-core]=0\n    )\n\n    for pkg in \"${!pkgs[@]}\"; do\n        ver=${pkgs[$pkg]}\n        if ! pkg_ver \"$pkg\" \"$ver\"; then\n            # shellcheck disable=SC2140\n            exit_message \\\n\"$pkg >= $ver is required for this script.  Please run \"\\\n\"\\\"dnf install $pkg; dnf update\\\" first.\"\n        fi\n    done;\n\n    if (( ${#missing[@]} )); then\n# shellcheck disable=SC2140\n        exit_message \\\n\"Commands not found: ${missing[*]}.  Possible bad PATH setting or corrupt \"\\\n\"installation.\"\n    fi\n}\n\n# This function will overwrite the repoquery_results associative array with the\n# info for the resulting package.  Note that we explicitly disable the epel repo\n# as a special-case below to avoid having the extras repository map to epel.\nrepoquery () {\n    local name val prev result\n    result=$(safednf -y -q \"${dist_repourl_swaps[@]}\" \\\n\t--setopt=epel.excludepkgs=epel-release repoquery -i \"$1\") ||\n    \texit_message \"Failed to fetch info for package $1.\"\n    if ! [[ $result ]]; then\n        # We didn't match this package, the repo could be disabled.\n        return 1\n    fi\n    declare -gA repoquery_results=()\n    while IFS=\" :\" read -r name val; do\n        if [[ -z $name ]]; then\n            repoquery_results[$prev]+=\" $val\"\n        else\n            prev=$name\n            repoquery_results[$name]=$val\n        fi\n    done <<<\"$result\"\n}\n\n# This function will overwrite the repoinfo_results associative array with the\n# info for the resulting repository.\n_repoinfo () {\n    local name val result\n    result=$(\n\tsafednf -y -q --repo=\"$1\" \"${dist_repourl_swaps[@]}\" repoinfo \"$1\"\n    ) || return\n    if [[ $result == 'Total packages: 0' ]]; then\n        # We didn't match this repo.\n        return 1\n    fi\n    declare -gA repoinfo_results=()\n    while IFS=\" :\" read -r name val; do\n        if [[ ! ( $name || $val) ]]; then\n            continue\n        fi\n        if [[ -z $name ]]; then\n            repoinfo_results[$prev]+=\" $val\"\n        else\n            prev=$name\n            repoinfo_results[$name]=$val\n        fi\n    done <<<\"$result\"\n\n    # Set the enabled state\n    if [[ ! ${enabled_repo_check[$1]} ]]; then\n\trepoinfo_results[Repo-status]=disabled\n    fi\n\n    # dnf repoinfo doesn't return the gpgkey, but we need that so we have to get\n    # it from the repo file itself.\n    # \"end_of_file\" is a hack here.  Since it is not a valid dnf setting we know\n    # it won't appear in a .repo file on a line by itself, so it's safe to\n    # search for the string to make the awk parser look all the way to the end\n    # of the file.\n    # shellcheck disable=SC2154\n    repoinfo_results[Repo-gpgkey]=$(\n        awk '\n            $0==\"['\"${repoinfo_results[Repo-id]}\"']\",$0==\"end_of_file\" {\n                if (l++ < 1) {next}\n                else if (/^\\[.*\\]$/) {nextfile}\n                else if (sub(/^gpgkey\\s*=\\s*file:\\/\\//,\"\")) {print; nextfile}\n                else {next}\n            }\n        ' < \"${repoinfo_results[Repo-filename]}\"\n    )\n\n    # Add an indicator of whether this is a subscription-manager managed\n    # repository.\n    # shellcheck disable=SC2154\n    repoinfo_results[Repo-managed]=$(\n        awk '\n            BEGIN {FS=\"[)(]\"}\n            /^# Managed by \\(.*\\) subscription-manager$/ {print $2}\n        ' < \"${repoinfo_results[Repo-filename]}\"\n    )\n}\n\n# We now store the repoinfo results in a cache.\ndeclare -g -A repoinfo_results_cache=()\nrepoinfo () {\n    local k\n    if [[ ! ${repoinfo_results_cache[$1]} ]]; then\n\t_repoinfo \"$@\" || return\n\trepoinfo_results_cache[$1]=1\n\tfor k in \"${!repoinfo_results[@]}\"; do\n\t    repoinfo_results_cache[$1:$k]=${repoinfo_results[$k]}\n\tdone\n    else\n\trepoinfo_results=()\n\tfor k in \"${!repoinfo_results_cache[@]}\"; do\n\t    local repo=${k%%:*} key=${k#*:}\n\t    if [[ $repo != \"$1\" ]]; then\n\t\tcontinue\n\t    fi\n\n\t    repoinfo_results[$key]=${repoinfo_results_cache[$k]}\n\tdone\n    fi\n}\n\nprovides_pkg () (\n    if [[ ! $1 ]]; then\n        return 0\n    fi\n\n    set -o pipefail\n    provides=$(\n\tsafednf -y -q \"${dist_repourl_swaps[@]}\" provides \"$1\" |\n\tawk '{print $1; nextfile}'\n    ) ||\n        return 1\n    set +o pipefail\n    pkg=$(rpm -q --queryformat '%{NAME}\\n' \"$provides\") ||\n            pkg=$(\n\t\tsafednf -y -q \"${dist_repourl_swaps[@]}\" repoquery \\\n\t\t    --queryformat '%{NAME}\\n' \"$provides\"\n\t    ) || exit_message \"Can't get package name for $provides.\"\n    printf '%s\\n' \"$pkg\"\n)\n\n# If you pass an empty arg as one of the package specs to rpm it will match\n# every package on the system.  This function simply strips out any empty args\n# and passes the rest to rpm to avoid this side-effect.\nsaferpm () (\n    args=()\n    for a in \"$@\"; do\n        if [[ $a ]]; then\n            args+=(\"$a\")\n        fi\n    done\n    rpm \"${args[@]}\"\n)\n\n# And a similar function for dnf\nsafednf () (\n    args=()\n    for a in \"$@\"; do\n        if [[ $a ]]; then\n            args+=(\"$a\")\n        fi\n    done\n    dnf \"${args[@]}\"\n)\n\n#\n# Three ways we check the repourl.  If dnf repoinfo fails then we assume the URL\n# is bad.  A missing URL is also considered bad.  Lastly we check to see if we\n# can fetch the repomd.xml file from the repository, and if not then the repourl\n# is considered bad.  In any of these cases we'll end up replacing the repourl\n# with a good one from our mirror of CentOS vault.\n#\ncheck_repourl () {\n    repoinfo \"$1\" || return\n    if [[ ! ${repoinfo_results[Repo-baseurl]} ]]; then\n\treturn 1\n    fi\n\n    local -a urls;\n    IFS=, read -r -a urls <<<\"${repoinfo_results[Repo-baseurl]}\"\n    local u\n    for u in \"${urls[@]##*( )}\"; do\n\tcurl -sfLI \"${u%% *}repodata/repomd.xml\" > /dev/null && return\n    done\n    return \"$(( $? ? $? : 1 ))\"\n}\n\ncollect_system_info () {\n    # Dump the DNF cache first so we start with a clean slate.\n    infomsg $'\\nRemoving dnf cache\\n'\n    rm -rf /var/cache/{yum,dnf}\n    # Check the efi mount first, so we can bail before wasting time on all these\n    # other checks if it's not there.\n    if [[ $update_efi ]]; then\n        local efi_mount kname\n        declare -g -a efi_disk efi_partition\n        efi_mount=$(findmnt --mountpoint /boot/efi --output SOURCE \\\n            --noheadings) ||\n            exit_message \"Can't find EFI mount.  No EFI  boot detected.\"\n        kname=$(lsblk -dno kname \"$efi_mount\")\n        efi_disk=(\"$(lsblk -dno pkname \"/dev/$kname\")\")\n\n        if [[ ${efi_disk[0]} ]]; then\n\t    efi_partition=(\"$(<\"/sys/block/${efi_disk[0]}/$kname/partition\")\")\n        else\n            # This is likely an md-raid or other type of virtual disk, we need\n            # to dig a little deeper to find the actual physical disks and\n            # partitions.\n            kname=$(lsblk -dno kname \"$efi_mount\")\n            cd \"/sys/block/$kname/slaves\" || exit_message \\\n\"Unable to gather EFI data: Can't cd to /sys/block/$kname/slaves.\"\n            if ! (shopt -s failglob; : ./*) 2>/dev/null; then\n                exit_message \\\n\"Unable to gather EFI data: No slaves found in /sys/block/$kname/slaves.\"\n            fi\n            efi_disk=()\n            for d in *; do\n                efi_disk+=(\"$(lsblk -dno pkname \"/dev/$d\")\")\n                efi_partition+=(\"$(<\"$d/partition\")\")\n                if [[ ! ${efi_disk[-1]} || ! ${efi_partition[-1]} ]]; then\n                    exit_message \\\n\"Unable to gather EFI data: Can't find disk name or partition number for $d.\"\n                fi\n            done\n            cd -\n        fi\n\n        # We need to make sure that these packages are always installed in an\n        # EFI system.\n        always_install+=(\n            \"shim-${cpu_arch_suffix_map[$ARCH]}\"\n            \"grub2-efi-${cpu_arch_suffix_map[$ARCH]}\"\n        )\n    fi\n\n    # Don't enable these module streams, even if they are enabled in the source\n    # distro.\n    declare -g -a module_excludes\n    module_excludes=(\n        libselinux-python:2.8\n    )\n\n    # Some OracleLinux modules have stream names of ol8 instead of rhel8 and ol\n    # instead of rhel.  This is a map that does a glob match and replacement.\n    local -A module_glob_map\n    module_glob_map=(\n        ['%:ol8']=:rhel8\n        ['%:ol']=:rhel\n    );\n\n    # We need to map rockylinux repository names to the equivalent repositories\n    # in the source distro.  To do that we look for known packages in each\n    # repository and see what repo they came from.  We need to use repoquery for\n    # this which requires downloading the package, so we pick relatively small\n    # packages for this.\n    declare -g -A repo_map pkg_repo_map\n    declare -g -a managed_repos\n    pkg_repo_map=(\n        [baseos]=rootfiles.noarch\n        [appstream]=apr-util-ldap.$ARCH\n        [ha]=pacemaker-doc.noarch\n        [powertools]=libaec-devel.$ARCH\n        [extras]=epel-release.noarch\n        [devel]=quota-devel.$ARCH\n    )\n\n    dist_id=$(os-release ID)\n    # We need a different dist ID for CentOS Linux vs CentOS Stream\n    if [[ $dist_id == centos ]] && rpm --quiet -q centos-stream-release; then\n\tdist_id+=-stream\n    fi\n\n    PRETTY_NAME=$(os-release PRETTY_NAME)\n    infomsg '%s' \\\n        \"Preparing to migrate $PRETTY_NAME to Rocky Linux 8.\"$'\\n\\n'\n\n    # Check to see if we need to change the repourl on any system repositories\n    # (CentOS 8)\n    local -A dist_repourl_map\n    dist_repourl_map=(\n\t[centos:baseos]=https://dl.rockylinux.org/vault/centos/8.5.2111/BaseOS/$ARCH/os/\n\t[centos:appstream]=https://dl.rockylinux.org/vault/centos/8.5.2111/AppStream/$ARCH/os/\n\t[centos:ha]=https://dl.rockylinux.org/vault/centos/8.5.2111/HighAvailability/$ARCH/os/\n\t[centos:powertools]=https://dl.rockylinux.org/vault/centos/8.5.2111/PowerTools/$ARCH/os/\n\t[centos:extras]=https://dl.rockylinux.org/vault/centos/8.5.2111/extras/$ARCH/os/\n\t[centos:devel]=https://dl.rockylinux.org/vault/centos/8.5.2111/Devel/$ARCH/os/\n    )\n\n    # In case migration is attempted from very old CentOS (before the repository\n    # names were lowercased)\n    for name in BaseOS AppStream PowerTools Devel; do\n\tdist_repourl_map[\"centos:$name\"]=${dist_repourl_map[\"centos:${name,,}\"]}\n    done\n\n    # HighAvailability is different again\n    dist_repourl_map[centos:HighAvailability]=${dist_repourl_map[centos:ha]}\n\n    # We need a list of enabled repositories\n    local -a enabled_repos=()\n    declare -g -A enabled_repo_check=()\n    declare -g -a dist_repourl_swaps=()\n    readarray -s 1 -t enabled_repos < <(dnf -q -y repolist --enabled)\n    for r in \"${enabled_repos[@]}\"; do\n\tenabled_repo_check[${r%% *}]=1\n    done\n\n\n    # ...and finally set a number of dnf options to replace the baseurl of these\n    # repos\n    local k\n    for k in \"${!dist_repourl_map[@]}\"; do\n\tlocal d=${k%%:*} r=${k#*:}\n\tif [[ $d != \"$dist_id\" || ! ${enabled_repo_check[$r]} ]] ||\n\t    check_repourl \"$r\"; then\n\t    continue\n\tfi\n\n\tdist_repourl_swaps+=(\n\t    \"--setopt=$r.mirrorlist=\"\n\t    \"--setopt=$r.metalink=\"\n\t    \"--setopt=$r.baseurl=\"\n\t    \"--setopt=$r.baseurl=${dist_repourl_map[$k]}\"\n\t)\n\n\tinfomsg 'Baseurl for %s is invalid, setting to %s.\\n' \\\n\t    \"$r\" \"${dist_repourl_map[$k]}\"\n    done\n\n    infomsg '%s' \"Determining repository names for $PRETTY_NAME\"\n\n    for r in \"${!pkg_repo_map[@]}\"; do\n        printf '.'\n        p=${pkg_repo_map[$r]}\n        repoquery \"$p\" || continue\n        repo_map[$r]=${repoquery_results[Repository]}\n    done\n\n    printf '%s\\n' '' '' \\\n\"Found the following repositories which map from $PRETTY_NAME to Rocky Linux 8:\"\n    column -t -s $'\\t' -N \"$PRETTY_NAME,Rocky Linux 8\" < <(\n        for r in \"${!repo_map[@]}\"; do\n            printf '%s\\t%s\\n' \"${repo_map[$r]}\" \"$r\"\n        done\n    )\n\n    infomsg $'\\n'\"Getting system package names for $PRETTY_NAME\"\n\n    # We don't know what the names of these packages are, we have to discover\n    # them via various means. The most common means is to look for either a\n    # distro-agnostic provides or a filename.  In a couple of cases we need to\n    # jump through hoops to get a filename that is provided specifically by the\n    # source distro.\n    # Get info for each repository to determine which ones are subscription\n    # managed.\n    # system-release here is a bit of a hack, but it ensures that the\n    # rocky-repos package will get installed.\n    for r in \"${!repo_map[@]}\"; do\n        repoinfo \"${repo_map[$r]}\" ||\n\t    exit_message \"Failed to fetch info for repository ${repo_map[$r]}.\"\n\n        if [[ $r == \"baseos\" ]]; then\n            local baseos_filename=system-release\n            if [[ ! ${repoinfo_results[Repo-managed]} ]]; then\n                baseos_filename=\"${repoinfo_results[Repo-filename]}\"\n            fi\n            local baseos_gpgkey=\"${repoinfo_results[Repo-gpgkey]}\"\n        fi\n        if [[ ${repoinfo_results[Repo-managed]} ]]; then\n            managed_repos+=(\"${repo_map[$r]}\")\n        fi\n    done\n\n    # First get info for the baseos repo\n    repoinfo \"${repo_map[baseos]}\" ||\n        exit_message \"Failed to fetch info for repository ${repo_map[baseos]}.\"\n\n    declare -g -A pkg_map provides_pkg_map\n    declare -g -a addl_provide_removes addl_pkg_removes\n    provides_pkg_map=(\n        [rocky-backgrounds]=system-backgrounds\n        [rocky-indexhtml]=redhat-indexhtml\n        [rocky-repos]=\"$baseos_filename\"\n        [rocky-logos]=system-logos\n        [rocky-logos-httpd]=system-logos-httpd\n        [rocky-logos-ipa]=system-logos-ipa\n        [rocky-gpg-keys]=\"$baseos_gpgkey\"\n        [rocky-release]=system-release\n    )\n    addl_provide_removes=(\n        redhat-release\n        redhat-release-eula\n    )\n\n    # Check to make sure that we don't already have a full or partial\n    # RockyLinux install.\n    if [[ $(rpm -qa \"${!provides_pkg_map[@]}\") ]]; then\n        exit_message \\\n$'Found a full or partial RockyLinux install already in place.  Aborting\\n'\n$'because continuing with the migration could cause further damage to system.'\n    fi\n\n    for pkg in \"${!provides_pkg_map[@]}\"; do\n        printf '.'\n        prov=${provides_pkg_map[$pkg]}\n        pkg_map[$pkg]=$(provides_pkg \"$prov\") ||\n            exit_message \"Can't get package that provides $prov.\"\n    done\n    for prov in \"${addl_provide_removes[@]}\"; do\n        printf '.'\n        local pkg;\n        pkg=$(provides_pkg \"$prov\") || continue\n        addl_pkg_removes+=(\"$pkg\")\n    done\n\n# shellcheck disable=SC2140\n    printf '%s\\n' '' '' \\\n\"Found the following system packages which map from $PRETTY_NAME to Rocky \"\\\n\"Linux 8:\"\n    column -t -s $'\\t' -N \"$PRETTY_NAME,Rocky Linux 8\" < <(\n        for p in \"${!pkg_map[@]}\"; do\n            printf '%s\\t%s\\n' \"${pkg_map[$p]}\" \"$p\"\n        done\n    )\n\n    infomsg $'\\n'\"Getting list of installed system packages.\"$'\\n'\n\n    readarray -t installed_packages < <(\n        saferpm -qa --queryformat=\"%{NAME}\\n\" \"${pkg_map[@]}\"\n    )\n    declare -g -A installed_pkg_check installed_pkg_map\n    for p in \"${installed_packages[@]}\"; do\n        installed_pkg_check[$p]=1\n    done\n    for p in \"${!pkg_map[@]}\"; do\n        if [[ ${pkg_map[$p]} && ${installed_pkg_check[${pkg_map[$p]}]} ]]; then\n            installed_pkg_map[$p]=${pkg_map[$p]}\n         fi\n    done;\n\n    # Special Handling for CentOS Stream Repos\n    installed_sys_stream_repos_pkgs=()\n    installed_stream_repos_pkgs=()\n    for p in \"${!stream_repos_pkgs[@]}\"; do\n        if [[ ${installed_pkg_map[$p]} &&\n              ${installed_pkg_map[$p]} == \"${stream_repos_pkgs[$p]}\" ]]\n        then\n            # System package that needs to be swapped / disabled\n            installed_pkg_map[$p]=\n            installed_sys_stream_repos_pkgs+=( \"${stream_repos_pkgs[$p]}\" )\n        elif rpm --quiet -q \"${stream_repos_pkgs[$p]}\"; then\n            # Non-system package, repos just need to be disabled.\n            installed_stream_repos_pkgs+=( \"${stream_repos_pkgs[$p]}\" )\n        fi\n    done\n\n# shellcheck disable=SC2140\n    printf '%s\\n' '' \\\n\"We will replace the following $PRETTY_NAME packages with their Rocky Linux 8 \"\\\n\"equivalents\"\n    column -t -s $'\\t' -N \"Packages to be Removed,Packages to be Installed\" < <(\n        for p in \"${!installed_pkg_map[@]}\"; do\n            printf '%s\\t%s\\n' \"${installed_pkg_map[$p]}\" \"$p\"\n        done\n    )\n\n    if (( ${#installed_sys_stream_repos_pkgs[@]} )); then\n# shellcheck disable=SC2026\n        printf '%s\\n' '' \\\n'Also to aid the transition from CentOS Stream the following packages will be '\\\n'removed from the rpm database but the included repos will be renamed and '\\\n'retained but disabled:' \\\n            \"${installed_sys_stream_repos_pkgs[@]}\"\n    fi\n\n    if (( ${#installed_stream_repos_pkgs[@]} )); then\n# shellcheck disable=SC2026\n        printf '%s\\n' '' \\\n'Also to aid the transition from CentOS Stream the repos included in the '\\\n'following packages will be renamed and retained but disabled:' \\\n            \"${installed_stream_repos_pkgs[@]}\"\n    fi\n\n    if (( ${#addl_pkg_removes[@]} )); then\n        printf '%s\\n' '' \\\n\"In addition to the above the following system packages will be removed:\" \\\n            \"${addl_pkg_removes[@]}\"\n    fi\n\n    # Release packages that are part of SIG's should be listed below when they\n    # are available.\n    # UPDATE: We may or may not do something with SIG's here, it could just be\n    # left as a separate exercise to swap out the sig repos.\n    #sigs_to_swap=()\n\n    infomsg '%s' $'\\n' \\\n        $'Getting a list of enabled modules for the system repositories.\\n'\n\n    # Get a list of system enabled modules.\n    readarray -t enabled_modules < <(\n        set -e -o pipefail\n        safednf -y -q \"${repo_map[@]/#/--repo=}\" \"${dist_repourl_swaps[@]}\" \\\n\t    module list --enabled |\n        awk '\n            $1 == \"@modulefailsafe\", /^$/ {next}\n            $1 == \"Name\", /^$/ {if ($1!=\"Name\" && !/^$/) print $1\":\"$2}\n            ' | sort -u\n        set +e +o pipefail\n    )\n\n    # Map the known module name differences.\n    disable_modules=()\n    local i gl repl mod\n    for i in \"${!enabled_modules[@]}\"; do\n        mod=${enabled_modules[$i]}\n        for gl in \"${!module_glob_map[@]}\"; do\n            repl=${module_glob_map[$gl]}\n            mod=${mod/$gl/$repl}\n        done\n        if [[ $mod != \"${enabled_modules[$i]}\" ]]; then\n            disable_modules+=(\"${enabled_modules[$i]}\")\n            enabled_modules[$i]=$mod\n        fi\n    done\n\n    # Remove entries matching any excluded modules.\n    if (( ${#module_excludes[@]} )); then\n        printf '%s\\n' '' \"Excluding modules:\" \"${module_excludes[@]}\"\n        local -A module_check='()'\n        local -a tmparr='()'\n        for m in \"${module_excludes[@]}\"; do\n            module_check[$m]=1\n        done\n        for m in \"${enabled_modules[@]}\"; do\n            if [[ ! ${module_check[$m]} ]]; then\n                tmparr+=(\"$m\")\n            fi\n        done\n        enabled_modules=(\"${tmparr[@]}\")\n    fi\n\n    printf '%s\\n' '' \"Found the following modules to re-enable at completion:\" \\\n        \"${enabled_modules[@]}\" ''\n\n    if (( ${#managed_repos[@]} )); then\n# shellcheck disable=SC2026\n        printf '%s\\n' '' \\\n'In addition, since this system uses subscription-manager the following '\\\n'managed repos will be disabled:' \\\n            \"${managed_repos[@]}\"\n    fi\n}\n\nconvert_info_dir=/root/convert\nunset convert_to_rocky reinstall_all_rpms verify_all_rpms update_efi \\\n    container_macros\n\nusage() {\n  printf '%s\\n' \\\n      \"Usage: ${0##*/} [OPTIONS]\" \\\n      '' \\\n      'Options:' \\\n      '-h Display this help' \\\n      '-r Convert to rocky' \\\n      '-V Verify switch' \\\n      '   !! USE WITH CAUTION !!'\n  exit 1\n} >&2\n\ngenerate_rpm_info() {\n    mkdir -p \"$convert_info_dir\"\n    infomsg  \"Creating a list of RPMs installed: $1\"$'\\n'\n# shellcheck disable=SC2140\n    rpm -qa --qf \\\n\"%{NAME}|%{VERSION}|%{RELEASE}|%{INSTALLTIME}|%{VENDOR}|%{BUILDTIME}|\"\\\n\"%{BUILDHOST}|%{SOURCERPM}|%{LICENSE}|%{PACKAGER}\\n\" |\n        sort > \"${convert_info_dir}/$HOSTNAME-rpm-list-$1.log\"\n    infomsg \"Verifying RPMs installed against RPM database: $1\"$'\\n\\n'\n    rpm -Va | sort -k3 > \\\n        \"${convert_info_dir}/$HOSTNAME-rpm-list-verified-$1.log\"\n}\n\n# Run a dnf update before the actual migration.\npre_update() {\n    infomsg '%s\\n' \"Running dnf update before we attempt the migration.\"\n    safednf -y \"${dist_repourl_swaps[@]}\" update || exit_message \\\n$'Error running pre-update.  Stopping now to avoid putting the system in an\\n'\\\n$'unstable state.  Please correct the issues shown here and try again.'\n}\n\npackage_swaps() {\n    # Save off any subscription-manager keys, just in case.\n    if ( shopt -s failglob dotglob; : \"$sm_ca_dir\"/* ) 2>/dev/null ; then\n        tmp_sm_ca_dir=$tmp_dir/sm-certs\n        mkdir \"$tmp_sm_ca_dir\" ||\n            exit_message \"Could not create directory: $tmp_sm_ca_dir\"\n        cp -f -dR --preserve=all \"$sm_ca_dir\"/* \"$tmp_sm_ca_dir/\" ||\n            exit_message \"Could not copy certs to $tmp_sm_ca_dir\"\n    fi\n\n    # prepare repo parameters\n    local -a dnfparameters\n    for repo in \"${!repo_urls[@]}\"; do\n        dnfparameters+=( \"--repofrompath=${repo},${repo_urls[${repo}]}\" )\n        dnfparameters+=( \"--setopt=${repo}.gpgcheck=1\" )\n        dnfparameters+=( \"--setopt=${repo}.gpgkey=file://${gpg_key_file}\" )\n    done\n\n    # CentOS Stream specific processing\n    if (( ${#installed_stream_repos_pkgs[@]} ||\n          ${#installed_sys_stream_repos_pkgs[@]} )); then\n        # Get a list of the repo files.\n        local -a repos_files\n        readarray -t repos_files < <(\n            saferpm -ql \"${installed_sys_stream_repos_pkgs[@]}\" \\\n                \"${installed_stream_repos_pkgs[@]}\" |\n            grep '^/etc/yum\\.repos\\.d/.\\+\\.repo$'\n        )\n\n        if (( ${#installed_sys_stream_repos_pkgs[@]} )); then\n            # Remove the package from the rpm db.\n            saferpm -e --justdb --nodeps -a \\\n                \"${installed_sys_stream_repos_pkgs[@]}\" ||\n            exit_message \\\n\"Could not remove packages from the rpm db: ${installed_sys_stream_repos_pkgs[*]}\"\n        fi\n\n        # Rename the stream repos with a prefix and fix the baseurl.\n        # shellcheck disable=SC2016\n        sed -i \\\n            -e 's/^\\[/['\"$stream_prefix\"'/' \\\n            -e 's|^mirrorlist=|#mirrorlist=|' \\\n            -e 's|^#baseurl=http://mirror.centos.org/$contentdir/$stream/|baseurl=http://mirror.centos.org/centos/8-stream/|' \\\n            -e 's|^baseurl=http://vault.centos.org/$contentdir/$stream/|baseurl=https://vault.centos.org/centos/8-stream/|' \\\n            \"${repos_files[@]}\"\n    fi\n\n    # Use dnf shell to swap the system packages out.\n    safednf -y shell --disablerepo=\\* --noautoremove \\\n\t\"${dist_repourl_swaps[@]}\" \\\n        --setopt=protected_packages= --setopt=keepcache=True \\\n        \"${dnfparameters[@]}\" \\\n        <<EOF\n        remove ${installed_pkg_map[@]} ${addl_pkg_removes[@]}\n        install ${!installed_pkg_map[@]}\n        run\n        exit\nEOF\n\n    # rocky-repos and rocky-gpg-keys are now installed, so we don't need the\n    # key file anymore\n    rm -rf \"$gpg_tmp_dir\"\n\n    # We need to check to make sure that all of the original system packages\n    # have been removed and all of the new ones have been added. If a package\n    # was supposed to be removed and one with the same name added back then\n    # we're kind of screwed for this check, as we can't be certain, but all the\n    # packages we're adding start with \"rocky-*\" so this really shouldn't happen\n    # and we can safely not check for it.  The worst that will happen is a rocky\n    # linux package will be removed and then installed again.\n    local -a check_removed check_installed\n    readarray -t check_removed < <(\n        saferpm -qa --qf '%{NAME}\\n' \"${installed_pkg_map[@]}\" \\\n            \"${addl_pkg_removes[@]}\" | sort -u\n    )\n\n    if (( ${#check_removed[@]} )); then\n        infomsg '%s' $'\\n' \\\n            \"Packages found on system that should still be removed.  Forcibly\" \\\n            \" removing them with rpm:\"$'\\n'\n        # Removed packages still found on the system.  Forcibly remove them.\n        for pkg in \"${check_removed[@]}\"; do\n            # Extra safety measure, skip if empty string\n            if [[ -z $pkg ]]; then\n                continue\n            fi\n            printf '%s\\n' \"$pkg\"\n            saferpm -e --allmatches --nodeps \"$pkg\" ||\n            saferpm -e --allmatches --nodeps --noscripts --notriggers \"$pkg\"\n        done\n    fi\n\n    # Check to make sure we installed everything we were supposed to.\n    readarray -t check_installed < <(\n        {\n            printf '%s\\n' \"${!installed_pkg_map[@]}\" | sort -u\n            saferpm -qa --qf '%{NAME}\\n' \"${!installed_pkg_map[@]}\" | sort -u\n        } | sort | uniq -u\n    )\n    if (( ${#check_installed[@]} )); then\n        infomsg '%s' $'\\n' \\\n            \"Some required packages were not installed by dnf.  Attempting to\" \\\n            \" force with rpm:\"$'\\n'\n\n        # Get a list of rpm packages to package names\n        local -A rpm_map\n        local -a file_list\n        for rpm in /var/cache/dnf/{rockybaseos,rockyappstream}-*/packages/*.rpm\n        do\n            rpm_map[$(\n                    rpm -q --qf '%{NAME}\\n' --nodigest \"$rpm\" 2>/dev/null\n                    )]=$rpm\n        done\n\n        # Attempt to install.\n        for pkg in \"${check_installed[@]}\"; do\n            printf '%s\\n' \"$pkg\"\n            if ! rpm -i --force --nodeps --nodigest \"${rpm_map[$pkg]}\" \\\n                2>/dev/null; then\n                # Try to install the package in just the db, then clean it up.\n                rpm -i --force --justdb --nodeps --nodigest \"${rpm_map[$pkg]}\" \\\n                    2>/dev/null\n\n                # Get list of files that are still causing problems and donk\n                # them.\n                readarray -t file_list < <(\n                    rpm -V \"$pkg\" 2>/dev/null | awk '$1!=\"missing\" {print $2}'\n                )\n                for file in \"${file_list[@]}\"; do\n                    rmdir \"$file\" ||\n                    rm -f \"$file\" ||\n                    rm -rf \"$file\"\n                done\n\n                # Now try re-installing the package to replace the missing\n                # files.  Regardless of the outcome here we just accept it and\n                # move on and hope for the best.\n                rpm -i --reinstall --force --nodeps --nodigest \\\n                    \"${rpm_map[$pkg]}\" 2>/dev/null\n            fi\n        done\n    fi\n\n    # Distrosync\n    infomsg $'Ensuring repos are enabled before the package swap\\n'\n    safednf -y --enableplugin=config_manager config-manager \\\n        --set-enabled \"${!repo_map[@]}\" || {\n        printf '%s\\n' 'Repo name missing?'\n        exit 25\n    }\n\n    if (( ${#managed_repos[@]} )); then\n        # Filter the managed repos for ones still in the system.\n        readarray -t managed_repos < <(\n            safednf -y -q repolist \"${managed_repos[@]}\" |\n                    awk '$1!=\"repo\" {print $1}'\n        )\n\n        if (( ${#managed_repos[@]} )); then\n            infomsg $'\\nDisabling subscription managed repos\\n'\n            safednf -y --enableplugin=config_manager config-manager \\\n                --disable \"${managed_repos[@]}\"\n        fi\n    fi\n\n    if (( ${#disable_modules[@]} )); then\n        infomsg $'Disabling modules\\n\\n'\n        safednf -y module disable \"${disable_modules[@]}\" ||\n            exit_message \"Can't disable modules ${disable_modules[*]}\"\n    fi\n\n    if (( ${#enabled_modules[@]} )); then\n        infomsg $'Enabling modules\\n\\n'\n        safednf -y module enable \"${enabled_modules[@]}\" ||\n                exit_message \"Can't enable modules ${enabled_modules[*]}\"\n    fi\n\n    # Make sure that excluded modules are disabled.\n    infomsg $'Disabling excluded modules\\n\\n'\n    safednf -y module disable \"${module_excludes[@]}\" ||\n            exit_message \"Can't disable modules ${module_excludes[*]}\"\n\n    infomsg $'\\nSyncing packages\\n\\n'\n    dnf -y distro-sync || exit_message \"Error during distro-sync.\"\n\n    # Disable Stream repos.\n    if (( ${#installed_sys_stream_repos_pkgs[@]} ||\n          ${#installed_stream_repos_pkgs[@]} )); then\n        dnf -y --enableplugin=config_manager config-manager --set-disabled \\\n            \"$stream_prefix*\" ||\n            errmsg \\\n$'Failed to disable CentOS Stream repos, please check and disable manually.\\n'\n\n        if (( ${#stream_always_replace[@]} )) &&\n            [[ $(saferpm -qa \"${stream_always_replace[@]}\") ]]; then\n            safednf -y distro-sync \"${stream_always_replace[@]}\" ||\n                exit_message \"Error during distro-sync.\"\n        fi\n\n        infomsg $'\\nCentOS Stream Migration Notes:\\n\\n'\n        cat <<EOF\nBecause CentOS Stream leads RockyLinux by the next point release many packages\nin Stream will have higher version numbers than those in RockyLinux, some will\neven be rebased to a new upstream version.  Downgrading these packages to the\nversions in RockyLinux carries the risk that the older version may not\nrecognize config files, data or other files generated by the newer version in\nStream.\n\nTo avoid issues with this the newer package versions from CentOS Stream have\nbeen retained.  Also the CentOS Stream repositories have been retained but\nrenamed with a prefix of \"stream-\" to avoid clashing with RockyLinux\nrepositories, but these same repos have also been disabled so that future\npackage installs will come from the stock RockyLinux repositories.\n\nIf you do nothing except update to the next point release of RockyLinux when it\nbecomes available then the packages retained from Stream should be replaced at\nthat time.  If you need to update a package from Stream (eg: to fix a bug or\nsecurity issue) then you will need to enable the appropriate repository to do\nso.\nEOF\n    fi\n\n    if rpm --quiet -q subscription-manager; then\n        infomsg $'Subscription Manager found on system.\\n\\n'\n        cat <<EOF\nIf you're converting from a subscription-managed distribution such as RHEL then\nyou may no longer need subscription-manager or dnf-plugin-subscription-manager.\nWhile it won't hurt anything to have it on your system you may be able to safely\nremove it with:\n\n\"dnf remove subscription-manager dnf-plugin-subscription-manager\".\n\nTake care that it doesn't remove something that you want to keep.\n\nThe subscription-manager dnf plugin may be enabled for the benefit of\nSubscription Management. If no longer desired, you can use\n\"subscription-manager config --rhsm.auto_enable_yum_plugins=0\" to block this\nbehavior.\nEOF\n    fi\n\n    if (( ${#always_install[@]} )); then\n        safednf -y install \"${always_install[@]}\" || exit_message \\\n            \"Error installing required packages: ${always_install[*]}\"\n    fi\n\n    if [[ $tmp_sm_ca_dir ]]; then\n        # Check to see if there's Subscription Manager certs which have been\n        # removed\n        local -a removed_certs\n        readarray -t removed_certs < <((\n            shopt -s nullglob dotglob\n            local -a certs\n            cd \"$sm_ca_dir\" && certs=(*)\n            cd \"$tmp_sm_ca_dir\" && certs+=(*)\n            IFS=$'\\n'\n            printf '%s' \"${certs[*]}\"\n        ) | sort | uniq -u)\n\n        if (( ${#removed_certs[@]} )); then\n            cp -n -dR --preserve=all \"$tmp_sm_ca_dir\"/* \"$sm_ca_dir/\" ||\n                exit_message \"Could not copy certs back to $sm_ca_dir\"\n\n            infomsg '%s' \\\n                $'Some Subscription Manager certificates ' \\\n                \"were restored to $sm_ca_dir after\"$'\\n' \\\n                $'migration so that the subscription-manager ' \\\n                $'command will continue to work:\\n\\n'\n            printf '%s\\n' \"${removed_certs[@]}\" ''\n            cat <<EOF\nIf you no longer need to use the subscription-manager command then you may\nsafely remove these files.\nEOF\n        fi\n    fi\n}\n\n# Check if this system is running on EFI\n# If yes, we'll need to run fix_efi() at the end of the conversion\nefi_check () {\n    # Check if we have /sys mounted and it is looking sane\n    if ! [[ -d /sys/class/block ]]; then\n        exit_message \"/sys is not accessible.\"\n    fi\n\n    # Now that we know /sys is reliable, use it to check if we are running on\n    # EFI or not\n    if systemd-detect-virt --quiet --container; then\n        declare -g container_macros\n        container_macros=$(mktemp /etc/rpm/macros.zXXXXXX)\n        printf '%s\\n' '%_netsharedpath /sys:/proc' > \"$container_macros\"\n    elif [[ -d /sys/firmware/efi/ ]]; then\n        declare -g update_efi\n        update_efi=true\n    fi\n}\n\n# Called to update the EFI boot.\nfix_efi () (\n    grub2-mkconfig -o /boot/efi/EFI/rocky/grub.cfg ||\n            exit_message \"Error updating the grub config.\"\n    for i in \"${!efi_disk[@]}\"; do\n        efibootmgr -c -d \"/dev/${efi_disk[$i]}\" -p \"${efi_partition[$i]}\" \\\n            -L \"Rocky Linux\" -l \"/EFI/rocky/shim${cpu_arch_suffix_map[$ARCH]}.efi\" ||\n            exit_message \"Error updating uEFI firmware.\"\n    done\n)\n\n# Download and verify the Rocky Linux package signing key\nestablish_gpg_trust () {\n    # create temp dir and verify it is really created and empty, so we are sure\n    # deleting it afterwards won't cause any harm\n    declare -g gpg_tmp_dir\n    gpg_tmp_dir=$tmp_dir/gpg\n    if ! mkdir \"$gpg_tmp_dir\" || [[ ! -d \"$gpg_tmp_dir\" ]]; then\n        exit_message \"Error creating temp dir\"\n    fi\n    # failglob makes pathname expansion fail if empty, dotglob adds files\n    # starting with . to pathname expansion\n    if ( shopt -s failglob dotglob; : \"$gpg_tmp_dir\"/* ) 2>/dev/null ; then\n        exit_message \"Temp dir not empty\"\n    fi\n\n    # extract the filename from the url, use the temp dir just created\n    declare -g gpg_key_file=\"$gpg_tmp_dir/${gpg_key_url##*/}\"\n\n    if ! curl -L -o \"$gpg_key_file\" --silent --show-error \"$gpg_key_url\"; then\n        rm -rf \"$gpg_tmp_dir\"\n        exit_message \"Error downloading the Rocky Linux signing key.\"\n    fi\n\n    if ! sha512sum --quiet -c <<<\"$gpg_key_sha512 $gpg_key_file\"; then\n        rm -rf \"$gpg_tmp_dir\"\n        exit_message \"Error validating the signing key.\"\n    fi\n}\n\n## End actual work\nconvert_to_rocky=true\n\nplatform_check\npre_setup\nremove_dnf_duplicates\ntrap exit_clean EXIT\npre_check\nefi_check\nbin_check\n\nif [[ $verify_all_rpms ]]; then\n  generate_rpm_info begin\nfi\n\nif [[ $convert_to_rocky ]]; then\n    collect_system_info\n    establish_gpg_trust\n    pre_update\n    package_swaps\nfi\n\nif [[ $verify_all_rpms && $convert_to_rocky ]]; then\n  generate_rpm_info finish\n  infomsg $'You may review the following files:\\n'\n  printf '%s\\n' \"$convert_info_dir/$HOSTNAME-rpm-list-\"*.log\nfi\n\nif [[ $update_efi && $convert_to_rocky ]]; then\n    fix_efi\nfi\n\nprintf '\\n\\n\\n'\nif [[ $convert_to_rocky ]]; then\n    infomsg $'\\nDone, please reboot your system.\\n'\nfi\nlogmessage\n"
        ]
      }
    }
  ]
}
