{
  "description": "Automation Document for installing the Crowdstike's Falcon Sensor .",
  "schemaVersion": "0.3",
  "assumeRole": "{{ AutomationAssumeRole }}",
  "parameters": {
    "AutomationAssumeRole": {
      "type": "String",
      "description": "(Required) The ARN of the role that allows Automation to perform the actions on your behalf. If no role is specified, Systems Manager Automation uses your IAM permissions to run this runbook.",
      "default": ""
    },
    "Action": {
      "type": "String",
      "allowedValues": [
        "Install",
        "Uninstall"
      ],
      "description": "(Required) Specify whether or not to install or uninstall the package.",
      "default": "Install"
    },
    "LinuxPackageVersion": {
      "type": "String",
      "description": "(Optional) The version of the package to install or uninstall on Linux nodes. If you do not specify a version, the system installs the default version specified by the Distributor package.",
      "default": ""
    },
    "LinuxInstallerParams": {
      "type": "String",
      "default": "",
      "description": "(Optional) Enter CrowdStrike's install time params to be used on Linux nodes. For more information refer to the console."
    },
    "WindowsPackageVersion": {
      "type": "String",
      "description": "(Optional) The version of the package to install or uninstall on Windows nodes. If you do not specify a version, the system installs the default version specified by the Distributor package.",
      "default": ""
    },
    "WindowsInstallerParams": {
      "type": "String",
      "default": "",
      "description": "(Optional) Enter CrowdStrike's install time params to be used on Windows nodes. For more information refer to the console."
    },
    "SecretStorageMethod": {
      "type": "String",
      "default": "ParameterStore",
      "description": "The method used to store the Falcon ClientId, ClientSecret, and Cloud for the CrowdStrike APIs.",
      "allowedValues": [
        "ParameterStore",
        "SecretsManager"
      ]
    },
    "FalconCloud": {
      "type": "String",
      "description": "SSM Parameter Store name that contains the Falcon Cloud URL for CrowdStrike APIs. Required if SecretStorageMethod is ParameterStore.",
      "default": "/CrowdStrike/Falcon/Cloud"
    },
    "FalconClientId": {
      "type": "String",
      "default": "/CrowdStrike/Falcon/ClientId",
      "description": "SSM Parameter Store name that contains the Falcon Client Id for CrowdStrike APIs. Required if SecretStorageMethod is ParameterStore."
    },
    "FalconClientSecret": {
      "type": "String",
      "description": "SSM Parameter Store name that contains the Falcon Client Secret for CrowdStrike APIs. Required if SecretStorageMethod is ParameterStore.",
      "default": "/CrowdStrike/Falcon/ClientSecret"
    },
    "SecretsManagerSecretName": {
      "type": "String",
      "description": "Secrets Manager Secret Name that contains the Falcon ClientId, ClientSecret, and Cloud for the CrowdStrike APIs. Required if SecretStorageMethod is SecretsManager. Refer to the user guide for required value format.",
      "default": "/CrowdStrike/Falcon/Distributor"
    },
    "InstanceIds": {
      "type": "StringList"
    },
    "Targets": {
      "type": "MapList",
      "default": []
    }
  },
  "mainSteps": [
    {
      "name": "HandlePreqrequisites",
      "action": "aws:executeScript",
      "nextStep": "Branch",
      "isEnd": false,
      "onFailure": "Abort",
      "inputs": {
        "Runtime": "python3.11",
        "Handler": "script_handler",
        "InputPayload": {
          "instances": "{{ InstanceIds }}",
          "region": "{{global:REGION}}",
          "falconCloud": "{{FalconCloud}}",
          "falconClientId": "{{FalconClientId}}",
          "falconClientSecret": "{{FalconClientSecret}}",
          "secretsManagerSecretName": "{{SecretsManagerSecretName}}",
          "secretStorageMethod": "{{SecretStorageMethod}}"
        },
        "Script": "\"\"\"Module for handling prerequisites for CrowdStrike Falcon AWS Automation document\"\"\"\n\nimport http.client\n\nimport urllib.parse\n\nimport time\n\nfrom datetime import datetime\n\nimport json\n\nfrom enum import StrEnum\n\nimport boto3\n\nfrom botocore.config import Config\n\nimport botocore.exceptions\n\n\nclass CrowdStrikeAPIError(Exception):\n    \"\"\"Crowdstrike API error\"\"\"\n\n\nclass InstanceStatus(StrEnum):\n    \"\"\"Enum for the InstanceStatus of the instance\"\"\"\n\n    ACTIVE = \"Active\"\n    CONNECTIONLOST = \"ConnectionLost\"\n    STOPPED = \"Stopped\"\n    TERMINATED = \"Terminated\"\n    UNKNOWN = \"Unknown\"\n\n\nclass PingStatus(StrEnum):\n    \"\"\"Enum for the PingStatus of the instance\"\"\"\n\n    ONLINE = \"Online\"\n    CONNECTIONLOST = \"ConnectionLost\"\n    INACTIVE = \"Inactive\"\n\n\ndef pretty_print_instances(instances):\n    instancesStr = \"\\n[\\n  \"\n    instancesStr += \",\\n  \".join(f'\"{i}\"' for i in instances)\n    instancesStr += \"\\n]\"\n\n    return instancesStr\n\n\nclass Falcon:\n    \"\"\"Crowdstrike Falcon API class\"\"\"\n\n    def __init__(self, cloud, client_id, client_secret, bearer_token=None):\n        \"\"\"Default constructor\n\n        Args:\n            cloud (str): Falcon API Gateway\n            client_id (str): Falcon OAuth2 Client ID\n            client_secret (str): Falcon OAuth2 Client Secret\n            bearer_token (str, optional): CrowdStrike API OAUTH2 Token. Defaults to None.\n        \"\"\"\n        self.cloud = cloud.replace(\"https://\", \"\").replace(\"http://\", \"\")\n        self.client_id = client_id\n        self.client_secret = client_secret\n        self.user_agent = \"crowdstrike-official-distributor-automation-doc/v3.0.0\"\n        self.bearer_token = bearer_token\n\n    def _handle_redirect(self, res):\n        \"\"\"Updates the cloud attribute with the new location received in the redirect\n\n        Args:\n            res (HTTPResponse): HTTP response object\n\n        Raises:\n            CrowdStrikeAPIError: If we are unable to handle the redirect\n        \"\"\"\n        location = res.getheader(\"Location\")\n        if location is None:\n            raise CrowdStrikeAPIError(\n                f\"Received redirect to {res.getheader('X-Cs-Region')}, but no location header was found. Ensure you are using the correct API Gateway.\"\n            )\n        new_cloud = urllib.parse.urlparse(location).netloc\n        print(\n            f\"WARNING: While using {self.cloud}, received redirect to {new_cloud}. Please update the value used for the crowdstrike cloud to prevent future redirects.\"\n        )\n        self.cloud = new_cloud\n\n    def _handle_rate_limit(self, res):\n        \"\"\"Handles rate limit exceptions by sleeping 10 seconds or X-RateLimit-RetryAfter\n        whichever is largest\n\n        Args:\n            res (HTTPResponse): HTTP response object\n        \"\"\"\n        retry_after = int(res.getheader(\"X-RateLimit-RetryAfter\"))\n        retry_datetime = datetime.utcfromtimestamp(retry_after)\n        now = datetime.utcnow()\n        wait_duration = max((retry_datetime - now).total_seconds(), 10)\n        print(f\"Rate limit exceeded. Retrying after {wait_duration} seconds.\")\n        time.sleep(wait_duration)\n\n    def _oauth(self):\n        \"\"\"Creates OAuth bearer token\n\n\n        Returns:\n            token (str): OAuth bearer token\n\n        Raises:\n            CrowdStrikeAPIError: If the API call fails\n        \"\"\"\n        print(\"Requesting Authentication token from Crowdstrike backend.\")\n\n        params = urllib.parse.urlencode(\n            {\n                \"client_id\": self.client_id,\n                \"client_secret\": self.client_secret,\n            }\n        )\n        headers = {\n            \"Content-Type\": \"application/x-www-form-urlencoded\",\n            \"User-Agent\": self.user_agent,\n        }\n        conn = http.client.HTTPSConnection(self.cloud)\n        conn.request(\"POST\", \"/oauth2/token\", params, headers)\n        res = conn.getresponse()\n\n        if res.status == 429:\n            self._handle_rate_limit(res)\n            return self._oauth()\n\n        if res.status in [301, 302, 303, 307, 308]:\n            self._handle_redirect(res)\n            return self._oauth()\n\n        if res.status != 201:\n            raise CrowdStrikeAPIError(\n                f\"Received non success response {res.status} while fetching token. Error {res.reason}\"\n            )\n\n        data = res.read()\n        print(\"Successfully received OAuth token.\")\n        self.bearer_token = json.loads(data)[\"access_token\"]\n\n    def get_ccid(self):\n        \"\"\"Returns the Customer ID\n\n        Returns:\n            ccid (str): Customer ID\n\n        Raises:\n            CrowdStrikeAPIError: If the API call fails\n        \"\"\"\n        print(\"Requesting Customer ID from Crowdstrike backend.\")\n\n        if self.bearer_token is None:\n            self._oauth()\n\n        headers = {\n            \"Authorization\": f\"Bearer {self.bearer_token}\",\n            \"User-Agent\": self.user_agent,\n        }\n\n        conn = http.client.HTTPSConnection(self.cloud)\n        conn.request(\"GET\", \"/sensors/queries/installers/ccid/v1\", \"\", headers)\n        res = conn.getresponse()\n\n        if res.status == 429:\n            self._handle_rate_limit(res)\n            return self.get_ccid()\n\n        if res.status in [301, 302, 303, 307, 308]:\n            self._handle_redirect(res)\n            return self.get_ccid()\n\n        if res.status != 200:\n            raise CrowdStrikeAPIError(\n                f\"Received non success response {res.status} while fetching Customer ID. Error {res.reason}\"\n            )\n\n        data = res.read()\n        print(\"Successfully received Customer ID.\")\n\n        return json.loads(data)[\"resources\"][0]\n\n    def get_install_token(self):\n        \"\"\"Returns the Installation Token\n\n        Returns:\n            token (str): Installation Token\n\n        Raises:\n            CrowdStrikeAPIError: If the API call fails\n        \"\"\"\n        print(\"Requesting Installation Token from Crowdstrike backend.\")\n\n        if self.bearer_token is None:\n            self._oauth()\n\n        conn = http.client.HTTPSConnection(self.cloud)\n\n        headers = {\n            \"Authorization\": f\"Bearer {self.bearer_token}\",\n            \"User-Agent\": self.user_agent,\n        }\n\n        conn.request(\n            \"GET\",\n            \"/installation-tokens/queries/tokens/v1?filter=status:'valid'\",\n            \"\",\n            headers,\n        )\n        install_token_query_resp = conn.getresponse()\n\n        if install_token_query_resp.status == 429:\n            self._handle_rate_limit(install_token_query_resp)\n            return self.get_install_token()\n\n        if install_token_query_resp.status in [301, 302, 303, 307, 308]:\n            self._handle_redirect(install_token_query_resp)\n            return self.get_install_token()\n\n        if install_token_query_resp.status != 200:\n            raise CrowdStrikeAPIError(\n                f\"Received non success response {install_token_query_resp.status} while fetching token. Error {install_token_query_resp.reason}\"\n            )\n\n        install_token_query_data = install_token_query_resp.read()\n        resources = json.loads(install_token_query_data)[\"resources\"]\n        if len(resources) == 0:\n            print(\"No Installation token found, skipping\")\n            return \"\"\n\n        install_token_id = resources[0]\n        url = f\"/installation-tokens/entities/tokens/v1?ids={install_token_id}\"\n        conn.request(\"GET\", url, \"\", headers)\n        entities_resp = conn.getresponse()\n\n        if entities_resp.status == 429:\n            self._handle_rate_limit(entities_resp)\n            return self.get_install_token()\n\n        if entities_resp.status in [301, 302, 303, 307, 308]:\n            self._handle_redirect(install_token_query_resp)\n            return self.get_install_token()\n\n        if entities_resp.status != 200:\n            raise CrowdStrikeAPIError(\n                f\"Received non success response {entities_resp.status} while fetching token by id {install_token_id}. Error {entities_resp.reason}\"\n            )\n\n        entities_resp_data = entities_resp.read()\n        token = json.loads(entities_resp_data)[\"resources\"][0][\"value\"]\n\n        print(\"Successfully received Installation token\")\n        return token\n\n\nclass SSMHelper:\n    \"\"\"A helper class for SSM\"\"\"\n\n    def __init__(self, config):\n        self.client = boto3.client(\"ssm\", config=config)\n\n    def get_parameter(self, path):\n        \"\"\"Get a SSM parameter by path and return value.\n\n        Handles throttling exceptions by backing off and retrying.\n\n        Args:\n            path (str): Path to the SSM parameter\n        \"\"\"\n\n        try:\n            response = self.client.get_parameter(\n                Name=path,\n                WithDecryption=True,\n            )\n            print(f\"Successfully received SSM parameter: {path}\")\n            return response[\"Parameter\"][\"Value\"]\n        except botocore.exceptions.ClientError as error:\n            if (\n                error.response.get(\"Error\", {}).get(\"Code\", None)\n                == \"ThrottlingException\"\n            ):\n                wait_time = 5\n                print(f\"Throttling exception, waiting {wait_time} seconds\")\n                time.sleep(wait_time)\n                return self.get_parameter(path)\n            else:\n                raise error\n\n\nclass SecretsManagerHelper:\n    \"\"\"A helper class for Secrets Manager\"\"\"\n\n    def __init__(self, config):\n        self.client = boto3.client(\"secretsmanager\", config=config)\n\n    def _validate_secret(self, secret_value):\n        \"\"\"Validate a Secrets Manager secret contains all required fields.\n\n        Args:\n            secret_value (dict): Secrets Manager secret value\n\n        Returns:\n            valid (bool): True if secret contains all required fields\n            fields: (list): List of missing fields\n        \"\"\"\n\n        required_fields = [\"clientid\", \"clientsecret\", \"cloud\"]\n        missing_fields = []\n\n        for field in required_fields:\n            if field not in secret_value:\n                missing_fields.append(field)\n\n        valid = len(missing_fields) == 0\n\n        return valid, missing_fields\n\n    def get_secret(self, secret_name):\n        \"\"\"Get a Secrets Manager secret by name and return value.\n\n        Validates the secret contains all required fields.\n\n        Handles throttling exceptions by backing off and retrying.\n\n        Args:\n            secret_name (str): secret name of the Secrets Manager secret\n\n        Returns:\n            secret_value (dict): Secrets Manager secret value\n\n        Raises:\n            botocore.exceptions.ClientError: If the API call fails\n            ValueError: If the secret does not contain all required fields\n        \"\"\"\n\n        try:\n            response = self.client.get_secret_value(SecretId=secret_name)\n            print(f\"Successfully received Secrets Manager secret: {secret_name}\")\n\n            secret_value = json.loads(response[\"SecretString\"])\n            # Instead of throwing an error if the secret contains fields with\n            # mismatching casing, we convert all keys to lowercase.\n            # This eliminates this error entirely.\n            secret_value = {k.lower(): v for k, v in secret_value.items()}\n\n            valid, missing_fields = self._validate_secret(secret_value)\n\n            if not valid:\n                raise ValueError(\n                    f\"Secret {secret_name} is missing required fields: {missing_fields}\"\n                )\n\n            return secret_value\n        except botocore.exceptions.ClientError as error:\n            if (\n                error.response.get(\"Error\", {}).get(\"Code\", None)\n                == \"ThrottlingException\"\n            ):\n                wait_time = 5\n                print(f\"Throttling exception, waiting {wait_time} seconds\")\n                time.sleep(wait_time)\n                return self.get_secret(secret_name)\n            else:\n                raise error\n\n\ndef describe_instance_information(config, instances):\n    \"\"\"\n    Get SSM instance information for the provided instances\n\n    Args:\n        config (botocore.config.Config): Botocore configuration object\n        instances (list): List of instance IDs\n\n    Returns:\n        dict: SSM instance information for each instance {<instanceId>: {\"InstanceStatus\": <value>, ...}, ...}\n        str: Error message, if any\n    \"\"\"\n    inventoryDict = {}\n\n    if not instances:\n        return inventoryDict, None\n\n    try:\n        client = boto3.client(\"ssm\", config=config)\n        paginator = client.get_paginator(\"describe_instance_information\")\n        page_iterator = paginator.paginate(\n            Filters=[\n                {\n                    \"Key\": \"InstanceIds\",\n                    \"Values\": instances,\n                }\n            ]\n        )\n\n        for page in page_iterator:\n            for instanceInfoList in page.get(\"InstanceInformationList\", {}):\n                instance_id = instanceInfoList.get(\"InstanceId\")\n                pingStatus = instanceInfoList.get(\"PingStatus\")\n\n                if pingStatus == PingStatus.ONLINE:\n                    inventoryDict[instance_id] = {\n                        \"InstanceStatus\": InstanceStatus.ACTIVE\n                    }\n                elif pingStatus == PingStatus.CONNECTIONLOST:\n                    inventoryDict[instance_id] = {\n                        \"InstanceStatus\": InstanceStatus.CONNECTIONLOST\n                    }\n                elif pingStatus == PingStatus.INACTIVE:\n                    inventoryDict[instance_id] = {\n                        \"InstanceStatus\": InstanceStatus.CONNECTIONLOST\n                    }\n                else:\n                    inventoryDict[instance_id] = {\n                        \"InstanceStatus\": InstanceStatus.UNKNOWN\n                    }\n\n        return inventoryDict, None\n    except botocore.exceptions.ClientError as error:\n        errorMsg = f\"Error calling ssm.DescribeInstanceInformation: {error}\"\n        if error.response.get(\"Error\", {}).get(\"Code\") == \"InvalidInstanceId\":\n          errorMsg += f\"\\n\\nPlease check the following instance IDs provided and verify that they are in the correct format.\\n{pretty_print_instances(instances)}\"\n        return inventoryDict, errorMsg\n    except Exception as error:\n        return inventoryDict, f\"Error calling ssm.DescribeInstanceInformation: {error}\\n\\nFor instances {pretty_print_instances(instances)}\"\n\n\ndef get_inventory(config, instances):\n    \"\"\"\n    Get SSM Inventory information for the provided instances\n\n    Args:\n        config (botocore.config.Config): Botocore configuration object\n        instances (list): List of instance IDs\n\n    Returns:\n        dict: SSM Inventory instance status for each instance {<instanceId>: {\"InstanceStatus\": <value>, ...}, ...}\n        str: Error message, if any\n    \"\"\"\n    inventoryDict = {}\n\n    if not instances:\n        return inventoryDict, None\n\n    try:\n        client = boto3.client(\"ssm\", config=config)\n        paginator = client.get_paginator(\"get_inventory\")\n        page_iterator = paginator.paginate(\n            Filters=[\n                {\n                    \"Key\": \"AWS:InstanceInformation.InstanceId\",\n                    \"Values\": instances,\n                    \"Type\": \"Equal\",\n                }\n            ]\n        )\n\n        for page in page_iterator:\n            for e in page[\"Entities\"]:\n                instance_id = e.get(\"Id\")\n                content = (\n                    e.get(\"Data\", {})\n                    .get(\"AWS:InstanceInformation\", {})\n                    .get(\"Content\", [])\n                )\n\n                if not content:\n                    continue\n\n                instanceInfo = content[0]\n                instanceInfo[\"Id\"] = instance_id\n                inventoryDict[instance_id] = instanceInfo\n\n        return inventoryDict, None\n\n    except botocore.exceptions.ClientError as error:\n        # Handle AccessDeniedException by falling back to ssm.DescribeInstanceInformation.\n        # This ensures backwords compatbility with FalconSensor-Linux, FalconSensor-Windows, and v1/v2 of the automation document.\n        if error.response.get(\"Error\", {}).get(\"Code\") == \"AccessDeniedException\":\n            print(\n                \"Unable to call ssm.GetInventory due to missing permissions. Consider adding the ssm:GetInventory action to your role. This will allow the automation document to correctly report if a instance was skipped due to being stopped, terminated, or in an unkown state.\"\n            )\n            return describe_instance_information(config, instances)\n        return inventoryDict, f\"Error calling ssm.GetInventory: {error}\\n\\nFor instances {pretty_print_instances(instances)}\"\n    except Exception as error:\n        return inventoryDict, f\"Error calling ssm.GetInventory: {error}\\n\\nFor instances {pretty_print_instances(instances)}\"\n\n\ndef add_unknown_status(instances, inventory):\n    \"\"\"\n    Adds the UNKNOWN status to instances that were not found in the inventory.\n\n    Args:\n        instances (list): List of instances\n        inventory (dict): Inventory of instances\n    \"\"\"\n    updatedInventory = inventory.copy()\n    for instance in instances:\n        if instance not in updatedInventory:\n            updatedInventory[instance] = {\"InstanceStatus\": InstanceStatus.UNKNOWN}\n\n    return updatedInventory\n\n\ndef script_handler(events, _):\n    \"\"\"Handler for executeScript action\n\n    Args:\n        events (dict): Input for the action\n        _ (dict): Context for the action\n\n    Returns:\n        dict: Output for the action\n    \"\"\"\n    config = Config(\n        region_name=events[\"region\"], retries={\"max_attempts\": 30, \"mode\": \"standard\"}\n    )\n\n    response = {\n        \"skipDistributor\": False,\n        \"failRun\": False,\n        \"falconOauthToken\": \"\",\n        \"message\": \"\",\n        \"errorMessage\": \"\",\n    }\n\n    instances = [i for i in events[\"instances\"] if i.strip()]\n\n    if len(instances) == 0:\n        response[\"skipDistributor\"] = True\n        response[\"failRun\"] = False\n        response[\"message\"] = (\n            \"Execution aborted: No instances were provided to the automation document.\"\n        )\n        return response\n\n    inventory, error = get_inventory(config, instances)\n\n    if error:\n        response[\"skipDistributor\"] = True\n        response[\"failRun\"] = True\n        response[\"errorMessage\"] = error\n        return response\n\n    inventory = add_unknown_status(instances, inventory)\n\n    instanceStatusCount = {\n        InstanceStatus.ACTIVE: [],\n        InstanceStatus.CONNECTIONLOST: [],\n        InstanceStatus.STOPPED: [],\n        InstanceStatus.TERMINATED: [],\n        InstanceStatus.UNKNOWN: [],\n    }\n\n    for instance, v in inventory.items():\n        instanceStatusCount[v[\"InstanceStatus\"]].append(instance)\n\n    print(\"Instances by status\")\n    print(json.dumps(instanceStatusCount, indent=4))\n\n    response[\"instanceList\"] = instanceStatusCount[InstanceStatus.ACTIVE]\n\n    if len(instanceStatusCount[InstanceStatus.ACTIVE]) == 0:\n        response[\"skipDistributor\"] = True\n        response[\"failRun\"] = False\n        message = \"Execution aborted: No instances in the ACTIVE state.\"\n        response[\"message\"] += message\n    else:\n        message = f\"Targeting the following ACTIVE instances:{pretty_print_instances(instanceStatusCount[InstanceStatus.ACTIVE])}\"\n        print(message)\n        response[\"message\"] += message\n\n    for status, message in [\n        (\n            InstanceStatus.STOPPED,\n            f\"\\n\\nThe following instances were skipped because they are in the STOPPED state. Start the instances and try again:{pretty_print_instances(instanceStatusCount[InstanceStatus.STOPPED])}\",\n        ),\n        (\n            InstanceStatus.TERMINATED,\n            f\"\\n\\nThe following instances were skipped because they are in the TERMINATED state:{pretty_print_instances(instanceStatusCount[InstanceStatus.TERMINATED])}\",\n        ),\n        (\n            InstanceStatus.UNKNOWN,\n            f\"\\n\\nThe following instances were skipped becuase they are in an UNKNOWN state. If the instance ID is correct and the instance is running this could indicate the instance is not managed by SSM.\\nPlease refer to the following article for troubleshooting: https://repost.aws/knowledge-center/systems-manager-ec2-instance-not-appear{pretty_print_instances(instanceStatusCount[InstanceStatus.UNKNOWN])}\",\n        ),\n        (\n            InstanceStatus.CONNECTIONLOST,\n            f\"\\n\\nThe following instances were skipped becuase they are in the CONNECTIONLOST state. If the instance is running, this could indicate there is a issue between SSM and the instance.\\nPlease refer to the following article for troubleshooting: https://repost.aws/knowledge-center/systems-manager-ec2-instance-not-appear{pretty_print_instances(instanceStatusCount[InstanceStatus.CONNECTIONLOST])}\",\n        ),\n    ]:\n        if instanceStatusCount[status]:\n            response[\"message\"] += message\n\n    if response[\"skipDistributor\"] or instanceStatusCount[InstanceStatus.ACTIVE] == 0:\n        return response\n\n    if events[\"secretStorageMethod\"] == \"ParameterStore\":\n        print(\"Using Parameter Store to retrieve secrets\")\n        ssm_helper = SSMHelper(config)\n        falcon_cloud = ssm_helper.get_parameter(events[\"falconCloud\"])\n        falcon_client_id = ssm_helper.get_parameter(events[\"falconClientId\"])\n        falcon_client_secret = ssm_helper.get_parameter(events[\"falconClientSecret\"])\n    else:\n        print(\"Using Secrets Manager to retrieve secrets\")\n        secret_helper = SecretsManagerHelper(config)\n        secret_value = secret_helper.get_secret(events[\"secretsManagerSecretName\"])\n        falcon_cloud = secret_value[\"cloud\"]\n        falcon_client_id = secret_value[\"clientid\"]\n        falcon_client_secret = secret_value[\"clientsecret\"]\n\n    falcon_client = Falcon(falcon_cloud, falcon_client_id, falcon_client_secret)\n\n    response[\"falconCcid\"] = falcon_client.get_ccid()\n    response[\"falconInstallToken\"] = falcon_client.get_install_token()\n    response[\"falconOauthToken\"] = falcon_client.bearer_token\n    response[\"falconCloud\"] = falcon_client.cloud\n    return response"
      },
      "outputs": [
        {
          "Name": "falconCloud",
          "Selector": "$.Payload.falconCloud",
          "Type": "String"
        },
        {
          "Name": "falconCcid",
          "Selector": "$.Payload.falconCcid",
          "Type": "String"
        },
        {
          "Name": "falconInstallToken",
          "Selector": "$.Payload.falconInstallToken",
          "Type": "String"
        },
        {
          "Name": "falconOauthToken",
          "Selector": "$.Payload.falconOauthToken",
          "Type": "String"
        },
        {
          "Name": "instanceList",
          "Selector": "$.Payload.instanceList",
          "Type": "StringList"
        },
        {
          "Name": "skipDistributor",
          "Selector": "$.Payload.skipDistributor",
          "Type": "Boolean"
        },
        {
          "Name": "failRun",
          "Selector": "$.Payload.failRun",
          "Type": "Boolean"
        },
        {
          "Name": "errorMessage",
          "Selector": "$.Payload.errorMessage",
          "Type": "String"
        },
        {
          "Name": "message",
          "Selector": "$.Payload.message",
          "Type": "String"
        }
      ]
    },
    {
      "name": "Branch",
      "action": "aws:branch",
      "inputs": {
        "Choices": [
          {
            "NextStep": "HandleCleanup",
            "Variable": "{{ HandlePreqrequisites.skipDistributor }}",
            "BooleanEquals": true
          }
        ],
        "Default": "ExecuteDistributorPackage"
      }
    },
    {
      "name": "ExecuteDistributorPackage",
      "action": "aws:runCommand",
      "nextStep": "HandleCleanup",
      "isEnd": false,
      "onFailure": "Continue",
      "inputs": {
        "Targets": "{{ Targets }}",
        "InstanceIds": "{{ HandlePreqrequisites.instanceList }}",
        "DocumentName": "AWS-ConfigureAWSPackage",
        "Parameters": {
          "installationType": "In-place update",
          "additionalArguments": {
            "SSM_CS_INSTALLTOKEN": "{{HandlePreqrequisites.falconInstallToken}}",
            "SSM_CS_CCID": "{{HandlePreqrequisites.falconCcid}}",
            "SSM_CS_WINDOWS_INSTALLPARAMS": "{{WindowsInstallerParams}}",
            "SSM_CS_WINDOWS_VERSION": "{{WindowsPackageVersion}}",
            "SSM_CS_LINUX_INSTALLPARAMS": "{{LinuxInstallerParams}}",
            "SSM_CS_LINUX_VERSION": "{{LinuxPackageVersion}}",
            "SSM_CS_AUTH_TOKEN": "{{HandlePreqrequisites.falconOauthToken}}",
            "SSM_CS_HOST": "{{HandlePreqrequisites.falconCloud}}"
          },
          "name": "FalconSensor-CrowdStrike",
          "action": "{{Action}}"
        }
      }
    },
    {
      "name": "HandleCleanup",
      "action": "aws:executeScript",
      "isEnd": true,
      "inputs": {
        "Runtime": "python3.11",
        "Handler": "script_handler",
        "InputPayload": {
          "region": "{{global:REGION}}",
          "falconOauthToken": "{{HandlePreqrequisites.falconOauthToken}}",
          "falconCloud": "{{HandlePreqrequisites.falconCloud}}",
          "falconClientId": "{{FalconClientId}}",
          "falconClientSecret": "{{FalconClientSecret}}",
          "secretsManagerSecretName": "{{SecretsManagerSecretName}}",
          "secretStorageMethod": "{{SecretStorageMethod}}",
          "distributorStatus": "{{ExecuteDistributorPackage.Status}}",
          "skipDistributor": "{{HandlePreqrequisites.skipDistributor}}",
          "failRun": "{{HandlePreqrequisites.failRun}}",
          "errorMessage": "{{HandlePreqrequisites.errorMessage}}",
          "message": "{{HandlePreqrequisites.message}}"
        },
        "Script": "\"\"\"Module for handling cleanup for CrowdStrike Falcon AWS Automation document\"\"\"\n\nimport http.client\n\nimport urllib.parse\n\nimport time\n\nfrom datetime import datetime\n\nimport json\n\nimport base64\n\nimport boto3\n\nfrom botocore.config import Config\n\nimport botocore.exceptions\n\n\nclass CrowdStrikeAPIError(Exception):\n    \"\"\"Crowdstrike API error\"\"\"\n\n\nclass Falcon:\n    \"\"\"Crowdstrike Falcon API class\"\"\"\n\n    def __init__(self, cloud, client_id, client_secret, bearer_token=None):\n        \"\"\"Default constructor\n\n        Args:\n            cloud (str): Falcon API Gateway\n            client_id (str): Falcon OAuth2 Client ID\n            client_secret (str): Falcon OAuth2 Client Secret\n            bearer_token (str, optional): CrowdStrike API OAUTH2 Token. Defaults to None.\n        \"\"\"\n        self.cloud = cloud.replace(\"https://\", \"\").replace(\"http://\", \"\")\n        self.client_id = client_id\n        self.client_secret = client_secret\n        self.user_agent = \"crowdstrike-official-distributor-automation-doc/v3.0.0\"\n        self.bearer_token = bearer_token\n\n    def _handle_redirect(self, res):\n        \"\"\"Updates the cloud attribute with the new location received in the redirect\n\n        Args:\n            res (HTTPResponse): HTTP response object\n\n        Raises:\n            CrowdStrikeAPIError: If we are unable to handle the redirect\n        \"\"\"\n        location = res.getheader(\"Location\")\n        if location is None:\n            raise CrowdStrikeAPIError(\n                f\"Received redirect to {res.getheader('X-Cs-Region')}, but no location header was found. Ensure you are using the correct API Gateway.\"\n            )\n        new_cloud = urllib.parse.urlparse(location).netloc\n        print(\n            f\"WARNING: While using {self.cloud}, received redirect to {new_cloud}. Please update the value used for the crowdstrike cloud to prevent future redirects.\"\n        )\n        self.cloud = new_cloud\n\n    def _handle_rate_limit(self, res):\n        \"\"\"Handles rate limit exceptions by sleeping 10 seconds or X-RateLimit-RetryAfter\n        whichever is largest\n\n        Args:\n            res (HTTPResponse): HTTP response object\n        \"\"\"\n        retry_after = int(res.getheader(\"X-RateLimit-RetryAfter\"))\n        retry_datetime = datetime.utcfromtimestamp(retry_after)\n        now = datetime.utcnow()\n        wait_duration = max((retry_datetime - now).total_seconds(), 10)\n        print(f\"Rate limit exceeded. Retrying after {wait_duration} seconds.\")\n        time.sleep(wait_duration)\n\n    def revoke_oauth_token(self):\n        \"\"\"Revokes a OAuth bearer token\n\n        Raises:\n            CrowdStrikeAPIError: If the API call fails\n        \"\"\"\n        print(\"Revoking Authentication token\")\n\n        credentials = base64.b64encode(\n            f\"{self.client_id}:{self.client_secret}\".encode()\n        ).decode()\n\n        params = urllib.parse.urlencode(\n            {\n                \"client_id\": self.client_id,\n                \"token\": self.bearer_token,\n            }\n        )\n\n        headers = {\n            \"Content-Type\": \"application/x-www-form-urlencoded\",\n            \"Authorization\": f\"Basic {credentials}\",\n            \"User-Agent\": self.user_agent,\n        }\n        conn = http.client.HTTPSConnection(self.cloud)\n        conn.request(\"POST\", \"/oauth2/revoke\", params, headers)\n        res = conn.getresponse()\n\n        if res.status == 429:\n            self._handle_rate_limit(res)\n            return self.revoke_oauth_token()\n\n        if res.status in [301, 302, 303, 307, 308]:\n            self._handle_redirect(res)\n            return self.revoke_oauth_token()\n\n        if res.status != 200:\n            print(\n                f\"Received non success response {res.status} while revoking token. Error {res.reason}\"\n            )\n            return\n\n        print(\"Successfully revoked Authentication token\")\n\n\nclass SSMHelper:\n    \"\"\"A helper class for SSM\"\"\"\n\n    def __init__(self, config):\n        self.client = boto3.client(\"ssm\", config=config)\n\n    def get_parameter(self, path):\n        \"\"\"Get a SSM parameter by path and return value.\n\n        Handles throttling exceptions by backing off and retrying.\n\n        Args:\n            path (str): Path to the SSM parameter\n        \"\"\"\n\n        try:\n            response = self.client.get_parameter(\n                Name=path,\n                WithDecryption=True,\n            )\n            print(f\"Successfully received SSM parameter: {path}\")\n            return response[\"Parameter\"][\"Value\"]\n        except botocore.exceptions.ClientError as error:\n            if (\n                error.response.get(\"Error\", {}).get(\"Code\", None)\n                == \"ThrottlingException\"\n            ):\n                wait_time = 5\n                print(f\"Throttling exception, waiting {wait_time} seconds\")\n                time.sleep(wait_time)\n                return self.get_parameter(path)\n            else:\n                raise error\n\n\nclass SecretsManagerHelper:\n    \"\"\"A helper class for Secrets Manager\"\"\"\n\n    def __init__(self, config):\n        self.client = boto3.client(\"secretsmanager\", config=config)\n\n    def _validate_secret(self, secret_value):\n        \"\"\"Validate a Secrets Manager secret contains all required fields.\n\n        Args:\n            secret_value (dict): Secrets Manager secret value\n\n        Returns:\n            valid (bool): True if secret contains all required fields\n            fields: (list): List of missing fields\n        \"\"\"\n\n        required_fields = [\"clientid\", \"clientsecret\", \"cloud\"]\n        missing_fields = []\n\n        for field in required_fields:\n            if field not in secret_value:\n                missing_fields.append(field)\n\n        valid = len(missing_fields) == 0\n\n        return valid, missing_fields\n\n    def get_secret(self, secret_name):\n        \"\"\"Get a Secrets Manager secret by name and return value.\n\n        Validates the secret contains all required fields.\n\n        Handles throttling exceptions by backing off and retrying.\n\n        Args:\n            secret_name (str): secret name of the Secrets Manager secret\n\n        Returns:\n            secret_value (dict): Secrets Manager secret value\n\n        Raises:\n            botocore.exceptions.ClientError: If the API call fails\n            ValueError: If the secret does not contain all required fields\n        \"\"\"\n\n        try:\n            response = self.client.get_secret_value(SecretId=secret_name)\n            print(f\"Successfully received Secrets Manager secret: {secret_name}\")\n\n            secret_value = json.loads(response[\"SecretString\"])\n            # Instead of throwing an error if the secret contains fields with\n            # mismatching casing, we convert all keys to lowercase.\n            # This eliminates this error entirely.\n            secret_value = {k.lower(): v for k, v in secret_value.items()}\n\n            valid, missing_fields = self._validate_secret(secret_value)\n\n            if not valid:\n                raise ValueError(\n                    f\"Secret {secret_name} is missing required fields: {missing_fields}\"\n                )\n\n            return secret_value\n        except botocore.exceptions.ClientError as error:\n            if (\n                error.response.get(\"Error\", {}).get(\"Code\", None)\n                == \"ThrottlingException\"\n            ):\n                wait_time = 5\n                print(f\"Throttling exception, waiting {wait_time} seconds\")\n                time.sleep(wait_time)\n                return self.get_secret(secret_name)\n            else:\n                raise error\n\n\ndef script_handler(events, _):\n    \"\"\"Handler for executeScript action\n\n    Args:\n        events (dict): Input for the action\n        _ (dict): Context for the action\n\n    Returns:\n        dict: Output for the action\n    \"\"\"\n    if (\n        events[\"falconOauthToken\"]\n        and \"falconOauthToken\" not in events[\"falconOauthToken\"]\n    ):\n        config = Config(\n            region_name=events[\"region\"],\n            retries={\"max_attempts\": 30, \"mode\": \"standard\"},\n        )\n\n        if events[\"secretStorageMethod\"] == \"ParameterStore\":\n            print(\"Using Parameter Store to retrieve secrets\")\n            ssm_helper = SSMHelper(config=config)\n            falcon_cloud = events[\"falconCloud\"]\n            falcon_client_id = ssm_helper.get_parameter(events[\"falconClientId\"])\n            falcon_client_secret = ssm_helper.get_parameter(\n                events[\"falconClientSecret\"]\n            )\n        else:\n            print(\"Using Secrets Manager to retrieve secrets\")\n            secret_helper = SecretsManagerHelper(config=config)\n            secret_value = secret_helper.get_secret(events[\"secretsManagerSecretName\"])\n            falcon_cloud = events[\"falconCloud\"]\n            falcon_client_id = secret_value[\"clientid\"]\n            falcon_client_secret = secret_value[\"clientsecret\"]\n\n        falcon_client = Falcon(\n            falcon_cloud,\n            falcon_client_id,\n            falcon_client_secret,\n            events[\"falconOauthToken\"],\n        )\n        falcon_client.revoke_oauth_token()\n\n    if events[\"message\"] and \"message\" not in events[\"message\"]:\n        print(events[\"message\"])\n\n    if events[\"errorMessage\"] and \"errorMessage\" not in events[\"errorMessage\"]:\n        print(events[\"errorMessage\"])\n\n    if events[\"failRun\"]:\n        raise Exception(\n            \"Marking the run as failed. Check the automation document output and the HandlePreqrequisites step logs for more details.\"\n        )\n\n    distributor_status = events[\"distributorStatus\"]\n    possible_states = [\n        \"success\",\n        \"pending\",\n        \"inprogress\",\n        \"failed\",\n        \"waiting\",\n        \"timedout\",\n        \"cancelled\",\n        \"cancelling\",\n    ]\n    valid_states = [\"success\", \"pending\"]\n    failed_run = False\n\n    failed_steps = []\n\n    if distributor_status.lower() in possible_states:\n        if distributor_status.lower() not in valid_states:\n            failed_steps.append(\"ExecuteDistributorPackage\")\n            failed_run = True\n\n    if failed_run:\n        raise Exception(\n            f\"Failed to execute distributor package. Failed steps: {failed_steps} check the step's logs for more details\"\n        )"
      }
    }
  ],
  "outputs": [
    "HandlePreqrequisites.message",
    "HandlePreqrequisites.errorMessage"
  ]
}
