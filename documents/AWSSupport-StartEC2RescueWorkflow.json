{
  "schemaVersion": "0.3",
  "description": "The AWSSupport-StartEC2RescueWorkflow runbook runs the provided base64 encoded script (Bash or PowerShell) on a helper Amazon Elastic Compute Cloud (Amazon EC2) instance created to rescue your Amazon EC2 instance. The Amazon Elastic Block Store (Amazon EBS) root volume of your instance is attached and mounted to the helper instance, also known as the EC2Rescue instance. If your instance is Windows, provide a PowerShell script, otherwise, use Bash. The runbook sets some environment variables which you can use in your script. The environment variables contain information about the input you provided, as well as information about the offline EBS root volume. The offline volume is already mounted and ready to use. For example, you can save a Desired State Configuration file to an offline Windows root volume, or chroot to an offline Linux root volume and perform an offline remediation.",
  "assumeRole": "{{ AutomationAssumeRole }}",
  "parameters": {
    "InstanceId": {
      "type": "AWS::EC2::Instance::Id",
      "description": "(Required) ID of your EC2 instance. IMPORTANT: AWS Systems Manager Automation stops this instance. When the instance is stopped, any data stored in the RAM or the instance store volumes is lost, and the automatic public IPv4 address is released if you are not using an Elastic IP.",
      "allowedPattern": "^i-[a-z0-9]{8,17}$"
    },
    "OfflineScript": {
      "type": "String",
      "description": "(Required) The base64 encoded script to execute against the helper instance. Use Bash if your source instance is Linux, and PowerShell if it is Windows.",
      "allowedPattern": "^[a-zA-Z0-9+/]{3,}[=]{0,2}$"
    },
    "EC2RescueInstanceType": {
      "type": "String",
      "description": "(Optional) The EC2 instance type for the EC2Rescue instance.",
      "default": "t2.medium",
      "allowedValues": [
        "t2.small",
        "t2.medium",
        "t2.large",
        "t3.small",
        "t3.medium",
        "t3.large",
        "i3.large"
      ]
    },
    "SubnetId": {
      "type": "String",
      "description": "(Optional) The subnet ID for the EC2Rescue instance. By default, the same subnet where the provided instance resides is used. IMPORTANT: If you provide a custom subnet, it must be in the same Availability Zone as InstanceId, and it must allow access to the SSM endpoints.",
      "default": "SelectedInstanceSubnet",
      "allowedPattern": "^SelectedInstanceSubnet$|^CreateNewVPC$|^subnet-[a-z0-9]{8,17}$"
    },
    "S3BucketName": {
      "description": "(Optional) The Amazon S3 bucket name in your account where you want to upload the troubleshooting logs. Make sure the bucket policy does not grant unnecessary read/write permissions to parties that do not need access to the collected logs.",
      "type": "AWS::S3::Bucket::Name",
      "default": ""
    },
    "S3Prefix": {
      "type": "String",
      "description": "(Optional) A prefix for the Amazon S3 logs.",
      "default": "AWSSupport-EC2Rescue",
      "allowedPattern": "^[a-zA-Z0-9][-./a-zA-Z0-9]{0,255}$"
    },
    "AMIPrefix": {
      "type": "String",
      "description": "(Optional) A prefix for the backup AMI name.",
      "default": "AWSSupport-EC2Rescue",
      "allowedPattern": "[-._a-zA-Z0-9]{3,20}$"
    },
    "CreatePreEC2RescueBackup": {
      "type": "String",
      "description": "(Optional) Set it to True to create an AMI of InstanceId before executing the script. The AMI will persist after the automation completes. It is your responsibility to secure access to the AMI, or to delete it.",
      "default": "False",
      "allowedValues": [
        "True",
        "False"
      ]
    },
    "CreatePostEC2RescueBackup": {
      "type": "String",
      "description": "(Optional) Set it to True to create an AMI of InstanceId after executing the script, before starting it. The AMI will persist after the automation completes. It is your responsibility to secure access to the AMI, or to delete it.",
      "default": "False",
      "allowedValues": [
        "True",
        "False"
      ]
    },
    "UniqueId": {
      "type": "String",
      "description": "(Optional) A unique identifier for the workflow.",
      "default": "{{ automation:EXECUTION_ID }}"
    },
    "AutomationAssumeRole": {
      "type": "String",
      "description": "(Optional) The ARN of the role that allows Automation to perform the actions on your behalf. If no role is specified, Systems Manager Automation uses your IAM permissions to execute this document.",
      "default": ""
    }
  },
  "mainSteps": [
    {
      "name": "waitForInstanceStatus",
      "action": "aws:waitForAwsResourceProperty",
      "description": "Waits for the instance is in 'running' or 'stopped' state.",
      "onFailure": "Abort",
      "isCritical": true,
      "maxAttempts": 5,
      "timeoutSeconds": 600,
      "inputs": {
        "Service": "ec2",
        "Api": "DescribeInstances",
        "InstanceIds": [
          "{{ InstanceId }}"
        ],
        "PropertySelector": "Reservations[0].Instances[0].State.Name",
        "DesiredValues": [
          "running",
          "stopped"
        ]
      }
    },
    {
      "name": "describeInstance",
      "description": "Describes the provided instance.",
      "action": "aws:executeAwsApi",
      "onFailure": "Abort",
      "isCritical": true,
      "inputs": {
        "Service": "ec2",
        "Api": "DescribeInstances",
        "InstanceIds": [
          "{{ InstanceId }}"
        ]
      },
      "outputs": [
        {
          "Name": "RootDeviceName",
          "Selector": "$.Reservations[0].Instances[0].RootDeviceName",
          "Type": "String"
        },
        {
          "Name": "Architecture",
          "Selector": "$.Reservations[0].Instances[0].Architecture",
          "Type": "String"
        },
        {
          "Name": "State",
          "Selector": "$.Reservations[0].Instances[0].State.Name",
          "Type": "String"
        },
        {
          "Name": "SubnetId",
          "Selector": "$.Reservations[0].Instances[0].NetworkInterfaces[0].SubnetId",
          "Type": "String"
        },
        {
          "Name": "Platform",
          "Selector": "$.Reservations[0].Instances[0].Platform",
          "Type": "String"
        },
        {
          "Name": "AvailabilityZone",
          "Selector": "$.Reservations[0].Instances[0].Placement.AvailabilityZone",
          "Type": "String"
        },
        {
          "Name": "InstanceLifecycle",
          "Selector": "$.Reservations[0].Instances[0].InstanceLifecycle",
          "Type": "String"
        }
      ]
    },
    {
      "name": "describeInstanceRootVolume",
      "action": "aws:executeAwsApi",
      "description": "Describes the provided instance's EBS root volume.",
      "onFailure": "Abort",
      "isCritical": true,
      "inputs": {
        "Service": "ec2",
        "Api": "DescribeVolumes",
        "Filters": [
          {
            "Name": "attachment.instance-id",
            "Values": [
              "{{ InstanceId }}"
            ]
          },
          {
            "Name": "attachment.device",
            "Values": [
              "{{ describeInstance.RootDeviceName }}"
            ]
          }
        ]
      },
      "outputs": [
        {
          "Name": "RootDeviceVolumeId",
          "Selector": "$.Volumes[0].Attachments[0].VolumeId",
          "Type": "String"
        },
        {
          "Name": "RootDeviceDeleteOnTermination",
          "Selector": "$.Volumes[0].Attachments[0].DeleteOnTermination",
          "Type": "Boolean"
        }
      ]
    },
    {
      "name": "assertInstanceRootVolumeIsEbs",
      "action": "aws:assertAwsResourceProperty",
      "description": "Checks the EBS root volume device type is EBS.",
      "onFailure": "Abort",
      "isCritical": true,
      "inputs": {
        "Service": "ec2",
        "Api": "DescribeInstances",
        "InstanceIds": [
          "{{ InstanceId }}"
        ],
        "PropertySelector": "$.Reservations[0].Instances[0].RootDeviceType",
        "DesiredValues": [
          "ebs"
        ]
      }
    },
    {
      "name": "assertInstanceRootVolumeIsNotEncrypted",
      "action": "aws:assertAwsResourceProperty",
      "description": "Checks the EBS root volume is not encrypted.",
      "onFailure": "Abort",
      "isCritical": true,
      "inputs": {
        "Service": "ec2",
        "Api": "DescribeVolumes",
        "Filters": [
          {
            "Name": "attachment.instance-id",
            "Values": [
              "{{ InstanceId }}"
            ]
          },
          {
            "Name": "attachment.device",
            "Values": [
              "{{ describeInstance.RootDeviceName }}"
            ]
          }
        ],
        "PropertySelector": "$.Volumes[0].Encrypted",
        "DesiredValues": [
          "False"
        ]
      }
    },
    {
      "name": "assertInstanceStopBehaviorIsStop",
      "action": "aws:assertAwsResourceProperty",
      "onFailure": "Abort",
      "isCritical": true,
      "description": "Ensures the provided instance's shutdown behavior is 'stop' and not 'terminate'.",
      "inputs": {
        "Service": "ec2",
        "Api": "DescribeInstanceAttribute",
        "InstanceId": "{{ InstanceId }}",
        "Attribute": "instanceInitiatedShutdownBehavior",
        "PropertySelector": "$.InstanceInitiatedShutdownBehavior.Value",
        "DesiredValues": [
          "stop"
        ]
      }
    },
    {
      "name": "assertNotFromMarketPlace",
      "action": "aws:assertAwsResourceProperty",
      "description": "Ensures the provided instance's does not have an AWS Marketplace product code associated.",
      "onFailure": "Abort",
      "isCritical": true,
      "inputs": {
        "Service": "ec2",
        "Api": "DescribeInstances",
        "InstanceIds": [
          "{{ InstanceId }}"
        ],
        "PropertySelector": "$.Reservations[0].Instances[0].ProductCodes",
        "DesiredValues": [
          "[]"
        ]
      }
    },
    {
      "name": "assertInstanceLifecycleIsNotSpot",
      "action": "aws:branch",
      "description": "Ensures the provided instance's Lifecycle is not 'Spot'.",
      "isEnd": true,
      "isCritical": true,
      "inputs": {
        "Choices": [
          {
            "NextStep": "assertNotPartOfAutoScalingGroup",
            "Not": {
              "Variable": "{{ describeInstance.InstanceLifecycle }}",
              "StringEquals": "spot"
            }
          }
        ]
      }
    },
    {
      "name": "assertNotPartOfAutoScalingGroup",
      "action": "aws:executeScript",
      "onFailure": "Abort",
      "isCritical": true,
      "description": "Ensures the provided instance is not part of an Amazon EC2 Auto Scaling group by calling the 'DescribeAutoScalingInstances' API. If the instance is part of an Amazon EC2 Auto Scaling group, ensures the EC2 instance is in 'Standby' lifecycle state.",
      "timeoutSeconds": 600,
      "inputs": {
        "Runtime": "python3.8",
        "Handler": "check_autoscaling_resource",
        "InputPayload": {
          "InstanceId": "{{ InstanceId }}"
        },
        "Script": "# Copyright 2022 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n# SPDX-License-Identifier: LicenseRef-.amazon.com.-AmznSL-1.0\n# Licensed under the Amazon Software License  http://aws.amazon.com/asl/\n\nimport sys\nimport boto3\nfrom botocore.exceptions import ClientError\n\nsys.tracebacklimit = 0\nautoscaling = boto3.client('autoscaling')\n\n\ndef check_autoscaling_resource(events, context):\n\n    try:\n        instances = autoscaling.describe_auto_scaling_instances(\n            InstanceIds=[events['InstanceId']]\n        )['AutoScalingInstances']\n        if instances and instances[0]['LifecycleState'] not in ['Standby']:\n            raise Exception(\n                'The target EC2 instance is part of an EC2 Auto Scaling Group and not in \"Standby\" lifecycle state')\n        else:\n            return\n\n    except ClientError as e:\n        c = e.response['Error']['Code']\n        m = e.response['Error']['Message']\n        raise Exception(\n            f'An error occurred when describing Auto Scaling instances: {c}:{m}')\n"
      }
    },
    {
      "name": "branchOnSubnetId",
      "action": "aws:branch",
      "description": "Branches the automation depending on whether a custom subnet ID for the target EC2 instance.",
      "onFailure": "Abort",
      "isCritical": true,
      "inputs": {
        "Choices": [
          {
            "NextStep": "ensureNoConcurrentExecutionsForTheInstance",
            "Variable": "{{ SubnetId }}",
            "StringEquals": "SelectedInstanceSubnet"
          },
          {
            "NextStep": "ensureNoConcurrentExecutionsForTheInstance",
            "Variable": "{{ SubnetId }}",
            "StringEquals": "CreateNewVPC"
          }
        ],
        "Default": "assertCustomSubnetIsInSameAZAsInstance"
      }
    },
    {
      "name": "assertCustomSubnetIsInSameAZAsInstance",
      "action": "aws:assertAwsResourceProperty",
      "description": "Checks the provided subnet is in the same Availability Zone as the provided instance.",
      "onFailure": "Abort",
      "isCritical": true,
      "inputs": {
        "Service": "ec2",
        "Api": "DescribeSubnets",
        "SubnetIds": [
          "{{ SubnetId }}"
        ],
        "PropertySelector": "$.Subnets[0].AvailabilityZone",
        "DesiredValues": [
          "{{ describeInstance.AvailabilityZone }}"
        ]
      }
    },
    {
      "name": "ensureNoConcurrentExecutionsForTheInstance",
      "action": "aws:executeScript",
      "description": "Ensures there is only one execution of this runbook targeting the provided EC2 instance. If the runbook finds another in progress execution targeting the same instance ID, it returns an error and ends.",
      "onFailure": "Abort",
      "maxAttempts": 3,
      "isCritical": true,
      "inputs": {
        "Runtime": "python3.8",
        "Handler": "check_concurrency",
        "InputPayload": {
          "InstanceId": "{{ InstanceId }}"
        },
        "Script": "# Copyright 2022 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n# SPDX-License-Identifier: LicenseRef-.amazon.com.-AmznSL-1.0\n# Licensed under the Amazon Software License  http://aws.amazon.com/asl/\n\nimport sys\nimport boto3\nfrom datetime import datetime, timezone\nfrom botocore.exceptions import ClientError\nfrom botocore.config import Config\n\nconfig = Config(\n   retries = {\n      'max_attempts': 10,\n      'mode': 'standard'\n   }\n)\n\nsys.tracebacklimit = 0\nssm = boto3.client('ssm', config=config)\n\n\ndef check_concurrency(events, context):\n\n    try:\n        # Get the current execution details\n        current_execution = ssm.describe_automation_executions(\n            Filters=[{'Key': 'ExecutionId',\n                      'Values': [context['automation:EXECUTION_ID']]}])['AutomationExecutionMetadataList'][0]\n\n        current_execution_id = current_execution['AutomationExecutionId']\n\n        # Get the target of execution (Instance ID)\n        if current_execution.get('Target'):\n            instance_id = current_execution['Target']\n        else:\n            instance_id = next(iter(ssm.get_automation_execution(AutomationExecutionId=current_execution_id)[\n                               'AutomationExecution'].get('Parameters', []).get('InstanceId', [])), '')\n\n        # Parent automations do not have a Target or instance parameter set. We just return.\n        if not instance_id:\n            return\n\n        # Check for other previous/older running automations for the same current document that are in progress\n        current_execution_start_time = datetime.fromtimestamp(\n            current_execution['ExecutionStartTime'].timestamp(), timezone.utc)\n        document_executions = ssm.describe_automation_executions(\n            Filters=[{'Key': 'DocumentNamePrefix', 'Values': [current_execution['DocumentName']]},\n                     {'Key': 'ExecutionStatus', 'Values': ['InProgress']},\n                     {'Key': 'StartTimeBefore', 'Values': [\n                         current_execution_start_time.strftime('%Y-%m-%dT%H:%M:%SZ')]}\n                     ])['AutomationExecutionMetadataList']\n\n        # Check for other previous executions targetting the same instance ID. If any, return an error\n        for execution in document_executions:\n            execution_id = execution['AutomationExecutionId']\n            if execution_id != current_execution_id:\n                if execution.get('Target', '') == instance_id:\n                    raise Exception('There is another execution of this document already in progress for {} with id {}'.format(\n                        instance_id, execution['AutomationExecutionId']))\n\n                execution_details = ssm.get_automation_execution(AutomationExecutionId=execution_id)[\n                    'AutomationExecution'].get('Parameters', []).get('InstanceId', [])\n                execution_instance_id = next(iter(execution_details), '')\n                if execution_instance_id == instance_id:\n                    raise Exception('There is another execution of this document already in progress for {} with id {}'.format(\n                        instance_id, execution['AutomationExecutionId']))\n\n    except ClientError as e:\n        c = e.response['Error']['Code']\n        m = e.response['Error']['Message']\n        raise Exception(\n            f'An error occurred when checking concurrent executions: {c}:{m}')\n\n    return\n"
      }
    },
    {
      "name": "stageEC2RescueAutomation",
      "action": "aws:createStack",
      "description": "Deploys the EC2Rescue CloudFormation stack.",
      "onFailure": "step:describeCloudFormationErrorFromStackEvents",
      "isCritical": true,
      "inputs": {
        "StackName": "AWSSupport-EC2Rescue-{{ UniqueId }}",
        "TemplateBody": "# Copyright 2022 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n# SPDX-License-Identifier: LicenseRef-.amazon.com.-AmznSL-1.0\n# Licensed under the Amazon Software License  http://aws.amazon.com/asl/\n\nAWSTemplateFormatVersion: 2010-09-09\nDescription: Creates a helper instance in the specified AZ or subnet\nParameters:\n  AZ:\n    Description: AZ in the current region.\n    Type: String\n    Default: ''\n  Architecture:\n    Type: String\n    AllowedValues:\n      - arm64\n      - x86_64\n  CurrentSubnetId:\n    Description: Current instance subnet ID.\n    Type: AWS::EC2::Subnet::Id\n  SubnetId:\n    Description: Existing subnet ID. If specified, no VPC is created.\n    Type: String\n    Default: ''\n  Platform:\n    Description: Source instance's platform.\n    Type: String\n    Default: ''\n  S3BucketName:\n    Description: S3 bucket name to upload troubleshooting logs to.\n    Type: String\n    Default: ''\n  S3Prefix:\n    Description: S3 bucket prefix to upload troubleshooting logs to.\n    Type: String\n    Default: ''\n  ExecutionId:\n    Description: Systems Manager Automation Execution ID.\n    Type: String\n    Default: ''\n  HelperInstanceWindowsAMI:\n    Description: Rescue instance AMI ID.\n    Type: 'AWS::SSM::Parameter::Value<AWS::EC2::Image::Id>'\n    Default: /aws/service/ami-windows-latest/Windows_Server-2019-English-Full-Base\n  HelperInstanceLinuxAMI:\n    Description: Rescue instance AMI ID.\n    Type: 'AWS::SSM::Parameter::Value<AWS::EC2::Image::Id>'\n    Default: /aws/service/ami-amazon-linux-latest/amzn-ami-hvm-x86_64-gp2\n  HelperInstanceARMLinuxAMI:\n    Description: Rescue instance AMI ID.\n    Type: 'AWS::SSM::Parameter::Value<AWS::EC2::Image::Id>'\n    Default: /aws/service/ami-amazon-linux-latest/amzn2-ami-hvm-arm64-gp2\n  CustomAMI:\n    Type: String\n    Description: (Optional) Custom AMI to use for the rescue instance.\n    ConstraintDescription: Must be a valid AMI ID.\n    Default: ''\n  HelperInstanceType:\n    Description: >-\n      The EC2 instance type for the EC2Rescue Windows instance.\n    Type: String\n    Default: t3.small\n    ConstraintDescription: Must be a valid EC2 instance type.\n  CreateHelperInstance:\n    Description: 'Confirm that you want to create the helper instance. Default: False'\n    Type: String\n    Default: 'False'\n    AllowedValues:\n      - 'True'\n      - 'False'\nConditions:\n  ArchitectureIsARM: !Equals \n    - !Ref Architecture\n    - arm64\n  CreateHelperInstance: !Equals \n    - !Ref CreateHelperInstance\n    - 'True'\n  UseWindowsAMI: !Equals \n    - !Ref Platform\n    - windows\n  UseCustomAMI: !Not \n    - !Equals \n      - !Ref CustomAMI\n      - ''\n  UseS3: !Not \n    - !Equals \n      - !Ref S3BucketName\n      - ''\n  NeedVPC: !Equals \n    - !Ref SubnetId\n    - 'CreateNewVPC'\n  UseInstanceSubnet: !Equals \n    - !Ref SubnetId\n    - 'SelectedInstanceSubnet'\nResources:\n  EC2RescueEC2Role:\n    Type: 'AWS::IAM::Role'\n    Properties:\n      RoleName: !Sub 'AWSSupport-EC2Rescue-EC2Role${ExecutionId}'\n      AssumeRolePolicyDocument:\n        Version: 2012-10-17\n        Statement:\n          - Effect: Allow\n            Principal:\n              Service: ec2.amazonaws.com\n            Action: 'sts:AssumeRole'\n      Policies:\n        - PolicyName: AWSSupport-EC2Rescue-EC2Role_Permissions\n          PolicyDocument:\n            Version: 2012-10-17\n            Statement:\n              - Sid: LinuxOfflineSSHKeyResetPermissions\n                Action:\n                  - 'ssm:PutParameter'\n                  - 'kms:Encrypt'\n                Resource: '*'\n                Effect: Allow\n        - PolicyName: AWSSupport-EC2Rescue-EC2Role_Read_S3_Permissions\n          PolicyDocument:\n            Version: 2012-10-17\n            Statement:\n              - Sid: S3ReadPermissions\n                Action:\n                  - 's3:GetBucketLocation'\n                  - 's3:GetObject'\n                  - 's3:GetEncryptionConfiguration'\n                  - 's3:ListMultipartUploadParts'\n                  - 's3:ListBucket'\n                  - 's3:ListBucketMultipartUploads'\n                Resource: '*'\n                Effect: Allow\n        - !If \n          - UseS3\n          - PolicyName: AWSSupport-EC2Rescue-EC2Role_Write_S3_Permissions\n            PolicyDocument:\n              Version: 2012-10-17\n              Statement:\n                - Sid: S3WritePermissions\n                  Action:\n                    - 's3:PutObject'\n                    - 's3:AbortMultipartUpload'\n                  Resource: !Sub 'arn:${AWS::Partition}:s3:::${S3BucketName}/${S3Prefix}/*'\n                  Effect: Allow\n          - !Ref 'AWS::NoValue'\n      ManagedPolicyArns:\n        - !Sub 'arn:${AWS::Partition}:iam::aws:policy/AmazonSSMManagedInstanceCore'\n        - !Sub 'arn:${AWS::Partition}:iam::aws:policy/AmazonSSMPatchAssociation'\n  EC2RescueInstanceProfile:\n    Type: 'AWS::IAM::InstanceProfile'\n    Properties:\n      Roles:\n        - !Ref EC2RescueEC2Role\n      InstanceProfileName: !Sub 'AWSSupport-EC2Rescue-EC2Role${ExecutionId}'\n  HelperEc2InstanceLaunchTemplate:\n    Type: AWS::EC2::LaunchTemplate\n    Properties:\n      LaunchTemplateData:\n        MetadataOptions:\n          HttpEndpoint: enabled\n          HttpTokens: optional\n  HelperInstance:\n    Condition: CreateHelperInstance\n    Type: 'AWS::EC2::Instance'\n    Properties:\n      ImageId: !If \n        - UseCustomAMI\n        - !Ref CustomAMI\n        - !If \n          - UseWindowsAMI\n          - !Ref HelperInstanceWindowsAMI\n          - !If\n            - ArchitectureIsARM\n            - !Ref HelperInstanceARMLinuxAMI\n            - !Ref HelperInstanceLinuxAMI\n      LaunchTemplate:\n        LaunchTemplateId: !Ref HelperEc2InstanceLaunchTemplate\n        Version: !GetAtt HelperEc2InstanceLaunchTemplate.LatestVersionNumber\n      InstanceType: !Ref HelperInstanceType\n      PropagateTagsToVolumeOnCreation: true\n      NetworkInterfaces:\n        - AssociatePublicIpAddress: true\n          DeleteOnTermination: true\n          DeviceIndex: '0'\n          SubnetId: !If \n            - NeedVPC\n            - !Ref Subnet\n            - !If\n              - UseInstanceSubnet\n              - !Ref CurrentSubnetId\n              - !Ref SubnetId\n      IamInstanceProfile: !Ref EC2RescueInstanceProfile\n  EC2RescueVPC:\n    Condition: NeedVPC\n    Type: 'AWS::EC2::VPC'\n    Properties:\n      CidrBlock: 172.31.0.0/16\n      InstanceTenancy: default\n      EnableDnsSupport: true\n      EnableDnsHostnames: true\n      Tags:\n        - Key: Name\n          Value: AWSSupport-EC2Rescue-VPC\n  Subnet:\n    Condition: NeedVPC\n    Type: 'AWS::EC2::Subnet'\n    Properties:\n      VpcId: !Ref EC2RescueVPC\n      CidrBlock: 172.31.0.0/24\n      AvailabilityZone: !Ref AZ\n      MapPublicIpOnLaunch: true\n      Tags:\n        - Key: Name\n          Value: AWSSupport-EC2Rescue-Subnet\n  InternetGateway:\n    Condition: NeedVPC\n    Type: 'AWS::EC2::InternetGateway'\n    Properties:\n      Tags:\n        - Key: Name\n          Value: AWSSupport-EC2Rescue-IGW\n  GatewayToInternet:\n    Condition: NeedVPC\n    Type: 'AWS::EC2::VPCGatewayAttachment'\n    Properties:\n      VpcId: !Ref EC2RescueVPC\n      InternetGatewayId: !Ref InternetGateway\n  PublicRouteTable:\n    Condition: NeedVPC\n    Type: 'AWS::EC2::RouteTable'\n    Properties:\n      VpcId: !Ref EC2RescueVPC\n      Tags:\n        - Key: Name\n          Value: AWSSupport-EC2Rescue-RT\n        - Key: Network\n          Value: Public\n  PublicRoute:\n    Condition: NeedVPC\n    DependsOn: GatewayToInternet\n    Type: 'AWS::EC2::Route'\n    Properties:\n      RouteTableId: !Ref PublicRouteTable\n      DestinationCidrBlock: 0.0.0.0/0\n      GatewayId: !Ref InternetGateway\n  PublicSubnetRouteTableAssociation:\n    Condition: NeedVPC\n    Type: 'AWS::EC2::SubnetRouteTableAssociation'\n    Properties:\n      SubnetId: !Ref Subnet\n      RouteTableId: !Ref PublicRouteTable\nOutputs:\n  HelperInstanceId:\n    Condition: CreateHelperInstance\n    Value: !Ref HelperInstance\n",
        "Capabilities": [
          "CAPABILITY_NAMED_IAM"
        ],
        "ClientRequestToken": "AWSSupport-EC2Rescue-{{ UniqueId }}",
        "Parameters": [
          {
            "ParameterKey": "CreateHelperInstance",
            "ParameterValue": "True"
          },
          {
            "ParameterKey": "Architecture",
            "ParameterValue": "{{ describeInstance.Architecture }}"
          },
          {
            "ParameterKey": "AZ",
            "ParameterValue": "{{ describeInstance.AvailabilityZone }}"
          },
          {
            "ParameterKey": "SubnetId",
            "ParameterValue": "{{ SubnetId }}"
          },
          {
            "ParameterKey": "CurrentSubnetId",
            "ParameterValue": "{{ describeInstance.SubnetId }}"
          },
          {
            "ParameterKey": "S3BucketName",
            "ParameterValue": "{{ S3BucketName }}"
          },
          {
            "ParameterKey": "S3Prefix",
            "ParameterValue": "{{ S3Prefix }}"
          },
          {
            "ParameterKey": "HelperInstanceType",
            "ParameterValue": "{{ EC2RescueInstanceType }}"
          },
          {
            "ParameterKey": "Platform",
            "ParameterValue": "{{ describeInstance.Platform }}"
          },
          {
            "ParameterKey": "ExecutionId",
            "ParameterValue": "{{ UniqueId }}"
          }
        ],
        "Tags": [
          {
            "Key": "Name",
            "Value": "AWSSupport-EC2Rescue: {{ InstanceId }}"
          },
          {
            "Key": "AWSSupport-EC2Rescue-AutomationExecution",
            "Value": "{{ UniqueId }}"
          }
        ]
      },
      "outputs": [
        {
          "Name": "CloudFormationStackId",
          "Selector": "$.StackId",
          "Type": "String"
        }
      ]
    },
    {
      "name": "waitForEC2RescueInstanceCreation",
      "action": "aws:waitForAwsResourceProperty",
      "description": "Waits for the EC2Rescue CloudFormation stack update to complete.",
      "onFailure": "step:describeCloudFormationErrorFromStackEvents",
      "isCritical": true,
      "maxAttempts": 5,
      "timeoutSeconds": 600,
      "inputs": {
        "Service": "cloudformation",
        "Api": "DescribeStacks",
        "StackName": "{{ stageEC2RescueAutomation.CloudFormationStackId }}",
        "PropertySelector": "$.Stacks[0].StackStatus",
        "DesiredValues": [
          "UPDATE_COMPLETE",
          "CREATE_COMPLETE"
        ]
      }
    },
    {
      "name": "describeEC2RescueInstance",
      "action": "aws:executeAwsApi",
      "description": "Describes the EC2Rescue CloudFormation stack resources to obtain the EC2Rescue helper instance ID.",
      "onFailure": "step:describeCloudFormationErrorFromStackEvents",
      "isCritical": true,
      "inputs": {
        "Service": "cloudformation",
        "Api": "DescribeStackResource",
        "StackName": "{{ stageEC2RescueAutomation.CloudFormationStackId }}",
        "LogicalResourceId": "HelperInstance"
      },
      "outputs": [
        {
          "Name": "EC2RescueInstanceId",
          "Selector": "$.StackResourceDetail.PhysicalResourceId",
          "Type": "String"
        }
      ]
    },
    {
      "name": "waitForEC2RescueInstanceToBeManaged",
      "action": "aws:waitForAwsResourceProperty",
      "description": "Waits for the EC2Rescue helper instance to become a managed instance.",
      "onFailure": "step:rebootEC2RescueInstance",
      "isCritical": false,
      "timeoutSeconds": 600,
      "inputs": {
        "Service": "ssm",
        "Api": "DescribeInstanceInformation",
        "InstanceInformationFilterList": [
          {
            "key": "InstanceIds",
            "valueSet": [
              "{{ describeEC2RescueInstance.EC2RescueInstanceId }}"
            ]
          }
        ],
        "PropertySelector": "$.InstanceInformationList[0].PingStatus",
        "DesiredValues": [
          "Online"
        ]
      },
      "nextStep": "setRootVolumeDeleteOnTerminationToFalse"
    },
    {
      "name": "rebootEC2RescueInstance",
      "action": "aws:executeAwsApi",
      "description": "Reboots the EC2Rescue helper instance if failed to become a managed instance.",
      "onFailure": "step:waitForCloudFormationStack",
      "isCritical": true,
      "inputs": {
        "Service": "ec2",
        "Api": "RebootInstances",
        "InstanceIds": [
          "{{ describeEC2RescueInstance.EC2RescueInstanceId }}"
        ]
      }
    },
    {
      "name": "waitAgainForEC2RescueInstanceToBeManaged",
      "action": "aws:waitForAwsResourceProperty",
      "description": "Waits again for the EC2Rescue helper instance to become a managed instance.",
      "onFailure": "step:waitForCloudFormationStack",
      "isCritical": true,
      "timeoutSeconds": 600,
      "inputs": {
        "Service": "ssm",
        "Api": "DescribeInstanceInformation",
        "InstanceInformationFilterList": [
          {
            "key": "InstanceIds",
            "valueSet": [
              "{{ describeEC2RescueInstance.EC2RescueInstanceId }}"
            ]
          }
        ],
        "PropertySelector": "$.InstanceInformationList[0].PingStatus",
        "DesiredValues": [
          "Online"
        ]
      }
    },
    {
      "name": "setRootVolumeDeleteOnTerminationToFalse",
      "onFailure": "step:restoreInstanceRootVolumeDeleteOnTerminationState",
      "isCritical": true,
      "action": "aws:executeAwsApi",
      "description": "Sets the delete on termination attribute for the root volume of the provided instance to 'false'.",
      "inputs": {
        "Service": "ec2",
        "Api": "ModifyInstanceAttribute",
        "InstanceId": "{{ InstanceId }}",
        "BlockDeviceMappings": [
          {
            "DeviceName": "{{ describeInstance.RootDeviceName }}",
            "Ebs": {
              "DeleteOnTermination": false,
              "VolumeId": "{{ describeInstanceRootVolume.RootDeviceVolumeId }}"
            }
          }
        ]
      }
    },
    {
      "name": "stopInstance",
      "action": "aws:changeInstanceState",
      "description": "Stops the provided instance.",
      "onFailure": "step:forceStopInstance",
      "inputs": {
        "InstanceIds": [
          "{{ InstanceId }}"
        ],
        "CheckStateOnly": false,
        "DesiredState": "stopped"
      },
      "isCritical": false,
      "nextStep": "branchOnPreEC2RescueBackup"
    },
    {
      "name": "forceStopInstance",
      "action": "aws:changeInstanceState",
      "description": "Forces stop the provided instance.",
      "onFailure": "step:restoreInstanceRootVolumeDeleteOnTerminationState",
      "isCritical": true,
      "inputs": {
        "InstanceIds": [
          "{{ InstanceId }}"
        ],
        "CheckStateOnly": false,
        "DesiredState": "stopped",
        "Force": true
      }
    },
    {
      "name": "branchOnPreEC2RescueBackup",
      "action": "aws:branch",
      "description": "Checks the CreatePreEC2RescueBackup input value. Creates a pre-EC2Rescue backup If 'CreatePreEC2RescueBackup' is equal to 'True'.",
      "onFailure": "Continue",
      "isCritical": true,
      "inputs": {
        "Choices": [
          {
            "NextStep": "preScriptBackup",
            "Variable": "{{ CreatePreEC2RescueBackup }}",
            "StringEquals": "True"
          }
        ],
        "Default": "installEC2RescueOnEC2RescueInstance"
      }
    },
    {
      "name": "preScriptBackup",
      "action": "aws:executeAwsApi",
      "description": "Creates an AMI backup of the provided instance.",
      "onFailure": "step:restoreInstanceRootVolumeDeleteOnTerminationState",
      "isCritical": true,
      "inputs": {
        "Service": "ec2",
        "Api": "CreateImage",
        "InstanceId": "{{ InstanceId }}",
        "Description": "Pre-Script Backup AMI Generated by Automation on {{ global:DATE_TIME }} from {{ InstanceId }}.",
        "NoReboot": false,
        "Name": "{{ AMIPrefix }}-Pre-Script-Backup_{{ InstanceId }}_{{ global:DATE_TIME }}"
      },
      "outputs": [
        {
          "Name": "ImageId",
          "Selector": "$.ImageId",
          "Type": "String"
        }
      ]
    },
    {
      "name": "tagPreScriptBackup",
      "action": "aws:createTags",
      "description": "Tags the AMI backup.",
      "onFailure": "Continue",
      "isCritical": false,
      "inputs": {
        "ResourceType": "EC2",
        "ResourceIds": [
          "{{ preScriptBackup.ImageId }}"
        ],
        "Tags": [
          {
            "Key": "Name",
            "Value": "AWSSupport-EC2Rescue: {{ InstanceId }}"
          },
          {
            "Key": "AWSSupport-EC2Rescue-AutomationExecution",
            "Value": "{{ UniqueId }}"
          }
        ]
      }
    },
    {
      "name": "installEC2RescueOnEC2RescueInstance",
      "action": "aws:runCommand",
      "description": "Installs EC2Rescue on the EC2Rescue helper instance.",
      "onFailure": "step:restoreInstanceRootVolumeDeleteOnTerminationState",
      "isCritical": true,
      "inputs": {
        "DocumentName": "AWS-ConfigureAWSPackage",
        "InstanceIds": [
          "{{ describeEC2RescueInstance.EC2RescueInstanceId }}"
        ],
        "Parameters": {
          "name": "AWSSupport-EC2Rescue",
          "action": "Install",
          "version": "latest"
        }
      }
    },
    {
      "name": "detachInstanceRootVolume",
      "action": "aws:executeAwsApi",
      "isCritical": true,
      "description": "Detaches the EBS root volume from the provided instance.",
      "onFailure": "Continue",
      "inputs": {
        "Service": "ec2",
        "Api": "DetachVolume",
        "VolumeId": "{{ describeInstanceRootVolume.RootDeviceVolumeId }}"
      }
    },
    {
      "name": "waitForInstanceRootVolumeToBeDetached",
      "action": "aws:waitForAwsResourceProperty",
      "description": "Waits until the EBS root volume is in 'available' state.",
      "onFailure": "Continue",
      "isCritical": true,
      "inputs": {
        "Service": "ec2",
        "Api": "DescribeVolumes",
        "VolumeIds": [
          "{{ describeInstanceRootVolume.RootDeviceVolumeId }}"
        ],
        "PropertySelector": "$.Volumes[0].State",
        "DesiredValues": [
          "available"
        ]
      }
    },
    {
      "name": "branchOnPlatform",
      "action": "aws:branch",
      "description": "Branches on the provided instance platform.",
      "onFailure": "step:stopEC2RescueInstance",
      "isCritical": true,
      "inputs": {
        "Choices": [
          {
            "NextStep": "attachInstanceRootVolumeToWindowsEC2RescueInstance",
            "Variable": "{{ describeInstance.Platform }}",
            "StringEquals": "windows"
          }
        ],
        "Default": "attachInstanceRootVolumeToLinuxEC2RescueInstance"
      }
    },
    {
      "name": "attachInstanceRootVolumeToWindowsEC2RescueInstance",
      "action": "aws:executeAwsApi",
      "description": "Attaches the EBS root volume to the Windows EC2Rescue helper instance as *xvdf*.",
      "onFailure": "Continue",
      "isCritical": true,
      "inputs": {
        "Service": "ec2",
        "Api": "AttachVolume",
        "Device": "xvdf",
        "InstanceId": "{{ describeEC2RescueInstance.EC2RescueInstanceId }}",
        "VolumeId": "{{ describeInstanceRootVolume.RootDeviceVolumeId }}"
      }
    },
    {
      "name": "waitForInstanceRootVolumeToBeAttachedToWindowsEC2RescueInstance",
      "action": "aws:waitForAwsResourceProperty",
      "description": "Waits for the EBS root volume status is 'in-use.",
      "onFailure": "Continue",
      "isCritical": true,
      "inputs": {
        "Service": "ec2",
        "Api": "DescribeVolumes",
        "VolumeIds": [
          "{{ describeInstanceRootVolume.RootDeviceVolumeId }}"
        ],
        "PropertySelector": "$.Volumes[0].State",
        "DesiredValues": [
          "in-use"
        ]
      }
    },
    {
      "name": "waitBeforeRunningScriptForWindows",
      "action": "aws:sleep",
      "description": "Sleeps for 30 seconds.",
      "onFailure": "Continue",
      "inputs": {
        "Duration": "PT30S"
      },
      "isCritical": false
    },
    {
      "name": "runScriptForWindows",
      "action": "aws:runCommand",
      "description": "Runs the provided offline script in PowerShell.",
      "onFailure": "Continue",
      "isCritical": true,
      "inputs": {
        "DocumentName": "AWS-RunPowerShellScript",
        "InstanceIds": [
          "{{ describeEC2RescueInstance.EC2RescueInstanceId }}"
        ],
        "Parameters": {
          "commands": [
            "Import-Module EC2Rescue",
            "",
            "try {",
            "    #region Set volume online and set global variables for the system",
            "    $env:EC2RESCUE_OFFLINE_EBS_DEVICE = \"xvdf\"",
            "    $env:EC2RESCUE_EC2RW_DIR = \"${env:PROGRAMFILES}\\Amazon\\EC2Rescue\"",
            "    $originalDrives = Get-PSDrive -PSProvider FileSystem",
            "    & \"${env:EC2RESCUE_EC2RW_DIR}\\EC2RescueCmd.exe\" /accepteula /offline:${env:EC2RESCUE_OFFLINE_EBS_DEVICE} /rescue:all /check-only /no-offline /no-fix-signature | Out-Null",
            "    $newDrives = Get-PSDrive -PSProvider FileSystem",
            "    $driveLetters = (Compare-Object $newDrives $originalDrives).InputObject.Name",
            "    if ($driveLetters) {",
            "        Write-Host \"Device $env:EC2RESCUE_OFFLINE_EBS_DEVICE mapped to $driveLetters\";",
            "        foreach ($driveLetter in $driveLetters) {",
            "            $OfflineWindowsInstall = Get-WindowsInstallData -OfflineWinDrive $driveLetter -IgnoreFailure",
            "            if ($OfflineWindowsInstall) {",
            "                $env:EC2RESCUE_ACCOUNT_ID = \"{{ global:ACCOUNT_ID }}\"",
            "                $env:EC2RESCUE_DATE = \"{{ global:DATE }}\"",
            "                $env:EC2RESCUE_DATE_TIME = \"{{ global:DATE_TIME }}\"",
            "                $env:EC2RESCUE_EXECUTION_ID = \"{{ automation:EXECUTION_ID }}\"",
            "                $env:EC2RESCUE_OFFLINE_CURRENT_CONTROL_SET = $OfflineWindowsInstall.CurrentControlSet",
            "                $env:EC2RESCUE_OFFLINE_DRIVE = $OfflineWindowsInstall.OfflineWindowsDrive",
            "                #$env:EC2RESCUE_OFFLINE_EBS_DEVICE set earlier in the script",
            "                $env:EC2RESCUE_OFFLINE_KERNEL_VER = $OfflineWindowsInstall.KernelVer",
            "                $env:EC2RESCUE_OFFLINE_OS_ARCHITECTURE = $OfflineWindowsInstall.OSArchitecture",
            "                $env:EC2RESCUE_OFFLINE_OS_TYPE = $OfflineWindowsInstall.OSType",
            "                $env:EC2RESCUE_OFFLINE_OS_CAPTION = $OfflineWindowsInstall.OSCaption",
            "                $env:EC2RESCUE_OFFLINE_PROGRAM_FILES_DIR = $OfflineWindowsInstall.ProgramFilesDir",
            "                $env:EC2RESCUE_OFFLINE_PROGRAM_FILES_X86_DIR = $OfflineWindowsInstall.ProgramFilesDirx86",
            "                $env:EC2RESCUE_OFFLINE_REGISTRY_DIR = $OfflineWindowsInstall.RegistryDir",
            "                $env:EC2RESCUE_OFFLINE_SYSTEM_ROOT = $OfflineWindowsInstall.SystemRoot",
            "                #$env:EC2RESCUE_PATH already set during package installation",
            "                $env:EC2RESCUE_REGION = \"{{ global:REGION }}\"",
            "                $env:EC2RESCUE_S3_BUCKET = \"{{ S3BucketName }}\"",
            "                $env:EC2RESCUE_S3_PREFIX = \"{{ S3Prefix }}\"",
            "                $env:EC2RESCUE_SOURCE_INSTANCE = \"{{ InstanceId }}\"",
            "                Write-Host \"EC2Rescue environment variables set\";",
            "                $script:EC2RESCUE_OFFLINE_WINDOWS_INSTALL = $OfflineWindowsInstall",
            "                Write-Host \"EC2Rescue script variables set\";",
            "            }                    ",
            "        }",
            "    }",
            "    #endregion",
            "    ",
            "    #region Execute user-provided script",
            "    $scriptblock = [scriptblock]::Create([System.Text.Encoding]::ASCII.GetString([System.Convert]::FromBase64String('{{ OfflineScript }}')))",
            "    & $scriptblock",
            "    #endregion",
            "",
            "    #region Fix disk signature and set volume offline",
            "    & \"${env:EC2RESCUE_EC2RW_DIR}\\EC2RescueCmd.exe\" /accepteula /offline:${env:EC2RESCUE_OFFLINE_EBS_DEVICE} /rescue:all /check-only | Out-Null",
            "    Write-Host \"Volume successfully set offline\"",
            "    #endregion",
            "}",
            "catch {",
            "    Write-Host $_.Exception.Message",
            "    #Disk signature fix",
            "    & \"${env:EC2RESCUE_EC2RW_DIR}\\EC2RescueCmd.exe\" /accepteula /offline:${env:EC2RESCUE_OFFLINE_EBS_DEVICE} /rescue:all /check-only | Out-Null",
            "    exit 1",
            "}"
          ]
        }
      },
      "nextStep": "stopEC2RescueInstance"
    },
    {
      "name": "attachInstanceRootVolumeToLinuxEC2RescueInstance",
      "action": "aws:executeAwsApi",
      "description": "Attaches the EBS root volume back to Linux EC2Rescue helper instance as */dev/sdf*.",
      "onFailure": "Continue",
      "isCritical": true,
      "inputs": {
        "Service": "ec2",
        "Api": "AttachVolume",
        "Device": "/dev/sdf",
        "InstanceId": "{{ describeEC2RescueInstance.EC2RescueInstanceId }}",
        "VolumeId": "{{ describeInstanceRootVolume.RootDeviceVolumeId }}"
      }
    },
    {
      "name": "waitForInstanceRootVolumeToBeAttachedToLinuxEC2RescueInstance",
      "action": "aws:waitForAwsResourceProperty",
      "description": "Waits for the EBS root volume status is 'in-use.",
      "onFailure": "Continue",
      "isCritical": true,
      "inputs": {
        "Service": "ec2",
        "Api": "DescribeVolumes",
        "VolumeIds": [
          "{{ describeInstanceRootVolume.RootDeviceVolumeId }}"
        ],
        "PropertySelector": "$.Volumes[0].State",
        "DesiredValues": [
          "in-use"
        ]
      }
    },
    {
      "name": "waitBeforeRunningScriptForLinux",
      "action": "aws:sleep",
      "description": "Sleeps for 30 seconds.",
      "onFailure": "Continue",
      "inputs": {
        "Duration": "PT30S"
      },
      "isCritical": false,
      "nextStep": "runScriptForLinux"
    },
    {
      "name": "runScriptForLinux",
      "action": "aws:runCommand",
      "description": "Runs the provided offline script in Bash.",
      "onFailure": "Continue",
      "isCritical": true,
      "inputs": {
        "DocumentName": "AWS-RunShellScript",
        "InstanceIds": [
          "{{ describeEC2RescueInstance.EC2RescueInstanceId }}"
        ],
        "Parameters": {
          "commands": [
            "#!/bin/sh",
            "# {{ InstanceId }} -> instance to which the rescue volume belongs",
            "# {{ S3BucketName }} -> S3 bucket where the logs should be uploaded",
            "error_trap()",
            "{",
            "    if test -n \"$1\" ; then",
            "        printf \"%s\\\\n\" \"$1\"",
            "    fi",
            "",
            "    printf \"%.s=\" $(seq 1 80)",
            "    printf \"\\\\nThe EC2Rescue execution did not complete successfully.\\\\n\"",
            "",
            "    cleanup",
            "",
            "    exit 1",
            "}",
            "",
            "cleanup()",
            "{",
            "    # Recreate the symlink if resolv.conf was one",
            "    if test \"${RESOLV_CONF_IS_SYMLINK}\" == \"True\"; then",
            "        cd \"${CHROOT}\"",
            "        if test -e etc/resolv.conf; then",
            "            rm -v etc/resolv.conf",
            "        fi",
            "        ln -s \"${SYMLINK_TARGET}\" etc/resolv.conf",
            "        cd - 1>/dev/null",
            "    # Restore original resolv.conf if it was backed up",
            "    elif test -e \"${CHROOT}\"/etc/resolv.conf.back ; then",
            "        mv -v \"${CHROOT}\"/etc/resolv.conf.back \"${CHROOT}/etc/resolv.conf\"",
            "    fi",
            "",
            "    if mount | grep -qc /mnt/mount ; then",
            "        umount -vR \"${CHROOT}\" 2>&1",
            "    fi",
            "}",
            "export CHROOT=/mnt/mount",
            "unalias -a",
            "",
            "# Check that a compatible Python interpreter is available in the host environemnt",
            "if command -v python3 > /dev/null; then",
            "    PYTHON=python3",
            "elif command -v python2.7 > /dev/null; then",
            "    PYTHON=python2.7",
            "else",
            "    error_trap \"Failed to find compatible Python environment!\"",
            "fi",
            "",
            "# Find the root file system on the rescue volume",
            "printf \"Locating rescue device\\\\n\"",
            "RESCUE_DEVICE=\"$(${PYTHON} -c \"",
            "from __future__ import print_function",
            "import ctypes",
            "import ctypes.util",
            "import os",
            "import re",
            "import shlex",
            "import subprocess",
            "import sys",
            "",
            "EXPECTED_ROOT_FS_DIRS = {'bin', 'boot', 'dev', 'etc', 'home', 'proc', 'root', 'sbin', 'sys', 'tmp', 'usr', 'var'}",
            "MOUNT_POINT = os.environ['CHROOT']",
            "LIBC = ctypes.CDLL(ctypes.util.find_library('c'), use_errno=True)",
            "",
            "",
            "def contains_root_fs(device_name):",
            "    if not os.path.isdir(MOUNT_POINT):",
            "        os.makedirs(MOUNT_POINT)",
            "    # TODO find a more native way to obtain the filesystem type",
            "    try:",
            "        fs_type = subprocess.check_output(shlex.split('blkid {} -s TYPE -o value'.format(device_name)),",
            "                                          universal_newlines=True).strip()",
            "    except Exception:",
            "        return False",
            "    try:",
            "        # Python does not have a builtin for mount so use libc to do it",
            "        # Ref: https://www.gnu.org/software/libc/manual/html_node/Mount_002dUnmount_002dRemount.html",
            "        # ctypes does not automatically convert unicode/byte strings so it is necessary to encode them in Python 3",
            "        ret = LIBC.mount(device_name.encode('ascii'), MOUNT_POINT.encode('ascii'), fs_type.encode('ascii'), 0, None)",
            "        if ret:",
            "            # the_errno = ctypes.get_errno()",
            "            # print('Failed to mount {}. {}'.format(device_name, os.strerror(the_errno)))",
            "            return False",
            "        if EXPECTED_ROOT_FS_DIRS & set(os.listdir(MOUNT_POINT)) == EXPECTED_ROOT_FS_DIRS:",
            "            return True",
            "        else:",
            "            return False",
            "    finally:",
            "        LIBC.umount(MOUNT_POINT.encode('ascii'))",
            "",
            "",
            "def run():",
            "    # This detection method relies on udev's standard storage naming rules",
            "    # https://cgit.freedesktop.org/systemd/systemd/tree/rules/60-persistent-storage.rules",
            "    partitions = list()",
            "    device_mapping = dict()",
            "    root_fs_dev = ''",
            "    possible_rescue_vol_root_fs_dev = list()",
            "    part_regex = re.compile(r'^.*part\\d*$')",
            "",
            "    os.chdir('/dev/disk/by-path/')",
            "    for device_path in os.listdir('/dev/disk/by-path'):",
            "        device_abs_path = os.path.join(os.path.abspath(os.readlink(device_path)))",
            "        if re.match(part_regex, device_path):",
            "            partitions.append(device_abs_path)",
            "        else:",
            "            device_mapping[device_abs_path] = list()",
            "    for device_name in device_mapping.keys():",
            "        for partition_name in partitions:",
            "            if device_name in partition_name:",
            "                device_mapping[device_name].append(partition_name)",
            "",
            "    with open('/proc/mounts') as proc_mounts:",
            "        for mount in proc_mounts:",
            "            mount = mount.split()",
            "            if mount[1] == '/':",
            "                root_fs_dev = mount[0]",
            "                break",
            "    if not root_fs_dev:",
            "        return 'Error: failed to find device name of root volume.'",
            "",
            "    for block_dev_name in device_mapping.keys():",
            "        # If the root device is a disk",
            "        if block_dev_name == root_fs_dev:",
            "            break",
            "        # If the root device is a partition",
            "        else:",
            "            if root_fs_dev in device_mapping[block_dev_name]:",
            "                root_fs_dev = block_dev_name",
            "                break",
            "    del device_mapping[root_fs_dev]",
            "    if not device_mapping:",
            "        return 'Error: no rescue volume attached.'",
            "",
            "    for possible_rescue_vol_dev in device_mapping.keys():",
            "        # Volume does not use partitions",
            "        if len(device_mapping[possible_rescue_vol_dev]) == 0:",
            "            if contains_root_fs(possible_rescue_vol_dev):",
            "                possible_rescue_vol_root_fs_dev.append(possible_rescue_vol_dev)",
            "        # Volume contains one or more partitions",
            "        else:",
            "            for partition_name in device_mapping[possible_rescue_vol_dev]:",
            "                if contains_root_fs(partition_name):",
            "                    possible_rescue_vol_root_fs_dev.append(partition_name)",
            "",
            "    if len(possible_rescue_vol_root_fs_dev) == 1:",
            "        print(possible_rescue_vol_root_fs_dev[0])",
            "    elif len(possible_rescue_vol_root_fs_dev) > 1:",
            "        return 'Error: found more than one possible rescue volume with a root filesystem: {}'.format(",
            "            ', '.join(possible_rescue_vol_root_fs_dev))",
            "    else:",
            "        return 'Error: failed to find a rescue volume with a root filesystem.'",
            "",
            "",
            "if __name__ == '__main__':",
            "    sys.exit(run())",
            "\")\" || error_trap",
            "",
            "# Unlabel the rescue instance's root volume to prevent false positive detection of duplicate labels",
            "if [[ -c /dev/xen/xenbus ]]; then",
            "    e2label /dev/xvda1 \"\" || error_trap \"Failed to unlabel the rescue instance's root volume\"",
            "    sed -i \"s|LABEL=/|UUID=$(blkid /dev/xvda1 -s UUID -o value)|\" /etc/fstab || error_trap \"Failed to update /etc/fstab on rescue instance\"",
            "else",
            "    e2label /dev/nvme0n1p1 \"\" || error_trap \"Failed to unlabel the rescue instance's root volume\"",
            "    sed -i \"s|LABEL=/|UUID=$(blkid /dev/nvme0n1p1 -s UUID -o value)|\" /etc/fstab || error_trap \"Failed to update /etc/fstab on rescue instance\"",
            "fi",
            "",
            "# Prepare for chroot",
            "printf \"Mounting rescue volume %s\\\\n\" \"${RESCUE_DEVICE}\" || error_trap",
            "mount \"${RESCUE_DEVICE}\" \"${CHROOT}\" || error_trap",
            "mount -R /sys \"${CHROOT}\"/sys || error_trap",
            "mount --make-rslave \"${CHROOT}\"/sys || error_trap",
            "mount -R /dev \"${CHROOT}\"/dev || error_trap",
            "mount --make-rslave \"${CHROOT}\"/dev || error_trap",
            "mount -t proc /proc \"${CHROOT}\"/proc || error_trap",
            "",
            "RESOLV_CONF_IS_SYMLINK=False",
            "SYMLINK_TARGET=\"\"",
            "# /etc/resolv.conf is a symlink in Ubuntu so dereference the symlink if needed",
            "if test -h \"${CHROOT}/etc/resolv.conf\"; then",
            "    RESOLV_CONF_IS_SYMLINK=True",
            "    SYMLINK_TARGET=$(readlink \"${CHROOT}/etc/resolv.conf\")",
            "    unlink \"${CHROOT}/etc/resolv.conf\"",
            "    printf \"unlink %s\\\\n\" \"${CHROOT}/etc/resolv.conf\"",
            "elif test -e \"${CHROOT}/etc/resolv.conf\" ; then",
            "    cp -v \"${CHROOT}/etc/resolv.conf\" \"${CHROOT}\"/etc/resolv.conf.back || error_trap",
            "fi",
            "cp -v /etc/resolv.conf \"${CHROOT}/etc/resolv.conf\" || error_trap",
            "",
            "# Remove any existing version of ec2rl",
            "EC2RL_NAME=\"${CHROOT}\"/usr/bin/ec2rl",
            "if [ -h \"${EC2RL_NAME}\" ] || [ -d \"${EC2RL_NAME}\" ] || [ -f \"${EC2RL_NAME}\" ]; then",
            "    printf \"Removing existing: %s\\\\n\" \"${EC2RL_NAME}\"",
            "    rm -v \"${EC2RL_NAME}\"",
            "fi",
            "",
            "# Copy ec2rl from the rescue host to the rescue volume",
            "# This may \"upgrade\" the version on the rescue volume if it was already installed",
            "EC2RL_DIR=\"$(dirname \"$(readlink /usr/bin/ec2rl)\")\"",
            "mkdir -vp \"$(dirname \"${CHROOT}\"\"${EC2RL_DIR}\")\" || error_trap",
            "cp -r \"${EC2RL_DIR}\" \"${CHROOT}\"\"$(dirname ${EC2RL_DIR})\" || error_trap \"Failed to copy ec2rl to rescue volume\"",
            "",
            "mkdir -vp \"${CHROOT}\"/usr/bin || error_trap \"Failed to create ${CHROOT}/usr/bin\"",
            "",
            "ln -vs \"${EC2RL_DIR}\"/ec2rl \"${CHROOT}\"/usr/bin/ec2rl || error_trap \"Failed to create ec2rl symlink\"",
            "",
            "export EC2RESCUE_ACCOUNT_ID=\"{{ global:ACCOUNT_ID }}\"",
            "export EC2RESCUE_DATE=\"{{ global:DATE }}\"",
            "export EC2RESCUE_DATE_TIME=\"{{ global:DATE_TIME }}\"",
            "export EC2RESCUE_REGION=\"{{ global:REGION }}\"",
            "export EC2RESCUE_EXECUTION_ID=\"{{ automation:EXECUTION_ID }}\"",
            "export EC2RESCUE_SOURCE_INSTANCE=\"{{ InstanceId }}\"",
            "export EC2RESCUE_S3_BUCKET=\"{{ S3BucketName }}\"",
            "export EC2RESCUE_S3_PREFIX=\"{{ S3Prefix }}\"",
            "export EC2RESCUE_OFFLINE_EBS_DEVICE=\"/dev/sdf\"",
            "export EC2RESCUE_OFFLINE_DEVICE=$RESCUE_DEVICE",
            "export EC2RESCUE_OFFLINE_SYSTEM_ROOT=$CHROOT",
            "export EC2RESCUE_PYTHON=$PYTHON",
            "export EC2RESCUE_EC2RL_DIR=$EC2RL_DIR",
            "",
            "base64 -d <<< {{ OfflineScript }} | /bin/bash ",
            "",
            "cleanup"
          ]
        }
      }
    },
    {
      "name": "stopEC2RescueInstance",
      "action": "aws:changeInstanceState",
      "description": "Stops the EC2Rescue helper instance.",
      "onFailure": "step:forceStopEC2RescueInstance",
      "inputs": {
        "InstanceIds": [
          "{{ describeEC2RescueInstance.EC2RescueInstanceId }}"
        ],
        "CheckStateOnly": false,
        "DesiredState": "stopped"
      },
      "isCritical": false,
      "nextStep": "detachInstanceRootVolumeFromEC2RescueInstance"
    },
    {
      "name": "forceStopEC2RescueInstance",
      "action": "aws:changeInstanceState",
      "description": "Forces stop the EC2Rescue helper instance.",
      "onFailure": "Continue",
      "isCritical": true,
      "inputs": {
        "InstanceIds": [
          "{{ describeEC2RescueInstance.EC2RescueInstanceId }}"
        ],
        "CheckStateOnly": false,
        "DesiredState": "stopped",
        "Force": true
      }
    },
    {
      "name": "detachInstanceRootVolumeFromEC2RescueInstance",
      "onFailure": "Continue",
      "isCritical": true,
      "description": "Detaches the EBS root volume from the EC2Rescue helper instance.",
      "action": "aws:executeAwsApi",
      "inputs": {
        "Service": "ec2",
        "Api": "DetachVolume",
        "VolumeId": "{{ describeInstanceRootVolume.RootDeviceVolumeId }}"
      }
    },
    {
      "name": "waitForRescuedInstanceRootVolumeToBeDetached",
      "action": "aws:waitForAwsResourceProperty",
      "description": "Waits until the EBS root volume is in 'available' state.",
      "onFailure": "Continue",
      "isCritical": true,
      "inputs": {
        "Service": "ec2",
        "Api": "DescribeVolumes",
        "VolumeIds": [
          "{{ describeInstanceRootVolume.RootDeviceVolumeId }}"
        ],
        "PropertySelector": "$.Volumes[0].State",
        "DesiredValues": [
          "available"
        ]
      }
    },
    {
      "name": "attachInstanceRootVolumeToInstance",
      "onFailure": "Continue",
      "isCritical": true,
      "description": "Attaches the EBS root volume back to the provided instance.",
      "action": "aws:executeAwsApi",
      "inputs": {
        "Service": "ec2",
        "Api": "AttachVolume",
        "Device": "{{ describeInstance.RootDeviceName }}",
        "InstanceId": "{{ InstanceId }}",
        "VolumeId": "{{ describeInstanceRootVolume.RootDeviceVolumeId }}"
      }
    },
    {
      "name": "waitForRescuedInstanceRootVolumeToBeAttached",
      "action": "aws:waitForAwsResourceProperty",
      "description": "Waits for the EBS root volume status is 'in-use.",
      "onFailure": "Continue",
      "isCritical": true,
      "inputs": {
        "Service": "ec2",
        "Api": "DescribeVolumes",
        "VolumeIds": [
          "{{ describeInstanceRootVolume.RootDeviceVolumeId }}"
        ],
        "PropertySelector": "$.Volumes[0].State",
        "DesiredValues": [
          "in-use"
        ]
      }
    },
    {
      "name": "branchOnPostEC2RescueBackup",
      "action": "aws:branch",
      "description": "Checks the CreatePostEC2RescueBackup input value. Creates post-EC2Rescue backup If 'CreatePostEC2RescueBackup' is set to 'True'.",
      "onFailure": "Continue",
      "isCritical": true,
      "inputs": {
        "Choices": [
          {
            "NextStep": "postScriptBackup",
            "Variable": "{{ CreatePostEC2RescueBackup }}",
            "StringEquals": "True"
          }
        ],
        "Default": "restoreInstanceRootVolumeDeleteOnTerminationState"
      }
    },
    {
      "name": "postScriptBackup",
      "action": "aws:executeAwsApi",
      "description": "Creates an AMI backup of the provided instance.",
      "onFailure": "Continue",
      "isCritical": true,
      "inputs": {
        "Service": "ec2",
        "Api": "CreateImage",
        "InstanceId": "{{ InstanceId }}",
        "Description": "Post-Script Backup AMI Generated by Automation on {{ global:DATE_TIME }} from {{ InstanceId }}.",
        "NoReboot": false,
        "Name": "{{ AMIPrefix }}-Post-Script-Backup_{{ InstanceId }}_{{ global:DATE_TIME }}"
      },
      "outputs": [
        {
          "Name": "ImageId",
          "Selector": "$.ImageId",
          "Type": "String"
        }
      ]
    },
    {
      "name": "tagPostScriptBackup",
      "action": "aws:createTags",
      "description": "Tags the AMI backup.",
      "onFailure": "Continue",
      "inputs": {
        "ResourceType": "EC2",
        "ResourceIds": [
          "{{ postScriptBackup.ImageId }}"
        ],
        "Tags": [
          {
            "Key": "Name",
            "Value": "AWSSupport-EC2Rescue: {{ InstanceId }}"
          },
          {
            "Key": "AWSSupport-EC2Rescue-AutomationExecution",
            "Value": "{{ UniqueId }}"
          }
        ]
      },
      "isCritical": false
    },
    {
      "name": "restoreInstanceRootVolumeDeleteOnTerminationState",
      "onFailure": "Continue",
      "isCritical": true,
      "action": "aws:executeAwsApi",
      "description": "Restores the initial delete on termination state for the root volume of the provided instance.",
      "inputs": {
        "Service": "ec2",
        "Api": "ModifyInstanceAttribute",
        "InstanceId": "{{ InstanceId }}",
        "BlockDeviceMappings": [
          {
            "DeviceName": "{{ describeInstance.RootDeviceName }}",
            "Ebs": {
              "DeleteOnTermination": "{{ describeInstanceRootVolume.RootDeviceDeleteOnTermination }}",
              "VolumeId": "{{ describeInstanceRootVolume.RootDeviceVolumeId }}"
            }
          }
        ]
      }
    },
    {
      "name": "restoreInstanceInitialState",
      "action": "aws:changeInstanceState",
      "description": "Restores the initial state of the provided instance ('running' or 'stopped').",
      "onFailure": "Continue",
      "isCritical": true,
      "inputs": {
        "InstanceIds": [
          "{{ InstanceId }}"
        ],
        "DesiredState": "{{ describeInstance.State }}"
      },
      "nextStep": "waitForCloudFormationStack"
    },
    {
      "name": "describeCloudFormationErrorFromStackEvents",
      "onFailure": "step:waitForCloudFormationStack",
      "action": "aws:executeAwsApi",
      "maxAttempts": 3,
      "description": "Describes errors from the EC2Rescue CloudFormation stack.",
      "inputs": {
        "Service": "cloudformation",
        "Api": "DescribeStackEvents",
        "StackName": "{{ stageEC2RescueAutomation.CloudFormationStackId }}"
      },
      "outputs": [
        {
          "Name": "Events",
          "Selector": "$.StackEvents..ResourceStatusReason",
          "Type": "StringList"
        }
      ],
      "isCritical": false
    },
    {
      "name": "waitForCloudFormationStack",
      "action": "aws:waitForAwsResourceProperty",
      "description": "Waits until the AWS CloudFormation stack is in a terminal status before deleting it.",
      "onFailure": "Continue",
      "timeoutSeconds": 600,
      "maxAttempts": 3,
      "inputs": {
        "Service": "cloudformation",
        "Api": "DescribeStacks",
        "StackName": "{{ stageEC2RescueAutomation.CloudFormationStackId }}",
        "PropertySelector": "$.Stacks[0].StackStatus",
        "DesiredValues": [
          "UPDATE_COMPLETE",
          "CREATE_COMPLETE",
          "ROLLBACK_FAILED",
          "ROLLBACK_COMPLETE",
          "DELETE_COMPLETE",
          "CREATE_FAILED",
          "DELETE_FAILED",
          "UPDATE_ROLLBACK_FAILED",
          "UPDATE_ROLLBACK_COMPLETE"
        ]
      },
      "isCritical": false
    },
    {
      "name": "unstageEC2RescueAutomation",
      "action": "aws:deleteStack",
      "description": "Deletes the EC2Rescue CloudFormation stack.",
      "maxAttempts": 3,
      "inputs": {
        "StackName": "{{ stageEC2RescueAutomation.CloudFormationStackId }}"
      },
      "isCritical": true,
      "isEnd": "true"
    }
  ],
  "outputs": [
    "runScriptForLinux.Output",
    "runScriptForWindows.Output",
    "preScriptBackup.ImageId",
    "postScriptBackup.ImageId"
  ]
}
