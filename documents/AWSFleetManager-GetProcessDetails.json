{
  "schemaVersion": "1.0",
  "description": "Get performance counters and details about the processes.",
  "sessionType": "InteractiveCommands",
  "parameters": {
    "PrintInteractiveStatements": {
      "type": "String",
      "description": "(Optional) If set to 'No', the command will not print text that indicates a keystroke is required for it to continue running.",
      "default": "No",
      "allowedValues": [
        "Yes",
        "No"
      ]
    }
  },
  "properties": {
    "windows": {
      "commands": "$ErrorActionPreference = 'Stop'\n\nFunction ParseInputParameter {\n    param (\n        [string]$Name,\n        [string]$Value,\n        [string]$Regex\n    )\n\n    $ValidParameterRegex = '^--%[ +{|{].*}( +)?$'\n    if ($Value -notmatch $ValidParameterRegex) {\n        ExitWithFailureMessage -Message \"Invalid syntax for the parameter $Name\"\n    }\n    $parameterValue = $Value.Substring(3)\n\n    $trimmedParameterValue = $parameterValue.TrimStart().TrimEnd()\n    $trimmedParameterValue = $trimmedParameterValue.Substring(1)\n    $trimmedParameterValue = $trimmedParameterValue.Substring(0, $trimmedParameterValue.Length - 1)\n\n    if ($Regex -and $trimmedParameterValue -notmatch $Regex) {\n        ExitWithFailureMessage -Message \"Invalid syntax for the parameter $Name\"\n    } else {\n        $trimmedParameterValue\n    }\n}\n\nfunction ExitWithFailureMessage {\n    param (\n        [string]$Message,\n        [string]$ExceptionMessage,\n        [Switch]$PrintJson\n    )\n    if ([string]::IsNullOrWhitespace($ExceptionMessage)) {\n        $errorMessage = $Message\n    } else {\n        $errorMessage = '{0} {1}' -f $Message, $ExceptionMessage\n    }\n    if ($PrintJson) {ConvertTo-Json -InputObject @{error = $errorMessage} -Compress}\n    WriteStandardError -Message $errorMessage\n    [System.Environment]::Exit(1)\n}\n\nfunction ExitWithFailureMessageAndExitCode {\n    param (\n        [string]$Message,\n        [string]$ExceptionMessage,\n        [int]$ExitCode,\n        [Switch]$PrintJson\n    )\n    if ([string]::IsNullOrWhitespace($ExceptionMessage)) {\n        $errorMessage = $Message\n    } else {\n        $errorMessage = '{0} {1}' -f $Message, $ExceptionMessage\n    }\n    if ($PSBoundParameters.ContainsKey('ExitCode') -eq $true) {\n        $exitCode = $ExitCode\n    } else {\n        $exitCode = 1\n    }\n    if ($PrintJson) {\n        $ErrorObject = @{\n            error = $errorMessage\n            exitCode = $exitCode\n        }\n        ConvertTo-Json -InputObject $ErrorObject -Compress\n    }\n    WriteStandardError -Message $errorMessage\n    [System.Environment]::Exit($exitCode)\n}\n\nfunction ExitWithSuccessMessage {\n    param (\n        [string]$Message\n    )\n    Write-Host $Message\n    [System.Environment]::Exit(0)\n}\n\nfunction WriteStandardError {\n    param (\n        [string]$Message\n    )\n    $Host.UI.WriteErrorLine($Message)\n}\n\n$script:ResultProperty = 'results'\n$script:DataProperty = 'data'\n$script:NextTokenProperty = 'nextToken'\n\nfunction ConvertBase64ToString {\n    param (\n        [string]$Base64\n    )\n    $bytes = [System.Convert]::FromBase64String($Base64)\n    [System.Text.Encoding]::UTF8.GetString($bytes)\n}\n\nfunction ConvertStringToBase64 {\n    param (\n        [string]$String\n    )\n    $bytes = [System.Text.Encoding]::UTF8.GetBytes($String)\n    [System.Convert]::ToBase64String($bytes)\n}\n\nfunction GetCompressionBoolean {\n    param (\n        [ValidateSet('No','Yes')]\n        [string]$CompressOutput\n    )\n    if ($CompressOutput -eq 'Yes') {\n        $true\n    } else {\n        $false\n    }\n}\n\nfunction GetJson {\n    param ($InputObject)\n    ConvertTo-Json -InputObject $InputObject -Compress -Depth 5\n}\n\nfunction GetBase64EncodedGzipString {\n    param ($InputString)\n\n    $inputBytes = [System.Text.Encoding]::UTF8.GetBytes($InputString)\n\n    try {\n        $memoryStream = New-Object -TypeName 'System.IO.MemoryStream'\n        $compressionMode = [System.IO.Compression.CompressionMode]::Compress\n        $gzipStream = New-Object -TypeName 'System.IO.Compression.GzipStream' -ArgumentList @($memoryStream, $compressionMode)\n\n        $gzipStream.Write($inputBytes, 0, $inputBytes.Length)\n        $gzipStream.Close()\n        $memoryStream.Close()\n\n        [System.Convert]::ToBase64String($memoryStream.ToArray())\n    } finally {\n        $gzipStream.Dispose()\n        $memoryStream.Dispose()\n    }\n}\n\nfunction GetResultAsString {\n    param (\n        [PSObject]$Object,\n        [bool]$Completed,\n        [switch]$ConvertNextTokenToBase64,\n        [bool]$EnableCompression,\n        [bool]$ForceEmptyNextToken,\n        [string]$NextToken,\n        [string]$PaginationProperty,\n        [array]$StringReplacementRegex\n    )\n\n    if ([string]::IsNullOrWhiteSpace($NextToken)) {\n        if ($Completed -eq $false -and $Object.Count -ge 1 -and $ForceEmptyNextToken -ne $true) {\n            if ($PaginationProperty -eq '.') {\n                $NextToken = $Object[-1]\n            } else {\n                $NextToken = $Object[-1].$PaginationProperty\n            }\n        }\n    }\n\n    if ($ForceEmptyNextToken) {\n        $NextToken = [string]::Empty\n    } elseif ($ConvertNextTokenToBase64) {\n        $NextToken = ConvertStringToBase64 -String $NextToken\n    }\n\n    $data = @{\n        $script:ResultProperty    = $Object\n        $script:NextTokenProperty = $NextToken\n    }\n\n    if ($EnableCompression -eq $true) {\n        $string = GetJson -InputObject $data\n\n        if ($StringReplacementRegex.Count -eq 2) {\n            $string = $string -replace $StringReplacementRegex\n        }\n\n        $data = GetBase64EncodedGzipString -InputString $string\n    }\n\n    $output = GetJson -InputObject @{\n        $script:DataProperty = $data\n    }\n    if ($StringReplacementRegex.Count -eq 2) {\n        $output -replace $StringReplacementRegex\n    } else {\n        $output\n    }\n}\n\nfunction GetMaximumOutputBytes {\n    param (\n        $AllowTruncatedOutput,\n        [int]$MaximumOutputSize = 2500\n    )\n    if ($AllowTruncatedOutput -eq 'Yes') {\n        0\n    } else {\n        $padding = (GetResultAsString -Object @() -Completed $false -EnableCompression $false).length\n        $MaximumOutputSize - $padding\n    }\n}\n\nfunction ProcessItems {\n    param (\n        [scriptblock]$ScriptBlock,\n        [switch]$ConvertNextTokenToBase64,\n        [int]$ChunksPerLoop = 1,\n        [bool]$EnableCompression,\n        [int]$MaximumOutputBytes,\n        [string]$PaginationProperty,\n        [string]$PropertyToRemove,\n        [string]$NextToken,\n        [switch]$SetNextTokenBeforeAdding,\n        [array]$StringReplacementRegex\n    )\n\n    $chunkedOutputArray = New-Object -TypeName 'System.Collections.ArrayList'\n\n    $outputResult = [string]::Empty\n\n    $outputTooBig = $false\n    $counter = 0\n\n    $getResultString = @{\n        EnableCompression = $EnableCompression\n        PaginationProperty = $PaginationProperty\n        StringReplacementRegex = $StringReplacementRegex\n    }\n\n    foreach ($item in (& $ScriptBlock)) {\n        if ($outputTooBig -eq $true) { break }\n\n        if ($NextToken -ne '*') {\n            if ($PaginationProperty -eq '.' -and $item -le $NextToken) {\n                continue\n            } elseif ($PaginationProperty -ne '.' -and $item.$PaginationProperty -le $NextToken) {\n                continue\n            }\n        }\n\n        if ($SetNextTokenBeforeAdding) {\n            if ($PaginationProperty -eq '.') {\n                $newNextToken = $item\n            } else {\n                $newNextToken = $item.$PaginationProperty\n            }\n        }\n\n        if ($PropertyToRemove) {\n            $item.PSObject.properties.remove($PropertyToRemove)\n        }\n\n        $null = $chunkedOutputArray.Add($item)\n\n        if ($counter -lt $ChunksPerLoop) {\n            $counter++\n            continue\n        }\n\n        $counter = 0\n\n        $properties = @{\n            Object = $chunkedOutputArray\n            Completed = $outputTooBig\n        }\n        if ($ConvertNextTokenToBase64) {\n            $properties.Add('ConvertNextTokenToBase64', $ConvertNextTokenToBase64)\n        }\n        if ($SetNextTokenBeforeAdding) {\n            $properties.Add('NextToken', $newNextToken)\n        }\n        $tempResult = GetResultAsString @properties @getResultString\n\n        if ($MaximumOutputBytes -eq 0 -or $tempResult.Length -le $MaximumOutputBytes) {\n            $outputResult = $tempResult\n        } else {\n            $outputTooBig = $true\n            break\n        }\n    }\n\n    # Processing remaining items if the output isn't too big yet\n    if ($outputTooBig -eq $false) {\n        $properties = @{\n            Object = $chunkedOutputArray\n            Completed = $outputTooBig\n            ForceEmptyNextToken = $true\n        }\n        if ($ConvertNextTokenToBase64) {\n            $properties.Add('ConvertNextTokenToBase64', $ConvertNextTokenToBase64)\n        }\n        if ($SetNextTokenBeforeAdding) {\n            $properties.Add('NextToken', $newNextToken)\n        }\n        $tempResult = GetResultAsString @getResultString @properties\n        if ($MaximumOutputBytes -eq 0 -or $tempResult.Length -le $MaximumOutputBytes) {\n            $outputResult = $tempResult\n        }\n    }\n\n    $outputResult\n}\n\n# Total memory consumption percentage\nfunction GetTotalMemoryUsage\n{\n    $ComputerMemory =  Get-CimInstance -Class WIN32_OperatingSystem\n    $Memory = ((($ComputerMemory.TotalVisibleMemorySize - $ComputerMemory.FreePhysicalMemory)*100)/ $ComputerMemory.TotalVisibleMemorySize)\n    return [String][math]::Round($Memory, 2)\n}\n\n# get the percentage value of total CPU usage consumption\nfunction GetTotalCPUUsage\n{\n    $Processors = Get-CimInstance -Query 'select Name, PercentProcessorTime from Win32_PerfFormattedData_PerfOS_Processor'\n    foreach ($processor in $Processors) {\n        if ($processor.Name -like '_Total') {\n            return [String]$processor.PercentProcessorTime\n        }\n    }\n}\n$PrintInteractiveStatements = Write-Output --%{{{ PrintInteractiveStatements }}}\n$PrintInteractiveStatements = ParseInputParameter -Name 'PrintInteractiveStatements' -Value $PrintInteractiveStatements -Regex '(Yes|No)'\n\n$script:FMToken = '__FM_SESSION_OUTPUT__'\n$script:DataProperty = 'data'\n$script:TimestampProperty = 'timestamp'\n$script:ProcessUsageDetailsProperty = 'processDetails'\n$script:SystemUsageProperty = 'systemDetails'\n$script:TotalCpuUsageProperty = 'totalCpuUsage'\n$script:TotalMemoryUsageProperty = 'totalMemoryUsage'\n\nFunction Main {\n    $selectObject = @{Property = @(\n    @{Name='id';      Expression = {[String]$_.IDProcess}},\n    @{Name='name';    Expression = {$_.name}},\n    @{Name='cpu';     Expression = {[String]$_.PercentProcessorTime}},\n    @{Name='memory';  Expression = {[String][Math]::Round(($_.workingSetPrivate / 1mb),2)}},\n    @{Name='handles'; Expression = {$_.HandleCount}},\n    @{Name='startTime'; Expression = {((Get-Date) - (New-TimeSpan -Seconds $_.elapsedTime)).ToString('r')}},\n    @{Name='threadCount'; Expression = {$_.ThreadCount}}\n)}\n\n    # id, name, cpu, memory, handles, startTime, threadCount\n    $process = Get-WmiObject -class Win32_PerfFormattedData_PerfProc_Process -filter { name!='_Total' and name!='Idle' }|\n                Select-Object @selectObject | Sort-Object -Descending 'Memory'\n\n    $processDetails = @{\n        $script:SystemUsageProperty = @{\n            $script:TotalCpuUsageProperty = GetTotalCPUUsage\n            $script:TotalMemoryUsageProperty = GetTotalMemoryUsage\n        }\n        $script:ProcessUsageDetailsProperty = $process\n    }\n\n    [int]$Timestamp = Get-Date -UFormat %s\n\n    $string = GetJson -InputObject @{\n        $script:TimestampProperty = $Timestamp\n        $script:DataProperty = $processDetails\n    }\n\n    $output = $script:FMToken\n\n    $output+$string\n}\n\ndo {\n    Main\n    ''\n\n    if ($PrintInteractiveStatements -eq 'Yes') {\n        $continue = Read-Host -Prompt 'Press q to end the loop or press any other key to continue.'\n    } else {\n        $continue = Read-Host\n    }\n} while ($continue -ne 'q')\n",
      "runAsElevated": true
    },
    "linux": {
      "commands": "#!/bin/bash\nset -e\n\nif [ -f /etc/os-release ]; then\n    . /etc/os-release\n    OS_RELEASE=\"$ID${VERSION_ID:+.${VERSION_ID}}\"\nelif [ -f /etc/centos-release ]; then\n    OS_RELEASE=\"centos.$(awk '{print $3}' /etc/centos-release)\"\nelif [ -f /etc/redhat-release ]; then\n    OS_RELEASE=\"rhel.$(lsb_release -r | awk '{print $2}')\"\nfi\n\ncase \"$OS_RELEASE\" in\n    amzn.2018.03|centos.6*|debian.9|rhel.6*|ubuntu.*)\n        command_path='/bin/'\n        ;;\n    amzn.2*|centos.*|debian.*|fedora.*|rhel.*|sles*)\n        command_path='/usr/bin/'\n        ;;\n    *)\n        # Catch all without the full path for untested platforms\n        command_path=''\nesac\n\nExitWithFailureMessage() {\n    MESSAGE=\"$1\"\n    JSON=\"$2\"\n    if [[ \"$JSON\" == \"PRINT_JSON\" ]]; then\n        \"${command_path}echo\" \"{\\\"error\\\":\\\"$MESSAGE\\\"}\"\n    fi\n    WriteStandardError \"$MESSAGE\"\n    exit 1\n}\n\n# exit codes. 0-100 are reserved exit codes. 101-150 codes are for linux, 151-200 are for macos and 200 onwards codes are for windows.\nExitWithFailureMessageAndExitCode() {\n    MESSAGE=\"$1\"\n    EXITCODE=\"$2\"\n    JSON=\"$3\"\n    if [[ \"$JSON\" == \"PRINT_JSON\" ]]; then\n        \"${command_path}echo\" \"{\\\"error\\\":\\\"$MESSAGE\\\",\\\"exitCode\\\":\\\"$EXITCODE\\\"}\"\n    fi\n    WriteStandardError \"$MESSAGE\"\n    exit \"$EXITCODE\"\n}\n\nExitWithSuccessMessage() {\n    \"${command_path}echo\" \"$1\"\n    exit 0\n}\n\nWriteStandardError() {\n    MESSAGE=\"$1\"\n    (>&2 \"${command_path}echo\" \"$MESSAGE\")\n}\n\nJQ=\"jq\"\nVERSION=\"1.6\"\nPRODUCT_PATH=\"/opt/amazon/ssm/fleet_manager\"\nJQ_BINARY=\"$PRODUCT_PATH/$JQ-$VERSION\"\n\nCheckSha256FileHash() {\n    FILE_PATH=\"$1\"\n    SHA256=\"$2\"\n\n    if [ -f \"$FILE_PATH\" ]; then\n        TEST=$(\"${command_path}echo\" \"$SHA256  $FILE_PATH\" | /usr/bin/sha256sum -c 2>&1) || return 1\n        return 0\n    fi\n\n    return 1\n}\n\nSetLockedDownPermissions() {\n    \"${command_path}chmod\" u+rwx \"$1\"\n    \"${command_path}chmod\" go-rwx \"$1\"\n    \"${command_path}chown\" \"$(/usr/bin/whoami)\":\"$(/usr/bin/id --group --name)\" \"$1\"\n}\n\nCreateLockedDownFolder() {\n    \"${command_path}mkdir\" -p \"$1\"\n    SetLockedDownPermissions \"$1\"\n}\n\nDownloadFile() {\n    SOURCE=\"$1\"\n    DESTINATION=\"$2\"\n    if [ -f /usr/bin/curl ]; then\n        /usr/bin/curl -s \"$SOURCE\" -o \"$DESTINATION\"\n    elif [ -f /usr/bin/wget ]; then\n        /usr/bin/wget -q \"$SOURCE\" -O \"$DESTINATION\"\n    else\n        ExitWithFailureMessage \"Unable to download the source using 'curl' or 'wget'. Failing execution.\" 'PRINT_JSON'\n    fi\n}\n\nIfRunningKernelVersion2() {\n    \"${command_path}uname\" -r | grep -q '^2\\.' || return 1\n}\n\nGetJQSHA256Hash() {\n    case \"$1\" in\n        'aarch64')\n            \"${command_path}echo\" \"a6e84e979b91b26763c700d4ba6c616554444bbbf0cf1863e96611b0e68b88f2\"\n            ;;\n        'armv6l')\n            \"${command_path}echo\" \"4717f1350a963e5ae5446e61eb21e3936754f84dd13586d494dcd6b497b267c1\"\n            ;;\n        'armv7l')\n            \"${command_path}echo\" \"e097be6c7ef954d581a359ad2d7aa4ec19c89bd3b9ab55919c826a1d30373a5c\"\n            ;;\n        'i686')\n            \"${command_path}echo\" \"062902c5a177cb80866d556a07e10331d9f8b8b676ffb1b7cd2985a9c2e539c8\"\n            ;;\n        'x86_64')\n            \"${command_path}echo\" \"15d1d1b093481c737603247a785731b7f32f3b4dccd63f77186de8bfe4f6fd68\"\n            ;;\n        'x86_64_kernel2')\n            \"${command_path}echo\" \"af986793a515d500ab2d35f8d2aecd656e764504b789b66d7e1a0b727a124c44\"\n            ;;\n        *)\n            ExitWithFailureMessage \"The CPU architecture '$1' is not supported. Failing execution.\" 'PRINT_JSON'\n            ;;\n    esac\n}\n\nRandomString() {\n    \"${command_path}cat\" /dev/urandom | /usr/bin/tr -dc 'a-zA-Z0-9' | /usr/bin/fold -w ${1:-32} | /usr/bin/head -n 1\n}\n\nInstallJQ() {\n    CreateLockedDownFolder \"$PRODUCT_PATH\"\n\n    CPU_ARCH=$(\"${command_path}uname\" -m)\n    IfRunningKernelVersion2 && CPU_ARCH=\"${CPU_ARCH}_kernel2\"\n    JQ_SHA256=$(GetJQSHA256Hash \"$CPU_ARCH\")\n\n    CheckSha256FileHash \"$JQ_BINARY\" \"$JQ_SHA256\" || {\n        JQ_TEMP_BINARY=\"$PRODUCT_PATH/$(RandomString)\"\n\n        OS_NAME=$(\"${command_path}uname\" -s)\n        REGION=\"us-east-1\"\n        S3_BUCKET=\"aws-fleet-manager-artifacts-us-east-1\"\n        S3_DNS=\"s3.us-east-1.amazonaws.com\"\n        SOURCE=\"https://$S3_BUCKET.$S3_DNS/$JQ/$VERSION/$OS_NAME/$CPU_ARCH/$JQ\"\n        DownloadFile \"$SOURCE\" \"$JQ_TEMP_BINARY\"\n\n        CheckSha256FileHash \"$JQ_TEMP_BINARY\" \"$JQ_SHA256\" || {\n            \"${command_path}rm\" --force \"$JQ_TEMP_BINARY\"\n            ExitWithFailureMessage \"Downloading the $JQ binary failed. Failing execution.\"\n        }\n\n        \"${command_path}mv\" \"$JQ_TEMP_BINARY\" \"$JQ_BINARY\"\n    }\n\n    SetLockedDownPermissions \"$JQ_BINARY\"\n}\n\nInstallJQ\n\nMain () {\n    Counters=''\n\n    while IFS= read -r cpuline; do\n        case \"$cpuline\" in\n            \"cpu \"*)\n                totalidle0=$(\"${command_path}echo\" \"$cpuline\" | \"${command_path}grep\" -e 'cpu ' | /usr/bin/awk '{print $5+$6}')\n                totalnoneidle0=$(\"${command_path}echo\" \"$cpuline\" | \"${command_path}grep\" -e 'cpu ' | /usr/bin/awk '{print $2+$3+$4+$7+$8+$9}')\n                overalltotal0=$((totalidle0 + totalnoneidle0))\n                ;;\n        esac\n    done <\"$cpustatfile\"\n\n    timestamp=$(date +%s)\n    Counters=$(\"${command_path}echo\" \"[ $timestamp ]\" | \"$JQ_BINARY\" -c '{timestamp: .[0]}')\n\n    processDetails=$(\"${command_path}echo\" '{\"data\": {\"processDetails\": []}}' | \"$JQ_BINARY\" -c '.')\n    Counters=$(\"$JQ_BINARY\" -c --argjson Counters \"$Counters\" --argjson processDetails \"$processDetails\" -n '$Counters * $processDetails')\n\n    cpuCounters=$(\"${command_path}echo\" '{\"data\": {\"systemDetails\": {\"totalCpuUsage\": []}}}' | \"$JQ_BINARY\" -c '.')\n    Counters=$(\"$JQ_BINARY\" -c --argjson Counters \"$Counters\" --argjson output \"$cpuCounters\" -n '$Counters * $output')\n\n    while IFS= read -r cpuline; do\n        case \"$cpuline\" in\n            \"cpu \"*)\n                idle1=$(\"${command_path}echo\" \"$cpuline\" | \"${command_path}grep\" -e 'cpu ' | /usr/bin/awk '{print $5+$6}')\n                noneidle1=$(\"${command_path}echo\" \"$cpuline\" | \"${command_path}grep\" -e 'cpu ' | /usr/bin/awk '{print $2+$3+$4+$7+$8+$9}')\n                overalltotal1=$((idle1 + noneidle1))\n                totaldif=$((overalltotal1 - overalltotal0))\n                ideldif=$((idle1 - totalidle0))\n                value=\\\"\"$(\"${command_path}echo\" \"[$totaldif, $ideldif]\" | \"$JQ_BINARY\" -c '(1000*(.[0] - .[1])/.[0]/10)')\"\\\"\n                output=$(\"${command_path}echo\" \"[ \"$value\"]\" | \"$JQ_BINARY\" -c '.[0]')\n                Counters=$(\"${command_path}echo\" \"$Counters\" | \"$JQ_BINARY\" -c --argjson output \"$output\" '.data.systemDetails.totalCpuUsage = $output')\n                ;;\n        esac\n    done <\"$cpustatfile\"\n\n    memCounters=$(\"${command_path}echo\" '{\"data\": {\"systemDetails\": {\"totalMemoryUsage\": []}}}' | \"$JQ_BINARY\" -c '.')\n    Counters=$(\"$JQ_BINARY\" -c --argjson Counters \"$Counters\" --argjson memCounters \"$memCounters\" -n '$Counters * $memCounters')\n    meminfo=$(\"${command_path}cat\" /proc/meminfo)\n    total=$(\"${command_path}echo\" \"$meminfo\" | \"${command_path}grep\" -e '^MemTotal' | /usr/bin/awk '{print $2}')\n    availableMem=$(\"${command_path}echo\" \"$meminfo\" | \"${command_path}grep\" -e '^MemAvailable' | /usr/bin/awk '{print $2}')\n    availableMemValue=\\\"$(\"${command_path}echo\" \"[$total, $availableMem]\" | \"$JQ_BINARY\" -c '((.[0] - .[1])/1024)')\\\"\n    memoryUsedInteger=$(\"${command_path}echo\" \"[$total, $availableMem]\" | \"$JQ_BINARY\" -c '((.[0] - .[1])/1024)')\n\n    totalMemValue=\\\"$(\"${command_path}echo\" \"[$total]\" | \"$JQ_BINARY\" -c '(.[0]/1024)')\\\"\n    totalMemoryInteger=$(\"${command_path}echo\" \"[$total]\" | \"$JQ_BINARY\" -c '(.[0]/1024)')\n\n    memoryConsumedPercentageValue=\\\"$(\"${command_path}echo\" \"[$memoryUsedInteger, $totalMemoryInteger]\" | \"$JQ_BINARY\" -c '((.[0]*100)/.[1])')\\\"\n    output=$(\"${command_path}echo\" \"[ \"$memoryConsumedPercentageValue\"]\" | \"$JQ_BINARY\" -c '.[0]')\n    Counters=$(\"${command_path}echo\" \"$Counters\" | \"$JQ_BINARY\" -c --argjson output \"$output\" '.data.systemDetails.totalMemoryUsage = $output')\n\n    # getting timezone eg: UTC\n    getTZ=$(date +%Z)\n\n    i=1\n    n=0\n    while read -r line; do\n        if [ $n -ge $i ]; then\n            pidValue=\\\"$(\"${command_path}echo\" \"$line\" | awk {'print $1'})\\\"\n            cpuValue=\\\"$(\"${command_path}echo\" \"$line\" | awk {'print $9'})\\\"\n            memoryValue=\\\"$(\"${command_path}echo\" \"$line\" | awk {'print $10'})\\\"\n            commandValue=$(\"${command_path}echo\" \"$line\" | awk {'print $11'})\n            monthValue=$(\"${command_path}echo\" \"$line\" | awk {'print $3'})\n            dateValue=$(\"${command_path}echo\" \"$line\" | awk {'print $4'})\n            timeValue=$(\"${command_path}echo\" \"$line\" | awk {'print $5'})\n            yearValue=$(\"${command_path}echo\" \"$line\" | awk {'print $6'})\n            startTime=$(date -d \"$monthValue $dateValue $timeValue $yearValue $getTZ\" -u)\n            userValue=$(\"${command_path}echo\" \"$line\" | awk {'print $7'})\n            output=$(\"${command_path}echo\" \"[ \"$pidValue\", \"$cpuValue\", \"$memoryValue\", \\\"$commandValue\\\", \\\"$startTime\\\", \\\"$userValue\\\"]\" | \"$JQ_BINARY\" -c '{\"id\": .[0], \"cpu\": .[1], \"memory\": .[2], \"name\": .[3], \"startTime\": .[4], \"user\": .[5]}')\n            Counters=$(\"${command_path}echo\" \"$Counters\" | \"$JQ_BINARY\" -c --argjson output \"$output\" '.data.processDetails += [$output]')\n        fi;\n        n=$((n+1))\n    done <<< \"$(ps -eo pid,lstart,user,etime,pcpu,pmem,cmd --sort=-pmem)\"\n\n    stringOutput=\"__FM_SESSION_OUTPUT__\"\n    result=\"${stringOutput}${Counters}\"\n\n    \"${command_path}echo\" \"$result\"\n}\n\nPrintInteractiveStatements='{{ PrintInteractiveStatements }}'\n\ncpustatfile='/proc/stat'\nnetstatfile='/proc/net/dev'\n\nwhile [ \"$Reply\" != 'q' ]; do\n    Main\n    \"${command_path}echo\"\n\n    if [ \"$PrintInteractiveStatements\" = 'Yes' ]; then\n        /usr/bin/printf 'Press q to end the loop or press any other key to continue.'\n    fi\n\n    read -r Reply\ndone\n",
      "runAsElevated": true
    },
    "macos": {
      "commands": "#!/bin/bash\nset -e\n\nExitWithFailureMessage() {\n    MESSAGE=\"$1\"\n    JSON=\"$2\"\n    if [[ \"$JSON\" == \"PRINT_JSON\" ]]; then\n        /bin/echo \"{\\\"error\\\":\\\"$MESSAGE\\\"}\"\n    fi\n    WriteStandardError \"$MESSAGE\"\n    exit 1\n}\n\nExitWithSuccessMessage() {\n    /bin/echo \"$1\"\n    exit 0\n}\n\nWriteStandardError() {\n    MESSAGE=\"$1\"\n    (>&2 /bin/echo \"$MESSAGE\")\n}\n\nJQ=\"jq\"\nVERSION=\"1.6\"\nPRODUCT_PATH=\"/opt/amazon/ssm/fleet_manager\"\nJQ_BINARY=\"$PRODUCT_PATH/$JQ-$VERSION\"\n\nCheckSha256FileHash() {\n    FILE_PATH=\"$1\"\n    SHA256=\"$2\"\n\n    if [ -f \"$FILE_PATH\" ]; then\n        TEST=$(/bin/echo \"$SHA256  $FILE_PATH\" | /usr/bin/shasum -c 2>&1) || return 1\n        return 0\n    fi\n\n    return 1\n}\n\nSetLockedDownPermissions() {\n    /bin/chmod u+rwx \"$1\"\n    /bin/chmod go-rwx \"$1\"\n    /usr/sbin/chown \"$(/usr/bin/whoami)\":\"$(/usr/bin/id -g -nr)\" \"$1\"\n}\n\nCreateLockedDownFolder() {\n    /bin/mkdir -p \"$1\"\n    SetLockedDownPermissions \"$1\"\n}\n\nDownloadFile() {\n    SOURCE=\"$1\"\n    DESTINATION=\"$2\"\n    /usr/bin/curl -s \"$SOURCE\" -o \"$DESTINATION\"\n}\n\nGetJQSHA256Hash() {\n    case \"$1\" in\n        'x86_64')\n            /bin/echo \"5c0a0a3ea600f302ee458b30317425dd9632d1ad8882259fcaf4e9b868b2b1ef\"\n            ;;\n        *)\n            ExitWithFailureMessage \"The CPU architecture '$1' is not supported. Failing execution.\" 'PRINT_JSON'\n            ;;\n    esac\n}\n\nRandomString() {\n    /usr/bin/openssl rand -base64 6\n}\n\nInstallJQ() {\n    CreateLockedDownFolder \"$PRODUCT_PATH\"\n\n    CPU_ARCH=$(/usr/bin/uname -m)\n    JQ_SHA256=$(GetJQSHA256Hash \"$CPU_ARCH\")\n\n    CheckSha256FileHash \"$JQ_BINARY\" \"$JQ_SHA256\" || {\n        JQ_TEMP_BINARY=\"$PRODUCT_PATH/$(RandomString)\"\n\n        OS_NAME=$(/usr/bin/uname -s)\n        REGION=\"us-east-1\"\n        S3_BUCKET=\"aws-fleet-manager-artifacts-us-east-1\"\n        S3_DNS=\"s3.us-east-1.amazonaws.com\"\n        SOURCE=\"https://$S3_BUCKET.$S3_DNS/$JQ/$VERSION/$OS_NAME/$CPU_ARCH/$JQ\"\n        DownloadFile \"$SOURCE\" \"$JQ_TEMP_BINARY\"\n\n        CheckSha256FileHash \"$JQ_TEMP_BINARY\" \"$JQ_SHA256\" || {\n            /bin/rm -f \"$JQ_TEMP_BINARY\"\n            ExitWithFailureMessage \"Downloading the $JQ binary failed. Failing execution.\"\n        }\n\n        /bin/mv \"$JQ_TEMP_BINARY\" \"$JQ_BINARY\"\n    }\n\n    SetLockedDownPermissions \"$JQ_BINARY\"\n}\n\nInstallJQ\n\nMain () {\n    Counters=''\n    timestamp=$(date +%s)\n\n    Counters=$(\"${command_path}echo\" \"[ $timestamp ]\" | \"$JQ_BINARY\" -c '{timestamp: .[0]}')\n    processDetails=$(\"${command_path}echo\" '{\"data\": {\"processDetails\": []}}' | \"$JQ_BINARY\" -c '.')\n\n    Counters=$(\"$JQ_BINARY\" -c --argjson Counters \"$Counters\" --argjson processDetails \"$processDetails\" -n '$Counters * $processDetails')\n    cpuCounters=$(\"${command_path}echo\" '{\"data\": {\"systemDetails\": {\"totalCpuUsage\": []}}}' | \"$JQ_BINARY\" -c '.')\n\n    Counters=$(\"$JQ_BINARY\" -c --argjson Counters \"$Counters\" --argjson output \"$cpuCounters\" -n '$Counters * $output')\n\n    zero=0\n    one=1\n    two=2\n    three=3\n    four=4\n    five=5\n    six=6\n    seven=7\n    eight=8\n    nine=9\n    ten=10\n\n    while read -r -a line; do\n        getTZ=\"${line[four]}\"\n    done <<< \"$(date)\"\n\n    i=1\n    n=0\n\n    cpuUsage=0\n    memUsage=0\n    while read -r -a line; do\n        if [[ n -ge i ]]; then\n            cpuUsage=`echo $cpuUsage + ${line[eight]} | bc`\n            memUsage=`echo $memUsage + ${line[nine]} | bc`\n\n            pidValue=\\\"${line[zero]}\\\"\n            cpuValue=\\\"${line[eight]}\\\"\n            memoryValue=\\\"${line[nine]}\\\"\n            commandValue=\"${line[ten]}\"\n            startTime=\"${line[two]} ${line[three]} ${line[five]} ${line[four]} ${getTZ}\"\n            userValue=\"${line[six]}\"\n            output=$(\"${command_path}echo\" \"[ \"$pidValue\", \"$cpuValue\", \"$memoryValue\", \\\"$commandValue\\\", \\\"$startTime\\\", \\\"$userValue\\\"]\" | \"$JQ_BINARY\" -c '{\"id\": .[0], \"cpu\": .[1], \"memory\": .[2], \"name\": .[3], \"startTime\": .[4], \"user\": .[5]}')\n            Counters=$(\"${command_path}echo\" \"$Counters\" | \"$JQ_BINARY\" -c --argjson output \"$output\" '.data.processDetails += [$output]')\n        fi\n        ((n++))\n    done <<< \"$(ps -eo pid,lstart,user,etime,pcpu,pmem,command -m)\"\n    cpuUsage=\\\"$cpuUsage\\\"\n    memUsage=\\\"$memUsage\\\"\n\n    output=$(\"${command_path}echo\" \"[ \"$cpuUsage\"]\" | \"$JQ_BINARY\" -c '.[0]')\n    Counters=$(\"${command_path}echo\" \"$Counters\" | \"$JQ_BINARY\" -c --argjson output \"$output\" '.data.systemDetails.totalCpuUsage = $output')\n\n    memCounters=$(\"${command_path}echo\" '{\"data\": {\"systemDetails\": {\"totalMemoryUsage\": []}}}' | \"$JQ_BINARY\" -c '.')\n    Counters=$(\"$JQ_BINARY\" -c --argjson Counters \"$Counters\" --argjson output \"$memCounters\" -n '$Counters * $output')\n    output=$(\"${command_path}echo\" \"[ \"$memUsage\"]\" | \"$JQ_BINARY\" -c '.[0]')\n    Counters=$(\"${command_path}echo\" \"$Counters\" | \"$JQ_BINARY\" -c --argjson output \"$output\" '.data.systemDetails.totalMemoryUsage = $output')\n\n    StringOutput=\"__FM_SESSION_OUTPUT__\"\n    StringOutput+=$Counters\n\n    \"${command_path}echo\" \"$StringOutput\"\n}\n\nPrintInteractiveStatements='{{ PrintInteractiveStatements }}'\n\nwhile [ \"$Reply\" != 'q' ]; do\n    Main\n    \"${command_path}echo\"\n\n    if [ \"$PrintInteractiveStatements\" = 'Yes' ]; then\n        /usr/bin/printf 'Press q to end the loop or press any other key to continue.'\n    fi\n\n    read -r Reply\ndone\n",
      "runAsElevated": true
    }
  }
}
