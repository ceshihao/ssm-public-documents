{
  "schemaVersion": "0.3",
  "description": "SSM Automation for upgrading SQL Server 2008 (or later) to SQL Server 2014/2016/2017/2019.  The running instance remains untouched, while the automation upgrades a cloned instance. If the instance is running Windows Server 2008 R2, the automation will upgrade the operating system to Windows Server 2012 R2. If you are upgrading the SQL Server to 2019  and your Windows is 2008/2012, it will first upgrade your Windows Server to 2016 and upgrade  SQL Server afterwards.",
  "parameters": {
    "InstanceId": {
      "type": "String",
      "description": "(Required) The instance running Windows Server 2008 R2 or above, SQL Server 2008 or above, with the SSM agent installed.",
      "allowedPattern": "^[a-zA-Z0-9]*i-[a-z0-9]{8,17}$"
    },
    "IamInstanceProfile": {
      "type": "String",
      "description": "(Required) The IAM instance profile managed policy attached. Please refer to https://docs.aws.amazon.com/systems-manager/latest/userguide/sysman-configuring-access-role.html for more information.",
      "allowedPattern": "^[\\w+=,.@-]{1,128}$"
    },
    "SubnetId": {
      "type": "String",
      "description": "(Required) Provide a subnet for the upgrade process. Verify that the subnet has outbound connectivity to AWS services, Amazon S3, and Microsoft (to download patches).",
      "allowedPattern": "^subnet-[a-z0-9]{8,17}$"
    },
    "SQLServerSnapshotId": {
      "type": "String",
      "description": "(Conditional) The snapshot id for target SQL Server installation media. This parameter  is not required for SQL Server license-included instances (instances launched using an  AWS provided Amazon Machine Image for Windows Server with Microsoft SQL Server), only  required if you are running BYOL instance.",
      "default": "",
      "allowedPattern": "(^$|^snap-[0-9a-f]+$)"
    },
    "AlternativeKeyPairName": {
      "type": "String",
      "description": "(Optional) The name of an alternative key pair to use during the upgrade process. Useful in situations where the key pair used on the original instance is not available.",
      "default": "",
      "allowedPattern": "^[\\x21-\\x7F]{0,255}$"
    },
    "KeepPreUpgradeImageBackUp": {
      "type": "String",
      "description": "(Optional) If set to True, the Automation doesn't delete the AMI created from the instance before the upgrade. By default, the AMI is deleted.",
      "default": "False",
      "allowedValues": [
        "True",
        "False"
      ]
    },
    "RebootInstanceBeforeTakingImage": {
      "type": "String",
      "description": "(Optional) If set to True, the Automation reboots the instance before creating a pre-upgrade AMI. By default, the Automation doesn't reboot before upgrade.",
      "default": "False",
      "allowedValues": [
        "True",
        "False"
      ]
    },
    "TargetSQLVersion": {
      "type": "String",
      "description": "(Optional) Select the target SQL Server version. Default is SQL Server 2016.",
      "default": "2016",
      "allowedValues": [
        "2014",
        "2016",
        "2017",
        "2019"
      ]
    }
  },
  "mainSteps": [
    {
      "name": "assertSSMAgentOnline",
      "action": "aws:assertAwsResourceProperty",
      "maxAttempts": 5,
      "timeoutSeconds": 120,
      "onFailure": "Abort",
      "inputs": {
        "Service": "ssm",
        "Api": "DescribeInstanceInformation",
        "InstanceInformationFilterList": [
          {
            "key": "InstanceIds",
            "valueSet": [
              "{{ InstanceId }}"
            ]
          }
        ],
        "PropertySelector": "$.InstanceInformationList[0].PingStatus",
        "DesiredValues": [
          "Online"
        ]
      },
      "isCritical": "true",
      "nextStep": "assertReadyToUpgradeSQLServer"
    },
    {
      "name": "assertReadyToUpgradeSQLServer",
      "action": "aws:runCommand",
      "maxAttempts": 3,
      "onFailure": "Abort",
      "timeoutSeconds": 300,
      "inputs": {
        "DocumentName": "AWS-RunPowerShellScript",
        "InstanceIds": [
          "{{ InstanceId }}"
        ],
        "Parameters": {
          "executionTimeout": "300",
          "commands": [
            "function Check-SqlUpgradeEligibility {",
            "$osInfo = (Get-WmiObject -class Win32_OperatingSystem)",
            "# https://docs.microsoft.com/en-us/windows/desktop/CIMWin32Prov/win32-operatingsystem ProductType 3 is Server\" ,",
            "if ($osInfo.ProductType -ne 3) {",
            "Write-Host \"Server Upgrade not allowed if Server is of type Work Station OR Domain Controller.\"",
            "exit 1",
            "}",
            "",
            "$OSVersion = $osInfo.Caption.ToUpper()",
            "$instances = (get-itemproperty \"HKLM:\\SOFTWARE\\Microsoft\\Microsoft SQL Server\").InstalledInstances",
            "if ($instances.count -eq 0) {",
            "Write-Host \"Couldn't find any installed instance of SQL Server.\"",
            "exit 1",
            "}",
            "if ($instances.count -gt 1) {",
            "Write-Host \"Found multiple instances of SQL Server, presently not supported\"",
            "exit 1",
            "}",
            "$instance = (Get-ItemProperty \"HKLM:\\SOFTWARE\\Microsoft\\Microsoft SQL Server\\Instance Names\\SQL\").$instances",
            "$instanceDetails = (Get-ItemProperty \"HKLM:\\SOFTWARE\\Microsoft\\Microsoft SQL Server\\$instance\\Setup\")",
            "$edition = $instanceDetails.Edition",
            "",
            "$targetSQLVersion = {{ TargetSQLVersion }}",
            "",
            "Write-Host \"SQL Server Edition is $edition\"",
            "",
            "if ($instanceDetails.Cluster) {",
            "Write-Host \"SQL Server is clustered, presently not supported\"",
            "exit 1",
            "}",
            "$v = $instanceDetails.Version.subString(0, $instanceDetails.Version.indexOf(\".\"))",
            "if ($v -ge 10) {",
            "if ($v -eq 10 ) {",
            "if ($instanceDetails.SP -lt 3) {",
            "Write-host \"SQL Server Version 2008 , apply patch for SQL Server 2008\"",
            "}",
            "ElseIf ($instanceDetails.SP -eq 3) {",
            "Write-host \"Supported SQL Version 2008 R2 SP3\"",
            "}",
            "}",
            "else {",
            "if (($v -eq 13) -and ($targetSQLVersion -eq '2014'))",
            "{ ",
            "Write-Host \"Current SQL Version 2016, cannot downgrade to 2014.\"",
            "exit 1",
            "}",
            "elseif (($v -eq 14) -and (($targetSQLVersion -eq '2016') -or ($targetSQLVersion -eq '2014')))",
            "{ ",
            "Write-Host \"Current SQL Version 2017, cannot downgrade to $targetSQLVersion.\"",
            "exit 1",
            "}",
            "elseif (($v -eq 15) -and (($targetSQLVersion -eq '2017') -or ($targetSQLVersion -eq '2016') -or ($targetSQLVersion -eq '2014')))",
            "{ ",
            "Write-Host \"Current SQL Version 2019, cannot downgrade to $targetSQLVersion.\"",
            "  exit 1",
            "}",
            "else",
            "{ ",
            "Write-host \"Supported SQL Version\"",
            "}",
            "}",
            "}",
            "else {",
            "Write-host \" SQL Server Version $instanceDetails.Version is presently not supported\"",
            "exit 1",
            "}",
            "[System.Reflection.Assembly]::LoadWithPartialName(\"Microsoft.SqlServer.SMO\") | out-null",
            "$SQLServer = New-Object (\"Microsoft.SqlServer.Management.Smo.Server\")",
            "if([string]::IsNullOrEmpty($SQLServer.VersionString)) {$SQLServer=New-Object (\"Microsoft.SqlServer.Management.Smo.Server\") \"$env:COMPUTERNAME\\$instances\"} ",
            "Foreach ($Database in $SQLServer.Databases) {",
            "if ($Database.IsMirroringEnabled) {",
            "$Name = $Database.Name",
            "Write-Host \"Mirroring is enabled for DB $Name \"",
            "Write-Host \" Presently we are not supporting Mirroring instances \"",
            "exit 1",
            "}",
            "}",
            "",
            "$targetVersion = {{ TargetSQLVersion }}",
            "if ((($OSVersion.indexOf(\"2019\")  -ge 0) -or ($OSVersion.indexOf(\"2016\")  -ge 0)) -and (($OSVersion.indexOf(\"STANDARD\") -ge 0) -or ($OSVersion.indexOf(\"DATACENTER\") -ge 0))) {",
            "Write-Host \"OSVersion : $OSVersion \"",
            "}",
            "elseif (($OSVersion.indexOf(\"2012\") -ge 0 ) -and (($OSVersion.indexOf(\"STANDARD\") -ge 0) -or ($OSVersion.indexOf(\"DATACENTER\") -ge 0))) {",
            "if($targetVersion -eq \"2019\")",
            "{",
            "Write-Host \"WINDOWSUPGRADE 2016 Will be done first\"",
            "}",
            "else",
            "{",
            "Write-Host \"OSVersion : $OSVersion \"",
            "}",
            "}",
            "elseif ($OSVersion.indexOf(\"2008\") -ge 0 -and (($OSVersion.indexOf(\"STANDARD\") -ge 0) -or ($OSVersion.indexOf(\"DATACENTER\") -ge 0))) {",
            "Write-Host \"WINDOWSUPGRADE 2012 Will be done first\"",
            "}",
            "else {",
            "Write-Host \"This document support upgrades of 2012 R2/RTM Standard, 2012 R2/RTM Datacenter, 2016 Standard and 2016 Datacenter\"",
            "exit 1",
            "}",
            "}",
            "",
            "",
            "function Validate-InstanceLicensing([string]$SnapshotId) {",
            "$IsError = $True",
            "try {",
            "# signature verification for IMDS",
            "Add-Type -AssemblyName System.Security",
            "$region = \"us-east-1\"",
            "[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12",
            "$certificate_string = (Invoke-RestMethod -Uri \"https://s3.us-west-2.amazonaws.com/aws.portingassistant.dotnet.datastore/certificates/imds_certificates.json\").certificates.$region",
            "$certificate_bytes_arr = [system.Text.Encoding]::UTF8.GetBytes($certificate_string)",
            "$token = (Invoke-RestMethod -Method Put -Uri http://169.254.169.254/latest/api/token -Headers @{\"X-aws-ec2-metadata-token-ttl-seconds\"=\"60\"})",
            "$Signature = [Convert]::FromBase64String((Invoke-WebRequest -UseBasicParsing -Headers @{'X-aws-ec2-metadata-token' = [string]$token} http://169.254.169.254/latest/dynamic/instance-identity/rsa2048).Content)",
            "$Document = [Text.Encoding]::UTF8.GetBytes((Invoke-WebRequest -UseBasicParsing -Headers @{'X-aws-ec2-metadata-token' = [string]$token} http://169.254.169.254/latest/dynamic/instance-identity/document).Content)",
            "$X509Certificate2 = New-Object -TypeName Security.Cryptography.X509Certificates.X509Certificate2 -ArgumentList @(,$certificate_bytes_arr)",
            "$Store = New-Object -TypeName Security.Cryptography.X509Certificates.X509Certificate2Collection -ArgumentList $X509Certificate2",
            "$SignatureDocument = New-Object -TypeName Security.Cryptography.Pkcs.SignedCms",
            "$SignatureDocument.Decode($Signature)",
            "$verify_result = $SignatureDocument.CheckSignature($Store, $true)",
            "if ($verify_result) {",
            "throw $verify_result",
            "}",
            "if(![Linq.Enumerable]::SequenceEqual($SignatureDocument.ContentInfo.Content, $Document)) {",
            "throw \"Instance Identity Document Cannot be Validated.\"",
            "}",
            "",
            "# compatible with PS2.0",
            "$token = (Invoke-RestMethod -Method Put -Uri http://169.254.169.254/latest/api/token -Headers @{\"X-aws-ec2-metadata-token-ttl-seconds\"=\"60\"})",
            "$webrequest = [System.Net.WebRequest]::Create(\"http://169.254.169.254/latest/dynamic/instance-identity/document\")",
            "$webrequest.Headers.Add(\"X-aws-ec2-metadata-token\",$token)",
            "$response = $webrequest.GetResponse()",
            "$stream = $response.GetResponseStream()",
            "$sr = new-object System.IO.StreamReader($stream)",
            "$content = $sr.ReadToEnd();",
            "[System.Reflection.Assembly]::LoadWithPartialName(\"System.Web.Extensions\") | out-null",
            "$ser = New-Object System.Web.Script.Serialization.JavaScriptSerializer",
            "$billingProduct = $ser.DeserializeObject($content).billingProducts",
            "if (($billingProduct -eq \"bp-6aa54003\") -or ($billingProduct -eq \"bp-62a5400b\") -or ($billingProduct -eq \"bp-65a5400c\")) {",
            "$IsError = $False",
            "Write-Host \"Instance has license included\"",
            "}",
            "elseif (-not [string]::IsNullOrEmpty($SnapshotId)) {",
            "$IsError = $False",
            "Write-Host \"Instance will use $SnapshotId for BYOL\"",
            "}",
            "else {",
            "$IsError = $True",
            "Write-Host \"Your instance is BYOL, but you did not provide a BYOL Windows installation media snapshot id. Please re-run this automation with the necessary paramaters.\"",
            "}",
            "}",
            "catch {",
            "Write-Error $_.Exception.Message",
            "}",
            "finally {",
            "if ($sr -ne $null) { $sr.Close(); }",
            "if ($response -ne $null) { $response.Close(); }",
            "if ($IsError) {",
            "exit 1",
            "}",
            "else {",
            "exit 0",
            "}",
            "}",
            "}",
            "",
            "try {",
            "Check-SqlUpgradeEligibility",
            "$SnapShotId = \"{{ SQLServerSnapshotId }}\"",
            "Validate-InstanceLicensing($SnapShotId)",
            "}",
            "catch {",
            "Write-Error $_.Exception.Message",
            "exit 1",
            "}"
          ]
        }
      },
      "isCritical": "true",
      "nextStep": "describeOriginalInstanceDetails"
    },
    {
      "name": "describeOriginalInstanceDetails",
      "action": "aws:executeAwsApi",
      "maxAttempts": 2,
      "onFailure": "Abort",
      "timeoutSeconds": 300,
      "inputs": {
        "Service": "ec2",
        "Api": "DescribeInstances",
        "InstanceIds": [
          "{{ InstanceId }}"
        ]
      },
      "outputs": [
        {
          "Name": "InstanceType",
          "Selector": "$.Reservations[0].Instances[0].InstanceType",
          "Type": "String"
        },
        {
          "Name": "KeyName",
          "Selector": "$.Reservations[0].Instances[0].KeyName",
          "Type": "String"
        },
        {
          "Name": "AvailabilityZone",
          "Selector": "$.Reservations[0].Instances[0].Placement.AvailabilityZone",
          "Type": "String"
        },
        {
          "Name": "RootDeviceName",
          "Selector": "$.Reservations[0].Instances[0].RootDeviceName",
          "Type": "String"
        },
        {
          "Name": "SubnetId",
          "Selector": "$.Reservations[0].Instances[0].NetworkInterfaces[0].SubnetId",
          "Type": "String"
        },
        {
          "Name": "Platform",
          "Selector": "$.Reservations[0].Instances[0].Platform",
          "Type": "String"
        },
        {
          "Name": "SecurityGroupIds",
          "Selector": "$.Reservations[0].Instances[0].SecurityGroups..GroupId",
          "Type": "StringList"
        }
      ],
      "isCritical": "false",
      "nextStep": "assertRootVolumeIsEbs"
    },
    {
      "name": "assertRootVolumeIsEbs",
      "action": "aws:assertAwsResourceProperty",
      "onFailure": "Abort",
      "maxAttempts": 2,
      "timeoutSeconds": 300,
      "inputs": {
        "Service": "ec2",
        "Api": "DescribeInstances",
        "InstanceIds": [
          "{{ InstanceId }}"
        ],
        "PropertySelector": "$.Reservations[0].Instances[0].RootDeviceType",
        "DesiredValues": [
          "ebs"
        ]
      },
      "isCritical": "true",
      "nextStep": "branchIfWindowsUpgradeRequired"
    },
    {
      "name": "branchIfWindowsUpgradeRequired",
      "action": "aws:branch",
      "onFailure": "Abort",
      "inputs": {
        "Choices": [
          {
            "NextStep": "putWindowsUpgradeRequiredMetric",
            "Variable": "{{ assertReadyToUpgradeSQLServer.Output }}",
            "Contains": "WINDOWSUPGRADE 2012"
          },
          {
            "NextStep": "putWindows2016UpgradeRequiredMetric",
            "Variable": "{{ assertReadyToUpgradeSQLServer.Output }}",
            "Contains": "WINDOWSUPGRADE 2016"
          }
        ],
        "Default": "branchOnRebootInstanceBeforeTakingImage"
      },
      "isCritical": "true"
    },
    {
      "name": "putWindowsUpgradeRequiredMetric",
      "action": "aws:putServerUpgradeMetrics",
      "maxAttempts": 3,
      "onFailure": "Abort",
      "inputs": {
        "DimensionName": "SSM_METRICS",
        "DimensionValue": "AWSEC2-CloneInstanceAndUpgradeSQLServer",
        "MetricName": "Windows_Upgrade_Required",
        "MetricValue": "1.0"
      },
      "isCritical": "true",
      "nextStep": "upgradeWindowsFirst"
    },
    {
      "name": "putWindows2016UpgradeRequiredMetric",
      "action": "aws:putServerUpgradeMetrics",
      "maxAttempts": 3,
      "onFailure": "Abort",
      "inputs": {
        "DimensionName": "SSM_METRICS",
        "DimensionValue": "AWSEC2-CloneInstanceAndUpgradeSQLServer",
        "MetricName": "Windows_Upgrade_Required",
        "MetricValue": "1.0"
      },
      "isCritical": "true",
      "nextStep": "upgradeWindows2016First"
    },
    {
      "name": "putNoWindowsUpgradeRequiredMetric",
      "action": "aws:putServerUpgradeMetrics",
      "maxAttempts": 3,
      "onFailure": "Abort",
      "inputs": {
        "DimensionName": "SSM_METRICS",
        "DimensionValue": "AWSEC2-CloneInstanceAndUpgradeSQLServer",
        "MetricName": "No_Windows_Upgrade_Required",
        "MetricValue": "1.0"
      },
      "isCritical": "true",
      "nextStep": "branchOnRebootInstanceBeforeTakingImage"
    },
    {
      "name": "upgradeWindowsFirst",
      "action": "aws:executeAutomation",
      "maxAttempts": 3,
      "onFailure": "Abort",
      "inputs": {
        "DocumentName": "AWSEC2-CloneInstanceAndUpgradeWindows",
        "RuntimeParameters": {
          "InstanceId": [
            "{{ InstanceId }}"
          ],
          "IamInstanceProfile": [
            "{{ IamInstanceProfile }}"
          ],
          "SubnetId": [
            "{{ SubnetId }}"
          ],
          "AlternativeKeyPairName": [
            "{{ AlternativeKeyPairName }}"
          ]
        }
      },
      "isCritical": "true",
      "nextStep": "getWindowsUpgradeAMI"
    },
    {
      "name": "upgradeWindows2016First",
      "action": "aws:executeAutomation",
      "maxAttempts": 3,
      "onFailure": "Abort",
      "inputs": {
        "DocumentName": "AWSEC2-CloneInstanceAndUpgradeWindows",
        "RuntimeParameters": {
          "InstanceId": [
            "{{ InstanceId }}"
          ],
          "IamInstanceProfile": [
            "{{ IamInstanceProfile }}"
          ],
          "SubnetId": [
            "{{ SubnetId }}"
          ],
          "AlternativeKeyPairName": [
            "{{ AlternativeKeyPairName }}"
          ],
          "TargetWindowVersion": [
            "2016"
          ]
        }
      },
      "isCritical": "true",
      "nextStep": "getWindows2016UpgradeAMI"
    },
    {
      "name": "getWindowsUpgradeAMI",
      "action": "aws:executeAwsApi",
      "onFailure": "Abort",
      "inputs": {
        "Service": "ssm",
        "Api": "GetAutomationExecution",
        "AutomationExecutionId": "{{ upgradeWindowsFirst.ExecutionId }}"
      },
      "outputs": [
        {
          "Name": "ImageId",
          "Selector": "$.AutomationExecution.Outputs.'UpgradedTo2012R2.ImageId'[0]",
          "Type": "String"
        }
      ],
      "isCritical": "true",
      "nextStep": "addUniqueTagForTheAMI"
    },
    {
      "name": "getWindows2016UpgradeAMI",
      "action": "aws:executeAwsApi",
      "onFailure": "Abort",
      "inputs": {
        "Service": "ssm",
        "Api": "GetAutomationExecution",
        "AutomationExecutionId": "{{ upgradeWindows2016First.ExecutionId }}"
      },
      "outputs": [
        {
          "Name": "ImageId",
          "Selector": "$.AutomationExecution.Outputs.'UpgradedFrom2012R2Or2016.ImageId'[0]",
          "Type": "String"
        }
      ],
      "isCritical": "true",
      "nextStep": "addUniqueTagForThe2016AMI"
    },
    {
      "name": "addUniqueTagForTheAMI",
      "action": "aws:createTags",
      "onFailure": "step:deleteServerUpgradeInstance",
      "inputs": {
        "ResourceIds": [
          "{{ getWindowsUpgradeAMI.ImageId }}"
        ],
        "Tags": [
          {
            "Key": "AWSEC2-ORIG-IMAGE-{{ automation:EXECUTION_ID }}",
            "Value": "AWSEC2-IMAGE: {{ InstanceId }}"
          }
        ],
        "ResourceType": "EC2"
      },
      "isCritical": "true",
      "nextStep": "describeOriginalInstanceImage"
    },
    {
      "name": "addUniqueTagForThe2016AMI",
      "action": "aws:createTags",
      "onFailure": "step:deleteServerUpgradeInstance",
      "inputs": {
        "ResourceIds": [
          "{{ getWindows2016UpgradeAMI.ImageId }}"
        ],
        "Tags": [
          {
            "Key": "AWSEC2-ORIG-IMAGE-{{ automation:EXECUTION_ID }}",
            "Value": "AWSEC2-IMAGE: {{ InstanceId }}"
          }
        ],
        "ResourceType": "EC2"
      },
      "isCritical": "true",
      "nextStep": "describeOriginalInstanceImage"
    },
    {
      "name": "branchOnRebootInstanceBeforeTakingImage",
      "action": "aws:branch",
      "onFailure": "Abort",
      "inputs": {
        "Choices": [
          {
            "NextStep": "createImageWithReboot",
            "Variable": "{{ RebootInstanceBeforeTakingImage }}",
            "EqualsIgnoreCase": "True"
          }
        ],
        "Default": "createImageWithNoReboot"
      },
      "isCritical": "true"
    },
    {
      "name": "createImageWithReboot",
      "action": "aws:executeAwsApi",
      "maxAttempts": 2,
      "onFailure": "step:deleteServerUpgradeInstance",
      "inputs": {
        "Service": "ec2",
        "Api": "CreateImage",
        "InstanceId": "{{ InstanceId }}",
        "Name": "AWSEC2SQLSERVER_ImageFromOriginalInstance_{{ automation:EXECUTION_ID }}",
        "NoReboot": false
      },
      "outputs": [
        {
          "Name": "ImageId",
          "Selector": "$.ImageId",
          "Type": "String"
        }
      ],
      "nextStep": "getImageWhereNoWindowUpgradeHappen"
    },
    {
      "name": "createImageWithNoReboot",
      "action": "aws:executeAwsApi",
      "maxAttempts": 2,
      "onFailure": "step:deleteServerUpgradeInstance",
      "inputs": {
        "Service": "ec2",
        "Api": "CreateImage",
        "InstanceId": "{{ InstanceId }}",
        "Name": "AWSEC2SQLSERVER_ImageFromOriginalInstance_{{ automation:EXECUTION_ID }}",
        "NoReboot": true
      },
      "outputs": [
        {
          "Name": "ImageId",
          "Selector": "$.ImageId",
          "Type": "String"
        }
      ],
      "nextStep": "getImageWhereNoWindowUpgradeHappen"
    },
    {
      "name": "getImageWhereNoWindowUpgradeHappen",
      "action": "aws:executeAwsApi",
      "maxAttempts": 2,
      "onFailure": "step:deleteServerUpgradeInstance",
      "inputs": {
        "Service": "ec2",
        "Api": "DescribeImages",
        "Filters": [
          {
            "Name": "name",
            "Values": [
              "AWSEC2SQLSERVER_ImageFromOriginalInstance_{{ automation:EXECUTION_ID }}"
            ]
          }
        ]
      },
      "outputs": [
        {
          "Name": "ImageId",
          "Selector": "$.Images[0].ImageId",
          "Type": "String"
        }
      ],
      "nextStep": "addTagForTheAMINoWindowUpgrade"
    },
    {
      "name": "addTagForTheAMINoWindowUpgrade",
      "action": "aws:createTags",
      "onFailure": "step:deleteServerUpgradeInstance",
      "inputs": {
        "ResourceIds": [
          "{{ getImageWhereNoWindowUpgradeHappen.ImageId }}"
        ],
        "Tags": [
          {
            "Key": "AWSEC2-ORIG-IMAGE-{{ automation:EXECUTION_ID }}",
            "Value": "AWSEC2-IMAGE: {{ InstanceId }}"
          }
        ],
        "ResourceType": "EC2"
      },
      "isCritical": "true",
      "nextStep": "describeOriginalInstanceImage"
    },
    {
      "name": "describeOriginalInstanceImage",
      "action": "aws:executeAwsApi",
      "maxAttempts": 2,
      "onFailure": "step:deleteServerUpgradeInstance",
      "inputs": {
        "Service": "ec2",
        "Api": "DescribeImages",
        "Filters": [
          {
            "Name": "tag-key",
            "Values": [
              "AWSEC2-ORIG-IMAGE-{{ automation:EXECUTION_ID }}"
            ]
          }
        ]
      },
      "outputs": [
        {
          "Name": "ImageId",
          "Selector": "$.Images[0].ImageId",
          "Type": "String"
        }
      ],
      "nextStep": "waitTillOriginalInstanceImageImageReady"
    },
    {
      "name": "waitTillOriginalInstanceImageImageReady",
      "action": "aws:waitForAwsResourceProperty",
      "onFailure": "step:deleteServerUpgradeInstance",
      "maxAttempts": 2,
      "inputs": {
        "Service": "ec2",
        "Api": "DescribeImages",
        "ImageIds": [
          "{{ describeOriginalInstanceImage.ImageId }}"
        ],
        "PropertySelector": "$.Images[0].State",
        "DesiredValues": [
          "available"
        ]
      },
      "nextStep": "branchUseAlternativeKeyPair"
    },
    {
      "name": "branchUseAlternativeKeyPair",
      "action": "aws:branch",
      "onFailure": "Abort",
      "inputs": {
        "Choices": [
          {
            "NextStep": "serverUpgradeInstanceWithAlternativeKeyPair",
            "Not": {
              "Variable": "{{ AlternativeKeyPairName }}",
              "StringEquals": ""
            }
          }
        ],
        "Default": "serverUpgradeInstanceWithOriginalKeyPair"
      },
      "isCritical": "true"
    },
    {
      "name": "serverUpgradeInstanceWithAlternativeKeyPair",
      "action": "aws:runInstances",
      "timeoutSeconds": 2700,
      "maxAttempts": 3,
      "onFailure": "step:deleteServerUpgradeInstance",
      "inputs": {
        "ImageId": "{{ describeOriginalInstanceImage.ImageId }}",
        "InstanceType": "{{ describeOriginalInstanceDetails.InstanceType }}",
        "MinInstanceCount": 1,
        "MaxInstanceCount": 1,
        "IamInstanceProfileName": "{{ IamInstanceProfile }}",
        "SubnetId": "{{ SubnetId }}",
        "KeyName": "{{ AlternativeKeyPairName }}",
        "SecurityGroupIds": [
          "{{ describeOriginalInstanceDetails.SecurityGroupIds }}"
        ],
        "TagSpecifications": [
          {
            "ResourceType": "instance",
            "Tags": [
              {
                "Key": "Name",
                "Value": "AWSEC2_UpgradeInstance_{{ automation:EXECUTION_ID }}"
              }
            ]
          }
        ],
        "UserData": "PHBvd2Vyc2hlbGw+CiRzZXJ2aWNlTmFtZSA9ICJBbWF6b25TU01BZ2VudCIKJHNlcnZpY2VEb3dubG9hZFBhdGggPSAiQzpcdGVtcFxBbWF6b25TU01BZ2VudFNldHVwLmV4ZSIKCklmIChHZXQtU2VydmljZSAkc2VydmljZU5hbWUgLUVycm9yQWN0aW9uIFNpbGVudGx5Q29udGludWUgLVdhcm5pbmdBY3Rpb24gU2lsZW50bHlDb250aW51ZSkgewogICAgSWYgKChHZXQtU2VydmljZSAkc2VydmljZU5hbWUpLlN0YXR1cyAtbmUgIlJ1bm5pbmciKSB7CiAgICAgICAgU3RhcnQtU2VydmljZSAkc2VydmljZU5hbWUKICAgICAgICBXcml0ZS1Ib3N0ICIkc2VydmljZU5hbWUgZm91bmQsIGJ1dCBpdCBpcyBub3QgcnVubmluZywgc28gc3RhcnRlZCBpdC4iCiAgICB9Cn0gRWxzZSB7CiAgICBXcml0ZS1Ib3N0ICIkc2VydmljZU5hbWUgbm90IGZvdW5kLCB0cnlpbmcgdG8gaW5zdGFsbC4iCiAgICAgTmV3LUl0ZW0gLUl0ZW1UeXBlIERpcmVjdG9yeSAtRm9yY2UgLVBhdGggIkM6XHRlbXAiCiAgICAgW1N5c3RlbS5OZXQuU2VydmljZVBvaW50TWFuYWdlcl06OlNlY3VyaXR5UHJvdG9jb2wgPSBbU3lzdGVtLk5ldC5TZWN1cml0eVByb3RvY29sVHlwZV06OlRsczEyOyAgCiAgICAoTmV3LU9iamVjdCBTeXN0ZW0uTmV0LldlYkNsaWVudCkuRG93bmxvYWRGaWxlKCJodHRwczovL3MzLmFtYXpvbmF3cy5jb20vZWMyLWRvd25sb2Fkcy13aW5kb3dzL1NTTUFnZW50L2xhdGVzdC93aW5kb3dzX2FtZDY0L0FtYXpvblNTTUFnZW50U2V0dXAuZXhlIiwgIiRzZXJ2aWNlRG93bmxvYWRQYXRoIikKICAgIFN0YXJ0LVByb2Nlc3MgLUZpbGVQYXRoICIkc2VydmljZURvd25sb2FkUGF0aCIgIC1Bcmd1bWVudExpc3QgQCgiL3F1aWV0IiwgIi9ub3Jlc3RhcnQiLCAiL2xvZyIsICJzc20taW5zdGFsbC5sb2ciLCAiQUxMT1dFQzJJTlNUQUxMPVlFUyIpIC1XYWl0CiAgICBTdGFydC1TbGVlcCAtcyAxMAogICAgU3RhcnQtU2VydmljZSAkc2VydmljZU5hbWUKICAgIFdyaXRlLUhvc3QgIiRzZXJ2aWNlTmFtZSBpbnN0YWxsZWQgYW5kIHN0YXJ0ZWQuIgp9CjwvcG93ZXJzaGVsbD4KPHBlcnNpc3Q+dHJ1ZTwvcGVyc2lzdD4="
      },
      "isCritical": "true",
      "nextStep": "getServerUpgradeInstance"
    },
    {
      "name": "serverUpgradeInstanceWithOriginalKeyPair",
      "action": "aws:runInstances",
      "timeoutSeconds": 2700,
      "maxAttempts": 3,
      "onFailure": "step:deleteServerUpgradeInstance",
      "inputs": {
        "ImageId": "{{ describeOriginalInstanceImage.ImageId }}",
        "InstanceType": "{{ describeOriginalInstanceDetails.InstanceType }}",
        "MinInstanceCount": 1,
        "MaxInstanceCount": 1,
        "IamInstanceProfileName": "{{ IamInstanceProfile }}",
        "SubnetId": "{{ SubnetId }}",
        "KeyName": "{{ describeOriginalInstanceDetails.KeyName }}",
        "SecurityGroupIds": [
          "{{ describeOriginalInstanceDetails.SecurityGroupIds }}"
        ],
        "TagSpecifications": [
          {
            "ResourceType": "instance",
            "Tags": [
              {
                "Key": "Name",
                "Value": "AWSEC2_UpgradeInstance_{{ automation:EXECUTION_ID }}"
              }
            ]
          }
        ],
        "UserData": "PHBvd2Vyc2hlbGw+CiRzZXJ2aWNlTmFtZSA9ICJBbWF6b25TU01BZ2VudCIKJHNlcnZpY2VEb3dubG9hZFBhdGggPSAiQzpcdGVtcFxBbWF6b25TU01BZ2VudFNldHVwLmV4ZSIKCklmIChHZXQtU2VydmljZSAkc2VydmljZU5hbWUgLUVycm9yQWN0aW9uIFNpbGVudGx5Q29udGludWUgLVdhcm5pbmdBY3Rpb24gU2lsZW50bHlDb250aW51ZSkgewogICAgSWYgKChHZXQtU2VydmljZSAkc2VydmljZU5hbWUpLlN0YXR1cyAtbmUgIlJ1bm5pbmciKSB7CiAgICAgICAgU3RhcnQtU2VydmljZSAkc2VydmljZU5hbWUKICAgICAgICBXcml0ZS1Ib3N0ICIkc2VydmljZU5hbWUgZm91bmQsIGJ1dCBpdCBpcyBub3QgcnVubmluZywgc28gc3RhcnRlZCBpdC4iCiAgICB9Cn0gRWxzZSB7CiAgICBXcml0ZS1Ib3N0ICIkc2VydmljZU5hbWUgbm90IGZvdW5kLCB0cnlpbmcgdG8gaW5zdGFsbC4iCiAgICAgTmV3LUl0ZW0gLUl0ZW1UeXBlIERpcmVjdG9yeSAtRm9yY2UgLVBhdGggIkM6XHRlbXAiCiAgICAgW1N5c3RlbS5OZXQuU2VydmljZVBvaW50TWFuYWdlcl06OlNlY3VyaXR5UHJvdG9jb2wgPSBbU3lzdGVtLk5ldC5TZWN1cml0eVByb3RvY29sVHlwZV06OlRsczEyOyAgCiAgICAoTmV3LU9iamVjdCBTeXN0ZW0uTmV0LldlYkNsaWVudCkuRG93bmxvYWRGaWxlKCJodHRwczovL3MzLmFtYXpvbmF3cy5jb20vZWMyLWRvd25sb2Fkcy13aW5kb3dzL1NTTUFnZW50L2xhdGVzdC93aW5kb3dzX2FtZDY0L0FtYXpvblNTTUFnZW50U2V0dXAuZXhlIiwgIiRzZXJ2aWNlRG93bmxvYWRQYXRoIikKICAgIFN0YXJ0LVByb2Nlc3MgLUZpbGVQYXRoICIkc2VydmljZURvd25sb2FkUGF0aCIgIC1Bcmd1bWVudExpc3QgQCgiL3F1aWV0IiwgIi9ub3Jlc3RhcnQiLCAiL2xvZyIsICJzc20taW5zdGFsbC5sb2ciLCAiQUxMT1dFQzJJTlNUQUxMPVlFUyIpIC1XYWl0CiAgICBTdGFydC1TbGVlcCAtcyAxMAogICAgU3RhcnQtU2VydmljZSAkc2VydmljZU5hbWUKICAgIFdyaXRlLUhvc3QgIiRzZXJ2aWNlTmFtZSBpbnN0YWxsZWQgYW5kIHN0YXJ0ZWQuIgp9CjwvcG93ZXJzaGVsbD4KPHBlcnNpc3Q+dHJ1ZTwvcGVyc2lzdD4="
      },
      "isCritical": "true",
      "nextStep": "getServerUpgradeInstance"
    },
    {
      "name": "getServerUpgradeInstance",
      "action": "aws:executeAwsApi",
      "onFailure": "step:deleteServerUpgradeInstance",
      "inputs": {
        "Service": "ec2",
        "Api": "DescribeInstances",
        "InstanceIds": null,
        "Filters": [
          {
            "Name": "tag:Name",
            "Values": [
              "AWSEC2_UpgradeInstance_{{ automation:EXECUTION_ID }}"
            ]
          }
        ]
      },
      "outputs": [
        {
          "Name": "InstanceId",
          "Selector": "$.Reservations[0].Instances[0].InstanceId",
          "Type": "String"
        }
      ],
      "isCritical": "true",
      "nextStep": "waitForInstanceToReady"
    },
    {
      "name": "waitForInstanceToReady",
      "action": "aws:waitForAwsResourceProperty",
      "onFailure": "step:rebootToMakeItReady",
      "timeoutSeconds": 600,
      "maxAttempts": 2,
      "inputs": {
        "Service": "ec2",
        "Api": "DescribeInstanceStatus",
        "InstanceIds": [
          "{{ getServerUpgradeInstance.InstanceId }}"
        ],
        "PropertySelector": "$.InstanceStatuses[0].InstanceStatus.Details[0].Status",
        "DesiredValues": [
          "passed"
        ]
      },
      "isCritical": "false",
      "nextStep": "waitForSSMAgentOnlineOnServerUpgradeInstance"
    },
    {
      "name": "rebootToMakeItReady",
      "action": "aws:executeAwsApi",
      "onFailure": "step:waitForInstanceToBeReadyAfterReboot",
      "inputs": {
        "Service": "ec2",
        "Api": "RebootInstances",
        "InstanceIds": [
          "{{ getServerUpgradeInstance.InstanceId }}"
        ]
      },
      "isCritical": "false",
      "nextStep": "waitForInstanceToBeReadyAfterReboot"
    },
    {
      "name": "waitForInstanceToBeReadyAfterReboot",
      "action": "aws:waitForAwsResourceProperty",
      "onFailure": "step:deleteServerUpgradeInstance",
      "timeoutSeconds": 600,
      "maxAttempts": 2,
      "inputs": {
        "Service": "ec2",
        "Api": "DescribeInstanceStatus",
        "InstanceIds": [
          "{{ getServerUpgradeInstance.InstanceId }}"
        ],
        "PropertySelector": "$.InstanceStatuses[0].InstanceStatus.Details[0].Status",
        "DesiredValues": [
          "passed"
        ]
      },
      "isCritical": "true",
      "nextStep": "waitForSSMAgentOnlineOnServerUpgradeInstance"
    },
    {
      "name": "waitForSSMAgentOnlineOnServerUpgradeInstance",
      "action": "aws:waitForAwsResourceProperty",
      "timeoutSeconds": 120,
      "maxAttempts": 5,
      "onFailure": "step:deleteServerUpgradeInstance",
      "inputs": {
        "Service": "ssm",
        "Api": "DescribeInstanceInformation",
        "InstanceInformationFilterList": [
          {
            "key": "InstanceIds",
            "valueSet": [
              "{{ getServerUpgradeInstance.InstanceId }}"
            ]
          }
        ],
        "PropertySelector": "$.InstanceInformationList[0].PingStatus",
        "DesiredValues": [
          "Online"
        ]
      },
      "isCritical": "true",
      "nextStep": "getUpgradeServerInstanceDetails"
    },
    {
      "name": "getUpgradeServerInstanceDetails",
      "action": "aws:executeAwsApi",
      "maxAttempts": 2,
      "onFailure": "step:deleteServerUpgradeInstance",
      "inputs": {
        "Service": "ec2",
        "Api": "DescribeInstances",
        "InstanceIds": [
          "{{ getServerUpgradeInstance.InstanceId }}"
        ]
      },
      "outputs": [
        {
          "Name": "AvailabilityZone",
          "Selector": "$.Reservations[0].Instances[0].Placement.AvailabilityZone",
          "Type": "String"
        },
        {
          "Name": "SubnetId",
          "Selector": "$.Reservations[0].Instances[0].NetworkInterfaces[0].SubnetId",
          "Type": "String"
        }
      ],
      "isCritical": "true",
      "nextStep": "branchForRequiredPatchesBeforeUpgrade"
    },
    {
      "name": "branchForRequiredPatchesBeforeUpgrade",
      "action": "aws:branch",
      "onFailure": "step:deleteServerUpgradeInstance",
      "inputs": {
        "Choices": [
          {
            "NextStep": "putSQL2008R2SP3Metric",
            "Variable": "{{ assertReadyToUpgradeSQLServer.Output }}",
            "Contains": "2008 R2 SP3"
          },
          {
            "NextStep": "putSQL2008Metric",
            "Variable": "{{ assertReadyToUpgradeSQLServer.Output }}",
            "Contains": "apply patch for SQL Server 2008"
          }
        ],
        "Default": "putSQL2012Metric"
      },
      "isCritical": "true"
    },
    {
      "name": "putSQL2008R2SP3Metric",
      "action": "aws:putServerUpgradeMetrics",
      "maxAttempts": 3,
      "onFailure": "Abort",
      "inputs": {
        "DimensionName": "SSM_METRICS",
        "DimensionValue": "AWSEC2-CloneInstanceAndUpgradeSQLServer",
        "MetricName": "SQL_2008_R2_SP3",
        "MetricValue": "1.0"
      },
      "isCritical": "true",
      "nextStep": "checkAndInstallSpecificPatchesForWindows2012R2"
    },
    {
      "name": "putSQL2008Metric",
      "action": "aws:putServerUpgradeMetrics",
      "maxAttempts": 3,
      "onFailure": "Abort",
      "inputs": {
        "DimensionName": "SSM_METRICS",
        "DimensionValue": "AWSEC2-CloneInstanceAndUpgradeSQLServer",
        "MetricName": "SQL_2008",
        "MetricValue": "1.0"
      },
      "isCritical": "true",
      "nextStep": "applySQLServerPatchForUpgradeEligible"
    },
    {
      "name": "putSQL2012Metric",
      "action": "aws:putServerUpgradeMetrics",
      "maxAttempts": 3,
      "onFailure": "Abort",
      "inputs": {
        "DimensionName": "SSM_METRICS",
        "DimensionValue": "AWSEC2-CloneInstanceAndUpgradeSQLServer",
        "MetricName": "SQL_2012",
        "MetricValue": "1.0"
      },
      "isCritical": "true",
      "nextStep": "runScriptBeforeSQLServerUpgrade"
    },
    {
      "name": "applySQLServerPatchForUpgradeEligible",
      "action": "aws:runCommand",
      "maxAttempts": 3,
      "onFailure": "step:deleteServerUpgradeInstance",
      "timeoutSeconds": 14400,
      "inputs": {
        "DocumentName": "AWS-RunPowerShellScript",
        "InstanceIds": [
          "{{ getServerUpgradeInstance.InstanceId }}"
        ],
        "Parameters": {
          "commands": [
            "function Apply-ServicePack {",
            "$instances = (get-itemproperty \"HKLM:\\SOFTWARE\\Microsoft\\Microsoft SQL Server\").InstalledInstances",
            "$SMOServerDLL = \"Microsoft.SqlServer.Management.Smo.Server\"",
            "[System.Reflection.Assembly]::LoadWithPartialName(\"Microsoft.SqlServer.SMO\") | out-null",
            "$SQLServer = New-Object ($SMOServerDLL)",
            "if ([string]::IsNullOrEmpty($SQLServer.VersionString)){$SQLServer=New-Object ($SMOServerDLL) \"$env:COMPUTERNAME\\$instances\"}  ",
            "Write-host \"SQLServer version $($SQLServer.VersionString)\"",
            "$Versions = $SQLServer.VersionString.Split(\".\")",
            "$SQLVersionObj = New-Object PSObject -Property @{",
            "Version = $SQLServer.VersionString",
            "Major = $Versions[0]",
            "Minor = $Versions[1]",
            "Build = $Versions[2]",
            "Revision = $Versions[3]",
            "}",
            "if ($SQLVersionObj.Major -ge 12) {",
            "Write-host \"Already SQL Server 2014 or above running, exiting\"",
            "exit 0",
            "}",
            "else {",
            "$DownloadUrl = Get-DownloadPath $SQLVersionObj.Major $SQLVersionObj.Minor $SQLVersionObj.Build $SQLVersionObj.Revision",
            "if (-not [string]::IsNullOrEmpty($DownloadUrl)) {",
            "$FileName = $DownloadUrl.Substring($DownloadUrl.LastIndexOf(\"/\") + 1)",
            "$ParentDirectory = \"C:\\SQLUpgrade\\{{ automation:EXECUTION_ID }}\"",
            "if ((Test-Path $ParentDirectory) -eq $false) {",
            "New-Item -ItemType directory -Path $ParentDirectory",
            "}",
            "$FullPath = $ParentDirectory + \"\\\" + $FileName",
            "Download-AndInstall $DownloadUrl $FullPath",
            "$SQLServerNew = New-Object ($SMOServerDLL)",
            "Write-Host \"After upgrade SQL Server version $($SQLServerNew.VersionString)\"",
            "}",
            "else {",
            "Write-host \"No need to install Service pack\"",
            "}",
            "}",
            "}",
            "",
            "function Get-DownloadPath {",
            "PARAM",
            "(",
            "$Major",
            ", $Minor",
            ", $Build",
            ", $Revision",
            ")",
            "if ($Major -eq 10) {",
            "#Microsoft SQL Server 2008 sp4, 10.0.6000.29\"",
            "if ($Minor -eq 0 -and ($Build -lt 6000 -or ($Build -eq 6000 -and $Revision -lt 29))) {",
            "return \"https://download.microsoft.com/download/5/E/7/5E7A89F7-C013-4090-901E-1A0F86B6A94C/ENU/SQLServer2008SP4-KB2979596-x64-ENU.exe\"",
            "}",
            "#Microsoft SQL Server 2008 R2 sp3, 10.50.6000.234\"",
            "elseif ($Minor -lt 50 -or ($Minor -eq 50 -and $Build -lt 6000) -or ($Minor -eq 50 -and $Build -eq 6000 -and $Revision -lt 34)) {",
            "return \"https://download.microsoft.com/download/D/7/A/D7A28B6C-FCFE-4F70-A902-B109388E01E9/ENU/SQLServer2008R2SP3-KB2979597-x64-ENU.exe\"",
            "}",
            "}",
            "else {",
            "#SQL Server 2012 Sp2 , 11.0.5058.0",
            "if ($Minor -eq 0 -and $Build -lt 5058) {",
            "return \"https://download.microsoft.com/download/D/F/7/DF7BEBF9-AA4D-4CFE-B5AE-5C9129D37EFD/SQLServer2012SP2-KB2958429-x64-ENU.exe\"",
            "}",
            "}",
            "}",
            "",
            "function Download-AndInstall {",
            "PARAM",
            "(",
            "$UrlToDownload",
            ", $LocalFilePath",
            ")",
            "$wc = New-Object System.Net.WebClient",
            "$attemptCount = 0",
            "Do {",
            "$attemptCount++",
            "$wc.DownloadFile($UrlToDownload , $LocalFilePath)",
            "} while (((Test-Path $LocalFilePath) -eq $false) -and ($attemptCount -le 3))",
            "If ((Test-Path $LocalFilePath) -eq $true) {",
            "Write-Host \"Downloaded service pack tofile to $LocalFilePath\"",
            "if ($UrlToDownload.IndexOf(\"SQLServer2008SP4\") -ge 0) {",
            "$InstallParameters = \"/allinstances /quiet \"",
            "}",
            "else {",
            "$InstallParameters = \"/allinstances /quiet /IAcceptSQLServerLicenseTerms=True\"",
            "}",
            "Start-Process $LocalFilePath -ArgumentList $InstallParameters -NoNewWindow -Wait",
            "Write-Host \"Installation complete\"",
            "}",
            "Else {",
            "Write-Host \"Error: Couldnâ€™t download service pack, exiting\"",
            "exit 1",
            "}",
            "}",
            "Apply-ServicePack"
          ]
        }
      },
      "isCritical": "true",
      "nextStep": "checkAndInstallSpecificPatchesForWindows2012R2"
    },
    {
      "name": "checkAndInstallSpecificPatchesForWindows2012R2",
      "action": "aws:runCommand",
      "maxAttempts": 3,
      "onFailure": "step:deleteServerUpgradeInstance",
      "timeoutSeconds": 14400,
      "inputs": {
        "DocumentName": "AWS-RunPowerShellScript",
        "InstanceIds": [
          "{{ getServerUpgradeInstance.InstanceId }}"
        ],
        "Parameters": {
          "commands": [
            "function Check-ForReboot {",
            "$AUTOUPDATE = (Get-ItemProperty \"HKLM:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\WindowsUpdate\\Auto Update\")",
            "If ($AUTOUPDATE.RebootRequired) {",
            "write-host \"Rebooting from Check-ForReboot\"",
            "exit 3010",
            "}",
            "else {",
            "Write-host \"Reboot not required\"",
            "}",
            "}",
            "",
            "function Install-PreReqForSQL {",
            "$HotFixPresent = Get-HotFix -id \"KB2919355\"",
            "if ($HotFixPresent) {",
            "write-host \"Found the required hotfix, so exiting\"",
            "exit 0",
            "}",
            "else {",
            "$autoupdate = New-Object -ComObject \"Microsoft.Update.AutoUpdate\"",
            "$autoupdate.DetectNow()",
            "$Session = New-Object -ComObject Microsoft.Update.Session",
            "$Search = $Session.CreateUpdateSearcher()",
            "$SearchResults = $Search.Search(\"IsInstalled=0 and IsHidden=0\")",
            "$TotalUpdates = $SearchResults.Updates.Count",
            "Write-Host \"There are $TotalUpdates TOTAL updates available.\"",
            "$AvailableUpdates = $SearchResults.Updates",
            "if ($AvailableUpdates.count -lt 1) {",
            "Write-Host \"Can't find required updates, exiting\"",
            "exit 1",
            "}",
            "$DownloadCollection = New-Object -com \"Microsoft.Update.UpdateColl\"",
            "$AvailableUpdates | ForEach-Object {",
            "if ($_.InstallationBehavior.CanRequestUserInput -ne $TRUE) {",
            "$DownloadCollection.Add($_) | Out-Null",
            "}",
            "}",
            "Write-Host \"Downloading updates...\"",
            "$Downloader = $Session.CreateUpdateDownloader()",
            "$Downloader.Updates = $DownloadCollection",
            "$Downloader.Download()",
            "Write-Verbose \"Creating Installation Object\"",
            "$InstallCollection = New-Object -com \"Microsoft.Update.UpdateColl\"",
            "$AvailableUpdates | ForEach-Object {",
            "if ($_.IsDownloaded) {",
            "$InstallCollection.Add($_) | Out-Null",
            "}",
            "}",
            "Write-Host \"Installing updates...\"",
            "$Installer = $Session.CreateUpdateInstaller()",
            "$Installer.Updates = $InstallCollection",
            "$Results = $Installer.Install()",
            "Write-Host \"Installation complete.\"",
            "exit 3010",
            "}",
            "}",
            "",
            "try {",
            "Check-ForReboot",
            "Install-PreReqForSQL",
            "}",
            "catch {",
            "Write-Error $_.Exception.Message",
            "exit 1",
            "}"
          ]
        }
      },
      "isCritical": "true",
      "nextStep": "runScriptBeforeSQLServerUpgrade"
    },
    {
      "name": "runScriptBeforeSQLServerUpgrade",
      "action": "aws:runCommand",
      "maxAttempts": 3,
      "onFailure": "step:deleteServerUpgradeInstance",
      "inputs": {
        "DocumentName": "AWS-RunPowerShellScript",
        "InstanceIds": [
          "{{ getServerUpgradeInstance.InstanceId }}"
        ],
        "Parameters": {
          "commands": [
            "function Enable-OfflineDisk {",
            "# Ensure this function runs in en-US culture\"",
            "# NOTE: This will fail if en-US is not available on the target server",
            "chcp 437 | Out-Null",
            "$offlinedisk = \"list disk\" | diskpart | Where-Object { $_ -match \"offline\" }",
            "",
            "if ($offlinedisk) {",
            "Write-Host \"Following Offline disk(s) found..Trying to bring Online.\"",
            "$offlinedisk",
            "foreach ($offdisk in $offlinedisk) {",
            "$offdiskS = $offdisk.Substring(2, 6)",
            "Write-Host \"Enabling $offdiskS\"",
            "$OnlineDisk = @\"",
            "select $offdiskS",
            "attributes disk clear readonly",
            "online disk",
            "attributes disk clear readonly",
            "\"@",
            "",
            "$noOut = $OnlineDisk | diskpart",
            "Start-Sleep 5",
            "}",
            "",
            "$offlinedisk = \"list disk\" | diskpart | Where-Object { $_ -match \"offline\" }",
            "",
            "if ($offlinedisk) {",
            "Write-Host \"Failed to bring the following disk(s) online\"",
            "$offlinedisk",
            "}",
            "else {",
            "Write-Host \"Disk(s) are now online.\"",
            "}",
            "}",
            "else {",
            "Write-Host \"All disk(s) are online!\"",
            "}",
            "}",
            "try {",
            "Enable-OfflineDisk",
            "$TEMPSTORAGE = \"C:\\SQLUpgrade\\{{ automation:EXECUTION_ID }}\"",
            "$TEMPSTOGAREFILE = \"$TEMPSTORAGE\\drive.txt\"",
            "if ((Test-Path $TEMPSTORAGE) -eq $false) {",
            "New-Item -ItemType directory -Path $TEMPSTORAGE",
            "}",
            "",
            "([System.IO.DriveInfo]::getdrives() | Where-Object { $_.DriveType -eq \"Fixed\" } | select-object -ExpandProperty Name) -join ',' | Out-File \"$TEMPSTOGAREFILE\"",
            "$OLDDRIVES = Get-Content -Path \"C:\\SQLUpgrade\\{{ automation:EXECUTION_ID }}\\drive.txt\" -TotalCount 1",
            "Write-host \"Drives are $OLDDRIVES \"",
            "}",
            "catch {",
            "Write-Error $_.Exception.Message",
            "exit 1",
            "}",
            ""
          ]
        }
      },
      "isCritical": "true",
      "nextStep": "branchOnLicenseIncludedInstance"
    },
    {
      "name": "branchOnLicenseIncludedInstance",
      "action": "aws:branch",
      "onFailure": "step:deleteServerUpgradeInstance",
      "inputs": {
        "Choices": [
          {
            "NextStep": "putLicenseIncludedInstanceMetric",
            "Variable": "{{ assertReadyToUpgradeSQLServer.Output }}",
            "Contains": "Instance has license included"
          }
        ],
        "Default": "putBYOLInstanceMetric"
      },
      "isCritical": "true"
    },
    {
      "name": "putLicenseIncludedInstanceMetric",
      "action": "aws:putServerUpgradeMetrics",
      "maxAttempts": 3,
      "onFailure": "step:deleteServerUpgradeInstance",
      "inputs": {
        "DimensionName": "SSM_METRICS",
        "DimensionValue": "AWSEC2-CloneInstanceAndUpgradeSQLServer",
        "MetricName": "License_Included_Instances",
        "MetricValue": "1.0"
      },
      "isCritical": "true",
      "nextStep": "getSQLServerEdition"
    },
    {
      "name": "putBYOLInstanceMetric",
      "action": "aws:putServerUpgradeMetrics",
      "maxAttempts": 3,
      "onFailure": "step:deleteServerUpgradeInstance",
      "inputs": {
        "DimensionName": "SSM_METRICS",
        "DimensionValue": "AWSEC2-CloneInstanceAndUpgradeSQLServer",
        "MetricName": "BYOL_Instances",
        "MetricValue": "1.0"
      },
      "isCritical": "true",
      "nextStep": "assertBYOLSQLServerSnapshotIdExist"
    },
    {
      "name": "assertBYOLSQLServerSnapshotIdExist",
      "action": "aws:assertAwsResourceProperty",
      "onFailure": "step:deleteServerUpgradeInstance",
      "maxAttempts": 3,
      "inputs": {
        "Service": "ec2",
        "Api": "DescribeSnapshots",
        "SnapshotIds": [
          "{{ SQLServerSnapshotId }}"
        ],
        "PropertySelector": "$.Snapshots[0].SnapshotId",
        "DesiredValues": [
          "{{ SQLServerSnapshotId }}"
        ]
      },
      "isCritical": "true",
      "nextStep": "createBYOLSQLServerMediaVolume"
    },
    {
      "name": "createBYOLSQLServerMediaVolume",
      "action": "aws:executeAwsApi",
      "maxAttempts": 3,
      "inputs": {
        "Service": "ec2",
        "Api": "CreateVolume",
        "AvailabilityZone": "{{ getUpgradeServerInstanceDetails.AvailabilityZone }}",
        "SnapshotId": "{{ SQLServerSnapshotId }}",
        "VolumeType": "gp2",
        "TagSpecifications": [
          {
            "ResourceType": "volume",
            "Tags": [
              {
                "Key": "SQLServerUpgradeVolumeKey",
                "Value": "SQLServerUpgradeVolume-{{ automation:EXECUTION_ID }}"
              }
            ]
          }
        ]
      },
      "outputs": [
        {
          "Name": "VolumeId",
          "Selector": "$.VolumeId",
          "Type": "String"
        }
      ],
      "onFailure": "step:deleteServerUpgradeInstance",
      "isCritical": "true",
      "nextStep": "getSQLServerMediaVolumeId"
    },
    {
      "name": "getSQLServerEdition",
      "action": "aws:runCommand",
      "maxAttempts": 3,
      "onFailure": "step:deleteServerUpgradeInstance",
      "timeoutSeconds": 300,
      "inputs": {
        "DocumentName": "AWS-RunPowerShellScript",
        "InstanceIds": [
          "{{ InstanceId }}"
        ],
        "Parameters": {
          "executionTimeout": "300",
          "commands": [
            "$instances = (get-itemproperty \"HKLM:\\SOFTWARE\\Microsoft\\Microsoft SQL Server\").InstalledInstances",
            "$instance = (Get-ItemProperty \"HKLM:\\SOFTWARE\\Microsoft\\Microsoft SQL Server\\Instance Names\\SQL\").$instances",
            "$instanceDetails = (Get-ItemProperty \"HKLM:\\SOFTWARE\\Microsoft\\Microsoft SQL Server\\$instance\\Setup\")",
            "$edition = ($instanceDetails.Edition).split()[0]",
            "Write-Host -NoNewline \"$edition\""
          ]
        }
      },
      "isCritical": "true",
      "nextStep": "getSQLServerSnapshotForLicenseIncludedInstance"
    },
    {
      "name": "getSQLServerSnapshotForLicenseIncludedInstance",
      "action": "aws:shareSQLMedia",
      "maxAttempts": 3,
      "onFailure": "step:deleteServerUpgradeInstance",
      "inputs": {
        "SQLServerVersion": "{{ TargetSQLVersion }}",
        "InstanceId": "{{ InstanceId }}",
        "SQLServerEdition": "{{ getSQLServerEdition.Output }}"
      },
      "outputs": [
        {
          "Name": "SnapshotId",
          "Selector": "$.EBSSnapshotId"
        }
      ],
      "isCritical": "true",
      "nextStep": "assertLicenseIncludedSQLServerSnapshotIdShared"
    },
    {
      "name": "assertLicenseIncludedSQLServerSnapshotIdShared",
      "action": "aws:assertAwsResourceProperty",
      "onFailure": "step:deleteServerUpgradeInstance",
      "maxAttempts": 3,
      "inputs": {
        "Service": "ec2",
        "Api": "DescribeSnapshots",
        "SnapshotIds": [
          "{{ getSQLServerSnapshotForLicenseIncludedInstance.EBSSnapshotId }}"
        ],
        "PropertySelector": "$.Snapshots[0].SnapshotId",
        "DesiredValues": [
          "{{ getSQLServerSnapshotForLicenseIncludedInstance.EBSSnapshotId }}"
        ]
      },
      "isCritical": "true",
      "nextStep": "createLicenseIncludedSQLServerMediaVolume"
    },
    {
      "name": "createLicenseIncludedSQLServerMediaVolume",
      "action": "aws:executeAwsApi",
      "maxAttempts": 3,
      "timeoutSeconds": 600,
      "inputs": {
        "Service": "ec2",
        "Api": "CreateVolume",
        "AvailabilityZone": "{{ getUpgradeServerInstanceDetails.AvailabilityZone }}",
        "SnapshotId": "{{ getSQLServerSnapshotForLicenseIncludedInstance.EBSSnapshotId }}",
        "VolumeType": "gp2",
        "TagSpecifications": [
          {
            "ResourceType": "volume",
            "Tags": [
              {
                "Key": "SQLServerUpgradeVolumeKey",
                "Value": "SQLServerUpgradeVolume-{{ automation:EXECUTION_ID }}"
              }
            ]
          }
        ]
      },
      "onFailure": "step:deleteServerUpgradeInstance",
      "isCritical": "true",
      "nextStep": "getSQLServerMediaVolumeId"
    },
    {
      "name": "getSQLServerMediaVolumeId",
      "action": "aws:executeAwsApi",
      "maxAttempts": 3,
      "onFailure": "step:deleteServerUpgradeInstance",
      "inputs": {
        "Service": "ec2",
        "Api": "DescribeVolumes",
        "Filters": [
          {
            "Name": "tag:SQLServerUpgradeVolumeKey",
            "Values": [
              "SQLServerUpgradeVolume-{{ automation:EXECUTION_ID }}"
            ]
          }
        ]
      },
      "outputs": [
        {
          "Name": "VolumeId",
          "Selector": "$.Volumes[0].VolumeId",
          "Type": "String"
        }
      ],
      "isCritical": "true",
      "nextStep": "waitUntilSQLServerMediaVolumeReady"
    },
    {
      "name": "waitUntilSQLServerMediaVolumeReady",
      "action": "aws:waitForAwsResourceProperty",
      "onFailure": "step:deleteServerUpgradeInstance",
      "maxAttempts": 3,
      "inputs": {
        "Service": "ec2",
        "Api": "DescribeVolumes",
        "Filters": [
          {
            "Name": "volume-id",
            "Values": [
              "{{ getSQLServerMediaVolumeId.VolumeId }}"
            ]
          }
        ],
        "PropertySelector": "$.Volumes[0].State",
        "DesiredValues": [
          "available"
        ]
      },
      "isCritical": "true",
      "nextStep": "attachSQLServerMediaVolumeToInstance"
    },
    {
      "name": "attachSQLServerMediaVolumeToInstance",
      "action": "aws:executeAwsApi",
      "maxAttempts": 3,
      "inputs": {
        "Service": "ec2",
        "Api": "AttachVolume",
        "Device": "xvdh",
        "InstanceId": "{{ getServerUpgradeInstance.InstanceId }}",
        "VolumeId": "{{ getSQLServerMediaVolumeId.VolumeId }}"
      },
      "onFailure": "step:deleteServerUpgradeInstance",
      "isCritical": "true",
      "nextStep": "waitUntilSQLServerMediaAttached"
    },
    {
      "name": "waitUntilSQLServerMediaAttached",
      "action": "aws:waitForAwsResourceProperty",
      "maxAttempts": 3,
      "inputs": {
        "Service": "ec2",
        "Api": "DescribeVolumes",
        "Filters": [
          {
            "Name": "volume-id",
            "Values": [
              "{{ getSQLServerMediaVolumeId.VolumeId }}"
            ]
          },
          {
            "Name": "attachment.instance-id",
            "Values": [
              "{{ getServerUpgradeInstance.InstanceId }}"
            ]
          }
        ],
        "PropertySelector": "$.Volumes[0].State",
        "DesiredValues": [
          "in-use"
        ]
      },
      "onFailure": "step:deleteServerUpgradeInstance",
      "isCritical": "true",
      "nextStep": "sleepForVolumeTobeAttached"
    },
    {
      "name": "sleepForVolumeTobeAttached",
      "action": "aws:sleep",
      "inputs": {
        "Duration": "PT10M"
      },
      "onFailure": "step:deleteServerUpgradeInstance",
      "isCritical": "true",
      "nextStep": "doRestartBeforeUpgradeStart"
    },
    {
      "name": "doRestartBeforeUpgradeStart",
      "action": "aws:runCommand",
      "maxAttempts": 3,
      "inputs": {
        "DocumentName": "AWS-RunPowerShellScript",
        "InstanceIds": [
          "{{ getServerUpgradeInstance.InstanceId }}"
        ],
        "Parameters": {
          "commands": [
            "Restart-Computer -Force"
          ]
        }
      },
      "onFailure": "step:deleteServerUpgradeInstance",
      "isCritical": "true",
      "nextStep": "sleepUntillRestartToBeFinished"
    },
    {
      "name": "sleepUntillRestartToBeFinished",
      "action": "aws:sleep",
      "maxAttempts": 3,
      "inputs": {
        "Duration": "PT5M"
      },
      "onFailure": "step:deleteServerUpgradeInstance",
      "isCritical": "true",
      "nextStep": "checkSSRSSetupRequirement"
    },
    {
      "name": "checkSSRSSetupRequirement",
      "action": "aws:branch",
      "maxAttempts": 3,
      "onFailure": "step:deleteServerUpgradeInstance",
      "inputs": {
        "Choices": [
          {
            "NextStep": "setupSSRS",
            "Or": [
              {
                "Variable": "{{ TargetSQLVersion }}",
                "EqualsIgnoreCase": "2014"
              },
              {
                "Variable": "{{ TargetSQLVersion }}",
                "EqualsIgnoreCase": "2016"
              }
            ]
          }
        ],
        "Default": "runSQLServerUpgrade"
      },
      "isCritical": "true"
    },
    {
      "name": "setupSSRS",
      "action": "aws:runCommand",
      "maxAttempts": 3,
      "inputs": {
        "DocumentName": "AWS-RunPowerShellScript",
        "InstanceIds": [
          "{{ getServerUpgradeInstance.InstanceId }}"
        ],
        "Parameters": {
          "commands": [
            "##################################################",
            "### Objective of this PS module is check if reporting service installed and",
            "### DB is absent, create the DB in native way to bypass the error",
            "### during SQL Server upgrade as listed https://blog.sqlauthority.com/2015/09/25/sql-server-failed-rule-valid-dsn-and-valid-database-compatibility-level-and-successful-connection/",
            "### This is needed for upgrading SQL Server 2012-14/16 etc..",
            "### This script needs to be executed conditionally... ",
            "##################################################",
            "",
            "## Check WMI action result ",
            "function CheckWmiAction",
            "{",
            "param($wmi_result, $actionname)",
            "if ($wmi_result.HRESULT -ne 0) {",
            "write-error \"$actionname failed. Error from WMI: $($wmi_result.Error)\"",
            "}",
            "}",
            "",
            "",
            "## Get the SSRS Wmiobject",
            "function Get-ReportingServerObject()",
            "{",
            "##objective is to get MS Name and Version before initialize WmiObject",
            "$instances = (get-itemproperty \"HKLM:\\SOFTWARE\\Microsoft\\Microsoft SQL Server\").InstalledInstances",
            "$instance = (Get-ItemProperty \"HKLM:\\SOFTWARE\\Microsoft\\Microsoft SQL Server\\Instance Names\\SQL\").$instances",
            "$instanceDetails = (Get-ItemProperty \"HKLM:\\SOFTWARE\\Microsoft\\Microsoft SQL Server\\$instance\\Setup\")",
            "$version = $instanceDetails.Version.subString(0, $instanceDetails.Version.indexOf(\".\"))",
            "",
            "return Get-WmiObject â€“namespace \"root\\Microsoft\\SqlServer\\ReportServer\\RS_$instances\\v$version\\Admin\" `",
            "-class MSReportServer_ConfigurationSetting -ComputerName localhost",
            "}",
            "",
            "try",
            "{",
            "$ErrorActionPreference = \"Stop\"",
            "$server = $env:COMPUTERNAME",
            "$HTTPport = 80 ",
            "",
            "## initialize SSRS WMIObject",
            "$RSObject = Get-ReportingServerObject",
            "",
            "if(![string]::IsNullOrEmpty($RSObject.DatabaseName))",
            "{",
            "return; #Reporting server DB set up is present, don't do anything.",
            "}",
            "",
            "$starttime=Get-Date",
            "$dbName='ReportServer'",
            "$LocalDetails =  GET-WinSystemLocale ",
            "$localeId = $LocalDetails.LCID ",
            "",
            "##check for service status, if it's stopped, first start for WMI object to work",
            "$reportServerService = $RSObject.ServiceName",
            "$service = Get-Service -Name $reportServerService",
            "if($service.Status -ne 'Running')",
            "{",
            "Start-Service -Name $reportServerService",
            "$service.WaitForStatus([System.ServiceProcess.ServiceControllerStatus]::Running)",
            "}",
            "##end of check ",
            "",
            "## Setting the web service URL ##",
            "write-host -foregroundcolor green \"Setting the web service URL\"",
            "write-host 'Calling SetVirtualDirectory'",
            "$r = $RSObject.SetVirtualDirectory('ReportServerWebService','ReportServer',$localeId)",
            "CheckWmiAction $r \"SetVirtualDirectory for ReportServer\"",
            "",
            "## ReserveURL for ReportServerWebService - port $HTTPport (for local usage)",
            "write-host \"Calling ReserveURL port $HTTPport\"",
            "$r = $RSObject.ReserveURL('ReportServerWebService',\"http://+:$HTTPport\",$localeId)",
            "CheckWmiAction $r \"ReserveURL for ReportServer port $HTTPport\" ",
            "",
            "## Setting the Database ##",
            "write-host -foregroundcolor green \"Setting the Database\"",
            "",
            "write-host \"Calling GenerateDatabaseCreationScript for database $dbName\"",
            "$r = $RSObject.GenerateDatabaseCreationScript($dbName,$localeId,$false)",
            "CheckWmiAction $r \"GenerateDatabaseCreationScript\"",
            "$script = $r.Script",
            "",
            "## Execute sql script to create the database",
            "write-host 'Executing Database Creation Script'",
            "$savedcvd = Get-Location",
            "Import-Module SQLPS",
            "Invoke-SqlCmd -Query $script",
            "Set-Location $savedcvd",
            "",
            "## GenerateGrantRightsScript ",
            "$DBUser = $RSObject.WindowsServiceIdentityActual",
            "write-host \"Calling GenerateDatabaseRightsScript with user $DBUser\"",
            "$r = $RSObject.GenerateDatabaseRightsScript($DBUser,$dbName,$false,$true)",
            "CheckWmiAction $r \"GenerateDatabaseRightsScript\"",
            "$script = $r.Script",
            "",
            "## Execute grant rights script",
            "write-host 'Executing Database Rights Script'",
            "$savedcvd = Get-Location",
            "cd sqlserver:\\",
            "Invoke-SqlCmd -Query $script",
            "Set-Location $savedcvd",
            "",
            "## SetDBConnection - uses Windows Service (type 2), username is ignored",
            "write-host \"Calling SetDatabaseConnection server $server, DB $dbName\"",
            "$r = $RSObject.SetDatabaseConnection($server,$dbName,2,'','')",
            "CheckWmiAction $r \"SetDatabaseConnection\"  ",
            "",
            "write-host 'Operations completed, Report Server is ready' ",
            "}",
            "catch {",
            "Write-Error $_.Exception.Message",
            "exit 1",
            "}"
          ]
        }
      },
      "onFailure": "step:deleteServerUpgradeInstance",
      "isCritical": "true",
      "nextStep": "runSQLServerUpgrade"
    },
    {
      "action": "aws:runCommand",
      "name": "runSQLServerUpgrade",
      "maxAttempts": 3,
      "inputs": {
        "DocumentName": "AWS-RunPowerShellScript",
        "InstanceIds": [
          "{{ getServerUpgradeInstance.InstanceId }}"
        ],
        "Parameters": {
          "commands": [
            "function Enable-OfflineDisk {",
            "# Ensure this function runs in en-US culture\"",
            "# NOTE: This will fail if en-US is not available on the target server",
            "chcp 437 | Out-Null",
            "$offlinedisk = \"list disk\" | diskpart | Where-Object { $_ -match \"offline\" }",
            "if ($offlinedisk) {",
            "Write-Host \"Following Offline disk(s) found..Trying to bring Online.\"",
            "$offlinedisk",
            "foreach ($offdisk in $offlinedisk) {",
            "$offdiskS = $offdisk.Substring(2, 6)",
            "Write-Host \"Enabling $offdiskS\"",
            "$OnlineDisk = @\"",
            "select $offdiskS",
            "attributes disk clear readonly",
            "online disk",
            "attributes disk clear readonly",
            "\"@",
            "",
            "$noOut = $OnlineDisk | diskpart",
            "Start-Sleep 5",
            "}",
            "",
            "$offlinedisk = \"list disk\" | diskpart | Where-Object { $_ -match \"offline\" }",
            "",
            "if ($offlinedisk) ",
            "{",
            "Write-Host \"Failed to bring the following disk(s) online\"",
            "$offlinedisk",
            "}",
            "else {",
            "Write-Host \"Disk(s) are now online.\"",
            "}",
            "}",
            "else {",
            "Write-Host \"All disk(s) are online!\"",
            "}",
            "}",
            "",
            "try {",
            "Enable-OfflineDisk",
            "$CURRENTDRIVE = ([System.IO.DriveInfo]::getdrives() | Where-Object { $_.DriveType -eq \"Fixed\" } | select-object -ExpandProperty Name) -join ','",
            "$OLDDRIVES = Get-Content -Path \"C:\\SQLUpgrade\\{{ automation:EXECUTION_ID }}\\drive.txt\" -TotalCount 1",
            "$oldDriveArray = $OLDDRIVES.split(',')",
            "$newDriveArray = $CURRENTDRIVE.split(',')",
            "foreach ($drive in $newDriveArray) {",
            "if (-not ($oldDriveArray -contains $drive)) {",
            "$NEWDRIVE = $drive",
            "break",
            "}",
            "}",
            "if (-not $NEWDRIVE) {",
            "Write-Log \"Can't find the new drive\"",
            "exit -1",
            "}",
            "Write-host \"Olddrives $OLDDRIVES , Currentdrives $CURRENTDRIVE, Newdrive $NEWDRIVE\"",
            "Write-Host \"SQL Server Installed media present in Drive $NEWDRIVE \"",
            "$INSTANCENAME = (get-itemproperty \"HKLM:\\SOFTWARE\\Microsoft\\Microsoft SQL Server\").InstalledInstances",
            "$targetVersion = {{ TargetSQLVersion }}",
            "if(($targetVersion -eq '2016') -or ($targetVersion -eq '2014')) {",
            "Invoke-expression \"$NEWDRIVE\\setup.exe /q /ACTION=upgrade /INSTANCEID=$INSTANCENAME /INSTANCENAME=$INSTANCENAME /IACCEPTSQLSERVERLICENSETERMS \"",
            "}",
            "else {",
            "Invoke-expression \"$NEWDRIVE\\setup.exe /q /ACTION=upgrade /INSTANCEID=$INSTANCENAME /INSTANCENAME=$INSTANCENAME /IACCEPTSQLSERVERLICENSETERMS /IACCEPTRSUNINSTALL \"",
            "}",
            "}",
            "catch {",
            "Write-Error $_.Exception.Message",
            "exit 1",
            "}"
          ]
        }
      },
      "onFailure": "step:deleteServerUpgradeInstance",
      "isCritical": "true",
      "nextStep": "restartSystemToFinishUpgrade"
    },
    {
      "name": "restartSystemToFinishUpgrade",
      "action": "aws:runCommand",
      "maxAttempts": 3,
      "inputs": {
        "DocumentName": "AWS-RunPowerShellScript",
        "InstanceIds": [
          "{{getServerUpgradeInstance.InstanceId}}"
        ],
        "Parameters": {
          "commands": [
            "Restart-Computer -Force"
          ]
        }
      },
      "onFailure": "step:deleteServerUpgradeInstance",
      "isCritical": "true",
      "nextStep": "sleepForSQLUpgradeAndStart"
    },
    {
      "name": "sleepForSQLUpgradeAndStart",
      "action": "aws:sleep",
      "inputs": {
        "Duration": "PT5M"
      },
      "onFailure": "step:deleteServerUpgradeInstance",
      "isCritical": "true",
      "nextStep": "waitForSSMAgentOnlineAfterUpgrade"
    },
    {
      "name": "waitForSSMAgentOnlineAfterUpgrade",
      "action": "aws:waitForAwsResourceProperty",
      "maxAttempts": 3,
      "onFailure": "step:deleteServerUpgradeInstance",
      "inputs": {
        "Service": "ssm",
        "Api": "DescribeInstanceInformation",
        "InstanceInformationFilterList": [
          {
            "key": "InstanceIds",
            "valueSet": [
              "{{ getServerUpgradeInstance.InstanceId }}"
            ]
          }
        ],
        "PropertySelector": "$.InstanceInformationList[0].PingStatus",
        "DesiredValues": [
          "Online"
        ]
      },
      "isCritical": "true",
      "nextStep": "detachSQLServerMediaVolume"
    },
    {
      "name": "detachSQLServerMediaVolume",
      "action": "aws:executeAwsApi",
      "maxAttempts": 3,
      "inputs": {
        "Service": "ec2",
        "Api": "DetachVolume",
        "InstanceId": "{{ getServerUpgradeInstance.InstanceId }}",
        "VolumeId": "{{ getSQLServerMediaVolumeId.VolumeId }}",
        "Force": true
      },
      "onFailure": "step:deleteServerUpgradeInstance",
      "isCritical": "true",
      "nextStep": "waitTillSQLServerMediaVolumeDetached"
    },
    {
      "name": "waitTillSQLServerMediaVolumeDetached",
      "action": "aws:waitForAwsResourceProperty",
      "maxAttempts": 3,
      "inputs": {
        "Service": "ec2",
        "Api": "DescribeVolumes",
        "Filters": [
          {
            "Name": "volume-id",
            "Values": [
              "{{ getSQLServerMediaVolumeId.VolumeId }}"
            ]
          }
        ],
        "PropertySelector": "$.Volumes[0].State",
        "DesiredValues": [
          "available"
        ]
      },
      "onFailure": "step:deleteServerUpgradeInstance",
      "isCritical": "true",
      "nextStep": "deleteSQLServerMediaVolume"
    },
    {
      "name": "deleteSQLServerMediaVolume",
      "action": "aws:executeAwsApi",
      "maxAttempts": 3,
      "inputs": {
        "Service": "ec2",
        "Api": "DeleteVolume",
        "VolumeId": "{{ getSQLServerMediaVolumeId.VolumeId }}"
      },
      "onFailure": "step:deleteServerUpgradeInstance",
      "isCritical": "true",
      "nextStep": "createImageUpgradedInstance"
    },
    {
      "name": "createImageUpgradedInstance",
      "action": "aws:executeAwsApi",
      "maxAttempts": 3,
      "inputs": {
        "Service": "ec2",
        "Api": "CreateImage",
        "InstanceId": "{{ getServerUpgradeInstance.InstanceId }}",
        "Name": "AWSEC2-SQLSERVERUPGRADE-{{ getServerUpgradeInstance.InstanceId }}-{{automation:EXECUTION_ID}}",
        "NoReboot": false
      },
      "outputs": [
        {
          "Name": "ImageId",
          "Selector": "$.ImageId",
          "Type": "String"
        }
      ],
      "onFailure": "step:deleteServerUpgradeInstance",
      "isCritical": "true",
      "nextStep": "waitTillUpgradedInstanceImageReady"
    },
    {
      "name": "waitTillUpgradedInstanceImageReady",
      "action": "aws:waitForAwsResourceProperty",
      "maxAttempts": 3,
      "inputs": {
        "Service": "ec2",
        "Api": "DescribeImages",
        "ImageIds": [
          "{{ createImageUpgradedInstance.ImageId }}"
        ],
        "PropertySelector": "$.Images[0].State",
        "DesiredValues": [
          "available"
        ]
      },
      "onFailure": "step:deleteServerUpgradeInstance",
      "isCritical": "true",
      "nextStep": "deleteServerUpgradeInstance"
    },
    {
      "name": "deleteServerUpgradeInstance",
      "action": "aws:executeAwsApi",
      "inputs": {
        "Service": "ec2",
        "Api": "TerminateInstances",
        "InstanceIds": [
          "{{ getServerUpgradeInstance.InstanceId }}"
        ]
      },
      "maxAttempts": 3,
      "isCritical": "true",
      "onFailure": "Continue",
      "timeoutSeconds": 1800,
      "nextStep": "branchOnDeletingImageFromOriginalInstance"
    },
    {
      "name": "branchOnDeletingImageFromOriginalInstance",
      "action": "aws:branch",
      "onFailure": "step:describeInstallationMediaVolume",
      "inputs": {
        "Choices": [
          {
            "NextStep": "deleteImageFromOriginalInstance",
            "Variable": "{{ KeepPreUpgradeImageBackUp }}",
            "EqualsIgnoreCase": "False"
          }
        ],
        "Default": "describeInstallationMediaVolume"
      },
      "isCritical": "true"
    },
    {
      "name": "deleteImageFromOriginalInstance",
      "action": "aws:deleteImage",
      "inputs": {
        "ImageId": "{{ describeOriginalInstanceImage.ImageId }}"
      },
      "maxAttempts": 3,
      "isCritical": "true",
      "onFailure": "Continue",
      "nextStep": "describeInstallationMediaVolume"
    },
    {
      "name": "describeInstallationMediaVolume",
      "action": "aws:executeAwsApi",
      "inputs": {
        "Service": "ec2",
        "Api": "DescribeVolumes",
        "Filters": [
          {
            "Name": "volume-id",
            "Values": [
              "{{ getSQLServerMediaVolumeId.VolumeId }}"
            ]
          }
        ]
      },
      "outputs": [
        {
          "Name": "State",
          "Selector": "$.Volumes[0].State",
          "Type": "String"
        }
      ],
      "maxAttempts": 3,
      "isCritical": "false",
      "onFailure": "Continue",
      "nextStep": "branchOnInstallationMediaVolumeStatus"
    },
    {
      "name": "branchOnInstallationMediaVolumeStatus",
      "action": "aws:branch",
      "onFailure": "step:getUpgradedImageDetails",
      "inputs": {
        "Choices": [
          {
            "NextStep": "retryDeletingInstallationMediaVolume",
            "Or": [
              {
                "Variable": "{{ describeInstallationMediaVolume.State }}",
                "EqualsIgnoreCase": "available"
              },
              {
                "Variable": "{{ describeInstallationMediaVolume.State }}",
                "EqualsIgnoreCase": "in-use"
              }
            ]
          }
        ],
        "Default": "getUpgradedImageDetails"
      },
      "isCritical": "false"
    },
    {
      "name": "retryDeletingInstallationMediaVolume",
      "action": "aws:executeAwsApi",
      "inputs": {
        "Service": "ec2",
        "Api": "DeleteVolume",
        "VolumeId": "{{ getSQLServerMediaVolumeId.VolumeId }}"
      },
      "maxAttempts": 3,
      "isCritical": "false",
      "onFailure": "step:getUpgradedImageDetails",
      "nextStep": "getUpgradedImageDetails"
    },
    {
      "name": "getUpgradedImageDetails",
      "action": "aws:executeAwsApi",
      "maxAttempts": 2,
      "inputs": {
        "Service": "ec2",
        "Api": "DescribeImages",
        "ImageIds": [
          "{{ createImageUpgradedInstance.ImageId }}"
        ]
      },
      "outputs": [
        {
          "Name": "ImageId",
          "Selector": "$.Images[0].ImageId",
          "Type": "String"
        },
        {
          "Name": "Name",
          "Selector": "$.Images[0].Name",
          "Type": "String"
        },
        {
          "Name": "State",
          "Selector": "$.Images[0].State",
          "Type": "String"
        }
      ],
      "isCritical": "true",
      "isEnd": "true"
    }
  ],
  "outputs": [
    "getUpgradedImageDetails.ImageId",
    "getUpgradedImageDetails.Name",
    "getUpgradedImageDetails.State"
  ]
}
