{
  "description": "### Document name - AWSFIS-Run-Network-Packet-Loss-ECS\n\n## What does this document do?\nIt adds packet loss to the network traffic, using the ECS fault injection endpoints.\nThis SSM document supports Amazon Linux and Ubuntu operating systems only.\n\n## Dependencies installed by this SSM Document\n* atd\n* curl\n* dig\n* jq\n* lsof\n* pgrep\nNote: This SSM document does not uninstall dependencies once installed. If you don't want this SSM document to install any dependencies, set InstallDependencies to False and bake the dependencies into your EC2 instance. For example, by using image-builder (https://aws.amazon.com/image-builder/).\n\n## Input Parameters\n* FISActionState: The FIS-populated action state JSON.\n* Sources: (Required) The sources, separated by commas, without spaces. The possible values are: an IPv4 address, an IPv4 CIDR block, a domain name, an AZ name (us-east-1a), an AZ ID (use1-az1), ALL, DYNAMODB, and S3. The default is ALL, which matches all IPv4 traffic.\n* LossPercent: The percent of packet loss. (default: 7).\n* DurationSeconds: (Required) The duration - in seconds - of the fault injection.\n* InstallDependencies: If set to True, Systems Manager installs the required dependencies on the target instances (default: True).\n* FlowsPercent: The percentage of network flows that will be affected by the action. The default is 100%.\n\n## Output Parameters\nNone.",
  "schemaVersion": "2.2",
  "parameters": {
    "FISActionState": {
      "type": "String",
      "description": "The FIS-populated action state JSON.",
      "allowedPattern": "^\\{\"id\":\"[\\s\\S]+\",\"callTime\":\\d{10},\"callCount\":\\d+}$"
    },
    "Sources": {
      "type": "String",
      "description": "(Required) The sources, separated by commas, without spaces. The possible values are: an IPv4 address, an IPv4 CIDR block, a domain name, an AZ name (us-east-1a), an AZ ID (use1-az1), ALL, DYNAMODB, and S3. The default is ALL, which matches all IPv4 traffic.",
      "allowedPattern": "^[0-9a-zA-Z./,-]+$"
    },
    "LossPercent": {
      "type": "String",
      "description": "The percent of packet loss. (default: 7).",
      "default": "7",
      "allowedPattern": "^([1-9][0-9]?|100)$"
    },
    "DurationSeconds": {
      "type": "String",
      "description": "(Required) The duration - in seconds - of the fault injection.",
      "allowedPattern": "^[0-9]+$"
    },
    "InstallDependencies": {
      "type": "String",
      "description": "If set to True, Systems Manager installs the required dependencies on the target instances (default: True).",
      "default": "True",
      "allowedValues": [
        "True",
        "False"
      ]
    },
    "FlowsPercent": {
      "type": "String",
      "description": "The percentage of network flows that will be affected by the action. The default is 100%.",
      "default": "100",
      "allowedPattern": "^([1-9][0-9]?|100)$"
    }
  },
  "mainSteps": [
    {
      "action": "aws:runShellScript",
      "name": "InstallDependencies",
      "precondition": {
        "StringEquals": [
          "platformType",
          "Linux"
        ]
      },
      "description": "## Parameter: InstallDependencies\nIf set to True, this step installs the required dependency via operating system's repository. It supports both\nDebian (apt) and CentOS (yum) based package managers.",
      "inputs": {
        "onFailure": "exit",
        "runCommand": [
          "#!/bin/bash\n\nset -o errexit\n\n# Configure ATD service if required\nconfigure_atd() {\n  if ! systemctl is-enabled atd || ! systemctl is-active atd; then\n    echo \"Enabling and starting atd\"\n    systemctl enable atd\n    systemctl start atd\n  fi\n}\n\n# Check if dependencies are already installed\ncheck_existing_dependencies() {\n  if [[ \"$( command -v atd 2>/dev/null )\" && \"$( command -v curl 2>/dev/null )\" && \"$( command -v dig 2>/dev/null )\" && \"$( command -v jq 2>/dev/null )\" && \"$( command -v lsof 2>/dev/null )\" && \"$( command -v pgrep 2>/dev/null )\" ]]; then\n    echo \"Dependencies are already installed.\"\n    exit\n  fi\n}\n\nvalidate_installation_settings() {\n  if [[ \"{{ InstallDependencies }}\" == False ]]; then\n    echo \"Missing dependencies detected with InstallDependencies set to false. Please install dependencies [\"atd\", \"curl\", \"dig\", \"jq\", \"lsof\", \"pgrep\"] or set InstallDependencies to true for supported operating systems.\" >&2\n    exit 1\n  fi\n}\n\nmain() {\n  check_existing_dependencies\n  validate_installation_settings\n  echo \"Installing required dependencies\"\n  trap 'status=$?; if [ $status -eq 1 ]; then echo \"Failed to install dependencies. Please retry or manually install dependencies [\"atd\", \"curl\", \"dig\", \"jq\", \"lsof\", \"pgrep\"] and set InstallDependencies to false.\" >&2; fi' EXIT\n\n\n  yum -y install at curl-minimal bind-utils jq lsof procps-ng\n  configure_atd\n}\n\nmain\n"
        ]
      }
    },
    {
      "action": "aws:runShellScript",
      "name": "FaultInjection",
      "precondition": {
        "StringEquals": [
          "platformType",
          "Linux"
        ]
      },
      "description": "# Parameters: Sources, FlowsPercent, LossPercent and DurationSeconds\nThis step starts by extracting the IP for all the `Sources` provided and adds a `LossPercent` for the given `DurationSeconds`, affecting only `FlowsPercent` of network flows, using the ECS fault injection endpoints.\nIt has two rollback mechanisms in place:\n- It will listen for exit signals (SIGINT and SIGTERM), and will stop the fault injection if any of them is received.\n- It will periodically enqueue rollback checks into a queue (using `at` command). This way, if the command is stopped and the rollback was not executed, the enqueued commands will try to stop it. (for example, if the command is stopped using kill -9).\nThis is just an extra safety check to avoid having the packet loss remain injected after the script is no longer running.\nThis document is also executed in heartbeat mode: every 20 seconds, FIS will update a file with the “last update” timestamp. If for any reason FIS stops updating that file, the document will assume that something is wrong with FIS and the fault will be stopped after 60 seconds.",
      "inputs": {
        "maxAttempts": 1,
        "timeoutSeconds": 43200,
        "runCommand": [
          "#!/bin/bash\nset -o errexit -o errtrace -o nounset -o pipefail\n\n########################\n# Function definitons  #\n########################\n\nforce_dns() {\n  local -r hostname=\"$1\"    # Hostname is expected as first argument\n  local -ar ips=(\"${@:2}\")  # The rest will be the IPs\n\n  # Force any new DNS resolution for that host to the latest known IPs\n  for ip in \"${ips[@]}\"; do\n    echo \"$ip $hostname ${DELETE_MSG:-\"#delete-after-fault-injection\"}\" >> \"${HOSTS_FILE:-/etc/hosts}\"\n  done\n\n  return 0\n}\n\nget_ips_from_input() {\n  local -r input=\"$1\"\n  local -r regex=\"$2\"\n\n  # Echoes the input and returns 0 if the input is valid, otherwise returns 1\n  local -r validated_input=$(grep -E \"$regex\" <<< \"$input\")\n  [ -z \"$validated_input\" ] || { echo \"$validated_input\" ; return 0 ;}\n\n  return 1\n}\n\nget_ips_from_dns() {\n  local -r domain=\"$1\"\n  local -a resolved_ips=()\n\n  # Echoes IPs of the domain and forces DNS resolution to the IPs then returns 0, otherwise returns 1\n  # Since `dig` can return different IPs, we call it 10 times to maximize the chances of covering as many IPs as possible for the provided domain\n  for _ in {1..10}\n    do\n      local -a dig_output=( $(dig +short \"$domain\" | grep -v '[[:alpha:]]') )\n      [ ${#dig_output[@]} -eq 0 ] || resolved_ips+=(\"${dig_output[@]}\")\n    done\n\n  if [ ${#resolved_ips[@]} -gt 0 ]; then\n    local -ar unique_resolved_ips=( $(printf '%s\\n' \"${resolved_ips[@]}\" | sort -u) )\n    [ ${#unique_resolved_ips[@]} -eq 0 ] || { echo \"${unique_resolved_ips[@]}\" ; force_dns \"$domain\" \"${unique_resolved_ips[@]}\" ; return 0 ;}\n  fi\n\n  return 1\n}\n\nget_protected_ips_from_protected_endpoints() {\n  local get_ips=\"$1\"\n  local -ar endpoints=(\"${@:2}\")\n\n  for e in \"${endpoints[@]}\"; do\n    local ips_output\n    ips_output=$(eval \"get_ips \\\"$e\\\"\")\n    if [[ -n \"$ips_output\" ]]; then\n      local -a ips=()\n      read -ra ips <<< \"$ips_output\"\n      PROTECTED_IPS+=(\"${ips[@]}\")\n    fi\n  done\n\n  return 0\n}\n\nget_protected_ips_from_ssm_connections() {\n  local -r regex=\"$1\"\n\n  if pgrep ssm > /dev/null; then\n    local -r ssm_connections=( $(lsof -a -nPi4 -c /ssm/ -Fn | awk '$1 ~ /^n/' | awk -F'->' '{print $2}' | awk -F':' '{print $1}' | awk \"/$regex/\" | awk NF) )\n    [ ${#ssm_connections[@]} -eq 0 ] || PROTECTED_IPS+=(\"${ssm_connections[@]}\")\n  fi\n\n  return 0\n}\n\nget_sorted_unique_protected_ips() {\n  if [ ${#PROTECTED_IPS[@]} -gt 0 ]; then\n    PROTECTED_IPS=($(for ip in \"${PROTECTED_IPS[@]}\"; do echo \"${ip}\"; done | sort -u))\n  fi\n\n  return 0\n}\n\n# Get the REGION of the instance\nEC2_REGION=$AWS_SSM_REGION_NAME\n\nIP_CIDR_REGEX=\"^(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\/(3[0-2]|[1-2][0-9]|[0-9]))$\"\n\nIP_REGEX=\"^(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])$\"\n\nDELETE_MSG=\"#delete-after-fault-injection\"\n\n# Endpoints we want to preserve (SSM API)\nSSMMESSAGES_ENDPOINT=ssmmessages.$AWS_SSM_REGION_NAME.amazonaws.com\nSSM_ENDPOINT=ssm.$AWS_SSM_REGION_NAME.amazonaws.com\nEC2MESSAGES_ENDPOINT=ec2messages.$AWS_SSM_REGION_NAME.amazonaws.com\n\nPROTECTED_ENDPOINTS=(\n  \"${SSMMESSAGES_ENDPOINT}\"\n  \"${SSM_ENDPOINT}\"\n  \"${EC2MESSAGES_ENDPOINT}\"\n)\n\nget_target_ips_from_sources() {\n  local get_ips=\"$1\"\n  local sources=\"$2\"\n\n  # Check if ANY source is \"ALL\" - short circuit to target all traffic\n  for source in ${sources//,/ }; do\n    if [[ \"$source\" == \"ALL\" ]]; then\n      TARGET_IPS=(\"0.0.0.0/0\")\n      echo \"Target IPs and ranges: ${TARGET_IPS[*]} (targeting all traffic)\"\n      return 0\n    fi\n  done\n\n  # Prepares the sources and get IPs for all of them\n  local -a invalid_sources=()\n  for source in ${sources//,/ }; do\n    ips=$(eval \"get_ips \\\"$source\\\"\")\n    if [ -n \"$ips\" ]; then\n      for ip in ${ips[*]}; do\n        TARGET_IPS+=(\"${ip}\")\n      done\n    else\n      invalid_sources+=(\"${source}\")\n    fi\n  done\n\n  if [ ${#invalid_sources[@]} -gt 0 ]; then\n    echo \"Invalid sources (malformed service name, DNS or IP address): ${invalid_sources[*]}\" >&2\n    exit 1\n  fi\n\n  echo \"Target IPs and ranges: ${TARGET_IPS[*]}\"\n\n  return 0\n}\n\nget_ips_from_aws_service() {\n  local -r input=\"$1\"\n  local -r ip_range_url=\"$2\"\n  local -r ec2_region=\"$3\"\n\n  # Only accepting DYNAMODB and S3 from ip-range service\n  if [[ \"$input\" =~ ^(\"DYNAMODB\"|\"S3\")$ ]]; then\n    # Echoes IPs of the Service\n    curl -s \"${ip_range_url}\" --connect-timeout 5 | jq -r '.prefixes[] | select(.region==\"'$ec2_region'\") | select(.service==\"'$input'\") | .ip_prefix'\n  fi\n}\n\nadd_tmds_ip_to_protected_endpoints() {\n  local -r ecs_agent_url=\"$1\" \n\n  # Extracts IP from ECS agent URL using 'cut' with forward slash delimiter (-d \"/\") and selecting third field (-f 3)\n  # \n  # Example:\n  # http://169.254.170.2/api/59d3b9b8bb55476488cee0122ea98da3-0949121929\n  #\n  # [1] http:\n  # [2] *blank\n  # [3] 169.254.170.2\n  # [4] v1\n  # [5] metadata\n  # \n  # tmds_ip will be \"169.254.170.2\"\n  local -r tmds_ip=$(echo \"${ecs_agent_url}\" | cut -d \"/\" -f 3)\n  echo \"Adding ECS task metadata IP: ${tmds_ip} to PROTECTED_ENDPOINTS\"\n  PROTECTED_ENDPOINTS+=(\"${tmds_ip}\")\n\n  return 0\n}\n\nenable_fault_ecs() {\n  # Call the ECS Agent start fault injection API\n  local -r curl_response=$(curl -s -X POST \"${ECS_AGENT_URI}/fault/v1/$FAULT_TYPE/start\" \\\n    -H 'Content-Type: application/json' \\\n    -d \"$JSON_PAYLOAD\" \\\n    --write-out '#%{response_code}')\n\n  echo \"curl -s -X POST ${ECS_AGENT_URI}/fault/v1/$FAULT_TYPE/start -H 'Content-Type: application/json' -d '$JSON_PAYLOAD' --write-out '#%{response_code}'\"\n  echo \"$curl_response\"\n  \n  local -r status_code=$(echo \"$curl_response\" | cut -d \"#\" -f 2)\n  if [[ $status_code -ge 400 ]]; then\n    echo \"There was an error starting the fault injection.\";\n\n    local mutated_hosts_file\n    mutated_hosts_file=$(mktemp)\n\n    if ! cp \"${HOSTS_FILE:-/etc/hosts}\" \"$mutated_hosts_file\"; then\n      echo \"Failed to copy current hosts file - exiting without restoring hosts file\" >&2\n      rm -f \"$mutated_hosts_file\"\n      rm -f \"$FLAG_PATH\" \"$ROLLBACK_PATH\" \"$HEARTBEAT_EXPIRATION_PATH\" \n      exit 1\n    fi\n\n    local restored_hosts_file\n    restored_hosts_file=$(mktemp)\n\n    sed \"/${DELETE_MSG:-\"#delete-after-fault-injection\"}/d\" \"${HOSTS_FILE:-/etc/hosts}\" > \"$restored_hosts_file\"\n\n    local actual_deleted_lines\n    actual_deleted_lines=$(grep --invert-match --line-regexp --file=\"$restored_hosts_file\" \"$mutated_hosts_file\" || true)\n\n    local expected_deleted_lines\n    expected_deleted_lines=$(grep \"${DELETE_MSG:-\"#delete-after-fault-injection\"}\" \"$mutated_hosts_file\" || true)\n\n    if [ \"$actual_deleted_lines\" != \"$expected_deleted_lines\" ]; then\n      echo \"sed operation produced unexpected results - exiting without restoring hosts file\" >&2\n      echo \"Before sed operation:\" >&2\n      cat \"${mutated_hosts_file}\" >&2\n      echo \"After sed operation:\" >&2\n      cat \"${restored_hosts_file}\" >&2\n      rm -f \"$restored_hosts_file\" \"$mutated_hosts_file\"\n      rm -f \"$FLAG_PATH\" \"$ROLLBACK_PATH\" \"$HEARTBEAT_EXPIRATION_PATH\"\n      exit 1\n    fi\n\n    if ! cat \"$restored_hosts_file\" > \"${HOSTS_FILE:-/etc/hosts}\"; then\n      echo \"Failed to write back to hosts file\" >&2\n      rm -f \"$restored_hosts_file\" \"$mutated_hosts_file\"\n      rm -f \"$FLAG_PATH\" \"$ROLLBACK_PATH\" \"$HEARTBEAT_EXPIRATION_PATH\"\n      exit 1\n    fi\n\n    local final_deleted_lines\n    final_deleted_lines=$(grep --invert-match --line-regexp --file=\"${HOSTS_FILE:-/etc/hosts}\" \"$mutated_hosts_file\" || true)\n\n    if [ \"$final_deleted_lines\" != \"$expected_deleted_lines\" ]; then\n      echo \"Hosts file restore verification failed after write-back to hosts file\" >&2\n      echo \"Before write-back operation:\" >&2\n      cat \"${restored_hosts_file}\" >&2\n      echo \"After write-back operation:\" >&2\n      cat \"${HOSTS_FILE:-/etc/hosts}\" >&2\n      rm -f \"$restored_hosts_file\" \"$mutated_hosts_file\"\n      rm -f \"$FLAG_PATH\" \"$ROLLBACK_PATH\" \"$HEARTBEAT_EXPIRATION_PATH\"\n      exit 1\n    fi\n\n    echo \"Hosts file restore completed successfully\"\n    rm -f \"$restored_hosts_file\" \"$mutated_hosts_file\"\n    rm -f \"$FLAG_PATH\" \"$ROLLBACK_PATH\" \"$HEARTBEAT_EXPIRATION_PATH\"\n    exit 1\n  fi\n}\n\ndisable_fault_ecs() {\n  local mutated_hosts_file\n  mutated_hosts_file=$(mktemp)\n\n  if ! cp \"${HOSTS_FILE:-/etc/hosts}\" \"$mutated_hosts_file\"; then\n    echo \"Failed to copy current hosts file - exiting without restoring hosts file\" >&2\n    rm -f \"$mutated_hosts_file\"\n    exit 1\n  fi\n\n  local restored_hosts_file\n  restored_hosts_file=$(mktemp)\n\n  sed \"/${DELETE_MSG:-\"#delete-after-fault-injection\"}/d\" \"${HOSTS_FILE:-/etc/hosts}\" > \"$restored_hosts_file\"\n\n  local actual_deleted_lines\n  actual_deleted_lines=$(grep --invert-match --line-regexp --file=\"$restored_hosts_file\" \"$mutated_hosts_file\" || true)\n\n  local expected_deleted_lines\n  expected_deleted_lines=$(grep \"${DELETE_MSG:-\"#delete-after-fault-injection\"}\" \"$mutated_hosts_file\" || true)\n\n  if [ \"$actual_deleted_lines\" != \"$expected_deleted_lines\" ]; then\n    echo \"sed operation produced unexpected results - exiting without restoring hosts file\" >&2\n    echo \"Before sed operation:\" >&2\n    cat \"${mutated_hosts_file}\" >&2\n    echo \"After sed operation:\" >&2\n    cat \"${restored_hosts_file}\" >&2\n    rm -f \"$restored_hosts_file\" \"$mutated_hosts_file\"\n    exit 1\n  fi\n\n  if ! cat \"$restored_hosts_file\" > \"${HOSTS_FILE:-/etc/hosts}\"; then\n    echo \"Failed to write back to hosts file\" >&2\n    rm -f \"$restored_hosts_file\" \"$mutated_hosts_file\"\n    exit 1\n  fi\n\n  local final_deleted_lines\n  final_deleted_lines=$(grep --invert-match --line-regexp --file=\"${HOSTS_FILE:-/etc/hosts}\" \"$mutated_hosts_file\" || true)\n\n  if [ \"$final_deleted_lines\" != \"$expected_deleted_lines\" ]; then\n    echo \"Hosts file restore verification failed after write-back to hosts file\" >&2\n    echo \"Before write-back operation:\" >&2\n    cat \"${restored_hosts_file}\" >&2\n    echo \"After write-back operation:\" >&2\n    cat \"${HOSTS_FILE:-/etc/hosts}\" >&2\n    rm -f \"$restored_hosts_file\" \"$mutated_hosts_file\"\n    exit 1\n  fi\n\n  rm -f \"$restored_hosts_file\" \"$mutated_hosts_file\"\n  echo \"Hosts file restore completed successfully\"\n\n  # Call status API before stop to verify the fault is still running\n  local fault_status\n  if [[ -z \"$JSON_PAYLOAD\" ]]; then\n    fault_status=$(curl -s -X POST \"${ECS_AGENT_URI}/fault/v1/$FAULT_TYPE/status\" | jq --raw-output '.Status')\n  else\n    fault_status=$(curl -s -X POST \"${ECS_AGENT_URI}/fault/v1/$FAULT_TYPE/status\" \\\n      -H 'Content-Type: application/json' \\\n      -d \"$JSON_PAYLOAD\" | jq --raw-output '.Status')\n  fi\n\n  echo \"The fault injection status is: $fault_status\"\n  if [[ $fault_status == 'not-running' ]]; then\n    echo \"The fault injection is already stopped. No need to call stop API.\"\n  else\n    # Call the ECS Agent stop fault injection API\n    local curl_response\n    if [[ -z \"$JSON_PAYLOAD\" ]]; then\n      echo \"curl -s -X POST ${ECS_AGENT_URI}/fault/v1/$FAULT_TYPE/stop --write-out '#%{response_code}'\"\n      curl_response=$(curl -s -X POST \"${ECS_AGENT_URI}/fault/v1/$FAULT_TYPE/stop\" --write-out '#%{response_code}')\n    else\n      echo \"curl -s -X POST ${ECS_AGENT_URI}/fault/v1/$FAULT_TYPE/stop -H 'Content-Type: application/json' -d '$JSON_PAYLOAD' --write-out '#%{response_code}'\"\n      curl_response=$(curl -s -X POST \"${ECS_AGENT_URI}/fault/v1/$FAULT_TYPE/stop\" \\\n        -H 'Content-Type: application/json' \\\n        -d \"$JSON_PAYLOAD\" \\\n        --write-out '#%{response_code}')\n    fi\n\n    echo \"$curl_response\"\n    local -r status_code=$(echo \"$curl_response\" | cut -d \"#\" -f 2)\n    if [[ $status_code -ge 400 ]]; then\n      echo \"There was an error stopping the fault injection.\"\n      exit 1\n    fi\n  fi\n}\n\nget_ips()\n{\n  local -r input=\"$1\"\n\n  get_ips_from_input \"$input\" \"$IP_CIDR_REGEX\" ||\n  get_ips_from_input \"$input\" \"$IP_REGEX\" ||\n  get_ips_from_dns \"$input\" ||\n  get_ips_from_aws_service \"$input\" \"$IP_RANGES_URL\" \"$EC2_REGION\"\n}\n\nget_protected_ips()\n{\n  add_tmds_ip_to_protected_endpoints \"$ECS_AGENT_URI\"\n  get_protected_ips_from_protected_endpoints get_ips \"${PROTECTED_ENDPOINTS[@]}\"\n  get_protected_ips_from_ssm_connections \"$IP_REGEX\"\n  get_sorted_unique_protected_ips\n  echo \"Protected IPs: ${PROTECTED_IPS[@]}\"\n}\n\nvalidate_variable_is_set() {\n    local -r variable_name=\"$1\"\n    local variable_value\n\n    eval \"variable_value=\\\"\\${$variable_name-}\\\"\"\n\n    if [[ -z \"${variable_value}\" ]]; then\n        echo \"Variable $variable_name is not set.\" >&2\n        return 1\n    fi\n\n    return 0\n}\nvalidate_parameter_within_range() {\n  local parameter=$1\n  local value=$2\n  local min=$3\n  local max=$4\n\n  if (( value >= min && value <= max )); then\n    return 0\n  fi\n\n  echo \"Parameter $parameter must be between $min and $max, was: '$value'\" >&2\n  exit 1\n}\n\nget_user_vars() {\n    # Define system variable patterns to exclude\n    local patterns=(\n        '^BASH_'\n        '^COMP_'\n        '^EUID$'\n        '^PPID$'\n        '^SHELLOPTS$'\n        '^UID$'\n        '^PWD$'\n        '^OLDPWD$'\n        '^SHLVL$'\n        '^_$'\n    )\n    \n    # Join patterns with |\n    local exclude_pattern=$(IFS='|'; echo \"${patterns[*]}\")\n\n    # Get variables using set, but exclude the function's own variables\n    set | grep \"^[A-Za-z][A-Za-z0-9_]*=\" | \n    grep -Ev \"$exclude_pattern\" | \n    grep -Ev \"^(patterns|exclude_pattern)=\"\n}\n\nverify_daemon_is_running(){\n    echo \"Making sure atd daemon is running\"\n    # atd must be running in order to use \"at\" later\n    atd || { echo \"Failed to run atd daemon, exiting...\" 1>&2 ; exit 1; }\n}\n\nschedule_rollback_attempt() {\n    echo \"bash $ROLLBACK_PATH\" | at now 2>&1 | grep -v \"warning: commands will be executed using /bin/sh\"\n}\n\n# Helper function to handle heartbeat mode logic\nhandle_heartbeat_update() {\n  if ! [[ -f \"$HEARTBEAT_EXPIRATION_PATH\" ]]; then\n    echo \"Fault is not running. Heartbeat failed.\" >&2\n    exit 1\n  fi\n\n  # Use flock to protect file access (using a subshell to make read+write atomic)\n  (\n    # fd 9 is bound to $HEARTBEAT_EXPIRATION_PATH\n    flock --exclusive 9\n\n    # Update the heartbeat expiration time (but cautiously avoid reducing it)\n    local -r CURRENT_HEARTBEAT_EXPIRATION=$(< \"$HEARTBEAT_EXPIRATION_PATH\")\n    if [[ $HEARTBEAT_EXPIRATION_TIME -gt $CURRENT_HEARTBEAT_EXPIRATION ]]; then\n      echo \"Updating heartbeat expiration to $HEARTBEAT_EXPIRATION_TIME\"\n      echo \"$HEARTBEAT_EXPIRATION_TIME\" > \"$HEARTBEAT_EXPIRATION_PATH\"\n    else\n      echo \"Update heartbeat expiration value older than current value. Skipping update.\"\n    fi\n  ) 9< \"$HEARTBEAT_EXPIRATION_PATH\"\n}\n\ninitialize_heartbeat(){\n  echo \"$HEARTBEAT_EXPIRATION_TIME\" > \"$HEARTBEAT_EXPIRATION_PATH\"\n}\n\nhandle_heartbeat() {\n  # $HEARTBEAT_MODE is HEARTBEAT, update expiration\n  if [[ \"$HEARTBEAT_MODE\" == \"HEARTBEAT\" ]]; then\n    handle_heartbeat_update\n    # Exit with code 0 to indicate successful heartbeat\n    exit 0\n  fi\n\n  # $HEARTBEAT_MODE is START, initialize expiration\n  initialize_heartbeat\n}\n\n\n\nrollback() {\n  eval \"$DISABLE_FAULT_COMMAND\" ; local STATUS=$?\n  rm -f \"$FLAG_PATH\"\n  rm -f \"$ROLLBACK_PATH\"\n  rm -f \"$HEARTBEAT_EXPIRATION_PATH\"\n  echo \"Rollback done.\"\n  return $STATUS\n}\n\nrun_fault_injection_loop() {\n  local RESULT=0\n\n  # Loop for duration of fault\n  while : ; do\n    if [[ $(date +%s) -gt $STOP_TIME ]]; then\n      echo \"Fault duration has completed.\"\n      break\n    fi\n\n    local CURRENT_HEARTBEAT_EXPIRATION=$(flock \"$HEARTBEAT_EXPIRATION_PATH\" cat \"$HEARTBEAT_EXPIRATION_PATH\")\n    if [[ $(date +%s) -gt $CURRENT_HEARTBEAT_EXPIRATION ]]; then\n      echo \"Fault expiring due to age of last heartbeat.\"\n      RESULT=1\n      break\n    fi\n\n    # Update flag to indicate that script is still alive\n    touch \"$FLAG_PATH\"\n\n    # Enqueue a rollback check\n    schedule_rollback_attempt\n\n    sleep \"$INJECTION_LOOP_SLEEP_SECONDS\"\n  done\n\n  # After the desired duration, the fault injection is removed\n  rollback || RESULT=1\n  return $RESULT\n}\n\nverify_daemon_is_running\nvalidate_variable_is_set \"ECS_AGENT_URI\"\nFIS_ACTION_STATE_JSON='{{ FISActionState }}'\n# Identify if the document is executed in heartbeat mode\nCALL_COUNT=\"$(echo $FIS_ACTION_STATE_JSON | jq -r '.callCount // empty')\"\nEXECUTION_MODE=\"$(if [[ \"$CALL_COUNT\" == \"1\" ]]; then echo \"START\"; else echo \"HEARTBEAT\"; fi)\"\nFAULT_IDENTIFIER=\"$(echo \"$FIS_ACTION_STATE_JSON\" | jq -r '.id // empty')\"\nHEARTBEAT_TIMESTAMP=\"$(echo \"$FIS_ACTION_STATE_JSON\" | jq -r '.callTime // empty')\"\n\nif [[ -z \"$FAULT_IDENTIFIER\" || -z \"$CALL_COUNT\" || -z \"$HEARTBEAT_TIMESTAMP\" ]]; then\n  echo \"Required FISActionState fields were not populated.\" >&2\n  exit 1\nfi\n########################\n# Fault-specific logic #\n########################\n\nFAULT_NAME=\"Run-Network-Packet-Loss-ECS\"\nFAULT_TYPE=\"network-packet-loss\"\n\nLOSS={{ LossPercent }}\nDURATION={{ DurationSeconds }}\nFLOWS_PERCENT={{ FlowsPercent }}\nSOURCES={{ Sources }}\nIP_RANGES_URL=\"https://ip-ranges.amazonaws.com/ip-ranges.json\"\n\nvalidate_parameter_within_range \"DurationSeconds\" $DURATION 1 43200\nvalidate_parameter_within_range \"FlowsPercent\" $FLOWS_PERCENT 1 100\n\nTARGET_IPS=()\nPROTECTED_IPS=()\n# When running in heartbeat mode, there is no need to calculate the target and protected IPs again\nif [[ \"$EXECUTION_MODE\" == \"START\" ]]; then\n    get_target_ips_from_sources get_ips \"${SOURCES[@]}\"\n    get_protected_ips\nfi\n\nJSON_PAYLOAD=$(jq -c --null-input \\\n                  --argjson LossPercent $LOSS \\\n                  --argjson FlowsPercent $FLOWS_PERCENT \\\n                  --arg Sources \"${TARGET_IPS[*]:-}\" \\\n                  --arg FilterSources \"${PROTECTED_IPS[*]:-}\" \\\n                  '{\n                    \"LossPercent\": $LossPercent,\n                    \"FlowsPercent\": $FlowsPercent,\n                    \"Sources\": ($Sources|split(\" \")),\n                    \"SourcesToFilter\": ($FilterSources|split(\" \"))\n                  }')\n\nFLAG_PATH=\"/var/lib/amazon/ssm/$FAULT_NAME-$FAULT_IDENTIFIER.flag\"\nROLLBACK_PATH=\"/var/lib/amazon/ssm/$FAULT_NAME-$FAULT_IDENTIFIER-Rollback.sh\"\nHEARTBEAT_EXPIRATION_PATH=\"/var/lib/amazon/ssm/$FAULT_IDENTIFIER-Heartbeat-Expiration\"\nSTOP_TIME=$(( $(date +%s) + DURATION ))\nHEARTBEAT_EXPIRATION_SECONDS=60\nHEARTBEAT_EXPIRATION_TIME=$((HEARTBEAT_TIMESTAMP + HEARTBEAT_EXPIRATION_SECONDS))\nHEARTBEAT_MODE=\"$(if [[ \"$CALL_COUNT\" == \"1\" ]]; then echo START; else echo HEARTBEAT; fi)\"\nMAX_FLAG_AGE_SECONDS=10\nINJECTION_LOOP_SLEEP_SECONDS=5\nATTEMPT_ROLLBACK_AT_SECONDS=20\nDISABLE_FAULT_COMMAND=\"disable_fault_ecs\"\nENABLE_FAULT_COMMAND=\"enable_fault_ecs\"\n\nhandle_heartbeat\nROLLBACK_LOG_FILE=\"/tmp/aws-fis-rollback-$(date -u +%Y-%m-%dT%H:%M:%SZ)-$.log\"\n\ncat << 'EOF' > \"$ROLLBACK_PATH\"\n#!/bin/bash\ndisable_fault_ecs() {\n  local mutated_hosts_file\n  mutated_hosts_file=$(mktemp)\n\n  if ! cp \"${HOSTS_FILE:-/etc/hosts}\" \"$mutated_hosts_file\"; then\n    echo \"Failed to copy current hosts file - exiting without restoring hosts file\" >&2\n    rm -f \"$mutated_hosts_file\"\n    exit 1\n  fi\n\n  local restored_hosts_file\n  restored_hosts_file=$(mktemp)\n\n  sed \"/${DELETE_MSG:-\"#delete-after-fault-injection\"}/d\" \"${HOSTS_FILE:-/etc/hosts}\" > \"$restored_hosts_file\"\n\n  local actual_deleted_lines\n  actual_deleted_lines=$(grep --invert-match --line-regexp --file=\"$restored_hosts_file\" \"$mutated_hosts_file\" || true)\n\n  local expected_deleted_lines\n  expected_deleted_lines=$(grep \"${DELETE_MSG:-\"#delete-after-fault-injection\"}\" \"$mutated_hosts_file\" || true)\n\n  if [ \"$actual_deleted_lines\" != \"$expected_deleted_lines\" ]; then\n    echo \"sed operation produced unexpected results - exiting without restoring hosts file\" >&2\n    echo \"Before sed operation:\" >&2\n    cat \"${mutated_hosts_file}\" >&2\n    echo \"After sed operation:\" >&2\n    cat \"${restored_hosts_file}\" >&2\n    rm -f \"$restored_hosts_file\" \"$mutated_hosts_file\"\n    exit 1\n  fi\n\n  if ! cat \"$restored_hosts_file\" > \"${HOSTS_FILE:-/etc/hosts}\"; then\n    echo \"Failed to write back to hosts file\" >&2\n    rm -f \"$restored_hosts_file\" \"$mutated_hosts_file\"\n    exit 1\n  fi\n\n  local final_deleted_lines\n  final_deleted_lines=$(grep --invert-match --line-regexp --file=\"${HOSTS_FILE:-/etc/hosts}\" \"$mutated_hosts_file\" || true)\n\n  if [ \"$final_deleted_lines\" != \"$expected_deleted_lines\" ]; then\n    echo \"Hosts file restore verification failed after write-back to hosts file\" >&2\n    echo \"Before write-back operation:\" >&2\n    cat \"${restored_hosts_file}\" >&2\n    echo \"After write-back operation:\" >&2\n    cat \"${HOSTS_FILE:-/etc/hosts}\" >&2\n    rm -f \"$restored_hosts_file\" \"$mutated_hosts_file\"\n    exit 1\n  fi\n\n  rm -f \"$restored_hosts_file\" \"$mutated_hosts_file\"\n  echo \"Hosts file restore completed successfully\"\n\n  # Call status API before stop to verify the fault is still running\n  local fault_status\n  if [[ -z \"$JSON_PAYLOAD\" ]]; then\n    fault_status=$(curl -s -X POST \"${ECS_AGENT_URI}/fault/v1/$FAULT_TYPE/status\" | jq --raw-output '.Status')\n  else\n    fault_status=$(curl -s -X POST \"${ECS_AGENT_URI}/fault/v1/$FAULT_TYPE/status\" \\\n      -H 'Content-Type: application/json' \\\n      -d \"$JSON_PAYLOAD\" | jq --raw-output '.Status')\n  fi\n\n  echo \"The fault injection status is: $fault_status\"\n  if [[ $fault_status == 'not-running' ]]; then\n    echo \"The fault injection is already stopped. No need to call stop API.\"\n  else\n    # Call the ECS Agent stop fault injection API\n    local curl_response\n    if [[ -z \"$JSON_PAYLOAD\" ]]; then\n      echo \"curl -s -X POST ${ECS_AGENT_URI}/fault/v1/$FAULT_TYPE/stop --write-out '#%{response_code}'\"\n      curl_response=$(curl -s -X POST \"${ECS_AGENT_URI}/fault/v1/$FAULT_TYPE/stop\" --write-out '#%{response_code}')\n    else\n      echo \"curl -s -X POST ${ECS_AGENT_URI}/fault/v1/$FAULT_TYPE/stop -H 'Content-Type: application/json' -d '$JSON_PAYLOAD' --write-out '#%{response_code}'\"\n      curl_response=$(curl -s -X POST \"${ECS_AGENT_URI}/fault/v1/$FAULT_TYPE/stop\" \\\n        -H 'Content-Type: application/json' \\\n        -d \"$JSON_PAYLOAD\" \\\n        --write-out '#%{response_code}')\n    fi\n\n    echo \"$curl_response\"\n    local -r status_code=$(echo \"$curl_response\" | cut -d \"#\" -f 2)\n    if [[ $status_code -ge 400 ]]; then\n      echo \"There was an error stopping the fault injection.\"\n      exit 1\n    fi\n  fi\n}\n\npessimistic_rollback() {\n    if ! [ -f \"$FLAG_PATH\" ] || [ \"$(( $(date +%s) - $(stat -c \"%Y\" \"$FLAG_PATH\") ))\" -gt $MAX_FLAG_AGE_SECONDS ] ; then\n        $DISABLE_FAULT_COMMAND\n        rm -f \"$FLAG_PATH\"\n        rm -f \"$HEARTBEAT_EXPIRATION_PATH\"\n        rm -f \"$ROLLBACK_PATH\"\n    fi\n}\nEOF\n\ncat << EOF >> \"$ROLLBACK_PATH\"\nFAULT_IDENTIFIER=$FAULT_IDENTIFIER\nFLAG_PATH=$FLAG_PATH\nROLLBACK_PATH=$ROLLBACK_PATH\nDISABLE_FAULT_COMMAND=$DISABLE_FAULT_COMMAND\nMAX_FLAG_AGE_SECONDS=$MAX_FLAG_AGE_SECONDS\nHEARTBEAT_EXPIRATION_PATH=$HEARTBEAT_EXPIRATION_PATH\nROLLBACK_LOG_FILE=\"$ROLLBACK_LOG_FILE\"\n$(get_user_vars)\n\n# Setup dual logging - redirect all output to both temp file and syslog\nexec 1> >(tee -a \"\\$ROLLBACK_LOG_FILE\" | while read line; do logger -t \"aws-fis-rollback\" -p \"local0.info\" \"[\\$(date -u '+%Y-%m-%dT%H:%M:%SZ')] \\$line\" 2>/dev/null || true; done)\nexec 2>&1\n\nif ! [ -t 0 ] ; then\n  sleep $ATTEMPT_ROLLBACK_AT_SECONDS\nfi\n\npessimistic_rollback\nEOF\n\necho \"Temporary rollback file created: $ROLLBACK_PATH (logs: $ROLLBACK_LOG_FILE)\"\n\ntrap 'rollback' INT TERM\n\necho \"Scheduling rollback\"\nschedule_rollback_attempt\n\n# Injecting fault\necho \"Enabling fault injection\"\ntouch \"$FLAG_PATH\"\neval \"$ENABLE_FAULT_COMMAND\"\nrun_fault_injection_loop\nexit $?\n"
        ]
      }
    }
  ]
}
