{
  "schemaVersion": "1.0",
  "templateBody": {
    "Parameters": {
      "IsPolicyAttachAllowed": {
        "Type": "String",
        "Default": "false",
        "AllowedValues": [
          "true",
          "false"
        ],
        "Description": "(Optional) Whether or not Quicksetup is allowed to attach policies to existing Instance profiles."
      },
      "HasDeletedBaseline": {
        "Type": "String",
        "Default": "false",
        "AllowedValues": [
          "true",
          "false"
        ],
        "Description": "(Optional) Whether patch policy contains a deleted custom patch baseline."
      },
      "QSType": {
        "Type": "String",
        "AllowedValues": [
          "LA",
          "TA",
          "MA"
        ],
        "Default": "TA",
        "Description": "(Required) Specifies the type of the QuickSetup: either local or organizational."
      },
      "QSConfigurationId": {
        "Type": "String",
        "Default": "",
        "Description": "(Required) Unique identifier of the deployed configuration."
      },
      "QSAttachConfigurationPolicy": {
        "Type": "String",
        "Default": "false",
        "AllowedValues": [
          "true",
          "false"
        ],
        "Description": "(Optional) Whether to attach Configuration permissions policy which sets boundaries of what configuration can do."
      },
      "PatchPolicyName": {
        "Type": "String",
        "Description": "(Required) The name of the patch policy."
      },
      "SelectedPatchBaselines": {
        "Type": "String",
        "Description": "(Required) Stringified JSON content of selected Patch baselines."
      },
      "PatchBaselineUseDefault": {
        "Type": "String",
        "Default": "default",
        "AllowedValues": [
          "default",
          "custom"
        ]
      },
      "ConfigurationOptionsPatchOperation": {
        "Type": "String",
        "Default": "Scan",
        "AllowedValues": [
          "Scan",
          "ScanAndInstall"
        ],
        "Description": "(Required) Whether to scan for patches or install patches."
      },
      "RateControlErrorThreshold": {
        "Type": "String",
        "Default": "2%",
        "Description": "(Optional) The number of errors that are allowed before the system stops sending requests to run the association on additional targets."
      },
      "RateControlConcurrency": {
        "Type": "String",
        "Default": "10%",
        "Description": "(Optional) The maximum number of targets allowed to run the association at the same time."
      },
      "ConfigurationOptionsScanValue": {
        "Type": "String",
        "Default": "cron(0 1 * * ? *)",
        "Description": "(Optional) CRON or Rate Expression at which to execute the association"
      },
      "ConfigurationOptionsScanNextInterval": {
        "Type": "String",
        "Default": "false",
        "AllowedValues": [
          "true",
          "false"
        ],
        "Description": "(Optional) Whether or not to run the State Manager scan associations on next CRON interval."
      },
      "ConfigurationOptionsInstallValue": {
        "Type": "String",
        "Default": "",
        "Description": "(Optional) CRON or Rate Expression at which to execute the association"
      },
      "ConfigurationOptionsInstallNextInterval": {
        "Type": "String",
        "Default": "true",
        "AllowedValues": [
          "true",
          "false"
        ],
        "Description": "(Optional) Whether or not to run the State Manager install associations on next CRON interval."
      },
      "OutputLogEnableS3": {
        "Type": "String",
        "Default": "true",
        "AllowedValues": [
          "true",
          "false"
        ],
        "Description": "(Optional) Whether or not to send output to s3 bucket."
      },
      "OutputS3Location": {
        "Type": "String",
        "Default": "",
        "Description": "(Optional) JSON string containing the information of the S3 bucket used for storing command output logs"
      },
      "OutputBucketRegion": {
        "Type": "String",
        "Default": "",
        "Description": "(Optional) The ID of the Region where the S3 bucket for storing command output logs is located."
      },
      "OutputS3BucketName": {
        "Type": "String",
        "Description": "(Optional) The name of the S3 bucket where command output logs are stored.",
        "AllowedPattern": "^[a-z0-9.-]{0,63}$",
        "Default": ""
      },
      "OutputS3KeyPrefix": {
        "Type": "String",
        "Description": "(Optional) The directory structure in the S3 bucket where command output logs are stored.",
        "Default": ""
      },
      "TargetType": {
        "Type": "String",
        "Default": "*",
        "AllowedValues": [
          "Tags",
          "InstanceIds",
          "ResourceGroups",
          "*"
        ],
        "Description": "(Optional) Specifies the way in which instances are targeted - applies only for local QuickSetup."
      },
      "TargetInstances": {
        "Type": "String",
        "Default": "*",
        "Description": "(Optional) Specifies the instances to be targeted when QSType=LA and ScanTargetType=InstanceIds."
      },
      "ResourceGroupName": {
        "Type": "String",
        "Default": "",
        "Description": "(Optional) Specifies the resource group name to be targeted when QSType=LA and ScanTargetType=ResourceGroups"
      },
      "RebootOption": {
        "Type": "String",
        "Default": "NoReboot",
        "AllowedValues": [
          "RebootIfNeeded",
          "NoReboot"
        ],
        "Description": "(Optional) Reboot behavior after a patch Install operation. If you choose NoReboot and patches are installed, the instance is marked as non-compliant until a subsequent reboot and scan."
      },
      "TargetTagKey": {
        "Type": "String",
        "Default": "",
        "Description": "(Optional) Specifies the tag key of instances to be targeted when QSType=LA and ScanTargetType=Tags"
      },
      "TargetTagValue": {
        "Type": "String",
        "Default": "",
        "Description": "(Optional) Specifies the tag value of instances to be targeted when QSType=LA and ScanTargetType=Tags"
      },
      "PatchBaselineRegion": {
        "Type": "String",
        "Default": "",
        "Description": "(Required) The region from which Patch Baselines are pulled"
      },
      "QSOwnerAccountId": {
        "Type": "String",
        "Default": "",
        "Description": "(Required) Account Id that owns the S3 bucket for baseline_overrides.json object"
      },
      "QSTargetOrganizationalUnits": {
        "Type": "CommaDelimitedList",
        "Default": "",
        "Description": "(Optional) A list of all Organizational Units (OUs) targeted for deployment"
      },
      "QSPrincipalOrgId": {
        "Type": "String",
        "Default": "",
        "Description": "(Optional) Principal Organization Id of the AWS Organization"
      }
    },
    "Conditions": {
      "ShouldAttachConfigurationPolicy": {
        "Fn::Equals": [
          {
            "Ref": "QSAttachConfigurationPolicy"
          },
          "true"
        ]
      },
      "PolicyAttachAllowed": {
        "Fn::Equals": [
          {
            "Ref": "IsPolicyAttachAllowed"
          },
          "true"
        ]
      },
      "IsGlobalRegion": {
        "Fn::Equals": [
          {
            "Ref": "AWS::Region"
          },
          {
            "Ref": "PatchBaselineRegion"
          }
        ]
      },
      "DeployManagementResources": {
        "Fn::And": [
          {
            "Condition": "IsGlobalRegion"
          },
          {
            "Fn::Equals": [
              {
                "Ref": "QSType"
              },
              "LA"
            ]
          }
        ]
      },
      "CreateInstallInstancesAssociation": {
        "Fn::Equals": [
          {
            "Ref": "ConfigurationOptionsPatchOperation"
          },
          "ScanAndInstall"
        ]
      },
      "EnabledOutputBucketWithPrefix": {
        "Fn::And": [
          {
            "Fn::Equals": [
              {
                "Ref": "OutputLogEnableS3"
              },
              "true"
            ]
          },
          {
            "Fn::Not": [
              {
                "Fn::Equals": [
                  {
                    "Ref": "OutputS3KeyPrefix"
                  },
                  ""
                ]
              }
            ]
          }
        ]
      },
      "EnabledOutputBucketWithoutPrefix": {
        "Fn::And": [
          {
            "Fn::Equals": [
              {
                "Ref": "OutputLogEnableS3"
              },
              "true"
            ]
          },
          {
            "Fn::Equals": [
              {
                "Ref": "OutputS3KeyPrefix"
              },
              ""
            ]
          }
        ]
      },
      "IsTagValueNotSpecified": {
        "Fn::Equals": [
          {
            "Ref": "TargetTagValue"
          },
          ""
        ]
      },
      "IsTagKeyAndValueTargeted": {
        "Fn::And": [
          {
            "Fn::Equals": [
              {
                "Ref": "TargetType"
              },
              "Tags"
            ]
          },
          {
            "Fn::Not": [
              {
                "Condition": "IsTagValueNotSpecified"
              }
            ]
          }
        ]
      },
      "IsTagKeyOnlyTargeted": {
        "Fn::And": [
          {
            "Fn::Equals": [
              {
                "Ref": "TargetType"
              },
              "Tags"
            ]
          },
          {
            "Condition": "IsTagValueNotSpecified"
          }
        ]
      },
      "IsResourceGroupTargeted": {
        "Fn::Equals": [
          {
            "Ref": "TargetType"
          },
          "ResourceGroups"
        ]
      },
      "TargetAll": {
        "Fn::Equals": [
          {
            "Ref": "TargetInstances"
          },
          "*"
        ]
      }
    },
    "Resources": {
      "BaselineOverridesAccessLogBucket": {
        "Type": "AWS::S3::Bucket",
        "Properties": {
          "BucketName": {
            "Fn::Join": [
              "-",
              [
                {
                  "Fn::Sub": "aws-quicksetup-patchpolicy-access-log-${QSOwnerAccountId}"
                },
                {
                  "Fn::Select": [
                    3,
                    {
                      "Fn::Split": [
                        "-",
                        {
                          "Fn::Select": [
                            2,
                            {
                              "Fn::Split": [
                                "/",
                                {
                                  "Ref": "AWS::StackId"
                                }
                              ]
                            }
                          ]
                        }
                      ]
                    }
                  ]
                },
                {
                  "Ref": "QSConfigurationId"
                }
              ]
            ]
          },
          "AccessControl": "Private",
          "BucketEncryption": {
            "ServerSideEncryptionConfiguration": [
              {
                "ServerSideEncryptionByDefault": {
                  "SSEAlgorithm": "AES256"
                }
              }
            ]
          },
          "LifecycleConfiguration": {
            "Rules": [
              {
                "Id": "MoveToGlacierAfter90Days_DeleteAfter10Years",
                "ExpirationInDays": 3653,
                "Status": "Enabled",
                "Transitions": [
                  {
                    "StorageClass": "GLACIER_IR",
                    "TransitionInDays": 90
                  }
                ]
              }
            ]
          },
          "OwnershipControls": {
            "Rules": [
              {
                "ObjectOwnership": "BucketOwnerEnforced"
              }
            ]
          },
          "PublicAccessBlockConfiguration": {
            "BlockPublicAcls": true,
            "BlockPublicPolicy": true,
            "IgnorePublicAcls": true,
            "RestrictPublicBuckets": true
          },
          "VersioningConfiguration": {
            "Status": "Enabled"
          }
        },
        "DeletionPolicy": "Retain",
        "Condition": "DeployManagementResources"
      },
      "BaselineOverridesAccessLogBucketPolicy": {
        "Type": "AWS::S3::BucketPolicy",
        "Properties": {
          "Bucket": {
            "Ref": "BaselineOverridesAccessLogBucket"
          },
          "PolicyDocument": {
            "Version": "2012-10-17",
            "Statement": [
              {
                "Sid": "DenyInsecureTransport",
                "Effect": "Deny",
                "Principal": "*",
                "Action": "s3:*",
                "Resource": [
                  {
                    "Fn::Sub": "arn:${AWS::Partition}:s3:::${BaselineOverridesAccessLogBucket}"
                  },
                  {
                    "Fn::Sub": "arn:${AWS::Partition}:s3:::${BaselineOverridesAccessLogBucket}/*"
                  }
                ],
                "Condition": {
                  "Bool": {
                    "aws:SecureTransport": "false"
                  }
                }
              },
              {
                "Sid": "S3ServerAccessLogsPolicy",
                "Effect": "Allow",
                "Principal": {
                  "Service": "logging.s3.amazonaws.com"
                },
                "Action": [
                  "s3:PutObject"
                ],
                "Resource": {
                  "Fn::Sub": "arn:${AWS::Partition}:s3:::${BaselineOverridesAccessLogBucket}/*"
                },
                "Condition": {
                  "ArnLike": {
                    "aws:SourceArn": {
                      "Fn::Sub": "arn:${AWS::Partition}:s3:::aws-quicksetup-patchpolicy-${QSOwnerAccountId}-${QSConfigurationId}"
                    }
                  },
                  "StringEquals": {
                    "aws:SourceAccount": {
                      "Ref": "QSOwnerAccountId"
                    }
                  }
                }
              }
            ]
          }
        },
        "Condition": "DeployManagementResources"
      },
      "BaselineOverridesLambdaFunction": {
        "Type": "AWS::Lambda::Function",
        "Properties": {
          "FunctionName": {
            "Fn::Join": [
              "-",
              [
                "baseline-overrides",
                {
                  "Fn::Select": [
                    3,
                    {
                      "Fn::Split": [
                        "-",
                        {
                          "Fn::Select": [
                            2,
                            {
                              "Fn::Split": [
                                "/",
                                {
                                  "Ref": "AWS::StackId"
                                }
                              ]
                            }
                          ]
                        }
                      ]
                    }
                  ]
                },
                {
                  "Ref": "QSConfigurationId"
                }
              ]
            ]
          },
          "Description": "Lambda function that responds to Delete and Create events from CloudFormation or performs baseline remediation when triggered by the State Manager Association executing the Automation Document",
          "Code": {
            "ZipFile": "# Copyright 2022 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n# Licensed under the Apache License, Version 2.0 (the 'License'). You\n# may not use this file except in compliance with the License. A copy of\n# the License is located at\n#     http://aws.amazon.com/apache2.0/\n# or in the 'license' file accompanying this file. This file is\n# distributed on an 'AS IS' BASIS, WITHOUT WARRANTIES OR CONDITIONS OF\n# ANY KIND, either express or implied. See the License for the specific\n# language governing permissions and limitations under the License.\n#\n# This handler performs CRUD operations on an S3 object.\n# This handler also adds a Quick Setup specific bucket policy to the bucket\n# to enable target nodes to pull down the S3 object during patching operations.\n\n\nimport boto3\nimport json\nimport urllib3\nimport time\nimport os\n\n\nSUCCESS = 'SUCCESS'\nFAILED = 'FAILED'\n\n# Events sent in by CloudFormation\nCREATE = 'Create'\nUPDATE = 'Update'\nDELETE = 'Delete'\n\n# Event sent in by Automation\nREMEDIATE = 'Remediate'\n\nDEFAULT_REGION = 'us-east-1'\n\nregion = os.environ['REGION']\ns3_client = boto3.client('s3', region_name=region)\nssm_client = boto3.client('ssm', region_name=region)\ns3_resource = boto3.resource('s3', region_name=region)\nhttp = urllib3.PoolManager()\n\n\ndef create_bucket(bucket_name):\n    bucket_creation_params = {\n        'ACL': 'private',\n        'Bucket': bucket_name,\n        'CreateBucketConfiguration': {\n            'LocationConstraint': region\n        },\n        'ObjectOwnership': 'BucketOwnerEnforced'\n    }\n\n    if region == DEFAULT_REGION:\n        del bucket_creation_params['CreateBucketConfiguration']\n        print('Creating a bucket in', DEFAULT_REGION, '...', '\\n')\n    else:\n        print('Creating a bucket in', region, '...', '\\n')\n\n    s3_client.create_bucket(**bucket_creation_params)\n    waiter = s3_client.get_waiter('bucket_exists')\n    waiter.wait(Bucket=bucket_name)\n    print('Successfully created the bucket:', bucket_name, '\\n')\n\n\ndef put_bucket_versioning(bucket_name):\n    print('Enabling bucket versioning... \\n')\n    s3_client.put_bucket_versioning(\n        Bucket=bucket_name,\n        VersioningConfiguration={\n            'MFADelete': 'Disabled',\n            'Status': 'Enabled'\n        }\n    )\n    print('Bucket versioning enabled \\n')\n\n\ndef put_bucket_encryption(bucket_name):\n    print('Applying server side encryption to the bucket... \\n')\n    s3_client.put_bucket_encryption(\n        Bucket=bucket_name,\n        ServerSideEncryptionConfiguration={\n            'Rules': [\n                {\n                    'ApplyServerSideEncryptionByDefault': {\n                        'SSEAlgorithm': 'AES256'\n                    }\n                }\n            ]\n        }\n    )\n    print('Encryption applied to the bucket \\n')\n\n\ndef put_public_access_block(bucket_name):\n    print('Turning on public access block for the bucket... \\n')\n    s3_client.put_public_access_block(\n        Bucket=bucket_name,\n        PublicAccessBlockConfiguration={\n            'BlockPublicAcls': True,\n            'IgnorePublicAcls': True,\n            'BlockPublicPolicy': True,\n            'RestrictPublicBuckets': True\n        }\n    )\n    print('Public access block turned on for the bucket \\n')\n\n\ndef put_bucket_lifecycle_configuration(bucket_name):\n    print('Applying lifecycle configuration to the bucket... \\n')\n    s3_client.put_bucket_lifecycle_configuration(\n        Bucket=bucket_name,\n        LifecycleConfiguration={\n            'Rules': [\n                {\n                    'ID': 'DeleteVersionsOlderThan90Days',\n                    'Filter': {\n                        'Prefix': 'baseline_overrides.json'\n                    },\n                    'Status': 'Enabled',\n                    'NoncurrentVersionExpiration': {\n                        'NoncurrentDays': 90\n                    }\n                }\n            ]\n        }\n    )\n    print('Lifecycle configuration applied to the bucket \\n')\n\n\ndef put_bucket_policy(bucket_name, resource_properties):\n    print('Constructing and applying bucket policy... \\n')\n    partition = resource_properties['Partition']\n    baseline_overrides_json = f'arn:{partition}:s3:::{bucket_name}/baseline_overrides.json'\n    qs_configuration_id = resource_properties['QSConfigId']\n    target_entities = resource_properties['TargetEntities']\n    organizational_units = resource_properties['OrgUnits']\n    principal_org_id = resource_properties['PrincipalOrgId']\n    account_id = resource_properties['AccountId']\n\n    bucket_policy = {\n        'Version': '2012-10-17',\n        'Statement': [\n            {\n                'Sid': 'DenyInsecureTransport',\n                'Effect': 'Deny',\n                'Principal': '*',\n                'Action': 's3:*',\n                'Resource': [\n                    f'arn:{partition}:s3:::{bucket_name}/*'\n                ],\n                'Condition': {\n                    'Bool': {\n                        'aws:SecureTransport': 'false'\n                    }\n                }\n            },\n            {\n                'Sid': 'DenyAllButPrincipalsWithTag',\n                'Effect': 'Deny',\n                'Principal': {\n                    'AWS': '*'\n                },\n                'Action': 's3:GetObject',\n                'Resource': [\n                    baseline_overrides_json\n                ],\n                'Condition': {\n                    'StringNotEquals': {\n                        f'aws:PrincipalTag/QSConfigId-{qs_configuration_id}': f'{qs_configuration_id}'\n                    }\n                }\n            }\n        ]\n    }\n\n    target_statement = {\n        'Sid': 'Target',\n        'Effect': 'Allow',\n        'Action': 's3:GetObject',\n        'Resource': baseline_overrides_json\n    }\n\n    if target_entities.upper() == 'TA' and len(organizational_units) and organizational_units[0].startswith('ou-'):\n        if len(organizational_units) == 0:\n            raise ValueError('Was expecting at least one OU')\n\n        principal_org_paths = [\n            f'{principal_org_id}/*/{ou}/*' for ou in organizational_units if ou.startswith('ou-')]\n\n        if len(principal_org_paths) == 0:\n            raise ValueError('Was expecting at least one OU')\n\n        target_statement['Principal'] = '*'\n        target_statement['Condition'] = {\n            'ForAnyValue:StringLike': {\n                'aws:PrincipalOrgPaths': principal_org_paths\n            }\n        }\n    elif target_entities.upper() == 'TA' and len(organizational_units) and organizational_units[0].startswith('r-'):\n        target_statement['Principal'] = '*'\n        target_statement['Condition'] = {\n            'StringEquals': {\n                'aws:PrincipalOrgID': [\n                    f'{principal_org_id}'\n                ]\n            }\n        }\n    elif target_entities.upper() == 'LA':\n        target_statement['Principal'] = {\"AWS\": account_id}\n    else:\n        raise ValueError(\n            'Got an unexpected value for target entities; was expecting ENTIRE_ORG, LOCAL, or OU')\n\n    bucket_policy['Statement'].append(target_statement)\n\n    s3_client.put_bucket_policy(\n        Bucket=bucket_name,\n        Policy=json.dumps(bucket_policy)\n    )\n    print('Bucket policy applied \\n')\n\n\ndef put_bucket_logging(bucket_name, access_log_bucket_name):\n    print('Enabling logging for the bucket... \\n')\n    s3_client.put_bucket_logging(\n        Bucket=bucket_name,\n        BucketLoggingStatus={\n            'LoggingEnabled': {\n                'TargetBucket': access_log_bucket_name,\n                'TargetPrefix': ''\n            }\n        }\n    )\n    print('Logging enabled for the bucket \\n')\n\n\ndef get_patch_baselines(patch_baseline_ids, request_type) -> dict:\n    print('Retrieving patch baselines... \\n')\n    patch_baselines = []\n    non_existent_baseline_ids = []\n\n    if request_type in (CREATE, UPDATE):\n        try:\n            for baseline_id in patch_baseline_ids:\n                baseline = ssm_client.get_patch_baseline(\n                    BaselineId=baseline_id\n                )\n                patch_baselines.append(baseline)\n\n            print('Patch baselines retrieved \\n')\n            return {\n                'PatchBaselines': json.dumps(patch_baselines, default=str),\n                'NonExistentBaselineIds': non_existent_baseline_ids\n            }\n        except ssm_client.exceptions.DoesNotExistException as err:\n            print(f'Baseline id {baseline_id} does not exist')\n            print(err, '\\n')\n            raise err\n\n    elif request_type == REMEDIATE:  # Different behavior for Remediate by design\n        for baseline_id in patch_baseline_ids:\n            try:\n                baseline = ssm_client.get_patch_baseline(\n                    BaselineId=baseline_id\n                )\n                patch_baselines.append(baseline)\n            except ssm_client.exceptions.DoesNotExistException:\n                non_existent_baseline_ids.append(baseline_id)\n\n        print('Patch baselines retrieved \\n')\n        return {\n            'PatchBaselines': json.dumps(patch_baselines, default=str),\n            'NonExistentBaselineIds': non_existent_baseline_ids\n        }\n\n\ndef place_baselines_into_bucket(bucket_name, baselines):\n    print('Loading the baselines... \\n')\n    s3_client.put_object(\n        Body=baselines['PatchBaselines'],\n        Bucket=bucket_name,\n        Key='baseline_overrides.json',\n    )\n    print('Baselines loaded \\n')\n\n    if baselines['NonExistentBaselineIds']:\n        print('The following baseline ids could not be found:',\n              baselines['NonExistentBaselineIds'], '\\n')\n        raise ValueError(\n            f'The following baseline ids could not be found: {baselines[\"NonExistentBaselineIds\"]}')\n\n\ndef permanently_delete_all_objects(bucket_name):\n    print('Deleting all objects in the bucket permanently... \\n')\n    bucket = s3_resource.Bucket(bucket_name)\n    bucket.object_versions.all().delete()\n    time.sleep(2)\n    print('Bucket has been emptied \\n')\n\n\ndef delete_bucket(bucket_name):\n    print('Deleting the bucket... \\n')\n    s3_client.delete_bucket(\n        Bucket=bucket_name\n    )\n    waiter = s3_client.get_waiter('bucket_not_exists')\n    waiter.wait(\n        Bucket=bucket_name\n    )\n    print('Bucket deleted successfully \\n')\n\n\ndef empty_and_delete_bucket(bucket_name):\n    try:\n        s3_client.head_bucket(\n            Bucket=bucket_name\n        )\n        permanently_delete_all_objects(bucket_name)\n        delete_bucket(bucket_name)\n    except Exception as err:\n        # Bucket does not exist or is not owned by the account\n        if err.response['Error']['Code'] == '404':\n            return\n        else:\n            raise err\n\n\ndef send(event, context, responseStatus, responseData=None, physicalResourceId=None, noEcho=False, reason=None):\n    request_type = event.get('RequestType')\n    if not request_type in (CREATE, UPDATE, DELETE):\n        return\n\n    print('Preparing response to CloudFormation... \\n')\n\n    responseUrl = event['ResponseURL']\n    responseBody = {\n        'Status': responseStatus,\n        'Reason': reason or f'See the details in CloudWatch Log Stream: {context.log_stream_name}',\n        'PhysicalResourceId': physicalResourceId or context.log_stream_name,\n        'StackId': event['StackId'],\n        'RequestId': event['RequestId'],\n        'LogicalResourceId': event['LogicalResourceId'],\n        'NoEcho': noEcho,\n        'Data': responseData\n    }\n\n    print('Response body:', responseBody, '\\n')\n    json_responseBody = json.dumps(responseBody)\n\n    headers = {\n        'content-type': '',\n        'content-length': str(len(json_responseBody))\n    }\n\n    try:\n        print('Sending response to CloudFormation via http request... \\n')\n        response = http.request(\n            'PUT', responseUrl, headers=headers, body=json_responseBody, retries=5)\n        print('Status code:', response.status, '\\n')\n\n    # If this actually happens, the stack could get stuck for an hour\n    # waiting for a response from this custom resource.\n    # There is a manual way to send a response using curl\n    except Exception as err:\n        print('Send failed executing http.request:')\n        print(err, '\\n')\n        raise err\n\n\ndef lambda_handler(event, context):\n    request_type = event.get('RequestType')\n\n    # In case of Remediate, ResourceProperties only has BucketName and PatchBaselineIds\n    resource_properties = event['ResourceProperties']\n\n    bucket_name = resource_properties['BucketName']\n    patch_baseline_ids = [baseline.get('value') for baseline in json.loads(resource_properties['PatchBaselines']).values()]\n    access_log_bucket_name = resource_properties.get('AccessLogBucketName')\n\n    print('Event:', event, '\\n')\n\n    try:\n        if request_type == CREATE:\n            create_bucket(bucket_name)\n            put_bucket_versioning(bucket_name)\n            put_bucket_encryption(bucket_name)\n            put_public_access_block(bucket_name)\n            put_bucket_lifecycle_configuration(bucket_name)\n            put_bucket_policy(bucket_name, resource_properties)\n            put_bucket_logging(bucket_name, access_log_bucket_name)\n            place_baselines_into_bucket(\n                bucket_name, get_patch_baselines(patch_baseline_ids, request_type))\n            send(event, context, SUCCESS, physicalResourceId=bucket_name)\n\n        elif request_type == UPDATE:\n            # We are making an assumption that Update event will never cause creation of another bucket.\n            # Bucket name is dynamically constructed using AccountId and QSConfigId\n            put_bucket_policy(bucket_name, resource_properties)\n            place_baselines_into_bucket(\n                bucket_name, get_patch_baselines(patch_baseline_ids, request_type))\n            send(event, context, SUCCESS, physicalResourceId=bucket_name)\n\n        elif request_type == DELETE:\n            empty_and_delete_bucket(bucket_name)\n            send(event, context, SUCCESS, physicalResourceId=bucket_name)\n\n        elif request_type == REMEDIATE:\n            print('Starting remediation... \\n')\n            place_baselines_into_bucket(\n                bucket_name, get_patch_baselines(patch_baseline_ids, request_type))\n            print('Remediation completed \\n')\n\n        else:\n            print('Unexpected request type received:', request_type)\n            raise ValueError(\n                'A valid RequestType is Create, Update, Delete, or Remediate')\n\n        return SUCCESS\n    except Exception as err:\n        print(err, '\\n')\n        print('You can review the log for the Lambda function for details \\n')\n        send(event, context, FAILED, reason=str(err), physicalResourceId=bucket_name)\n        raise err  # To send signal to Automation Document of failure\n"
          },
          "Runtime": "python3.11",
          "Handler": "index.lambda_handler",
          "Environment": {
            "Variables": {
              "REGION": {
                "Ref": "PatchBaselineRegion"
              }
            }
          },
          "MemorySize": 128,
          "Role": {
            "Fn::GetAtt": [
              "BaselineOverridesLambdaRole",
              "Arn"
            ]
          },
          "Timeout": 300
        },
        "Condition": "DeployManagementResources"
      },
      "BaselineOverridesLambdaRole": {
        "Type": "AWS::IAM::Role",
        "Properties": {
          "RoleName": {
            "Fn::Sub": "AWS-QuickSetup-BaselineOverrides-LambdaRole-${QSConfigurationId}"
          },
          "AssumeRolePolicyDocument": {
            "Version": "2012-10-17",
            "Statement": [
              {
                "Effect": "Allow",
                "Principal": {
                  "Service": [
                    "lambda.amazonaws.com"
                  ]
                },
                "Action": [
                  "sts:AssumeRole"
                ]
              }
            ]
          },
          "Policies": [
            {
              "PolicyName": {
                "Fn::Sub": "AWS-QuickSetup-BaselineOverrides-LambdaPolicy-${QSConfigurationId}"
              },
              "PolicyDocument": {
                "Version": "2012-10-17",
                "Statement": [
                  {
                    "Sid": "AllowS3Actions",
                    "Effect": "Allow",
                    "Action": [
                      "s3:CreateBucket",
                      "s3:PutBucketVersioning",
                      "s3:PutBucketOwnershipControls",
                      "s3:PutBucketPublicAccessBlock",
                      "s3:PutEncryptionConfiguration",
                      "s3:GetObject",
                      "s3:PutBucketPolicy",
                      "s3:GetObjectVersion",
                      "s3:PutObject",
                      "s3:DeleteObject",
                      "s3:ListBucketVersions",
                      "s3:DeleteObjectVersion",
                      "s3:DeleteBucket",
                      "s3:PutLifecycleConfiguration",
                      "s3:ListBucket",
                      "s3:PutBucketLogging"
                    ],
                    "Resource": [
                      {
                        "Fn::Sub": "arn:${AWS::Partition}:s3:::aws-quicksetup-patchpolicy-${QSOwnerAccountId}-${QSConfigurationId}/*"
                      },
                      {
                        "Fn::Sub": "arn:${AWS::Partition}:s3:::aws-quicksetup-patchpolicy-${QSOwnerAccountId}-${QSConfigurationId}"
                      }
                    ]
                  },
                  {
                    "Sid": "AllowLogging",
                    "Effect": "Allow",
                    "Action": [
                      "logs:CreateLogStream",
                      "logs:PutLogEvents",
                      "logs:CreateLogGroup"
                    ],
                    "Resource": [
                      {
                        "Fn::Join": [
                          "",
                          [
                            {
                              "Fn::Sub": "arn:${AWS::Partition}:logs:${AWS::Region}:${QSOwnerAccountId}:log-group:/aws/lambda/baseline-overrides-"
                            },
                            {
                              "Fn::Select": [
                                3,
                                {
                                  "Fn::Split": [
                                    "-",
                                    {
                                      "Fn::Select": [
                                        2,
                                        {
                                          "Fn::Split": [
                                            "/",
                                            {
                                              "Ref": "AWS::StackId"
                                            }
                                          ]
                                        }
                                      ]
                                    }
                                  ]
                                }
                              ]
                            },
                            "-",
                            {
                              "Ref": "QSConfigurationId"
                            },
                            ":*"
                          ]
                        ]
                      }
                    ]
                  },
                  {
                    "Sid": "AllowSSMActions",
                    "Action": [
                      "ssm:GetPatchBaseline"
                    ],
                    "Effect": "Allow",
                    "Resource": "*"
                  }
                ]
              }
            }
          ],
          "PermissionsBoundary": {
            "Fn::If": [
              "ShouldAttachConfigurationPolicy",
              {
                "Fn::Sub": "arn:${AWS::Partition}:iam::aws:policy/AWSQuickSetupPatchPolicyPermissionsBoundary"
              },
              {
                "Ref": "AWS::NoValue"
              }
            ]
          }
        },
        "Condition": "DeployManagementResources"
      },
      "BaselineOverridesLambdaTrigger": {
        "Type": "Custom::S3Object",
        "Properties": {
          "ServiceToken": {
            "Fn::GetAtt": [
              "BaselineOverridesLambdaFunction",
              "Arn"
            ]
          },
          "AccountId": {
            "Ref": "QSOwnerAccountId"
          },
          "QSConfigId": {
            "Ref": "QSConfigurationId"
          },
          "BucketName": {
            "Fn::Sub": "aws-quicksetup-patchpolicy-${QSOwnerAccountId}-${QSConfigurationId}"
          },
          "AccessLogBucketName": {
            "Ref": "BaselineOverridesAccessLogBucket"
          },
          "Partition": {
            "Ref": "AWS::Partition"
          },
          "TargetEntities": {
            "Ref": "QSType"
          },
          "OrgUnits": {
            "Ref": "QSTargetOrganizationalUnits"
          },
          "PrincipalOrgId": {
            "Ref": "QSPrincipalOrgId"
          },
          "PatchBaselines": {
            "Ref": "SelectedPatchBaselines"
          }
        },
        "Condition": "DeployManagementResources"
      },
      "BaselineOverridesStateManagerAssociation": {
        "Type": "AWS::SSM::Association",
        "Properties": {
          "AssociationName": {
            "Fn::Sub": "AWS-QuickSetup-PatchPolicy-BaselineRemediation-${QSConfigurationId}"
          },
          "Name": {
            "Ref": "BaselineOverridesRemediationDocument"
          },
          "ApplyOnlyAtCronInterval": true,
          "ScheduleExpression": "cron(0 0/1 * * ? *)"
        },
        "Condition": "DeployManagementResources"
      },
      "BaselineOverridesRemediationDocument": {
        "Type": "AWS::SSM::Document",
        "Properties": {
          "Name": {
            "Fn::Sub": "AWSQuickSetup-PatchPolicy-Remediation-${QSConfigurationId}"
          },
          "DocumentType": "Automation",
          "UpdateMethod": "NewVersion",
          "Content": {
            "description": "This Document is to trigger the Lambda function to perform remediation only.",
            "schemaVersion": "0.3",
            "assumeRole": "{{ AutomationAssumeRole }}",
            "parameters": {
              "AutomationAssumeRole": {
                "type": "String",
                "default": {
                  "Fn::GetAtt": [
                    "BaselineOverridesRemediationAutomationRole",
                    "Arn"
                  ]
                }
              },
              "LambdaFunctionArn": {
                "type": "String",
                "default": {
                  "Fn::GetAtt": [
                    "BaselineOverridesLambdaFunction",
                    "Arn"
                  ]
                }
              },
              "BucketName": {
                "type": "String",
                "default": {
                  "Fn::Sub": "aws-quicksetup-patchpolicy-${QSOwnerAccountId}-${QSConfigurationId}"
                }
              },
              "PatchBaselines": {
                "type": "String",
                "default": {
                  "Ref": "SelectedPatchBaselines"
                }
              }
            },
            "mainSteps": [
              {
                "name": "invokeBaselineOverridesLambdaFunction",
                "action": "aws:invokeLambdaFunction",
                "maxAttempts": 3,
                "timeoutSeconds": 300,
                "inputs": {
                  "FunctionName": "{{ LambdaFunctionArn }}",
                  "InputPayload": {
                    "RequestType": "Remediate",
                    "ResourceProperties": {
                      "BucketName": "{{ BucketName }}",
                      "PatchBaselines": "{{ PatchBaselines }}"
                    }
                  }
                }
              }
            ]
          }
        },
        "Condition": "DeployManagementResources"
      },
      "BaselineOverridesRemediationAutomationRole": {
        "Type": "AWS::IAM::Role",
        "Properties": {
          "RoleName": {
            "Fn::Sub": "AWS-QuickSetup-Remediation-AutomationRole-${QSConfigurationId}"
          },
          "AssumeRolePolicyDocument": {
            "Version": "2012-10-17",
            "Statement": [
              {
                "Effect": "Allow",
                "Principal": {
                  "Service": [
                    "ssm.amazonaws.com"
                  ]
                },
                "Action": [
                  "sts:AssumeRole"
                ]
              }
            ]
          },
          "Policies": [
            {
              "PolicyName": {
                "Fn::Sub": "AWS-QuickSetup-Remediation-AutomationPolicy-${QSConfigurationId}"
              },
              "PolicyDocument": {
                "Version": "2012-10-17",
                "Statement": [
                  {
                    "Effect": "Allow",
                    "Action": [
                      "lambda:InvokeFunction"
                    ],
                    "Resource": {
                      "Fn::GetAtt": [
                        "BaselineOverridesLambdaFunction",
                        "Arn"
                      ]
                    }
                  }
                ]
              }
            }
          ],
          "PermissionsBoundary": {
            "Fn::If": [
              "ShouldAttachConfigurationPolicy",
              {
                "Fn::Sub": "arn:${AWS::Partition}:iam::aws:policy/AWSQuickSetupPatchPolicyPermissionsBoundary"
              },
              {
                "Ref": "AWS::NoValue"
              }
            ]
          }
        },
        "Condition": "DeployManagementResources"
      },
      "RoleForAutomation": {
        "Type": "AWS::IAM::Role",
        "Properties": {
          "AssumeRolePolicyDocument": {
            "Version": "2012-10-17",
            "Statement": [
              {
                "Effect": "Allow",
                "Principal": {
                  "Service": [
                    "ssm.amazonaws.com"
                  ]
                },
                "Action": [
                  "sts:AssumeRole"
                ]
              }
            ]
          },
          "PermissionsBoundary": {
            "Fn::If": [
              "ShouldAttachConfigurationPolicy",
              {
                "Fn::Sub": "arn:${AWS::Partition}:iam::aws:policy/AWSQuickSetupPatchPolicyPermissionsBoundary"
              },
              {
                "Ref": "AWS::NoValue"
              }
            ]
          },
          "Policies": [
            {
              "PolicyDocument": {
                "Version": "2012-10-17",
                "Statement": [
                  {
                    "Effect": "Deny",
                    "Action": [
                      "iam:TagRole",
                      "iam:AttachRolePolicy"
                    ],
                    "Resource": {
                      "Fn::Sub": "arn:${AWS::Partition}:iam::${AWS::AccountId}:role/AWS-QuickSetup-AutomationRole-*"
                    }
                  },
                  {
                    "Effect": "Allow",
                    "Action": [
                      "iam:AttachRolePolicy"
                    ],
                    "Resource": [
                      {
                        "Fn::If": [
                          "PolicyAttachAllowed",
                          "*",
                          {
                            "Fn::Sub": "arn:${AWS::Partition}:iam::${AWS::AccountId}:role/AmazonSSMRoleForInstancesQuickSetup"
                          }
                        ]
                      }
                    ],
                    "Condition": {
                      "ArnEquals": {
                        "iam:PolicyARN": [
                          {
                            "Fn::Sub": "arn:${AWS::Partition}:iam::aws:policy/AmazonSSMManagedInstanceCore"
                          },
                          {
                            "Fn::Sub": "arn:${AWS::Partition}:iam::aws:policy/AWSQuickSetupPatchPolicyBaselineAccess"
                          }
                        ]
                      }
                    }
                  },
                  {
                    "Effect": "Allow",
                    "Action": [
                      "iam:PassRole"
                    ],
                    "Resource": {
                      "Fn::Sub": "arn:${AWS::Partition}:iam::${AWS::AccountId}:role/AmazonSSMRoleForInstancesQuickSetup"
                    },
                    "Condition": {
                      "StringEquals": {
                        "iam:PassedToService": [
                          "ec2.amazonaws.com"
                        ]
                      }
                    }
                  },
                  {
                    "Effect": "Allow",
                    "Action": [
                      "iam:PassRole"
                    ],
                    "Resource": {
                      "Fn::Sub": "arn:${AWS::Partition}:iam::${AWS::AccountId}:role/AmazonSSMRoleForInstancesQuickSetup"
                    },
                    "Condition": {
                      "StringEquals": {
                        "iam:PassedToService": [
                          "ssm.amazonaws.com"
                        ]
                      }
                    }
                  },
                  {
                    "Effect": "Allow",
                    "Action": [
                      "ec2:AssociateIamInstanceProfile"
                    ],
                    "Resource": "*",
                    "Condition": {
                      "StringEquals": {
                        "ec2:NewInstanceProfile": {
                          "Fn::Sub": "arn:${AWS::Partition}:iam::${AWS::AccountId}:instance-profile/AmazonSSMRoleForInstancesQuickSetup"
                        }
                      }
                    }
                  },
                  {
                    "Effect": "Allow",
                    "Action": [
                      "iam:AddRoleToInstanceProfile"
                    ],
                    "Resource": {
                      "Fn::Sub": "arn:${AWS::Partition}:iam::${AWS::AccountId}:instance-profile/AmazonSSMRoleForInstancesQuickSetup"
                    }
                  },
                  {
                    "Effect": "Allow",
                    "Action": [
                      "iam:CreateRole",
                      "iam:GetRole"
                    ],
                    "Resource": {
                      "Fn::Sub": "arn:${AWS::Partition}:iam::${AWS::AccountId}:role/AmazonSSMRoleForInstancesQuickSetup"
                    }
                  },
                  {
                    "Effect": "Allow",
                    "Action": [
                      "iam:CreateInstanceProfile"
                    ],
                    "Resource": {
                      "Fn::Sub": "arn:${AWS::Partition}:iam::${AWS::AccountId}:instance-profile/AmazonSSMRoleForInstancesQuickSetup"
                    }
                  },
                  {
                    "Effect": "Allow",
                    "Action": [
                      "ec2:DescribeIamInstanceProfileAssociations",
                      "ec2:DescribeInstances",
                      "iam:GetInstanceProfile",
                      "iam:ListInstanceProfilesForRole",
                      "iam:TagRole",
                      "ssm:DescribeInstanceInformation",
                      "ssm:UpdateManagedInstanceRole",
                      "ssm:GetAutomationExecution",
                      "ssm:StartAutomationExecution"
                    ],
                    "Resource": "*"
                  },
                  {
                    "Effect": "Allow",
                    "Action": [
                      "iam:PassRole"
                    ],
                    "Resource": {
                      "Fn::Sub": "arn:${AWS::Partition}:iam::${AWS::AccountId}:role/AWS-QuickSetup-AutomationRole-${AWS::Region}-${QSConfigurationId}"
                    },
                    "Condition": {
                      "StringEquals": {
                        "iam:PassedToService": [
                          "ssm.amazonaws.com"
                        ]
                      }
                    }
                  }
                ]
              },
              "PolicyName": {
                "Fn::Sub": "AWS-QuickSetup-AutomationPolicy-IAM-${AWS::Region}-${QSConfigurationId}"
              }
            },
            {
              "PolicyDocument": {
                "Version": "2012-10-17",
                "Statement": [
                  {
                    "Effect": "Allow",
                    "Action": [
                      "ssm:RemoveTagsFromResource",
                      "ssm:GetInventory",
                      "ssm:AddTagsToResource"
                    ],
                    "Resource": "*"
                  }
                ]
              },
              "PolicyName": {
                "Fn::Sub": "AWS-QuickSetup-AutomationPolicy-NameTagRemediation-${AWS::Region}-${QSConfigurationId}"
              }
            },
            {
              "PolicyDocument": {
                "Version": "2012-10-17",
                "Statement": [
                  {
                    "Effect": "Allow",
                    "Action": [
                      "ec2:CreateTags",
                      "ec2:DeleteTags"
                    ],
                    "Resource": "*",
                    "Condition": {
                      "ForAllValues:StringEquals": {
                        "aws:TagKeys": {
                          "Fn::Sub": "QSConfigName-${QSConfigurationId}"
                        }
                      }
                    }
                  }
                ]
              },
              "PolicyName": {
                "Fn::Sub": "AWS-QuickSetup-AutomationPolicy-AddRemoveNameTag-${AWS::Region}-${QSConfigurationId}"
              }
            }
          ],
          "RoleName": {
            "Fn::Sub": "AWS-QuickSetup-AutomationRole-${AWS::Region}-${QSConfigurationId}"
          }
        },
        "DependsOn": [
          "CreateAndAttachIAMToEc2InstanceDocument",
          "AddRemoveNameTagAutomationDocument",
          "NameTagRemediationDocument"
        ]
      },
      "EnableExplorerRoleForPatchPolicy": {
        "Type": "AWS::IAM::Role",
        "Properties": {
          "AssumeRolePolicyDocument": {
            "Version": "2012-10-17",
            "Statement": [
              {
                "Effect": "Allow",
                "Principal": {
                  "Service": [
                    "ssm.amazonaws.com"
                  ]
                },
                "Action": [
                  "sts:AssumeRole"
                ]
              }
            ]
          },
          "Policies": [
            {
              "PolicyDocument": {
                "Version": "2012-10-17",
                "Statement": [
                  {
                    "Effect": "Allow",
                    "Action": [
                      "iam:ListRoles",
                      "config:DescribeConfigurationRecorders",
                      "compute-optimizer:GetEnrollmentStatus",
                      "support:DescribeTrustedAdvisorChecks"
                    ],
                    "Resource": "*"
                  },
                  {
                    "Effect": "Allow",
                    "Action": [
                      "ssm:UpdateServiceSetting",
                      "ssm:GetServiceSetting"
                    ],
                    "Resource": [
                      {
                        "Fn::Sub": "arn:${AWS::Partition}:ssm:*:*:servicesetting/ssm/opsitem/ssm-patchmanager"
                      },
                      {
                        "Fn::Sub": "arn:${AWS::Partition}:ssm:*:*:servicesetting/ssm/opsitem/EC2"
                      },
                      {
                        "Fn::Sub": "arn:${AWS::Partition}:ssm:*:*:servicesetting/ssm/opsdata/ExplorerOnboarded"
                      },
                      {
                        "Fn::Sub": "arn:${AWS::Partition}:ssm:*:*:servicesetting/ssm/opsdata/Association"
                      },
                      {
                        "Fn::Sub": "arn:${AWS::Partition}:ssm:*:*:servicesetting/ssm/opsdata/ComputeOptimizer"
                      },
                      {
                        "Fn::Sub": "arn:${AWS::Partition}:ssm:*:*:servicesetting/ssm/opsdata/ConfigCompliance"
                      },
                      {
                        "Fn::Sub": "arn:${AWS::Partition}:ssm:*:*:servicesetting/ssm/opsdata/OpsData-TrustedAdvisor"
                      },
                      {
                        "Fn::Sub": "arn:${AWS::Partition}:ssm:*:*:servicesetting/ssm/opsdata/SupportCenterCase"
                      }
                    ]
                  },
                  {
                    "Effect": "Allow",
                    "Action": [
                      "iam:CreateServiceLinkedRole"
                    ],
                    "Resource": {
                      "Fn::Sub": "arn:${AWS::Partition}:iam::*:role/aws-service-role/ssm.${AWS::URLSuffix}/AWSServiceRoleForAmazonSSM"
                    },
                    "Condition": {
                      "StringEquals": {
                        "iam:AWSServiceName": "ssm.amazonaws.com"
                      }
                    }
                  }
                ]
              },
              "PolicyName": "SSMQuickSetupEnableExplorerInlinePolicy"
            }
          ],
          "PermissionsBoundary": {
            "Fn::If": [
              "ShouldAttachConfigurationPolicy",
              {
                "Fn::Sub": "arn:${AWS::Partition}:iam::aws:policy/AWSQuickSetupPatchPolicyPermissionsBoundary"
              },
              {
                "Ref": "AWS::NoValue"
              }
            ]
          },
          "RoleName": {
            "Fn::Sub": "AWS-QuickSetup-EnableExplorer-${AWS::Region}-${QSConfigurationId}"
          }
        }
      },
      "QuickSetupEnableExplorerAssociation": {
        "Type": "AWS::SSM::Association",
        "Properties": {
          "Name": "AWS-EnableExplorer",
          "AssociationName": {
            "Fn::Sub": "AWS-QuickSetup-PatchPolicy-EnableExplorer-${QSConfigurationId}"
          },
          "Parameters": {
            "AutomationAssumeRole": [
              {
                "Fn::GetAtt": [
                  "EnableExplorerRoleForPatchPolicy",
                  "Arn"
                ]
              }
            ]
          }
        }
      },
      "NameTagDeleteLambda": {
        "Type": "AWS::Lambda::Function",
        "Properties": {
          "Code": {
            "ZipFile": "# Copyright 2022 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n\n# This handler responds to a Cloud Formation Stack 'DELETE' notification. \n# It is responsible for detaching all name tags from target nodes, including\n# nodes that are no longer a target of the Quick Setup Configuration but for which\n# drift has not yet been remediated.\nfrom asyncore import poll\nfrom botocore.exceptions import ClientError\nimport boto3\nimport json\nfrom urllib.request import build_opener, HTTPHandler, Request\nimport os\nimport time\n\n# ENVIRONMENT VARIABLES\nregion = os.environ['REGION']\n\n# CONSTANTS\nMINUTES_FOR_POLLING_COMPLETION = 600 # 10 hrs max.\nASSOCIATION_NON_TERMINAL_STATUSES = [\"Pending\", \"InProgress\"]\nDESCRIBE_ASSOCIATION_KEYS = [\"AssociationId\",\"Parameters\",\"DocumentVersion\",\"ScheduleExpression\",\\\n    \"OutputLocation\",\"Name\",\"Targets\",\"AssociationName\",\"AssociationVersion\",\"AutomationTargetParameterName\",\\\n    \"MaxErrors\",\"MaxConcurrency\",\"ComplianceSeverity\",\"SyncCompliance\",\"ApplyOnlyAtCronInterval\",\"CalendarNames\",\\\n    \"TargetLocations\"]\n\n# CLIENTS\nclient = boto3.client('ssm', region_name= region)  \n\ndef build_request(event,status, message):\n    try:\n        stack_id = check_for_key(event, 'StackId')\n        request_id = check_for_key(event, 'RequestId')\n        logical_resource_id = check_for_key(event, 'LogicalResourceId')\n\n        body = json.dumps({        \n            'Status': status,        \n            'Reason': message,        \n            'StackId': stack_id,\n            'RequestId': request_id,\n            'LogicalResourceId': logical_resource_id,\n            'PhysicalResourceId': 'associationId'})\n     \n        request = Request(check_for_key(event, 'ResponseURL'), data=body.encode('utf-8'))\n        request.add_header('Content-Type', '')\n        request.add_header('Content-Length', len(body.encode('utf-8')))\n        request.get_method = lambda: 'PUT'\n        return request\n    except Exception as ex:\n        raise Exception(\"An Exception occurred while building a response for Cloud Formation. %s\"%(str(ex)))\n\ndef poll_for_association_completion(event, association_ids):\n    for id in association_ids:\n        counter = 0\n        while True:\n            print(\"Polling for Association completion: %s\"%(id))\n            response = client.describe_association_executions(AssociationId=id)\n            print(\"DescribeAssociationExecution result: %s\"%(str(response)))\n            ## check status, exit if good\n            executions = response[\"AssociationExecutions\"]\n            if (len(executions) < 1):\n                msg = \"Association %s has never been executed. Something went wrong. \"%(id)\n                send_response(event, \"FAILED\", msg)\n                return False\n            else:\n                status = executions[0][\"Status\"]\n                print(\"Found status of %s for latest execution of %s\"%(status, id))\n                # Association Execution History is always reported in descending order. \n                if (status in ASSOCIATION_NON_TERMINAL_STATUSES):\n                    print(\"Association %s is %s . Waiting 5 seconds. \"%(id, executions[0][\"Status\"]))\n                    time.sleep(5)\n                    counter +=1\n\n                    if counter == MINUTES_FOR_POLLING_COMPLETION:\n                        msg = \"Association has not finished in the required time. Exiting.\"\n                        send_response(event, \"FAILED\", msg)\n                        return False\n                else:\n                    # if the status is not success, fail the Lambda. \n                    if (status.lower() != \"success\"):\n                        msg = \"Association %s returned a non-success status of %s.\"%(id, status)\n                        send_response(event, \"FAILED\", msg)\n                        return False\n                    else:\n                        print(\"Association %s completed successfully.\"%(id))\n                        return True\n\ndef build_opener_and_open(request):\n    opener = build_opener(HTTPHandler)\n    response = opener.open(request) \n    return response\n\ndef send_response(event, status, message, count = 0):\n    try:\n        request = build_request(event, status, message)\n        response = build_opener_and_open(request)\n        # This snippet is the reason behind not using the cfnresponse python module\n        # found here: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/cfn-lambda-function-code-cfnresponsemodule.html\n        # The cfnresponse python module simply print's an http status code error and succeeds. \n        # The desired behavior is for the Lambda to fail if the response code is not 200.\n        # technically, this response status should be a string but the urllib library doesn't say\n        # if it is translated to a string or not.\n        if str(response.status) != \"200\":\n            raise Exception(\"Received a failed response from Cloud Formation: %s\"%(str(response.status)))\n    except Exception as ex:\n        print(\"An Exception occured while sending a response to Cloud Formation. \")\n        if count < 3:\n            count +=1\n            send_response(event, status, message, count)\n        else:\n            raise Exception(\"Retries failed. Failing Lambda execution.\")\n\n\ndef check_for_key(hash, key):\n    if not key in hash:\n        raise Exception(\"The required key %s is not present in %s. Failing.\"%(key, str(hash)))\n    else:\n        # return the value\n        return hash[key]\n\ndef update_association(event, association_id):\n\n    print(\"Describing association %s for update command.\"%(association_id))\n    response = client.describe_association(AssociationId=association_id)\n    print(response)\n\n    association = response['AssociationDescription']\n    print(\"Using Association Overview %s: \"%(str(association)))\n    print(\"Stripping described association of keys that cannot be used in update command.\")\n    keys_to_pop = []\n    [keys_to_pop.append(key) if key not in DESCRIBE_ASSOCIATION_KEYS else print(key) for key in association]\n    [association.pop(key) for key in keys_to_pop]\n\n    # Postfix name with -delete for easy identification. \n    if not association[\"AssociationName\"].endswith(\"-DELETE\"):\n        association[\"AssociationName\"] = association[\"AssociationName\"] + \"-DELETE\"\n\n    # TAG DOCUMENT\n    if \"TagAction\" in association[\"Parameters\"]:\n        association[\"AutomationTargetParameterName\"] = \"InstanceId\"\n        association[\"Targets\"] = association[\"Targets\"]\n        association[\"Parameters\"][\"TagAction\"] = [\"Remove\"]\n    else: \n        # REMEDIATION DOCUMENT\n        # Remediation document uses the NoOp Automation target tag which State Manager does not\n        # comprehend as a parameter and only adds if the following parameters are not present.\n        if \"Targets\" in association: \n            association.pop(\"Targets\")\n\n    print(\"Attempting to update association %s\"%(association))\n    response = client.update_association(**association)\n    print(\"UpdateResponse: %s\"%(str(response)))\n\ndef try_update_association(event, association_id, association_ids):\n    \"\"\"\n    Attempts to update an association, handling AssociationDoesNotExist errors gracefully.\n    If successful, adds the association_id to the association_ids list.\n\n    Args:\n        event: CloudFormation event\n        association_id: ID of the association to update\n        association_ids: List to append successful association IDs to\n    \"\"\"\n    try:\n        update_association(event, association_id)\n    except ClientError as e:\n        error_code = e.response.get('Error', {}).get('Code')\n        # catch AssociationDoesNotExist error and ignore it (in case customer deleted it before manually)\n        if error_code != 'AssociationDoesNotExist':\n            raise\n    else:\n        association_ids.append(association_id)\n\ndef handler(event, context):      \n    try:\n        print(\"Received event %s\"%(str(event)))\n    \n        request = None\n        request = check_for_key(event, 'RequestType')\n\n        if (request == None or request.lower() != 'delete'):\n            msg = \"Received a %s request. Tag Detach Machine only handles CF Stack 'Delete' events. Succeeding.\"%(str(request))\n            send_response(event, \"SUCCESS\", msg)\n            return\n\n        resource_properties = check_for_key(event, \"ResourceProperties\")\n\n        tag_association_id =check_for_key(resource_properties, 'TagAssociationId')\n        remediation_association_id = check_for_key(resource_properties, 'RemediationAssociationId')\n        association_ids = []\n\n        # Now update the associations to have the names postfixed with DELETE and trigger a name tag delete.\n        try_update_association(event, tag_association_id, association_ids)\n        try_update_association(event, remediation_association_id, association_ids)\n\n        # Giving Association time to update and trigger new executions.\n        print(\"Sleeping to give Association time to update: %s\"%(time.ctime()))\n        time.sleep(15)\n        print(\"Done sleeping: %s\"%(time.ctime()))\n\n        #Now poll for the associations to finish\n        success = poll_for_association_completion(event, association_ids)\n\n        if success == True:\n            # Once the associations have finished.\n            send_response(event, \"SUCCESS\", \"Association's successfully completed. Exiting Lambda.\")\n        else:\n            msg = \"Name tags failed to delete. Retaining resources so customer can trigger a delete after the fact.\"\n            send_response(event, \"FAILED\", \"%s:\"%(msg))\n\n    except Exception as e:\n        send_response(event, \"FAILED\", \"%s:\"%(str(e)))\n        raise(e)\n"
          },
          "Timeout": 900,
          "Description": "Lambda for handling CF 'Delete' events to remove the name tags from resources.",
          "Runtime": "python3.11",
          "Role": {
            "Fn::GetAtt": [
              "RoleForLambdaNameTagDelete",
              "Arn"
            ]
          },
          "FunctionName": {
            "Fn::Join": [
              "-",
              [
                {
                  "Fn::Sub": "delete-name-tags-${AWS::Region}"
                },
                {
                  "Fn::Select": [
                    3,
                    {
                      "Fn::Split": [
                        "-",
                        {
                          "Fn::Select": [
                            2,
                            {
                              "Fn::Split": [
                                "/",
                                {
                                  "Ref": "AWS::StackId"
                                }
                              ]
                            }
                          ]
                        }
                      ]
                    }
                  ]
                },
                {
                  "Ref": "QSConfigurationId"
                }
              ]
            ]
          },
          "Handler": "index.handler",
          "Environment": {
            "Variables": {
              "REGION": {
                "Ref": "AWS::Region"
              }
            }
          }
        },
        "DependsOn": [
          "RoleForLambdaNameTagDelete"
        ]
      },
      "RoleForLambdaNameTagDelete": {
        "Type": "AWS::IAM::Role",
        "Properties": {
          "AssumeRolePolicyDocument": {
            "Version": "2012-10-17",
            "Statement": [
              {
                "Effect": "Allow",
                "Principal": {
                  "Service": [
                    "lambda.amazonaws.com"
                  ]
                },
                "Action": [
                  "sts:AssumeRole"
                ]
              }
            ]
          },
          "Policies": [
            {
              "PolicyDocument": {
                "Version": "2012-10-17",
                "Statement": [
                  {
                    "Effect": "Allow",
                    "Action": [
                      "ssm:DescribeAssociationExecutions",
                      "ssm:UpdateAssociation",
                      "ssm:DescribeAssociation"
                    ],
                    "Resource": [
                      "*"
                    ]
                  }
                ]
              },
              "PolicyName": {
                "Fn::Sub": "AWS-QuickSetup-LambdaPolicy-NameTagDelete-${AWS::Region}-${QSConfigurationId}"
              }
            },
            {
              "PolicyDocument": {
                "Version": "2012-10-17",
                "Statement": [
                  {
                    "Effect": "Allow",
                    "Action": [
                      "iam:PassRole"
                    ],
                    "Resource": [
                      {
                        "Fn::Sub": "arn:${AWS::Partition}:iam::${AWS::AccountId}:role/AWS-QuickSetup-AutomationRole-${AWS::Region}-${QSConfigurationId}"
                      }
                    ]
                  }
                ]
              },
              "PolicyName": {
                "Fn::Sub": "AWS-QuickSetup-LambdaPolicy-PassRole-${AWS::Region}-${QSConfigurationId}"
              }
            }
          ],
          "ManagedPolicyArns": [
            {
              "Fn::Sub": "arn:${AWS::Partition}:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole"
            }
          ],
          "PermissionsBoundary": {
            "Fn::If": [
              "ShouldAttachConfigurationPolicy",
              {
                "Fn::Sub": "arn:${AWS::Partition}:iam::aws:policy/AWSQuickSetupPatchPolicyPermissionsBoundary"
              },
              {
                "Ref": "AWS::NoValue"
              }
            ]
          },
          "RoleName": {
            "Fn::Sub": "AWS-QuickSetup-PatchPolicy-RoleForLambda-NT-${AWS::Region}-${QSConfigurationId}"
          }
        }
      },
      "NameTagDeleteMachine": {
        "Type": "Custom::NameTagDeleteMachine",
        "Version": "1.0",
        "Properties": {
          "ServiceToken": {
            "Fn::GetAtt": [
              "NameTagDeleteLambda",
              "Arn"
            ]
          },
          "AutomationAssumeRole": {
            "Fn::GetAtt": [
              "RoleForAutomation",
              "Arn"
            ]
          },
          "RemediationAssociationId": {
            "Fn::GetAtt": "SystemAssociationForNameTagRemediation.AssociationId"
          },
          "TagAssociationId": {
            "Fn::GetAtt": "SystemAssociationForAddRemoveNameTag.AssociationId"
          }
        },
        "DependsOn": [
          "RoleForAutomation",
          "NameTagDeleteLambda",
          "RoleForLambdaNameTagDelete",
          "SystemAssociationForAddRemoveNameTag",
          "SystemAssociationForNameTagRemediation"
        ]
      },
      "SystemAssociationForScanningPatches": {
        "Type": "AWS::SSM::Association",
        "Properties": {
          "Name": "AWS-RunPatchBaseline",
          "AssociationName": {
            "Fn::Sub": "AWS-QuickSetup-PatchPolicy-ScanForPatches-${QSConfigurationId}"
          },
          "Parameters": {
            "Operation": [
              "Scan"
            ],
            "BaselineOverride": [
              {
                "Fn::Sub": "s3://aws-quicksetup-patchpolicy-${QSOwnerAccountId}-${QSConfigurationId}/baseline_overrides.json"
              }
            ],
            "RebootOption": [
              {
                "Ref": "RebootOption"
              }
            ]
          },
          "ScheduleExpression": {
            "Ref": "ConfigurationOptionsScanValue"
          },
          "ApplyOnlyAtCronInterval": {
            "Ref": "ConfigurationOptionsScanNextInterval"
          },
          "SyncCompliance": "MANUAL",
          "Targets": {
            "Fn::If": [
              "IsTagKeyAndValueTargeted",
              [
                {
                  "Key": {
                    "Fn::Sub": "tag:${TargetTagKey}"
                  },
                  "Values": [
                    {
                      "Ref": "TargetTagValue"
                    }
                  ]
                }
              ],
              {
                "Fn::If": [
                  "IsTagKeyOnlyTargeted",
                  [
                    {
                      "Key": "tag-key",
                      "Values": [
                        {
                          "Ref": "TargetTagKey"
                        }
                      ]
                    }
                  ],
                  {
                    "Fn::If": [
                      "IsResourceGroupTargeted",
                      [
                        {
                          "Key": "resource-groups:Name",
                          "Values": [
                            {
                              "Ref": "ResourceGroupName"
                            }
                          ]
                        }
                      ],
                      {
                        "Fn::If": [
                          "TargetAll",
                          [
                            {
                              "Key": "InstanceIds",
                              "Values": [
                                "*"
                              ]
                            }
                          ],
                          [
                            {
                              "Key": "InstanceIds",
                              "Values": {
                                "Fn::Split": [
                                  ",",
                                  {
                                    "Ref": "TargetInstances"
                                  }
                                ]
                              }
                            }
                          ]
                        ]
                      }
                    ]
                  }
                ]
              }
            ]
          },
          "MaxConcurrency": {
            "Ref": "RateControlConcurrency"
          },
          "MaxErrors": {
            "Ref": "RateControlErrorThreshold"
          },
          "OutputLocation": {
            "Fn::If": [
              "EnabledOutputBucketWithPrefix",
              {
                "S3Location": {
                  "OutputS3BucketName": {
                    "Ref": "OutputS3BucketName"
                  },
                  "OutputS3KeyPrefix": {
                    "Ref": "OutputS3KeyPrefix"
                  },
                  "OutputS3Region": {
                    "Ref": "OutputBucketRegion"
                  }
                }
              },
              {
                "Fn::If": [
                  "EnabledOutputBucketWithoutPrefix",
                  {
                    "S3Location": {
                      "OutputS3BucketName": {
                        "Ref": "OutputS3BucketName"
                      },
                      "OutputS3Region": {
                        "Ref": "OutputBucketRegion"
                      }
                    }
                  },
                  {
                    "Ref": "AWS::NoValue"
                  }
                ]
              }
            ]
          }
        }
      },
      "SystemAssociationForInstallingPatches": {
        "Type": "AWS::SSM::Association",
        "Properties": {
          "Name": "AWS-RunPatchBaseline",
          "AssociationName": {
            "Fn::Sub": "AWS-QuickSetup-PatchPolicy-InstallPatches-${QSConfigurationId}"
          },
          "Parameters": {
            "Operation": [
              "Install"
            ],
            "BaselineOverride": [
              {
                "Fn::Sub": "s3://aws-quicksetup-patchpolicy-${QSOwnerAccountId}-${QSConfigurationId}/baseline_overrides.json"
              }
            ],
            "RebootOption": [
              {
                "Ref": "RebootOption"
              }
            ]
          },
          "ApplyOnlyAtCronInterval": {
            "Ref": "ConfigurationOptionsInstallNextInterval"
          },
          "ScheduleExpression": {
            "Ref": "ConfigurationOptionsInstallValue"
          },
          "SyncCompliance": "MANUAL",
          "Targets": {
            "Fn::If": [
              "IsTagKeyAndValueTargeted",
              [
                {
                  "Key": {
                    "Fn::Sub": "tag:${TargetTagKey}"
                  },
                  "Values": [
                    {
                      "Ref": "TargetTagValue"
                    }
                  ]
                }
              ],
              {
                "Fn::If": [
                  "IsTagKeyOnlyTargeted",
                  [
                    {
                      "Key": "tag-key",
                      "Values": [
                        {
                          "Ref": "TargetTagKey"
                        }
                      ]
                    }
                  ],
                  {
                    "Fn::If": [
                      "IsResourceGroupTargeted",
                      [
                        {
                          "Key": "resource-groups:Name",
                          "Values": [
                            {
                              "Ref": "ResourceGroupName"
                            }
                          ]
                        }
                      ],
                      {
                        "Fn::If": [
                          "TargetAll",
                          [
                            {
                              "Key": "InstanceIds",
                              "Values": [
                                "*"
                              ]
                            }
                          ],
                          [
                            {
                              "Key": "InstanceIds",
                              "Values": {
                                "Fn::Split": [
                                  ",",
                                  {
                                    "Ref": "TargetInstances"
                                  }
                                ]
                              }
                            }
                          ]
                        ]
                      }
                    ]
                  }
                ]
              }
            ]
          },
          "MaxConcurrency": {
            "Ref": "RateControlConcurrency"
          },
          "MaxErrors": {
            "Ref": "RateControlErrorThreshold"
          },
          "OutputLocation": {
            "Fn::If": [
              "EnabledOutputBucketWithPrefix",
              {
                "S3Location": {
                  "OutputS3BucketName": {
                    "Ref": "OutputS3BucketName"
                  },
                  "OutputS3KeyPrefix": {
                    "Ref": "OutputS3KeyPrefix"
                  },
                  "OutputS3Region": {
                    "Ref": "OutputBucketRegion"
                  }
                }
              },
              {
                "Fn::If": [
                  "EnabledOutputBucketWithoutPrefix",
                  {
                    "S3Location": {
                      "OutputS3BucketName": {
                        "Ref": "OutputS3BucketName"
                      },
                      "OutputS3Region": {
                        "Ref": "OutputBucketRegion"
                      }
                    }
                  },
                  {
                    "Ref": "AWS::NoValue"
                  }
                ]
              }
            ]
          }
        },
        "Condition": "CreateInstallInstancesAssociation"
      },
      "SystemAssociationForEc2IamManagement": {
        "Type": "AWS::SSM::Association",
        "Properties": {
          "ScheduleExpression": "rate(30 days)",
          "Name": {
            "Ref": "CreateAndAttachIAMToEc2InstanceDocument"
          },
          "AssociationName": {
            "Fn::Sub": "AWS-QuickSetup-PatchPolicy-AttachIAMToEc2Instance-${QSConfigurationId}"
          },
          "Parameters": {
            "AutomationAssumeRole": [
              {
                "Fn::GetAtt": [
                  "RoleForAutomation",
                  "Arn"
                ]
              }
            ],
            "IsPolicyAttachAllowed": [
              {
                "Ref": "IsPolicyAttachAllowed"
              }
            ],
            "QSConfigurationId": [
              {
                "Ref": "QSConfigurationId"
              }
            ],
            "AwsAccountId": [
              {
                "Ref": "AWS::AccountId"
              }
            ]
          },
          "AutomationTargetParameterName": "InstanceId",
          "Targets": {
            "Fn::If": [
              "IsTagKeyAndValueTargeted",
              [
                {
                  "Key": {
                    "Fn::Sub": "tag:${TargetTagKey}"
                  },
                  "Values": [
                    {
                      "Ref": "TargetTagValue"
                    }
                  ]
                }
              ],
              {
                "Fn::If": [
                  "IsTagKeyOnlyTargeted",
                  [
                    {
                      "Key": "tag-key",
                      "Values": [
                        {
                          "Ref": "TargetTagKey"
                        }
                      ]
                    }
                  ],
                  {
                    "Fn::If": [
                      "IsResourceGroupTargeted",
                      [
                        {
                          "Key": "ResourceGroup",
                          "Values": [
                            {
                              "Ref": "ResourceGroupName"
                            }
                          ]
                        }
                      ],
                      {
                        "Fn::If": [
                          "TargetAll",
                          [
                            {
                              "Key": "InstanceIds",
                              "Values": [
                                "*"
                              ]
                            }
                          ],
                          [
                            {
                              "Key": "ParameterValues",
                              "Values": {
                                "Fn::Split": [
                                  ",",
                                  {
                                    "Ref": "TargetInstances"
                                  }
                                ]
                              }
                            }
                          ]
                        ]
                      }
                    ]
                  }
                ]
              }
            ]
          }
        },
        "DependsOn": [
          "CreateAndAttachIAMToEc2InstanceDocument",
          "RoleForAutomation"
        ]
      },
      "SystemAssociationForAddRemoveNameTag": {
        "Type": "AWS::SSM::Association",
        "Properties": {
          "ScheduleExpression": "rate(30 days)",
          "Name": {
            "Ref": "AddRemoveNameTagAutomationDocument"
          },
          "AssociationName": {
            "Fn::Sub": "AWS-QuickSetup-PatchPolicy-AddRemoveNameTag-${QSConfigurationId}"
          },
          "Parameters": {
            "AutomationAssumeRole": [
              {
                "Fn::GetAtt": [
                  "RoleForAutomation",
                  "Arn"
                ]
              }
            ],
            "QSConfigurationName": [
              {
                "Ref": "PatchPolicyName"
              }
            ],
            "QSConfigurationId": [
              {
                "Ref": "QSConfigurationId"
              }
            ],
            "TagAction": [
              "Add"
            ]
          },
          "AutomationTargetParameterName": "InstanceId",
          "Targets": {
            "Fn::If": [
              "IsTagKeyAndValueTargeted",
              [
                {
                  "Key": {
                    "Fn::Sub": "tag:${TargetTagKey}"
                  },
                  "Values": [
                    {
                      "Ref": "TargetTagValue"
                    }
                  ]
                }
              ],
              {
                "Fn::If": [
                  "IsTagKeyOnlyTargeted",
                  [
                    {
                      "Key": "tag-key",
                      "Values": [
                        {
                          "Ref": "TargetTagKey"
                        }
                      ]
                    }
                  ],
                  {
                    "Fn::If": [
                      "IsResourceGroupTargeted",
                      [
                        {
                          "Key": "ResourceGroup",
                          "Values": [
                            {
                              "Ref": "ResourceGroupName"
                            }
                          ]
                        }
                      ],
                      {
                        "Fn::If": [
                          "TargetAll",
                          [
                            {
                              "Key": "InstanceIds",
                              "Values": [
                                "*"
                              ]
                            }
                          ],
                          [
                            {
                              "Key": "ParameterValues",
                              "Values": {
                                "Fn::Split": [
                                  ",",
                                  {
                                    "Ref": "TargetInstances"
                                  }
                                ]
                              }
                            }
                          ]
                        ]
                      }
                    ]
                  }
                ]
              }
            ]
          }
        },
        "DependsOn": [
          "AddRemoveNameTagAutomationDocument",
          "RoleForAutomation"
        ]
      },
      "SystemAssociationForHybridIamManagement": {
        "Type": "AWS::SSM::Association",
        "Properties": {
          "ScheduleExpression": "rate(30 days)",
          "Name": {
            "Ref": "CreateAndAttachIAMToHybridInstanceDocument"
          },
          "AssociationName": {
            "Fn::Sub": "AWS-QuickSetup-PatchPolicy-AttachIAMToHybridInstance-${QSConfigurationId}"
          },
          "Parameters": {
            "AutomationAssumeRole": [
              {
                "Fn::GetAtt": [
                  "RoleForAutomation",
                  "Arn"
                ]
              }
            ],
            "IsPolicyAttachAllowed": [
              {
                "Ref": "IsPolicyAttachAllowed"
              }
            ],
            "QSConfigurationId": [
              {
                "Ref": "QSConfigurationId"
              }
            ],
            "AwsAccountId": [
              {
                "Ref": "AWS::AccountId"
              }
            ],
            "Region": [
              {
                "Ref": "AWS::Region"
              }
            ]
          },
          "AutomationTargetParameterName": "InstanceId",
          "Targets": {
            "Fn::If": [
              "IsTagKeyAndValueTargeted",
              [
                {
                  "Key": {
                    "Fn::Sub": "tag:${TargetTagKey}"
                  },
                  "Values": [
                    {
                      "Ref": "TargetTagValue"
                    }
                  ]
                }
              ],
              {
                "Fn::If": [
                  "IsTagKeyOnlyTargeted",
                  [
                    {
                      "Key": "tag-key",
                      "Values": [
                        {
                          "Ref": "TargetTagKey"
                        }
                      ]
                    }
                  ],
                  {
                    "Fn::If": [
                      "IsResourceGroupTargeted",
                      [
                        {
                          "Key": "ResourceGroup",
                          "Values": [
                            {
                              "Ref": "ResourceGroupName"
                            }
                          ]
                        }
                      ],
                      {
                        "Fn::If": [
                          "TargetAll",
                          [
                            {
                              "Key": "InstanceIds",
                              "Values": [
                                "*"
                              ]
                            }
                          ],
                          [
                            {
                              "Key": "ParameterValues",
                              "Values": {
                                "Fn::Split": [
                                  ",",
                                  {
                                    "Ref": "TargetInstances"
                                  }
                                ]
                              }
                            }
                          ]
                        ]
                      }
                    ]
                  }
                ]
              }
            ]
          }
        },
        "DependsOn": "CreateAndAttachIAMToHybridInstanceDocument"
      },
      "SystemAssociationForNameTagRemediation": {
        "Type": "AWS::SSM::Association",
        "Properties": {
          "ScheduleExpression": "rate(1 day)",
          "Name": {
            "Ref": "NameTagRemediationDocument"
          },
          "AssociationName": {
            "Fn::Sub": "AWS-QuickSetup-PatchPolicy-NameTagRemediation-${QSConfigurationId}"
          },
          "Parameters": {
            "AutomationAssumeRole": [
              {
                "Fn::GetAtt": [
                  "RoleForAutomation",
                  "Arn"
                ]
              }
            ],
            "TargetType": [
              {
                "Ref": "TargetType"
              }
            ],
            "NameKey": [
              {
                "Fn::Sub": "QSConfigName-${QSConfigurationId}"
              }
            ],
            "NameValue": [
              {
                "Ref": "PatchPolicyName"
              }
            ],
            "TargetValues": [
              {
                "Fn::If": [
                  "IsTagKeyAndValueTargeted",
                  {
                    "Fn::Join": [
                      "",
                      [
                        "{\"Key\":\"",
                        {
                          "Fn::Sub": "${TargetTagKey}"
                        },
                        "\",",
                        "\"Value\":\"",
                        {
                          "Ref": "TargetTagValue"
                        },
                        "\"}"
                      ]
                    ]
                  },
                  {
                    "Fn::If": [
                      "IsTagKeyOnlyTargeted",
                      {
                        "Fn::Join": [
                          "",
                          [
                            "{\"Key\":\"",
                            {
                              "Ref": "TargetTagKey"
                            },
                            "\"}"
                          ]
                        ]
                      },
                      {
                        "Fn::If": [
                          "IsResourceGroupTargeted",
                          {
                            "Fn::Join": [
                              "",
                              [
                                "{\"Key\":\"",
                                {
                                  "Ref": "ResourceGroupName"
                                },
                                "\"}"
                              ]
                            ]
                          },
                          {
                            "Fn::If": [
                              "TargetAll",
                              "{\"Key\":\"*\"}",
                              {
                                "Fn::Join": [
                                  "",
                                  [
                                    "{\"Key\":\"",
                                    {
                                      "Ref": "TargetInstances"
                                    },
                                    "\"}"
                                  ]
                                ]
                              }
                            ]
                          }
                        ]
                      }
                    ]
                  }
                ]
              }
            ],
            "Region": [
              {
                "Fn::Sub": "${AWS::Region}"
              }
            ]
          }
        },
        "DependsOn": [
          "NameTagRemediationDocument",
          "RoleForAutomation"
        ]
      },
      "CreateAndAttachIAMToEc2InstanceDocument": {
        "Type": "AWS::SSM::Document",
        "Properties": {
          "UpdateMethod": "NewVersion",
          "Content": {
            "description": "Composite document for Quick Setup Managing Instances association. This document ensures IAM role for instance profile is created in account with all required policies",
            "schemaVersion": "0.3",
            "assumeRole": "{{AutomationAssumeRole}}",
            "parameters": {
              "AutomationAssumeRole": {
                "type": "String"
              },
              "InstanceId": {
                "type": "String"
              },
              "IsPolicyAttachAllowed": {
                "type": "String"
              },
              "AwsAccountId": {
                "type": "String"
              },
              "QSConfigurationId": {
                "type": "String"
              }
            },
            "mainSteps": [
              {
                "name": "branchOnInstanceType",
                "action": "aws:branch",
                "inputs": {
                  "Choices": [
                    {
                      "NextStep": "getExistingRoleName",
                      "Variable": "{{InstanceId}}",
                      "StartsWith": "i-"
                    }
                  ]
                },
                "isEnd": true
              },
              {
                "name": "getExistingRoleName",
                "action": "aws:executeScript",
                "maxAttempts": 3,
                "inputs": {
                  "Runtime": "python3.11",
                  "Handler": "getInstanceProfileName",
                  "InputPayload": {
                    "InstanceId": "{{InstanceId}}"
                  },
                  "Script": "import boto3\n\ndef getInstanceProfileName(events, context):\n    ec2_client = boto3.client(\"ec2\")\n    response = ec2_client.describe_instances(InstanceIds=[events[\"InstanceId\"]])\n    if 'IamInstanceProfile' in response['Reservations'][0]['Instances'][0]:\n        return {'RoleName': response['Reservations'][0]['Instances'][0]['IamInstanceProfile']['Arn'].split('/').pop()}\n    return {'RoleName': 'NoRoleFound'}"
                },
                "outputs": [
                  {
                    "Name": "existingInstanceProfileRoleName",
                    "Selector": "$.Payload.RoleName",
                    "Type": "String"
                  }
                ],
                "nextStep": "branchIfProfileExists"
              },
              {
                "name": "branchIfProfileExists",
                "action": "aws:branch",
                "inputs": {
                  "Choices": [
                    {
                      "NextStep": "createRoleIfNotExists",
                      "Variable": "{{getExistingRoleName.existingInstanceProfileRoleName}}",
                      "StringEquals": "NoRoleFound"
                    }
                  ],
                  "Default": "checkIfPolicyAttachAllowed"
                }
              },
              {
                "name": "checkIfPolicyAttachAllowed",
                "action": "aws:branch",
                "inputs": {
                  "Choices": [
                    {
                      "NextStep": "getRoleFromInstanceProfile",
                      "Variable": "{{IsPolicyAttachAllowed}}",
                      "StringEquals": "true"
                    }
                  ],
                  "Default": "createRoleIfNotExists"
                }
              },
              {
                "name": "getRoleFromInstanceProfile",
                "action": "aws:executeAwsApi",
                "inputs": {
                  "Service": "iam",
                  "Api": "GetInstanceProfile",
                  "InstanceProfileName": "{{getExistingRoleName.existingInstanceProfileRoleName}}"
                },
                "outputs": [
                  {
                    "Name": "existingRoleName",
                    "Selector": "$.InstanceProfile.Roles[0].RoleName",
                    "Type": "String"
                  }
                ],
                "nextStep": "attachBaselineOverridePolicyToExistingRole"
              },
              {
                "name": "attachBaselineOverridePolicyToExistingRole",
                "action": "aws:executeAwsApi",
                "inputs": {
                  "Service": "iam",
                  "Api": "AttachRolePolicy",
                  "RoleName": "{{getRoleFromInstanceProfile.existingRoleName}}",
                  "PolicyArn": {
                    "Fn::Sub": "arn:${AWS::Partition}:iam::aws:policy/AWSQuickSetupPatchPolicyBaselineAccess"
                  }
                },
                "description": "Attach required managed policy to Instance Profile role.",
                "nextStep": "attachAmazonSSMManagedInstanceCoreToExistingRole",
                "onFailure": "Abort"
              },
              {
                "name": "attachAmazonSSMManagedInstanceCoreToExistingRole",
                "action": "aws:executeAwsApi",
                "inputs": {
                  "Service": "iam",
                  "Api": "AttachRolePolicy",
                  "RoleName": "{{getRoleFromInstanceProfile.existingRoleName}}",
                  "PolicyArn": {
                    "Fn::Sub": "arn:${AWS::Partition}:iam::aws:policy/AmazonSSMManagedInstanceCore"
                  }
                },
                "nextStep": "attachTagToExistingRole"
              },
              {
                "name": "attachTagToExistingRole",
                "action": "aws:executeAwsApi",
                "inputs": {
                  "Service": "iam",
                  "Api": "TagRole",
                  "RoleName": "{{getRoleFromInstanceProfile.existingRoleName}}",
                  "Tags": [
                    {
                      "Key": {
                        "Fn::Sub": "QSConfigId-${QSConfigurationId}"
                      },
                      "Value": {
                        "Fn::Sub": "${QSConfigurationId}"
                      }
                    }
                  ]
                },
                "isEnd": true
              },
              {
                "name": "createRoleIfNotExists",
                "action": "aws:executeScript",
                "inputs": {
                  "Runtime": "python3.11",
                  "Handler": "createRoleIfNotExists",
                  "InputPayload": {
                    "Path": "/",
                    "RoleName": "AmazonSSMRoleForInstancesQuickSetup",
                    "AssumeRolePolicyDocument": "{\"Version\":\"2012-10-17\",\"Statement\":[{\"Effect\":\"Allow\",\"Principal\":{\"Service\":\"ec2.amazonaws.com\"},\"Action\":\"sts:AssumeRole\"}]}",
                    "Description": "EC2 role for SSM for Quick-Setup"
                  },
                  "Script": "import boto3\nfrom botocore.exceptions import ClientError\niam_client = boto3.client('iam')            \ndef createRoleIfNotExists(events, context):\n    try:\n        iam_client.create_role(\n            Path=events['Path'],\n            RoleName=events['RoleName'],\n            AssumeRolePolicyDocument=events['AssumeRolePolicyDocument'],\n            Description=events['Description']\n        )\n    except ClientError as e:\n        if e.response['Error']['Code'] == 'EntityAlreadyExists':\n            print('Role already exists. Skipping creation.')\n        else:\n            raise e"
                },
                "onFailure": "Abort",
                "description": "Create AmazonSSMRoleForInstancesQuickSetup Role For SSM Quick Setup",
                "nextStep": "assertRoleForInstanceProfileExists"
              },
              {
                "name": "assertRoleForInstanceProfileExists",
                "action": "aws:assertAwsResourceProperty",
                "inputs": {
                  "Service": "iam",
                  "Api": "GetRole",
                  "PropertySelector": "$.Role.RoleName",
                  "DesiredValues": [
                    "AmazonSSMRoleForInstancesQuickSetup"
                  ],
                  "RoleName": "AmazonSSMRoleForInstancesQuickSetup"
                },
                "nextStep": "attachBaselineOverridePolicyToRole"
              },
              {
                "name": "attachBaselineOverridePolicyToRole",
                "action": "aws:executeAwsApi",
                "inputs": {
                  "Service": "iam",
                  "Api": "AttachRolePolicy",
                  "RoleName": "AmazonSSMRoleForInstancesQuickSetup",
                  "PolicyArn": {
                    "Fn::Sub": "arn:${AWS::Partition}:iam::aws:policy/AWSQuickSetupPatchPolicyBaselineAccess"
                  }
                },
                "description": "Attach required managed policy to Instance Profile role.",
                "nextStep": "attachTagToRole",
                "onFailure": "Abort"
              },
              {
                "name": "attachTagToRole",
                "action": "aws:executeAwsApi",
                "inputs": {
                  "Service": "iam",
                  "Api": "TagRole",
                  "RoleName": "AmazonSSMRoleForInstancesQuickSetup",
                  "Tags": [
                    {
                      "Key": {
                        "Fn::Sub": "QSConfigId-${QSConfigurationId}"
                      },
                      "Value": {
                        "Fn::Sub": "${QSConfigurationId}"
                      }
                    }
                  ]
                },
                "nextStep": "attachAmazonSSMManagedInstanceCoreToRole"
              },
              {
                "name": "attachAmazonSSMManagedInstanceCoreToRole",
                "action": "aws:executeAwsApi",
                "inputs": {
                  "Service": "iam",
                  "Api": "AttachRolePolicy",
                  "RoleName": "AmazonSSMRoleForInstancesQuickSetup",
                  "PolicyArn": {
                    "Fn::Sub": "arn:${AWS::Partition}:iam::aws:policy/AmazonSSMManagedInstanceCore"
                  }
                },
                "nextStep": "executeAttachIAMToInstance"
              },
              {
                "name": "executeAttachIAMToInstance",
                "action": "aws:executeAutomation",
                "maxAttempts": 10,
                "timeoutSeconds": 60,
                "inputs": {
                  "DocumentName": "AWS-AttachIAMToInstance",
                  "RuntimeParameters": {
                    "RoleName": "AmazonSSMRoleForInstancesQuickSetup",
                    "ForceReplace": false,
                    "AutomationAssumeRole": "{{ AutomationAssumeRole }}",
                    "InstanceId": "{{ InstanceId }}"
                  }
                },
                "isEnd": true
              }
            ]
          },
          "DocumentType": "Automation",
          "TargetType": "/AWS::EC2::Instance",
          "Name": {
            "Fn::Sub": "AWSQuickSetup-CreateAndAttachIAMToEc2Node-${QSConfigurationId}"
          }
        }
      },
      "NameTagRemediationDocument": {
        "Type": "AWS::SSM::Document",
        "Properties": {
          "Content": {
            "description": "Composite document for Quick Setup Naming  functionality. This document ensures that the appropriate tag is removed from all nodes in an account that are no longer a target of a Patch Policy.",
            "schemaVersion": "0.3",
            "assumeRole": "{{AutomationAssumeRole}}",
            "parameters": {
              "AutomationAssumeRole": {
                "type": "String"
              },
              "TargetType": {
                "type": "String"
              },
              "NameKey": {
                "type": "String"
              },
              "NameValue": {
                "type": "String"
              },
              "TargetValues": {
                "type": "String"
              },
              "Region": {
                "type": "String"
              }
            },
            "mainSteps": [
              {
                "name": "performRemediation",
                "action": "aws:executeScript",
                "inputs": {
                  "Runtime": "python3.11",
                  "Handler": "begin_remediation",
                  "InputPayload": {
                    "TargetType": "{{TargetType}}",
                    "NameKey": "{{NameKey}}",
                    "NameValue": "{{NameValue}}",
                    "Targets": "{{TargetValues}}",
                    "Region": "{{Region}}"
                  },
                  "Script": "import os\nimport resource\nimport boto3\nimport time\nimport json\n\ndef get_ssm_client(region):\n    return boto3.client('ssm', region_name=region)\n\ndef get_ec2_client(region):\n    return boto3.client('ec2', region_name=region)\n\ndef throw_exception_on_response_code(response):\n    response_code = str(response[\"ResponseMetadata\"][\"HTTPStatusCode\"])\n    if  response_code != \"200\":\n        raise Exception(\"Non-OK Status Code received: %s. Full Response: %s. Failing remediation document\"%(response_code, str(response)))\n\ndef remove_tag_from_resources(on_prem_instances, tag_key, region):\n    print(\"Removing tags from on prem instances: %s\"%(\",\".join(on_prem_instances)))\n    try:\n        for on_prem_instance in on_prem_instances:\n            response = get_ssm_client(region).remove_tags_from_resource(\n                ResourceType='ManagedInstance',\n                ResourceId=on_prem_instance,\n                TagKeys=[\n                    tag_key\n                ]\n            )\n            print(response)\n            throw_exception_on_response_code(response)\n            time.sleep(0.05)\n    except Exception as e:\n        print(\"Exception occurred removing tag for on prem instance %s: %s\"%(on_prem_instance, str(e)))\n        raise(e)\n\ndef delete_tags(ec2_instances, tag_key, tag_value, region):\n    print(\"Removing tags from ec2 instances: %s\"%(\",\".join(ec2_instances)))\n    try:\n        for i in range(0, len(ec2_instances), 250):\n            response = get_ec2_client(region).delete_tags(\n                DryRun=False,\n                Resources=ec2_instances[i:i+250],\n                Tags=[\n                    {\n                        'Key': tag_key,\n                        'Value': tag_value\n                    }\n                ]\n            )\n            throw_exception_on_response_code(response)\n            time.sleep(0.20)\n    except Exception as e:\n        print(\"Exception occurred removing tag from EC2 Instance %s: %s\"%(\", \".join(ec2_instances), str(e)))\n        raise (e)\n\ndef get_inventory(request, region):\n\n    try:\n        instance_ids = []\n        print(\"Calling get_inventory with request : \\n%s \\n\\n\"%(str(request)))\n        response = get_ssm_client(region).get_inventory(**request)\n        print(\"\\n\\n\")\n        print(response)\n        throw_exception_on_response_code(response)\n\n        [instance_ids.append(i[\"Id\"]) for i in response[\"Entities\"]]\n        next_token = None\n        if \"NextToken\" in response:\n            next_token = response[\"NextToken\"]\n\n        while next_token:\n            request[\"NextToken\"] = next_token\n            response = get_ssm_client(region).get_inventory(**request)\n            \n            throw_exception_on_response_code(response)\n            \n            [instance_ids.append(i[\"Id\"]) for i in response[\"Entities\"]]\n            \n            time.sleep(0.33)\n\n            if \"NextToken\" in response:\n                next_token = response[\"NextToken\"]\n            else:\n                next_token = None\n\n        return instance_ids\n    except Exception as e: \n        print(\"Something went wrong retrieving inventory with request: %s. \\\n         Exception: %s .\\n Failing remediation document. \"%(request, str(e)))\n        raise e\n\ndef remove_tags(list_of_instances, tag_key, tag_value, region):\n    mi = []\n    i = []\n    for instance in list_of_instances:\n        if (instance.startswith(\"mi\")):\n            mi.append(instance)\n        else:\n            i.append(instance)\n   \n    delete_tags(i, tag_key, tag_value, region)           \n    remove_tag_from_resources(mi, tag_key, region)\n\ndef get_tag_request(target):\n    tag_key = check_for_key(target, \"Key\")\n    \n    request = {\n        \"Filters\": [{\n            \"Key\": \"AWS:Tag.Key\", \n            \"Values\": [tag_key],\n            \"Type\": \"Equal\"\n\n        }]\n    }\n    # For the case where only a tag-key is targeted.\n    if \"Value\" in target:\n        tag_value = check_for_key(target, \"Value\")\n        request[\"Filters\"].append({\n            \"Key\": \"AWS:Tag.Value\", \n            \"Values\": [tag_value],\n            \"Type\": \"Equal\"\n        })\n\n    return request\n\ndef get_resource_group_request(target):\n    # for resource groups, the name is the Target key. e.g. '\"Target\": {\"Key\": \"ResourceGroupName\"}:\n    resource_group_name = check_for_key(target, \"Key\")\n    request = {    \n        \"Filters\": [{\n\n            \"Key\": \"AWS:ResourceGroup.Name\",\n            \"Values\": [resource_group_name],\n            \"Type\": \"Equal\"\n        }]\n    }\n    return request\n\ndef get_instance_ids_request(target):\n    request = {\"Filters\": []}\n    instance_ids = check_for_key(target, \"Key\").split(\",\")\n    for ids in range(0, len(instance_ids), 40):\n        request[\"Filters\"].append(            {\n                \"Key\": \"AWS:InstanceInformation.InstanceId\",\n                \"Values\": instance_ids[ids:ids+40],\n                \"Type\": \"Equal\"\n            })\n    return request\n\ndef check_for_key(hashmap, key):\n    if not key in hashmap:\n        raise Exception(\"The required key %s is not present. Failing.\"%(key))\n    else:\n        # return the value\n        return hashmap[key]\n\ndef get_target_request(target_type, target):\n    if target_type.lower() == \"tags\":\n        return get_tag_request(target)\n    elif target_type.lower() == \"instanceids\":\n        return get_instance_ids_request(target)\n    elif target_type.lower() == \"resourcegroups\":\n        return get_resource_group_request(target)\n    \n    raise Exception(\"Unable to understand the target type of the Patch Policy.\\\n         Received values was: %s. Failing remediation document. \"%(target_type))\n\ndef begin_remediation(event, context):\n    # Get all variables\n    target_type = check_for_key(event, \"TargetType\")\n\n    if target_type == \"*\":\n        return\n\n    name_key = check_for_key(event, \"NameKey\")\n    name_value = check_for_key(event, \"NameValue\")\n    region = check_for_key(event, \"Region\")\n\n    ## Add exception (to make it more robust)\n    target_dict = check_for_key(event, \"Targets\")\n\n    target = json.loads(target_dict)\n\n    # This filter will return all targets of the Patch Policy.\n    request = get_target_request(target_type, target)\n    target_instances = get_inventory(request, region)\n\n    # This will return targets that have the name tag\n    new_request = {\"Filters\": [{\n            \"Key\": \"AWS:Tag.Key\",\n            \"Values\": [name_key],\n            \"Type\": \"Equal\"\n        },\n        {\n            \"Key\": \"AWS:InstanceInformation.InstanceStatus\",\n            \"Values\": [\"Terminated\", \"ConnectionLost\"],\n            \"Type\": \"NotEqual\"\n        }]}\n\n    named_instances = get_inventory(new_request, region)\n\n    # 'get instances that are NOT a target of the Patch Policy but have the name tag'\n    instances_to_remove = set(named_instances) - set(target_instances)\n\n    # remove the tags\n    remove_tags(instances_to_remove, name_key, name_value, region)"
                },
                "outputs": [
                  {
                    "Name": "existingInstanceProfileRoleName",
                    "Selector": "$.Payload.RoleName",
                    "Type": "String"
                  }
                ],
                "isEnd": true
              }
            ]
          },
          "DocumentType": "Automation",
          "UpdateMethod": "NewVersion",
          "Name": {
            "Fn::Sub": "AWSQuickSetup-NameTagRemediation-${QSConfigurationId}"
          }
        }
      },
      "AddRemoveNameTagAutomationDocument": {
        "Type": "AWS::SSM::Document",
        "Properties": {
          "UpdateMethod": "NewVersion",
          "Content": {
            "description": "Quick Setup document for remediating the name tag on EC2 instances.",
            "schemaVersion": "0.3",
            "assumeRole": "{{AutomationAssumeRole}}",
            "parameters": {
              "AutomationAssumeRole": {
                "type": "String"
              },
              "InstanceId": {
                "type": "String"
              },
              "QSConfigurationName": {
                "type": "String"
              },
              "QSConfigurationId": {
                "type": "String"
              },
              "TagAction": {
                "type": "String",
                "allowedValues": [
                  "Add",
                  "Remove"
                ]
              }
            },
            "mainSteps": [
              {
                "name": "branchOnInstanceType",
                "action": "aws:branch",
                "inputs": {
                  "Choices": [
                    {
                      "NextStep": "branchOnActionEC2",
                      "Variable": "{{InstanceId}}",
                      "StartsWith": "i-"
                    },
                    {
                      "NextStep": "branchOnActionHybrid",
                      "Variable": "{{InstanceId}}",
                      "StartsWith": "mi-"
                    }
                  ]
                },
                "isEnd": true
              },
              {
                "name": "branchOnActionEC2",
                "action": "aws:branch",
                "inputs": {
                  "Choices": [
                    {
                      "NextStep": "removeTagFromEC2Node",
                      "Variable": "{{TagAction}}",
                      "StringEquals": "Remove"
                    },
                    {
                      "NextStep": "addTagToEC2Node",
                      "Variable": "{{TagAction}}",
                      "StringEquals": "Add"
                    }
                  ]
                }
              },
              {
                "name": "removeTagFromEC2Node",
                "action": "aws:executeAwsApi",
                "inputs": {
                  "Service": "ec2",
                  "Api": "DeleteTags",
                  "Resources": [
                    "{{InstanceId}}"
                  ],
                  "Tags": [
                    {
                      "Key": "QSConfigName-{{QSConfigurationId}}"
                    }
                  ]
                },
                "onFailure": "Abort",
                "isEnd": true
              },
              {
                "name": "addTagToEC2Node",
                "action": "aws:executeAwsApi",
                "inputs": {
                  "Service": "ec2",
                  "Api": "CreateTags",
                  "Resources": [
                    "{{InstanceId}}"
                  ],
                  "Tags": [
                    {
                      "Key": "QSConfigName-{{QSConfigurationId}}",
                      "Value": "{{QSConfigurationName}}"
                    }
                  ]
                },
                "onFailure": "Abort",
                "isEnd": true
              },
              {
                "name": "branchOnActionHybrid",
                "action": "aws:branch",
                "inputs": {
                  "Choices": [
                    {
                      "NextStep": "removeTagFromHybridNode",
                      "Variable": "{{TagAction}}",
                      "StartsWith": "Remove"
                    },
                    {
                      "NextStep": "addTagToHybridNode",
                      "Variable": "{{TagAction}}",
                      "StringEquals": "Add"
                    }
                  ]
                }
              },
              {
                "name": "removeTagFromHybridNode",
                "action": "aws:executeAwsApi",
                "inputs": {
                  "Service": "ssm",
                  "Api": "RemoveTagsFromResource",
                  "ResourceType": "ManagedInstance",
                  "ResourceId": "{{InstanceId}}",
                  "TagKeys": [
                    "QSConfigName-{{QSConfigurationId}}"
                  ]
                },
                "onFailure": "Abort",
                "isEnd": true
              },
              {
                "name": "addTagToHybridNode",
                "action": "aws:executeAwsApi",
                "inputs": {
                  "Service": "ssm",
                  "Api": "AddTagsToResource",
                  "ResourceType": "ManagedInstance",
                  "ResourceId": "{{InstanceId}}",
                  "Tags": [
                    {
                      "Key": "QSConfigName-{{QSConfigurationId}}",
                      "Value": "{{QSConfigurationName}}"
                    }
                  ]
                },
                "onFailure": "Abort",
                "isEnd": true
              }
            ]
          },
          "DocumentType": "Automation",
          "Name": {
            "Fn::Sub": "AWSQuickSetup-AddOrRemoveTag-PatchPolicy-${QSConfigurationId}"
          },
          "TargetType": "/"
        }
      },
      "CreateAndAttachIAMToHybridInstanceDocument": {
        "Type": "AWS::SSM::Document",
        "Properties": {
          "UpdateMethod": "NewVersion",
          "Content": {
            "description": "Composite document for Quick Setup IAM Management of hybrid instances. This document ensures IAM role for instance profile is created in account with all required policies for Hybrid nodes.",
            "schemaVersion": "0.3",
            "assumeRole": "{{AutomationAssumeRole}}",
            "parameters": {
              "AutomationAssumeRole": {
                "type": "String"
              },
              "InstanceId": {
                "type": "String"
              },
              "IsPolicyAttachAllowed": {
                "type": "String"
              },
              "AwsAccountId": {
                "type": "String"
              },
              "QSConfigurationId": {
                "type": "String"
              },
              "Region": {
                "type": "String"
              }
            },
            "mainSteps": [
              {
                "name": "branchOnInstanceType",
                "action": "aws:branch",
                "inputs": {
                  "Choices": [
                    {
                      "NextStep": "getExistingRoleName",
                      "Variable": "{{InstanceId}}",
                      "StartsWith": "mi-"
                    }
                  ]
                },
                "isEnd": true
              },
              {
                "name": "getExistingRoleName",
                "action": "aws:executeScript",
                "inputs": {
                  "Runtime": "python3.11",
                  "Handler": "getRoleName",
                  "InputPayload": {
                    "InstanceId": "{{InstanceId}}",
                    "Region": "{{Region}}"
                  },
                  "Script": "import boto3\n\ndef getRoleName(events, context):\n    region = events[\"Region\"]\n    ssm_client = boto3.client(\"ssm\", region)\n    response = ssm_client.describe_instance_information(\n        InstanceInformationFilterList=[\n            {\n                'key': 'InstanceIds',\n                'valueSet': [\n                    events[\"InstanceId\"],\n                ]\n            },\n        ]\n    )\n   \n    if len (response[\"InstanceInformationList\"]) > 0 and \"IamRole\" in response[\"InstanceInformationList\"][0]: \n        return {'RoleName': response[\"InstanceInformationList\"][0][\"IamRole\"].split('/').pop()}\n    return {'RoleName': 'NoRoleFound'}"
                },
                "outputs": [
                  {
                    "Name": "roleName",
                    "Selector": "$.Payload.RoleName",
                    "Type": "String"
                  }
                ],
                "nextStep": "branchIfProfileExists"
              },
              {
                "name": "branchIfProfileExists",
                "action": "aws:branch",
                "inputs": {
                  "Choices": [
                    {
                      "NextStep": "createRoleIfNotExists",
                      "Variable": "{{getExistingRoleName.roleName}}",
                      "StringEquals": "NoRoleFound"
                    }
                  ],
                  "Default": "checkIfPolicyAttachAllowed"
                }
              },
              {
                "name": "checkIfPolicyAttachAllowed",
                "action": "aws:branch",
                "inputs": {
                  "Choices": [
                    {
                      "NextStep": "attachBaselineOverridePolicyToExistingRole",
                      "Variable": "{{IsPolicyAttachAllowed}}",
                      "StringEquals": "true"
                    }
                  ],
                  "Default": "createRoleIfNotExists"
                }
              },
              {
                "name": "attachBaselineOverridePolicyToExistingRole",
                "action": "aws:executeAwsApi",
                "inputs": {
                  "Service": "iam",
                  "Api": "AttachRolePolicy",
                  "RoleName": "{{getExistingRoleName.roleName}}",
                  "PolicyArn": {
                    "Fn::Sub": "arn:${AWS::Partition}:iam::aws:policy/AWSQuickSetupPatchPolicyBaselineAccess"
                  }
                },
                "description": "Attach required managed policy to Instance Profile role.",
                "nextStep": "attachAmazonSSMManagedInstanceCoreToExistingRole",
                "onFailure": "Abort"
              },
              {
                "name": "attachAmazonSSMManagedInstanceCoreToExistingRole",
                "action": "aws:executeAwsApi",
                "inputs": {
                  "Service": "iam",
                  "Api": "AttachRolePolicy",
                  "RoleName": "{{getExistingRoleName.roleName}}",
                  "PolicyArn": {
                    "Fn::Sub": "arn:${AWS::Partition}:iam::aws:policy/AmazonSSMManagedInstanceCore"
                  }
                },
                "nextStep": "attachTagToExistingRole"
              },
              {
                "name": "attachTagToExistingRole",
                "action": "aws:executeAwsApi",
                "inputs": {
                  "Service": "iam",
                  "Api": "TagRole",
                  "RoleName": "{{getExistingRoleName.roleName}}",
                  "Tags": [
                    {
                      "Key": {
                        "Fn::Sub": "QSConfigId-${QSConfigurationId}"
                      },
                      "Value": {
                        "Fn::Sub": "${QSConfigurationId}"
                      }
                    }
                  ]
                },
                "isEnd": true
              },
              {
                "name": "createRoleIfNotExists",
                "action": "aws:executeScript",
                "inputs": {
                  "Runtime": "python3.11",
                  "Handler": "createRoleIfNotExists",
                  "InputPayload": {
                    "Path": "/",
                    "RoleName": "AmazonSSMRoleForInstancesQuickSetup",
                    "AssumeRolePolicyDocument": "{\"Version\":\"2012-10-17\",\"Statement\":[{\"Effect\":\"Allow\",\"Principal\":{\"Service\":\"ssm.amazonaws.com\"},\"Action\":\"sts:AssumeRole\"}]}",
                    "Description": "SSM Hybrid role for SSM for Quick-Setup"
                  },
                  "Script": "import boto3\nfrom botocore.exceptions import ClientError\n\niam_client = boto3.client('iam')   \n\ndef createRoleIfNotExists(events, context):\n    try:\n        iam_client.create_role(Path=events['Path'], RoleName=events['RoleName'], AssumeRolePolicyDocument=events['AssumeRolePolicyDocument'], Description=events['Description'])\n    except ClientError as e:        \n        if e.response['Error']['Code'] == 'EntityAlreadyExists':\n            print('Role already exists. Skipping creation.')\n        else:            \n            raise e"
                },
                "onFailure": "Abort",
                "description": "Create AmazonSSMRoleForInstancesQuickSetup Role For SSM Quick Setup",
                "nextStep": "assertRoleExists"
              },
              {
                "name": "assertRoleExists",
                "action": "aws:assertAwsResourceProperty",
                "inputs": {
                  "Service": "iam",
                  "Api": "GetRole",
                  "PropertySelector": "$.Role.RoleName",
                  "DesiredValues": [
                    "AmazonSSMRoleForInstancesQuickSetup"
                  ],
                  "RoleName": "AmazonSSMRoleForInstancesQuickSetup"
                },
                "nextStep": "attachBaselineOverridePolicyToRole"
              },
              {
                "name": "attachBaselineOverridePolicyToRole",
                "action": "aws:executeAwsApi",
                "inputs": {
                  "Service": "iam",
                  "Api": "AttachRolePolicy",
                  "RoleName": "AmazonSSMRoleForInstancesQuickSetup",
                  "PolicyArn": {
                    "Fn::Sub": "arn:${AWS::Partition}:iam::aws:policy/AWSQuickSetupPatchPolicyBaselineAccess"
                  }
                },
                "description": "Attach required managed policy to Instance Profile role.",
                "nextStep": "attachAmazonSSMManagedInstanceCoreToRole",
                "onFailure": "Abort"
              },
              {
                "name": "attachAmazonSSMManagedInstanceCoreToRole",
                "action": "aws:executeAwsApi",
                "inputs": {
                  "Service": "iam",
                  "Api": "AttachRolePolicy",
                  "RoleName": "AmazonSSMRoleForInstancesQuickSetup",
                  "PolicyArn": {
                    "Fn::Sub": "arn:${AWS::Partition}:iam::aws:policy/AmazonSSMManagedInstanceCore"
                  }
                },
                "nextStep": "attachTagToRole"
              },
              {
                "name": "attachTagToRole",
                "action": "aws:executeAwsApi",
                "inputs": {
                  "Service": "iam",
                  "Api": "TagRole",
                  "RoleName": "AmazonSSMRoleForInstancesQuickSetup",
                  "Tags": [
                    {
                      "Key": {
                        "Fn::Sub": "QSConfigId-${QSConfigurationId}"
                      },
                      "Value": {
                        "Fn::Sub": "${QSConfigurationId}"
                      }
                    }
                  ]
                },
                "nextStep": "attachRoleToInstance"
              },
              {
                "name": "attachRoleToInstance",
                "action": "aws:executeScript",
                "inputs": {
                  "Runtime": "python3.11",
                  "Handler": "addRoleToHybridInstance",
                  "InputPayload": {
                    "RoleName": "AmazonSSMRoleForInstancesQuickSetup",
                    "InstanceId": "{{InstanceId}}",
                    "Region": "{{Region}}"
                  },
                  "Script": "import boto3\nfrom botocore.exceptions import ClientError\n\ndef addRoleToHybridInstance(events, context):\n    try:\n        ssm_client = boto3.client('ssm', region_name=events['Region'])   \n        ssm_client.update_managed_instance_role(InstanceId=events['InstanceId'],IamRole=events['RoleName'])\n    except ClientError as e:                   \n        raise e"
                },
                "onFailure": "Abort",
                "description": "Add AmazonSSMRoleForInstancesQuickSetup Role to the hybrid (mi-) instance.",
                "isEnd": true
              }
            ]
          },
          "DocumentType": "Automation",
          "Name": {
            "Fn::Sub": "AWSQuickSetup-CreateAndAttachIAMToHybridNode-${QSConfigurationId}"
          },
          "TargetType": "/AWS::SSM::ManagedInstance"
        },
        "DependsOn": "RoleForAutomation"
      }
    }
  }
}
