{
  "description": "Perform VSS Freeze or Thaw operation to enable application-consistent snapshots on an EC2 Windows instance. The caller is responsible for initiating EBS create snapshot after Freeze completion.",
  "schemaVersion": "2.2",
  "parameters": {
    "executionTimeout": {
      "default": "800",
      "description": "(Optional) The time in seconds for this command to be completed before it is considered to have failed. Extending this timeout will cause the command to wait longer for VSS to start its freeze. Default is 800 seconds. Maximum is 172800 (48 hours). Minimum is 120.",
      "type": "String",
      "allowedPattern": "(1[2-9][0-9]{1})|([2-9][0-9]{2})|([1-9][0-9]{3,4})|(1[0-6][0-9]{4})|(17[0-1][0-9]{3})|(172[0-7][0-9]{2})|(172800)"
    },
    "Action": {
      "allowedValues": [
        "Freeze",
        "Thaw"
      ],
      "default": "Freeze",
      "description": "(Required) Freeze operation will flush pending IO to the specified EBS volume and halt IO.  Thaw operation will resume IO to the EBS volume.  Thaw must be called within 10 seconds of Freeze completion.",
      "type": "String"
    },
    "Volumes": {
      "default": "",
      "description": "(Required for Freeze) Freeze IO to a comma delimited list of EBS volumes IDs. Example: vol-1234567812345678,vol-2234567812345678",
      "type": "String",
      "allowedPattern": "^\\s*([Vv][Oo][Ll]-[0-9a-zA-Z_]+(\\s*,\\s*[Vv][Oo][Ll]-[0-9a-zA-Z_]+)*)*$"
    },
    "Devices": {
      "default": "",
      "description": "(Required for Freeze) Freeze IO to a comma delimited list of device names. Example: xvdb,xvdc",
      "type": "String",
      "allowedPattern": "^[a-zA-Z0-9/,\\s]*$"
    },
    "CopyOnly": {
      "allowedValues": [
        "True",
        "False"
      ],
      "default": "False",
      "description": "(Optional) Select True to indicate a COPY ONLY backup operation.  By default a FULL backup operation is performed.  This option will prevent breaking the differential backup chain in SQL Server when performing a backup.",
      "type": "String"
    },
    "NoWriters": {
      "allowedValues": [
        "True",
        "False"
      ],
      "default": "False",
      "description": "(Optional) Select True to exclude application VSS writers from the snapshot process. This option may be useful to resolve conflicts with third party VSS backup solutions.",
      "type": "String"
    }
  },
  "mainSteps": [
    {
      "inputs": {
        "workingDirectory": "",
        "timeoutSeconds": "{{executionTimeout}}",
        "runCommand": [
          "# Copyright 2017-2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.",
          "",
          "Set-StrictMode -Version Latest",
          "$ErrorActionPreference = \"Stop\"",
          "",
          "# PowerShell does not necessarily set the exit code as 1 in the event of exception.",
          "# In order to ensure Run Command reports the correct status, we must set the exit code.",
          "trap {",
          "    [Environment]::Exit(1)",
          "}",
          "",
          "# Matches NVMe EBS volumes SerialNumber. E.g. vol123456789abcd_000001",
          "# Also matches cases where there are spaces between the volume id and namespace id E.g. 'vol1234567     _000001'",
          "$EBS_VOLUME_MATCH = '(?<=vol)[0-9a-zA-Z]*(?= *_)'",
          "# Matches PV 8.2.3+ disks SerialNumber and NVMe EBS volumes AdapterSerialNumber. E.g. vol123456789abcd",
          "$EBS_VOLUME_MATCH2 = '(?<=vol)(.*)'",
          "",
          "$vssAgentPath = \"$env:ProgramFiles\\Amazon\\AwsVssComponents\\ec2-vss-agent.exe\"",
          "$vssPath = \"$env:ProgramFiles\\Amazon\\AwsVssComponents\\\"",
          "",
          "#",
          "# Function to begin the VSS snapshot of a EBS volume",
          "#",
          "function EbsVssFreeze {",
          "    param(",
          "        [string]$driveLetter,",
          "        [boolean]$CopyOnly,",
          "        [boolean]$NoWriters,",
          "        [uint32]$waitForFreezeTimeout=180",
          "    )",
          "",
          "    # We have two methods to prevent re-entrace. First we check if the VSS Agent is running.  Second",
          "    # if the named pipe server creation fails we know another instance of this script is running.",
          "    if ((get-process \"ec2-vss-agent\" -ea SilentlyContinue) -ne $Null) { ",
          "        Write-Host \"ec2-vss-agent is current running, snapshot already in progress.\" ",
          "        return $false",
          "    }",
          "",
          "    try {",
          "        $namedPipe = '01C0026F-7357-49CD-BD74-657EAF079673'",
          "        $pipeServer = new-object System.IO.Pipes.NamedPipeServerStream($namedPipe, ",
          "            [System.IO.Pipes.PipeDirection]::In,",
          "            1,",
          "            [System.IO.Pipes.PipeTransmissionMode]::Byte,",
          "            [System.IO.Pipes.PipeOptions]::Asynchronous)",
          "",
          "        $asyncResult = $pipeServer.WaitForConnectionAsync()",
          "",
          "        Write-Host 'Pipe server started'",
          "    } catch {",
          "        Write-Host \"Pipe server failed to start.  Possibly another instance of this script is running.\"",
          "        return $false",
          "    }",
          "",
          "    $params = $driveLetter",
          "",
          "    if ($copyOnly) {",
          "        Write-Host \"Copy only option selected\"",
          "        $params = \"-copy \" + $params",
          "    }",
          "",
          "    if ($noWriters) {",
          "        Write-Host \"No writers option selected\"",
          "        $params = \"-nw \" + $params",
          "    }",
          "",
          "    $process = Start-Process $vssAgentPath $params -PassThru",
          "    if ($process -eq $null) {",
          "        return $false",
          "    }",
          "",
          "    Write-Host 'Waiting for Freeze pipe'",
          "",
          "    #",
          "    # Wait up to $waitForFreezeTimeout seconds for connection from provider indicating VSS freeze has begun",
          "    #",
          "    $status = $true",
          "    try {",
          "        if ($asyncResult.AsyncWaitHandle.WaitOne($waitForFreezeTimeout * 1000)){",
          "            Write-Host 'Freeze pipe connected'",
          "            $pipeReader = new-object System.IO.StreamReader($pipeServer)",
          "            $string = $pipeReader.ReadLine()",
          "            Write-Host 'EBS snapshot Freeze message received:' $string",
          "        } else {",
          "            Write-Host \"Timeout waiting for VSS Freeze. Consider increasing the executionTimeout parameter.\"",
          "            $status = $false",
          "        }",
          "    } catch {",
          "        Write-Host 'Freeze pipe read'",
          "        Write-Error  $_",
          "        $status = $false",
          "    } finally {",
          "        Write-Host 'Disposing of pipes'",
          "        if ((Test-Path variable:pipeReader) -and $pipeReader) { $pipeReader.Dispose() }",
          "        $pipeServer.Dispose()",
          "        $asyncResult.AsyncWaitHandle.Close()",
          "    }",
          "",
          "    return $status",
          "}",
          "",
          "",
          "#",
          "# Function to release VSS freeze of EBS volume after snapshot is complete.",
          "#",
          "function EbsVssThaw() {",
          "",
          "    $namedPipe = \"8ef5c9e5-9c84-43eb-a8f7-c60b0efd7b72\"",
          "    $string = [string]::Empty",
          "",
          "    try {",
          "        $pipeClient = new-object System.IO.Pipes.NamedPipeClientStream(\".\",",
          "            $namedPipe, ",
          "            [System.IO.Pipes.PipeDirection]::In,",
          "            [System.IO.Pipes.PipeOptions]::Asynchronous)",
          "",
          "        # Wait for connection from provider indicating VSS freeze has completed",
          "        $pipeClient.Connect(10000)",
          "        try {",
          "            $pipeReader = new-object System.IO.StreamReader($pipeClient)",
          "            $string = $pipeReader.ReadLine()",
          "        } catch {",
          "            Write-Host \"Thaw pipe read failed\"",
          "            Write-Error  $_",
          "        } finally {",
          "            $pipeReader.Dispose()",
          "        }",
          "    } catch {",
          "        Write-Host \"Thaw pipe connection failed\"",
          "        Write-Error  $_",
          "    } finally {",
          "        $pipeClient.Dispose()",
          "    }",
          "",
          "    if ($string -like 'EBS done') {",
          "        return $true",
          "    } else {",
          "        return $false",
          "    }",
          "}",
          "",
          "#",
          "# Helper function to retrieve EC2 instance meta-data.",
          "#",
          "function Get-EC2InstanceMetadata {",
          "    param([string]$Path)",
          "",
          "    try {",
          "        ## Attempt v1 IMDS API",
          "        return Invoke-RestMethod -Method \"GET\" -URI \"http://169.254.169.254/latest/$Path\"",
          "    } catch {",
          "        ## IMDSv1 not supported, will attempt IMDSv2",
          "        $Token = [string](Invoke-RestMethod -Method \"PUT\" -URI \"http://169.254.169.254/latest/api/token\" `",
          "                    -Headers @{\"X-aws-ec2-metadata-token-ttl-seconds\"=\"1200\"})",
          "        $Headers = @{\"X-aws-ec2-metadata-token\"=$Token}",
          "        return Invoke-RestMethod -Method \"GET\" -URI \"http://169.254.169.254/latest/$Path\" -Headers $Headers",
          "    }",
          "}",
          "",
          "",
          "#",
          "# Helper function to convert SCSI target ID to xvd* EBS device name.",
          "#",
          "function Convert-SCSITargetIdToDeviceName {",
          "    param([int]$SCSITargetId)",
          "    If ($SCSITargetId -eq 0) {",
          "        return '/dev/sda1'",
          "    }",
          "    $deviceName = 'xvd'",
          "    If ($SCSITargetId -gt 25) {",
          "        $deviceName += [char](0x60 + [int]($SCSITargetId / 26))",
          "    }",
          "    $deviceName += [char](0x61 + $SCSITargetId % 26)",
          "    return $deviceName",
          "}",
          "",
          "",
          "#",
          "# Retrieve Storage Spaces drive mapping with EBS volume ID for C5 and newer instance types",
          "#",
          "function Get-AwsNvmeStorageSpacesEbsDiskMapping {",
          "    ",
          "    $disklist = @()",
          "    $physicalDisks = @()",
          "",
          "    # Exit if we are not on at least Server 2012",
          "    if (([Decimal]([environment]::OSVersion.Version).Major + [Decimal]([environment]::OSVersion.Version).Minor * .1) -lt 6.2) {",
          "        return $null",
          "    }",
          "",
          "    $physicalDisks += Get-PhysicalDisk | Where-Object {",
          "        $_.Manufacturer -match 'NVMe' -and $_.Model -match 'Amazon' -and",
          "        ( $_.SerialNumber -match $EBS_VOLUME_MATCH -or",
          "        ((Get-Member -InputObject $_ -Name \"AdapterSerialNumber\") -and $_.AdapterSerialNumber -match $EBS_VOLUME_MATCH2) )",
          "    }",
          "    ",
          "    if (!$physicalDisks -or ($physicalDisks.Count -eq 0)) {",
          "        return $null",
          "    }",
          "    ",
          "    $InstanceId = Get-EC2InstanceMetadata \"meta-data/instance-id\"",
          "",
          "    $BlockDeviceMapping = (Get-EC2Instance -Instance $InstanceId).Instances.BlockDeviceMappings",
          "",
          "    foreach ($pd in $physicalDisks) {",
          "",
          "        $pool1 = Get-StoragePool -PhysicalDisk $pd -IsPrimordial $False -ErrorAction SilentlyContinue",
          "",
          "        $volumeNumber = $pd.SerialNumber | Select-String $EBS_VOLUME_MATCH | % { $_.Matches } | % { $_.Value }",
          "        ",
          "        if ($volumeNumber -eq $null) {",
          "            $volumeNumber = $pd.AdapterSerialNumber | Select-String $EBS_VOLUME_MATCH2 | % { $_.Matches } | % { $_.Value }",
          "        }",
          "",
          "        $ebsVolumeId = \"vol-$volumeNumber\"",
          "        $matchingBlockDevice = $BlockDeviceMapping | Where-Object {($_.Ebs -ne $null) -and ($_.Ebs.VolumeId -eq $ebsVolumeId)}",
          "",
          "        foreach ($vd in Get-VirtualDisk) {",
          "            $pool2 = Get-StoragePool -VirtualDisk $vd",
          "            if (($pool1 -like $pool2) -and ($volumeNumber -ne $null)) {",
          "                $disk = ($vd | Get-Disk)",
          "                $parts = @($disk | Get-Partition)",
          "                foreach ($part in $parts) {",
          "                    $vol = ($part | Get-Volume)",
          "                    $isReadOnly = ($pool2.IsReadOnly -or $disk.IsReadOnly -or $part.IsReadOnly)",
          "                    $diskList += New-Object PSObject -Property @{",
          "                        Disk          = If ($pd -eq $null) { $null } Else { $pd.DeviceId };",
          "                        Partitions    = 0;",
          "                        DriveLetter   = If ($vol -eq $null) { $null } Else { ($vol.DriveLetter + ':') };",
          "                        EbsVolumeId   = If ($pd -eq $null) { $null } Else { $ebsVolumeId };",
          "                        Device        = If ($matchingBlockDevice -eq $null) { $pd.FriendlyName } Else { $matchingBlockDevice.DeviceName };",
          "                        VolumeName    = If ($vol -eq $null) { $null } Else { $vol.FileSystemLabel };",
          "                        IsReadOnly    = $isReadOnly;",
          "                    }",
          "                }",
          "            }",
          "        }",
          "    }",
          "",
          "    return $disklist",
          "}",
          "",
          "",
          "#",
          "# Retrieve EBS volumes associated with a Storage Spaces pool ",
          "#",
          "function Get-XenStorageSpacesEbsDiskMapping {",
          "    ",
          "    $disklist = @()",
          "    $physicalDisks = @()",
          "",
          "    # Older versions of XenVBD use the attachment point to determine serial number",
          "    $ATTACHMENT_ORDER_MATCH = '^(\\d{4})$'",
          "",
          "    # Exit if we are not on at least Server 2012",
          "    if (([Decimal]([environment]::OSVersion.Version).Major + [Decimal]([environment]::OSVersion.Version).Minor * .1) -lt 6.2) {",
          "        return $null",
          "    }",
          "",
          "    $physicalDisks += Get-PhysicalDisk | Where-Object {",
          "        ( ($_.SerialNumber -match $ATTACHMENT_ORDER_MATCH -and $_.SerialNumber -ne '0000') -or",
          "        $_.SerialNumber -match $EBS_VOLUME_MATCH2 ) -and",
          "        $_.Manufacturer -match 'AWS' -and $_.Model -match 'PVDISK'",
          "    }",
          "    ",
          "    if (!$physicalDisks -or ($physicalDisks.Count -eq 0)) {",
          "        return $null",
          "    }",
          "",
          "    $InstanceId = Get-EC2InstanceMetadata \"meta-data/instance-id\"",
          "",
          "    $BlockDeviceMapping = (Get-EC2Instance -Instance $InstanceId).Instances.BlockDeviceMappings",
          "",
          "    foreach ($pd in $physicalDisks) {",
          "        $volumeNumber = $pd.SerialNumber | Select-String $EBS_VOLUME_MATCH2 | % { $_.Matches } | % { $_.Value }",
          "        if ($volumeNumber -ne $null) {",
          "            $ebsVolumeId = \"vol-$volumeNumber\"",
          "            $device = $BlockDeviceMapping | Where-Object { $_.Ebs.VolumeId -eq $ebsVolumeId }",
          "            if ($device -ne $null) {",
          "                $BlockDeviceName = $device.DeviceName",
          "            }",
          "            else {",
          "                $ebsVolumeId = $null",
          "            }",
          "        }",
          "        elseif ($pd.SerialNumber -match $ATTACHMENT_ORDER_MATCH) {",
          "            $BlockDeviceName = Convert-SCSITargetIdToDeviceName $pd.SerialNumber",
          "            $device = $BlockDeviceMapping | Where-Object {$_.DeviceName -like (\"*\" + $BlockDeviceName)}",
          "            if ($device -ne $null) {",
          "                $ebsVolumeId = $device.Ebs.VolumeId",
          "            }",
          "            else {",
          "                $ebsVolumeId = $null",
          "            }",
          "        }",
          "        else {",
          "            $ebsVolumeId = $null",
          "        }",
          "",
          "        $pool1 = Get-StoragePool -PhysicalDisk $pd -IsPrimordial $False -ErrorAction SilentlyContinue",
          "",
          "        foreach ($vd in Get-VirtualDisk) {",
          "            $pool2 = Get-StoragePool -VirtualDisk $vd",
          "            if (($pool1 -like $pool2) -and ($ebsVolumeId -ne $null)) {",
          "                $disk = ($vd | Get-Disk)",
          "                $parts = @($disk | Get-Partition)",
          "                foreach ($part in $parts) {",
          "                    $vol = ($part | Get-Volume)",
          "                    $isReadOnly = ($pool2.IsReadOnly -or $disk.IsReadOnly -or $part.IsReadOnly)",
          "                    $diskList += New-Object PSObject -Property @{",
          "                        Disk          = If ($pd -eq $null) { $null } Else { $pd.DeviceId };",
          "                        Partitions    = 0;",
          "                        DriveLetter   = If ($vol -eq $null) { $null } Else { ($vol.DriveLetter + ':') };",
          "                        EbsVolumeId   = If ($pd -eq $null) { $null } Else { $ebsVolumeId };",
          "                        Device        = If ($pd -eq $null) { $null } Else { $device.DeviceName };",
          "                        VolumeName    = If ($vol -eq $null) { $null } Else { $vol.FileSystemLabel };",
          "                        IsReadOnly    = $isReadOnly;",
          "                    }",
          "                }",
          "            }",
          "        }",
          "    }",
          "",
          "    return $disklist",
          "}",
          "",
          "",
          "#",
          "# Helper function to collect connected EBS volumes attached to local EC2 instance.",
          "#",
          "function Get-EbsDiskMapping {",
          "",
          "    Try {",
          "        $InstanceId = Get-EC2InstanceMetadata \"meta-data/instance-id\"",
          "        $BlockDeviceMappings = (Get-EC2Instance -Instance $InstanceId).Instances.BlockDeviceMappings",
          "    } Catch {",
          "        Write-Host \"Could not access the AWS API, therefore, VolumeId is not available. ",
          "        Verify that your instance role has Describe-Instances permission.\" -ForegroundColor Yellow",
          "        throw",
          "    }",
          "",
          "    $diskList = Get-WmiObject -Class Win32_DiskDrive | ForEach-Object {",
          "        $DiskDrive = $_",
          "        $Volumes = Get-WmiObject -Query \"ASSOCIATORS OF {Win32_DiskDrive.DeviceID='$($DiskDrive.DeviceID)'} WHERE AssocClass=Win32_DiskDriveToDiskPartition\" | ForEach-Object {",
          "            $DiskPartition = $_",
          "            Get-WmiObject -Query \"ASSOCIATORS OF {Win32_DiskPartition.DeviceID='$($DiskPartition.DeviceID)'} WHERE AssocClass=Win32_LogicalDiskToPartition\"",
          "        }",
          "        $volumeNumber = $DiskDrive.SerialNumber | Select-String $EBS_VOLUME_MATCH | % { $_.Matches } | % { $_.Value }",
          "        if ($volumeNumber -eq $null) {",
          "            $volumeNumber = $DiskDrive.SerialNumber | Select-String $EBS_VOLUME_MATCH2 | % { $_.Matches } | % { $_.Value }",
          "        }",
          "        if ($volumeNumber -ne $null) {",
          "            $ebsVolumeId = \"vol-$volumeNumber\"",
          "            $BlockDevice = $BlockDeviceMappings | Where-Object { $_.Ebs.VolumeId -eq $ebsVolumeId }",
          "            if ($BlockDevice -ne $null) {",
          "                $BlockDeviceName = $BlockDevice.DeviceName",
          "            }",
          "        }",
          "        elseif ($DiskDrive.PNPDeviceID -like \"*PROD_PVDISK*\") {",
          "            $BlockDeviceName = Convert-SCSITargetIdToDeviceName($DiskDrive.SCSITargetId)",
          "            $BlockDevice = $BlockDeviceMappings | Where-Object { $_.DeviceName -like (\"*\" + $BlockDeviceName) }",
          "        }",
          "        else {",
          "            $BlockDeviceName = $null",
          "            $BlockDevice = $null",
          "        }",
          "",
          "        $foundWriteableVolume = $false",
          "        foreach ($volume in $Volumes) {",
          "            if ($volume.Access -ne 1) {",
          "                $foundWriteableVolume = $true",
          "            }",
          "        }",
          "",
          "        if ($BlockDevice -ne $null -and $BlockDevice.Ebs -ne $null) {",
          "            New-Object PSObject -Property @{",
          "                Disk          = $DiskDrive.Index;",
          "                Partitions    = $DiskDrive.Partitions;",
          "                DriveLetter   = If ($Volumes -eq $null) { $null } Else { $Volumes.DeviceID };",
          "                EbsVolumeId   = If ($BlockDevice -eq $null) { $null } Else { $BlockDevice.Ebs.VolumeId };",
          "                Device        = If ($BlockDeviceName -eq $null) { $null } Else { $BlockDeviceName };",
          "                VolumeName    = If ($Volumes -eq $null) { $null } Else { $Volumes.VolumeName };",
          "                IsReadOnly    = If (-not $foundWriteableVolume) { $true } Else { $false };",
          "            }",
          "        }",
          "    } | Sort-Object Disk",
          "",
          "    return $diskList",
          "}",
          "",
          "",
          "#",
          "# Get a mapping of the local drives to EBS volumes",
          "#",
          "function Get-EbsConnectedVolume",
          "{",
          "    $diskList = @()",
          "",
          "    # If any of the functions return $null it will be added to the disk list which we do not want!",
          "    $disks = Get-EbsDiskMapping",
          "    if ($disks) {",
          "        $diskList += $disks",
          "    }",
          "",
          "    $disks =  Get-XenStorageSpacesEbsDiskMapping",
          "    if ($disks) {",
          "        $diskList += $disks",
          "    }",
          "",
          "    $disks =  Get-AwsNvmeStorageSpacesEbsDiskMapping",
          "    if ($disks) {",
          "        $diskList += $disks",
          "    }",
          "",
          "    return $diskList",
          "}",
          "",
          "",
          "#",
          "# Complete the vss freeze",
          "#",
          "function VssFreeze() {",
          "    param(",
          "        [string[]]$Devices,",
          "        [string[]]$Volumes,",
          "        [boolean]$CopyOnly,",
          "        [boolean]$NoWriters,",
          "        [uint32]$waitForFreezeTimeout=180",
          "    )",
          "    if (!(Test-Path $vssAgentPath)) {",
          "        Write-Host 'ec2-vss-agent.exe is not installed. To install, run command AWS-ConfigureAWSPackage with package AwsVssComponents'",
          "        return $false",
          "    }",
          "",
          "    $volumeList = Get-EbsConnectedVolume",
          "",
          "    $DrivesToFreeze = @()",
          "    foreach ($v in $volumeList) {",
          "        if ( ($v.DriveLetter -ne $null)) {",
          "            if ((($v.Device -ne $null) -and ($Devices.Contains($v.Device)) -or  ($Devices.Contains('/dev/' + $v.Device))) -or",
          "                (($v.EbsVolumeId -ne $null) -and $Volumes.Contains($v.EbsVolumeId))) {  ",
          "                $DrivesToFreeze += $v.DriveLetter",
          "            }",
          "        }",
          "    }",
          "    if ($Devices.Contains(\"/dev/sda1\")) {",
          "        Write-Error \"Freeze of the root volume is not supported through this command, use AWSEC2-CreateVssSnapshot to include the root volume\"",
          "        return $false",
          "    }",
          "    if ($DrivesToFreeze.Count -eq 0) {",
          "        Write-Error \"No mounted EBS drives detected\"",
          "        return $false",
          "    }",
          "    $DrivesToFreezeString = ($DrivesToFreeze | sort -Unique) -join ' '",
          "    Write-Host \"Beginning Freeze for drives:\" $DrivesToFreezeString",
          "    ",
          "    return EbsVssFreeze $DrivesToFreezeString $CopyOnly $NoWriters $waitForFreezeTimeout",
          "}",
          "",
          "#",
          "# Complete the vss thaw",
          "#",
          "function VssThaw() {",
          "",
          "    $process = get-process \"ec2-vss-agent\" -ea SilentlyContinue",
          "    if (!$process) { ",
          "        Write-Host \"ec2-vss-agent is not running, Freeze command must be run first, and Thaw must run within 10 seconds of completion\" ",
          "        return $false",
          "    }",
          "",
          "    $AppConsistent = EbsVssThaw",
          "    if ($AppConsistent) {",
          "        Write-Host 'Thaw successful'",
          "    } else {",
          "        Write-Host 'Thaw unsuccessful, snapshots may not be app consistent, see event log for more details'",
          "    }",
          "",
          "    return $AppConsistent",
          "}",
          "",
          "",
          "",
          "",
          "",
          "$Action = \"{{Action}}\"",
          "Write-Host \"Starting AWSWindows-ManageVssIo $Action $(Get-Date)\"",
          "",
          "if ($Action -eq \"Freeze\") {",
          "    $DevicesString = '{{Devices}}'",
          "    $Devices = $DevicesString.Split(\",\").Trim()",
          "    $VolumesString = '{{Volumes}}'",
          "    $Volumes = $VolumesString.Split(\",\").Trim()",
          "    Write-Host $Devices",
          "    Write-Host $Volumes",
          "",
          "    [boolean]$CopyOnly = [System.Convert]::ToBoolean(\"{{CopyOnly}}\")",
          "",
          "    [boolean]$NoWriters = [System.Convert]::ToBoolean(\"{{NoWriters}}\")",
          "",
          "    [uint32]$executionTimeout = {{executionTimeout}}",
          "    [uint32]$waitForFreezeTimeout = $executionTimeout - 60",
          "",
          "    VssFreeze $Devices $Volumes $CopyOnly $NoWriters $waitForFreezetimeout",
          "} else {",
          "    $AppConsistent = VssThaw",
          "    exit [int](-not $AppConsistent)",
          "}",
          "",
          ""
        ]
      },
      "name": "runPowerShellScript",
      "action": "aws:runPowerShellScript",
      "precondition": {
        "StringEquals": [
          "platformType",
          "Windows"
        ]
      }
    }
  ]
}
