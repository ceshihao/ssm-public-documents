{
  "schemaVersion": "2.2",
  "description": "Perform VSS Freeze or Thaw operation to enable application consistent snapshots on an EC2 Windows instance. The caller is responsible for initiating EBS create snapshot after Freeze completion.",
  "parameters": {
    "executionTimeout": {
      "default": "800",
      "description": "(Optional) The time in seconds for this command to be completed before it is considered to have failed. Extending this timeout will cause the command to wait longer for VSS to start its freeze. Default is 800 seconds. Maximum is 172800 (48 hours). Minimum is 120. ",
      "type": "String",
      "allowedPattern": "^(1[2-9][0-9]{1})|([2-9][0-9]{2})|([1-9][0-9]{3,4})|(1[0-6][0-9]{4})|(17[0-1][0-9]{3})|(172[0-7][0-9]{2})|(172800)$"
    },
    "Action": {
      "allowedValues": [
        "Freeze",
        "Thaw"
      ],
      "default": "Freeze",
      "description": "(Required) Freeze operation will flush pending IO to the specified EBS volume and halt IO.  Thaw operation will resume IO to the EBS volume.  Thaw must be called within 10 seconds of Freeze completion.",
      "type": "String"
    },
    "Volumes": {
      "default": "",
      "description": "(Required for Freeze) Freeze IO to a comma delimited list of EBS volumes IDs. Example: vol-1234567812345678,vol-2234567812345678",
      "type": "String",
      "allowedPattern": "^ *([Vv][Oo][Ll]-[0-9a-zA-Z_]+( *, *[Vv][Oo][Ll]-[0-9a-zA-Z_]+)*)*$"
    },
    "Devices": {
      "default": "",
      "description": "(Required for Freeze) Freeze IO to a comma delimited list of device names. Example: xvdb,xvdc",
      "type": "String",
      "allowedPattern": "^[a-zA-Z0-9/, ]*$"
    },
    "CopyOnly": {
      "allowedValues": [
        "True",
        "False"
      ],
      "default": "False",
      "description": "(Optional) Select True to indicate a COPY ONLY backup operation.  By default a FULL backup operation is performed.  This option will prevent breaking the differential backup chain in SQL Server when performing a backup.",
      "type": "String"
    },
    "NoWriters": {
      "allowedValues": [
        "True",
        "False"
      ],
      "default": "False",
      "description": "(Optional) Select True to exclude application VSS writers from the snapshot process. This option may be useful to resolve conflicts with third party VSS backup solutions.",
      "type": "String"
    }
  },
  "mainSteps": [
    {
      "inputs": {
        "workingDirectory": "",
        "timeoutSeconds": "{{executionTimeout}}",
        "runCommand": [
          "Set-StrictMode -Version Latest",
          "$ErrorActionPreference = \"Stop\"",
          "trap {",
          "Write-Host \"Encountered unexpected error. Please see error details below\"",
          "$_.Exception | Format-List -Force",
          "$_.InvocationInfo | Format-List -Force",
          "[Environment]::Exit(1)",
          "}",
          "$EBS_VOLUME_MATCH = '(?<=vol)[0-9a-zA-Z]*(?= *_)'",
          "$EBS_VOLUME_MATCH2 = '(?<=vol)(.*)'",
          "$vssAgentPath = \"$env:ProgramFiles\\Amazon\\AwsVssComponents\\ec2-vss-agent.exe\"",
          "$vssPath = \"$env:ProgramFiles\\Amazon\\AwsVssComponents\\\"",
          "function EbsVssFreeze {",
          "param(",
          "[string]$driveLetter,",
          "[boolean]$CopyOnly,",
          "[boolean]$NoWriters,",
          "[uint32]$waitForFreezeTimeout=180",
          ")",
          "if ((get-process \"ec2-vss-agent\" -ea SilentlyContinue) -ne $Null) {",
          "Write-Host \"ec2-vss-agent is current running, snapshot already in progress.\"",
          "return $false",
          "}",
          "try {",
          "$namedPipe = '01C0026F-7357-49CD-BD74-657EAF079673'",
          "$pipeServer = new-object System.IO.Pipes.NamedPipeServerStream($namedPipe,",
          "[System.IO.Pipes.PipeDirection]::In,",
          "1,",
          "[System.IO.Pipes.PipeTransmissionMode]::Byte,",
          "[System.IO.Pipes.PipeOptions]::Asynchronous)",
          "$asyncResult = $pipeServer.WaitForConnectionAsync()",
          "Write-Host 'Pipe server started'",
          "} catch {",
          "Write-Host \"Pipe server failed to start. Possibly another instance of this script is running.\"",
          "return $false",
          "}",
          "$params = $driveLetter",
          "if ($copyOnly) {",
          "Write-Host \"Copy only option selected\"",
          "$params = \"-copy \" + $params",
          "}",
          "if ($noWriters) {",
          "Write-Host \"No writers option selected\"",
          "$params = \"-nw \" + $params",
          "}",
          "$process = Start-Process $vssAgentPath $params -PassThru",
          "if ($process -eq $null) {",
          "return $false",
          "}",
          "Write-Host 'Waiting for Freeze pipe'",
          "$status = $true",
          "try {",
          "if ($asyncResult.AsyncWaitHandle.WaitOne($waitForFreezeTimeout * 1000)){",
          "Write-Host 'Freeze pipe connected'",
          "$pipeReader = new-object System.IO.StreamReader($pipeServer)",
          "$string = $pipeReader.ReadLine()",
          "Write-Host 'EBS snapshot Freeze message received:' $string",
          "} else {",
          "Write-Host \"Timeout waiting for VSS Freeze. Consider increasing the executionTimeout parameter.\"",
          "$status = $false",
          "}",
          "} catch {",
          "Write-Host 'Freeze pipe read'",
          "Write-Error $_",
          "$status = $false",
          "} finally {",
          "Write-Host 'Disposing of pipes'",
          "if ((Test-Path variable:pipeReader) -and $pipeReader) { $pipeReader.Dispose() }",
          "$pipeServer.Dispose()",
          "$asyncResult.AsyncWaitHandle.Close()",
          "}",
          "return $status",
          "}",
          "function EbsVssThaw() {",
          "$namedPipe = \"8ef5c9e5-9c84-43eb-a8f7-c60b0efd7b72\"",
          "$string = [string]::Empty",
          "try {",
          "$pipeClient = new-object System.IO.Pipes.NamedPipeClientStream(\".\",",
          "$namedPipe,",
          "[System.IO.Pipes.PipeDirection]::In,",
          "[System.IO.Pipes.PipeOptions]::Asynchronous)",
          "$pipeClient.Connect(10000)",
          "try {",
          "$pipeReader = new-object System.IO.StreamReader($pipeClient)",
          "$string = $pipeReader.ReadLine()",
          "} catch {",
          "Write-Host \"Thaw pipe read failed\"",
          "Write-Error $_",
          "} finally {",
          "$pipeReader.Dispose()",
          "}",
          "} catch {",
          "Write-Host \"Thaw pipe connection failed\"",
          "Write-Error $_",
          "} finally {",
          "$pipeClient.Dispose()",
          "}",
          "if ($string -like 'EBS done') {",
          "return $true",
          "} else {",
          "return $false",
          "}",
          "}",
          "function Get-EC2InstanceId {",
          "return $env:AWS_SSM_INSTANCE_ID",
          "}",
          "function Convert-SCSITargetIdToDeviceName {",
          "param([int]$SCSITargetId)",
          "If ($SCSITargetId -eq 0) {",
          "return '/dev/sda1'",
          "}",
          "$deviceName = 'xvd'",
          "If ($SCSITargetId -gt 25) {",
          "$deviceName += [char](0x60 + [int]($SCSITargetId / 26))",
          "}",
          "$deviceName += [char](0x61 + $SCSITargetId % 26)",
          "return $deviceName",
          "}",
          "function Get-DynamicDiskPartitionsOnEBSVolumes {",
          "Try {",
          "$InstanceId = Get-EC2InstanceId",
          "$BlockDeviceMappings = (Get-EC2Instance -Instance $InstanceId).Instances.BlockDeviceMappings",
          "} Catch {",
          "Write-Host \"Could not access the AWS API, therefore, VolumeId is not available.",
          "Verify that your instance role has Describe-Instances permission.\" -ForegroundColor Yellow",
          "throw",
          "}",
          "$diskList = Get-WmiObject -Class Win32_DiskDrive | ForEach-Object {",
          "$DiskDrive = $_",
          "$LogicalDiskManagerPartitions = Get-WmiObject -Query \"ASSOCIATORS OF {Win32_DiskDrive.DeviceID='$($DiskDrive.DeviceID)'} WHERE AssocClass=Win32_DiskDriveToDiskPartition\" | Where {$_.Type -match \"Logical Disk Manager\"}",
          "if (-not $LogicalDiskManagerPartitions) {",
          "return",
          "}",
          "$Volumes = $LogicalDiskManagerPartitions | ForEach-Object {",
          "$DiskPartition = $_",
          "Get-WmiObject -Query \"ASSOCIATORS OF {Win32_DiskPartition.DeviceID='$($DiskPartition.DeviceID)'} WHERE AssocClass=Win32_LogicalDiskToPartition\"",
          "}",
          "$volumeNumber = $DiskDrive.SerialNumber | Select-String $EBS_VOLUME_MATCH | % { $_.Matches } | % { $_.Value }",
          "if ($volumeNumber -eq $null) {",
          "$volumeNumber = $DiskDrive.SerialNumber | Select-String $EBS_VOLUME_MATCH2 | % { $_.Matches } | % { $_.Value }",
          "}",
          "if ($volumeNumber -ne $null) {",
          "$ebsVolumeId = \"vol-$volumeNumber\"",
          "$BlockDevice = $BlockDeviceMappings | Where-Object { $_.Ebs.VolumeId -eq $ebsVolumeId }",
          "if ($BlockDevice -ne $null) {",
          "$BlockDeviceName = $BlockDevice.DeviceName",
          "}",
          "}",
          "elseif ($DiskDrive.PNPDeviceID -like \"*PROD_PVDISK*\") {",
          "$BlockDeviceName = Convert-SCSITargetIdToDeviceName($DiskDrive.SCSITargetId)",
          "$BlockDevice = $BlockDeviceMappings | Where-Object { $_.DeviceName -like (\"*\" + $BlockDeviceName) }",
          "}",
          "else {",
          "$BlockDeviceName = $null",
          "$BlockDevice = $null",
          "}",
          "$foundWriteableVolume = $false",
          "foreach ($volume in $Volumes) {",
          "if ($volume.Access -ne 1) {",
          "$foundWriteableVolume = $true",
          "}",
          "}",
          "if ($BlockDevice -ne $null -and $BlockDevice.Ebs -ne $null) {",
          "New-Object PSObject -Property @{",
          "Disk = $DiskDrive.Index;",
          "Partitions = $DiskDrive.Partitions;",
          "AccessPath = If ($Volumes -eq $null) { $null } Else { $Volumes.DeviceID };",
          "EbsVolumeId = If ($BlockDevice -eq $null) { $null } Else { $BlockDevice.Ebs.VolumeId };",
          "Device = If ($BlockDeviceName -eq $null) { $null } Else { $BlockDeviceName };",
          "VolumeName = If ($Volumes -eq $null) { $null } Else { $Volumes.VolumeName };",
          "IsReadOnly = If (-not $foundWriteableVolume) { $true } Else { $false };",
          "}",
          "}",
          "} | Sort-Object Disk",
          "return $diskList",
          "}",
          "function Get-AwsNvmeStorageSpacesEbsDiskMapping {",
          "$disklist = @()",
          "$physicalDisks = @()",
          "$physicalDisks += Get-PhysicalDisk | Where-Object {",
          "(($_.Manufacturer -match 'NVMe') -and ($_.Model -match 'Amazon') -and",
          "($_.SerialNumber -match $EBS_VOLUME_MATCH)) -or",
          "((Get-Member -InputObject $_ -Name \"AdapterSerialNumber\") -and ($_.AdapterSerialNumber -match $EBS_VOLUME_MATCH2))",
          "}",
          "if (!$physicalDisks -or ($physicalDisks.Count -eq 0)) {",
          "return $null",
          "}",
          "$InstanceId = Get-EC2InstanceId",
          "$BlockDeviceMapping = (Get-EC2Instance -Instance $InstanceId).Instances.BlockDeviceMappings",
          "foreach ($pd in $physicalDisks) {",
          "$pool1 = Get-StoragePool -PhysicalDisk $pd -IsPrimordial $False -ErrorAction SilentlyContinue",
          "$volumeNumber = $pd.SerialNumber | Select-String $EBS_VOLUME_MATCH | % { $_.Matches } | % { $_.Value }",
          "if ($volumeNumber -eq $null) {",
          "$volumeNumber = $pd.AdapterSerialNumber | Select-String $EBS_VOLUME_MATCH2 | % { $_.Matches } | % { $_.Value }",
          "}",
          "$ebsVolumeId = \"vol-$volumeNumber\"",
          "$matchingBlockDevice = $BlockDeviceMapping | Where-Object {($_.Ebs -ne $null) -and ($_.Ebs.VolumeId -eq $ebsVolumeId)}",
          "foreach ($vd in Get-VirtualDisk) {",
          "$pool2 = Get-StoragePool -VirtualDisk $vd",
          "if (($pool1 -like $pool2) -and ($volumeNumber -ne $null)) {",
          "$disk = ($vd | Get-Disk)",
          "$parts = @($disk | Get-Partition | Where-Object -Property Type -NE Reserved | Where-Object -Property Type -NE \"XINT13 Extended\")",
          "foreach ($part in $parts) {",
          "$vol = ($part | Get-Volume)",
          "$isReadOnly = ($pool2.IsReadOnly -or $disk.IsReadOnly -or $part.IsReadOnly)",
          "$diskList += New-Object PSObject -Property @{",
          "Disk = If ($pd -eq $null) { $null } Else { $pd.DeviceId };",
          "Partitions = 0;",
          "AccessPath = If ($vol -ne $null -and $vol.DriveLetter) { ($vol.DriveLetter + ':') } elseif ($part.AccessPaths) { $part.AccessPaths[0] } else { $null };",
          "EbsVolumeId = If ($pd -eq $null) { $null } Else { $ebsVolumeId };",
          "Device = If ($matchingBlockDevice -eq $null) { $pd.FriendlyName } Else { $matchingBlockDevice.DeviceName };",
          "VolumeName = If ($vol -eq $null) { $null } Else { $vol.FileSystemLabel };",
          "IsReadOnly = $isReadOnly;",
          "}",
          "}",
          "}",
          "}",
          "}",
          "return $disklist",
          "}",
          "function Get-XenStorageSpacesEbsDiskMapping {",
          "$disklist = @()",
          "$physicalDisks = @()",
          "$ATTACHMENT_ORDER_MATCH = '^(\\d{4})$'",
          "$physicalDisks += Get-PhysicalDisk | Where-Object {",
          "($_.SerialNumber -match $ATTACHMENT_ORDER_MATCH -and $_.SerialNumber -ne '0000') -or",
          "(($_.SerialNumber -match $EBS_VOLUME_MATCH2) -and",
          "($_.Manufacturer -match 'AWS' -and $_.Model -match 'PVDISK'))",
          "}",
          "if (!$physicalDisks -or ($physicalDisks.Count -eq 0)) {",
          "return $null",
          "}",
          "$InstanceId = Get-EC2InstanceId",
          "$BlockDeviceMapping = (Get-EC2Instance -Instance $InstanceId).Instances.BlockDeviceMappings",
          "foreach ($pd in $physicalDisks) {",
          "$volumeNumber = $pd.SerialNumber | Select-String $EBS_VOLUME_MATCH2 | % { $_.Matches } | % { $_.Value }",
          "if ($volumeNumber -ne $null) {",
          "$ebsVolumeId = \"vol-$volumeNumber\"",
          "$device = $BlockDeviceMapping | Where-Object { $_.Ebs.VolumeId -eq $ebsVolumeId }",
          "if ($device -ne $null) {",
          "$BlockDeviceName = $device.DeviceName",
          "}",
          "else {",
          "Write-Host \"Found disk with unrecognized volume id: $ebsVolumeId. Ignoring as instance store\"",
          "$BlockDeviceName = $null",
          "$ebsVolumeId = $null",
          "}",
          "}",
          "elseif ($pd.SerialNumber -match $ATTACHMENT_ORDER_MATCH) {",
          "$BlockDeviceName = Convert-SCSITargetIdToDeviceName $pd.SerialNumber",
          "$device = $BlockDeviceMapping | Where-Object {$_.DeviceName -like (\"*\" + $BlockDeviceName)}",
          "if ($device -ne $null) {",
          "$ebsVolumeId = $device.Ebs.VolumeId",
          "}",
          "else {",
          "Write-Host \"Found disk with unrecognized block device: $BlockDeviceName. Ignoring as instance store\"",
          "$ebsVolumeId = $null",
          "}",
          "}",
          "else {",
          "Write-Host \"Found disk with unrecognized serial number: $($pd.SerialNumber). Will ignore.\"",
          "$BlockDeviceName = $null",
          "$ebsVolumeId = $null",
          "}",
          "$pool1 = Get-StoragePool -PhysicalDisk $pd -IsPrimordial $False -ErrorAction SilentlyContinue",
          "foreach ($vd in Get-VirtualDisk) {",
          "$pool2 = Get-StoragePool -VirtualDisk $vd",
          "if (($pool1 -like $pool2) -and ($ebsVolumeId -ne $null)) {",
          "$disk = ($vd | Get-Disk)",
          "$parts = @($disk | Get-Partition | Where-Object -Property Type -NE Reserved | Where-Object -Property Type -NE \"XINT13 Extended\")",
          "foreach ($part in $parts) {",
          "$vol = ($part | Get-Volume)",
          "$isReadOnly = ($pool2.IsReadOnly -or $disk.IsReadOnly -or $part.IsReadOnly)",
          "$diskList += New-Object PSObject -Property @{",
          "Disk = If ($pd -eq $null) { $null } Else { $pd.DeviceId };",
          "Partitions = 0;",
          "AccessPath = If ($vol -ne $null -and $vol.DriveLetter) { ($vol.DriveLetter + ':') } elseif ($part.AccessPaths) { $part.AccessPaths[0] } else { $null };",
          "EbsVolumeId = If ($pd -eq $null) { $null } Else { $ebsVolumeId };",
          "Device = If ($pd -eq $null) { $null } Else { $BlockDeviceName };",
          "VolumeName = If ($vol -eq $null) { $null } Else { $vol.FileSystemLabel };",
          "IsReadOnly = $isReadOnly;",
          "}",
          "}",
          "}",
          "}",
          "}",
          "return $disklist",
          "}",
          "function Get-EbsDiskMapping {",
          "$disklist = @()",
          "$physicalDisks = @()",
          "$ATTACHMENT_ORDER_MATCH = '^(\\d{4})$'",
          "$physicalDisks += Get-PhysicalDisk | Where-Object {",
          "($_.SerialNumber -match $ATTACHMENT_ORDER_MATCH) -or",
          "(($_.SerialNumber -match $EBS_VOLUME_MATCH2) -and",
          "($_.Manufacturer -match 'AWS' -and $_.Model -match 'PVDISK')) -or",
          "($_.SerialNumber -match $EBS_VOLUME_MATCH)",
          "}",
          "if (!$physicalDisks -or ($physicalDisks.Count -eq 0)) {",
          "return $null",
          "}",
          "$InstanceId = Get-EC2InstanceId",
          "$BlockDeviceMapping = (Get-EC2Instance -Instance $InstanceId).Instances.BlockDeviceMappings",
          "foreach ($pd in $physicalDisks) {",
          "$volumeNumber = $pd.SerialNumber | Select-String $EBS_VOLUME_MATCH | % { $_.Matches } | % { $_.Value }",
          "if ($volumeNumber -eq $null) {",
          "$volumeNumber = $pd.SerialNumber | Select-String $EBS_VOLUME_MATCH2 | % { $_.Matches } | % { $_.Value }",
          "}",
          "if ($volumeNumber -ne $null) {",
          "$ebsVolumeId = \"vol-$volumeNumber\"",
          "$device = $BlockDeviceMapping | Where-Object { $_.Ebs.VolumeId -eq $ebsVolumeId }",
          "if ($device -ne $null) {",
          "$BlockDeviceName = $device.DeviceName",
          "}",
          "else {",
          "Write-Host \"Found disk with unrecognized volume id: $ebsVolumeId. Ignoring as instance store\"",
          "$BlockDeviceName = $null",
          "$ebsVolumeId = $null",
          "}",
          "}",
          "elseif ($pd.SerialNumber -match $ATTACHMENT_ORDER_MATCH) {",
          "$BlockDeviceName = Convert-SCSITargetIdToDeviceName $pd.SerialNumber",
          "$device = $BlockDeviceMapping | Where-Object {$_.DeviceName -like (\"*\" + $BlockDeviceName)}",
          "if ($device -ne $null) {",
          "$ebsVolumeId = $device.Ebs.VolumeId",
          "}",
          "else {",
          "Write-Host \"Found disk with unrecognized block device: $BlockDeviceName. Ignoring as instance store\"",
          "$ebsVolumeId = $null",
          "}",
          "}",
          "else {",
          "Write-Host \"Found disk with unrecognized serial number: $($pd.SerialNumber). Will ignore.\"",
          "$BlockDeviceName = $null",
          "$ebsVolumeId = $null",
          "}",
          "$disk = ($pd | Get-Disk -ErrorAction Ignore) ",
          "$parts = @($disk | Get-Partition | Where-Object -Property Type -NE Reserved | Where-Object -Property Type -NE \"XINT13 Extended\")",
          "foreach ($part in $parts) {",
          "$vol = ($part | Get-Volume)",
          "$isReadOnly = ($disk.IsReadOnly -or $part.IsReadOnly)",
          "$diskList += New-Object PSObject -Property @{",
          "Disk = If ($pd -eq $null) { $null } Else { $pd.DeviceId };",
          "Partitions = 0;",
          "AccessPath = If ($vol -ne $null -and $vol.DriveLetter) { ($vol.DriveLetter + ':') } elseif ($part.AccessPaths) { $part.AccessPaths[0] } else { $null };",
          "EbsVolumeId = If ($pd -eq $null) { $null } Else { $ebsVolumeId };",
          "Device = If ($pd -eq $null) { $null } Else { $BlockDeviceName };",
          "VolumeName = If ($vol -eq $null) { $null } Else { $vol.FileSystemLabel };",
          "IsReadOnly = $isReadOnly;",
          "}",
          "}",
          "}",
          "return $disklist",
          "}",
          "function Get-EbsConnectedVolume",
          "{",
          "$diskList = @()",
          "$disks = Get-EbsDiskMapping",
          "if ($disks) {",
          "$diskList += $disks",
          "}",
          "$disks = Get-XenStorageSpacesEbsDiskMapping",
          "if ($disks) {",
          "$diskList += $disks",
          "}",
          "$disks = Get-AwsNvmeStorageSpacesEbsDiskMapping",
          "if ($disks) {",
          "$diskList += $disks",
          "}",
          "$disks = Get-DynamicDiskPartitionsOnEBSVolumes",
          "if ($disks) {",
          "$diskList += $disks",
          "}",
          "return $diskList",
          "}",
          "function Get-OSVersionNumber {",
          "return ([Decimal]([environment]::OSVersion.Version).Major + [Decimal]([environment]::OSVersion.Version).Minor * .1)",
          "}",
          "function VssFreeze() {",
          "param(",
          "[string[]]$Devices,",
          "[string[]]$Volumes,",
          "[boolean]$CopyOnly,",
          "[boolean]$NoWriters,",
          "[uint32]$waitForFreezeTimeout=180",
          ")",
          "if ((Get-OSVersionNumber) -lt 6.2) {",
          "Write-Host \"Error: Must be running on Windows Server 2012 or later. Please target an older version of this document.\"",
          "Write-Host \"For more details see: https://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/application-consistent-snapshots-prereqs.html\"",
          "return $false",
          "}",
          "if (!(Test-Path $vssAgentPath)) {",
          "Write-Host 'ec2-vss-agent.exe is not installed. To install, run command AWS-ConfigureAWSPackage with package AwsVssComponents'",
          "return $false",
          "}",
          "$volumeList = Get-EbsConnectedVolume",
          "$DrivesToFreeze = @()",
          "foreach ($v in $volumeList) {",
          "if ( ($v.AccessPath -ne $null)) {",
          "if ((($v.Device -ne $null) -and ($Devices.Contains($v.Device)) -or ($Devices.Contains('/dev/' + $v.Device))) -or",
          "(($v.EbsVolumeId -ne $null) -and $Volumes.Contains($v.EbsVolumeId))) {",
          "$DrivesToFreeze += $v.AccessPath",
          "}",
          "}",
          "}",
          "if ($Devices.Contains(\"/dev/sda1\")) {",
          "Write-Error \"Freeze of the root volume is not supported through this command, use AWSEC2-CreateVssSnapshot to include the root volume\"",
          "return $false",
          "}",
          "if ($DrivesToFreeze.Count -eq 0) {",
          "Write-Error \"No mounted EBS drives detected\"",
          "return $false",
          "}",
          "$DrivesToFreezeString = ($DrivesToFreeze | sort -Unique) -join ' '",
          "Write-Host \"Beginning Freeze for drives:\" $DrivesToFreezeString",
          "return EbsVssFreeze $DrivesToFreezeString $CopyOnly $NoWriters $waitForFreezeTimeout",
          "}",
          "function VssThaw() {",
          "$process = get-process \"ec2-vss-agent\" -ea SilentlyContinue",
          "if (!$process) {",
          "Write-Host \"ec2-vss-agent is not running, Freeze command must be run first, and Thaw must run within 10 seconds of completion\"",
          "return $false",
          "}",
          "$AppConsistent = EbsVssThaw",
          "if ($AppConsistent) {",
          "Write-Host 'Thaw successful'",
          "} else {",
          "Write-Host 'Thaw unsuccessful, snapshots may not be app consistent, see event log for more details'",
          "}",
          "return $AppConsistent",
          "}",
          "",
          "$Action = \"{{Action}}\"",
          "Write-Host \"Starting AWSWindows-ManageVssIo $Action $(Get-Date)\"",
          "",
          "if ($Action -eq \"Freeze\") {",
          "    $DevicesString = '{{Devices}}'",
          "    $Devices = $DevicesString.Split(\",\").Trim()",
          "    $VolumesString = '{{Volumes}}'",
          "    $Volumes = $VolumesString.Split(\",\").Trim()",
          "    Write-Host $Devices",
          "    Write-Host $Volumes",
          "",
          "    [boolean]$CopyOnly = [System.Convert]::ToBoolean(\"{{CopyOnly}}\")",
          "",
          "    [boolean]$NoWriters = [System.Convert]::ToBoolean(\"{{NoWriters}}\")",
          "",
          "    [uint32]$executionTimeout = {{executionTimeout}}",
          "    [uint32]$waitForFreezeTimeout = $executionTimeout - 60",
          "",
          "    VssFreeze $Devices $Volumes $CopyOnly $NoWriters $waitForFreezetimeout",
          "} else {",
          "    $AppConsistent = VssThaw",
          "    exit [int](-not $AppConsistent)",
          "}",
          "",
          ""
        ]
      },
      "name": "runPowerShellScript",
      "action": "aws:runPowerShellScript",
      "precondition": {
        "StringEquals": [
          "platformType",
          "Windows"
        ]
      }
    }
  ]
}
