{
  "schemaVersion": "2.2",
  "description": "Perform VSS Freeze or Thaw operation to enable application consistent snapshots on an EC2 Windows instance. The caller is responsible for initiating EBS create snapshot after Freeze completion.",
  "parameters": {
    "executionTimeout": {
      "default": "800",
      "description": "(Optional) The time in seconds for this command to be completed before it is considered to have failed. Extending this timeout will cause the command to wait longer for VSS to start its freeze. Default is 800 seconds. Maximum is 172800 (48 hours). Minimum is 120.",
      "type": "String",
      "allowedPattern": "^(1[2-9][0-9]{1})|([2-9][0-9]{2})|([1-9][0-9]{3,4})|(1[0-6][0-9]{4})|(17[0-1][0-9]{3})|(172[0-7][0-9]{2})|(172800)$"
    },
    "Action": {
      "allowedValues": [
        "Freeze",
        "Thaw"
      ],
      "default": "Freeze",
      "description": "(Required) Freeze operation will flush pending IO to the specified EBS volume and halt IO.  Thaw operation will resume IO to the EBS volume.  Thaw must be called within 10 seconds of Freeze completion.",
      "type": "String"
    },
    "Volumes": {
      "default": "",
      "description": "(Required for Freeze) Freeze IO to a comma delimited list of EBS volumes IDs. Example: vol-1234567812345678,vol-2234567812345678",
      "type": "String",
      "allowedPattern": "^ *([Vv][Oo][Ll]-[0-9a-zA-Z_]+( *, *[Vv][Oo][Ll]-[0-9a-zA-Z_]+)*)*$"
    },
    "Devices": {
      "default": "",
      "description": "(Required for Freeze) Freeze IO to a comma delimited list of device names. Example: xvdb,xvdc",
      "type": "String",
      "allowedPattern": "^[a-zA-Z0-9/, ]*$"
    },
    "CopyOnly": {
      "allowedValues": [
        "True",
        "False"
      ],
      "default": "False",
      "description": "(Optional) Select True to indicate a COPY ONLY backup operation.  By default a FULL backup operation is performed.  This option will prevent breaking the differential backup chain in SQL Server when performing a backup.",
      "type": "String"
    },
    "NoWriters": {
      "allowedValues": [
        "True",
        "False"
      ],
      "default": "False",
      "description": "(Optional) Select True to exclude application VSS writers from the snapshot process. This option may be useful to resolve conflicts with third party VSS backup solutions.",
      "type": "String"
    }
  },
  "mainSteps": [
    {
      "inputs": {
        "workingDirectory": "",
        "timeoutSeconds": "{{executionTimeout}}",
        "runCommand": [
          "# Copyright 2017-2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.",
          "",
          "Set-StrictMode -Version Latest",
          "$ErrorActionPreference = \"Stop\"",
          "",
          "# PowerShell does not necessarily set the exit code as 1 in the event of exception.",
          "# In order to ensure Run Command reports the correct status, we must set the exit code.",
          "trap {",
          "    Write-Host \"Encountered unexpected error. Please see error details below\"",
          "    $_.Exception | Format-List -Force",
          "    $_.InvocationInfo | Format-List -Force",
          "    [Environment]::Exit(1)",
          "}",
          "",
          "# Matches NVMe EBS volumes SerialNumber. E.g. vol123456789abcd_000001",
          "# Also matches cases where there are spaces between the volume id and namespace id E.g. 'vol1234567     _000001'",
          "$EBS_VOLUME_MATCH = '(?<=vol)[0-9a-zA-Z]*(?= *_)'",
          "# Matches PV 8.2.3+ disks SerialNumber and NVMe EBS volumes AdapterSerialNumber. E.g. vol123456789abcd",
          "$EBS_VOLUME_MATCH2 = '(?<=vol)(.*)'",
          "",
          "$vssAgentPath = \"$env:ProgramFiles\\Amazon\\AwsVssComponents\\ec2-vss-agent.exe\"",
          "$vssPath = \"$env:ProgramFiles\\Amazon\\AwsVssComponents\\\"",
          "",
          "#",
          "# Function to begin the VSS snapshot of a EBS volume",
          "#",
          "function EbsVssFreeze {",
          "    param(",
          "        [string]$driveLetter,",
          "        [boolean]$CopyOnly,",
          "        [boolean]$NoWriters,",
          "        [uint32]$waitForFreezeTimeout=180",
          "    )",
          "",
          "    # We have two methods to prevent re-entrace. First we check if the VSS Agent is running.  Second",
          "    # if the named pipe server creation fails we know another instance of this script is running.",
          "    if ((get-process \"ec2-vss-agent\" -ea SilentlyContinue) -ne $Null) { ",
          "        Write-Host \"ec2-vss-agent is current running, snapshot already in progress.\" ",
          "        return $false",
          "    }",
          "",
          "    try {",
          "        $namedPipe = '01C0026F-7357-49CD-BD74-657EAF079673'",
          "        $pipeServer = new-object System.IO.Pipes.NamedPipeServerStream($namedPipe, ",
          "            [System.IO.Pipes.PipeDirection]::In,",
          "            1,",
          "            [System.IO.Pipes.PipeTransmissionMode]::Byte,",
          "            [System.IO.Pipes.PipeOptions]::Asynchronous)",
          "",
          "        $asyncResult = $pipeServer.WaitForConnectionAsync()",
          "",
          "        Write-Host 'Pipe server started'",
          "    } catch {",
          "        Write-Host \"Pipe server failed to start.  Possibly another instance of this script is running.\"",
          "        return $false",
          "    }",
          "",
          "    $params = $driveLetter",
          "",
          "    if ($copyOnly) {",
          "        Write-Host \"Copy only option selected\"",
          "        $params = \"-copy \" + $params",
          "    }",
          "",
          "    if ($noWriters) {",
          "        Write-Host \"No writers option selected\"",
          "        $params = \"-nw \" + $params",
          "    }",
          "",
          "    $process = Start-Process $vssAgentPath $params -PassThru",
          "    if ($process -eq $null) {",
          "        return $false",
          "    }",
          "",
          "    Write-Host 'Waiting for Freeze pipe'",
          "",
          "    #",
          "    # Wait up to $waitForFreezeTimeout seconds for connection from provider indicating VSS freeze has begun",
          "    #",
          "    $status = $true",
          "    try {",
          "        if ($asyncResult.AsyncWaitHandle.WaitOne($waitForFreezeTimeout * 1000)){",
          "            Write-Host 'Freeze pipe connected'",
          "            $pipeReader = new-object System.IO.StreamReader($pipeServer)",
          "            $string = $pipeReader.ReadLine()",
          "            Write-Host 'EBS snapshot Freeze message received:' $string",
          "        } else {",
          "            Write-Host \"Timeout waiting for VSS Freeze. Consider increasing the executionTimeout parameter.\"",
          "            $status = $false",
          "        }",
          "    } catch {",
          "        Write-Host 'Freeze pipe read'",
          "        Write-Error  $_",
          "        $status = $false",
          "    } finally {",
          "        Write-Host 'Disposing of pipes'",
          "        if ((Test-Path variable:pipeReader) -and $pipeReader) { $pipeReader.Dispose() }",
          "        $pipeServer.Dispose()",
          "        $asyncResult.AsyncWaitHandle.Close()",
          "    }",
          "",
          "    return $status",
          "}",
          "",
          "",
          "#",
          "# Function to release VSS freeze of EBS volume after snapshot is complete.",
          "#",
          "function EbsVssThaw() {",
          "",
          "    $namedPipe = \"8ef5c9e5-9c84-43eb-a8f7-c60b0efd7b72\"",
          "    $string = [string]::Empty",
          "",
          "    try {",
          "        $pipeClient = new-object System.IO.Pipes.NamedPipeClientStream(\".\",",
          "            $namedPipe, ",
          "            [System.IO.Pipes.PipeDirection]::In,",
          "            [System.IO.Pipes.PipeOptions]::Asynchronous)",
          "",
          "        # Wait for connection from provider indicating VSS freeze has completed",
          "        $pipeClient.Connect(10000)",
          "        try {",
          "            $pipeReader = new-object System.IO.StreamReader($pipeClient)",
          "            $string = $pipeReader.ReadLine()",
          "        } catch {",
          "            Write-Host \"Thaw pipe read failed\"",
          "            Write-Error  $_",
          "        } finally {",
          "            $pipeReader.Dispose()",
          "        }",
          "    } catch {",
          "        Write-Host \"Thaw pipe connection failed\"",
          "        Write-Error  $_",
          "    } finally {",
          "        $pipeClient.Dispose()",
          "    }",
          "",
          "    if ($string -like 'EBS done') {",
          "        return $true",
          "    } else {",
          "        return $false",
          "    }",
          "}",
          "",
          "#",
          "# Helper function to retrieve EC2 instance meta-data.",
          "#",
          "function Get-EC2InstanceMetadata {",
          "    param([string]$Path)",
          "",
          "    try {",
          "        ## Attempt v1 IMDS API",
          "        return Invoke-RestMethod -Method \"GET\" -URI \"http://169.254.169.254/latest/$Path\"",
          "    } catch {",
          "        ## IMDSv1 not supported, will attempt IMDSv2",
          "        $Token = [string](Invoke-RestMethod -Method \"PUT\" -URI \"http://169.254.169.254/latest/api/token\" `",
          "                    -Headers @{\"X-aws-ec2-metadata-token-ttl-seconds\"=\"1200\"})",
          "        $Headers = @{\"X-aws-ec2-metadata-token\"=$Token}",
          "        return Invoke-RestMethod -Method \"GET\" -URI \"http://169.254.169.254/latest/$Path\" -Headers $Headers",
          "    }",
          "}",
          "",
          "",
          "#",
          "# Helper function to convert SCSI target ID to xvd* EBS device name.",
          "#",
          "function Convert-SCSITargetIdToDeviceName {",
          "    param([int]$SCSITargetId)",
          "    If ($SCSITargetId -eq 0) {",
          "        return '/dev/sda1'",
          "    }",
          "    $deviceName = 'xvd'",
          "    If ($SCSITargetId -gt 25) {",
          "        $deviceName += [char](0x60 + [int]($SCSITargetId / 26))",
          "    }",
          "    $deviceName += [char](0x61 + $SCSITargetId % 26)",
          "    return $deviceName",
          "}",
          "",
          "",
          "#",
          "# Retrieve Mapping for Dynamic Disks specifically. The Windows Storage Management APIs",
          "# cannot detect Dynamic Disks, and Dynamic Disks are deprecated, so we use the WMI instead.",
          "#",
          "function Get-DynamicDiskPartitionsOnEBSVolumes {",
          "",
          "    Try {",
          "        $InstanceId = Get-EC2InstanceMetadata \"meta-data/instance-id\"",
          "        $BlockDeviceMappings = (Get-EC2Instance -Instance $InstanceId).Instances.BlockDeviceMappings",
          "    } Catch {",
          "        Write-Host \"Could not access the AWS API, therefore, VolumeId is not available. ",
          "        Verify that your instance role has Describe-Instances permission.\" -ForegroundColor Yellow",
          "        throw",
          "    }",
          "",
          "    $diskList = Get-WmiObject -Class Win32_DiskDrive | ForEach-Object {",
          "        $DiskDrive = $_",
          "        ",
          "        # We are looking for partition types that indicate the presence of Dynamic Disks, which are:",
          "        #   MBR Partition Type 0x42, which the WMI returns as \"Logical Disk Manager\"",
          "        #   GPT Partition Type af9b60a0-1431-4f62-bc68-3311714a69ad, which the WMI returns as \"GPT: Logical Disk Manager Data\"",
          "        $LogicalDiskManagerPartitions = Get-WmiObject -Query \"ASSOCIATORS OF {Win32_DiskDrive.DeviceID='$($DiskDrive.DeviceID)'} WHERE AssocClass=Win32_DiskDriveToDiskPartition\" | Where {$_.Type -match \"Logical Disk Manager\"}",
          "        if (-not $LogicalDiskManagerPartitions) {",
          "            # Because this function processes the same physical disk objects as Get-EbsDiskMapping, we do not",
          "            # need to return \"empty\" disk objects here without volume information. We only need to consider",
          "            # the cases where there are Logical Disk Manager partitions, which Get-EbsDiskMapping cannot query.",
          "            return",
          "        }",
          "        ",
          "        # Note: https://docs.microsoft.com/en-us/previous-versions/windows/desktop/vdswmi/win32-mountpoint",
          "        #       > There may not be any way to search from Win32_MountPoint to get to the associated Win32_DiskDrive; such a combination is only possible with a drive letter mount.",
          "        #       We can only locate volumes with drive letters when using the WMI, so Dynamic Disks must have drive letters on their volumes.",
          "        $Volumes = $LogicalDiskManagerPartitions | ForEach-Object {",
          "            $DiskPartition = $_",
          "            Get-WmiObject -Query \"ASSOCIATORS OF {Win32_DiskPartition.DeviceID='$($DiskPartition.DeviceID)'} WHERE AssocClass=Win32_LogicalDiskToPartition\"",
          "        }",
          "        ",
          "        # Convert the serial number of these Win32_DiskDrives (Which represent physical volumes) to an EBS volume ID.",
          "        $volumeNumber = $DiskDrive.SerialNumber | Select-String $EBS_VOLUME_MATCH | % { $_.Matches } | % { $_.Value }",
          "        if ($volumeNumber -eq $null) {",
          "            $volumeNumber = $DiskDrive.SerialNumber | Select-String $EBS_VOLUME_MATCH2 | % { $_.Matches } | % { $_.Value }",
          "        }",
          "        if ($volumeNumber -ne $null) {",
          "            $ebsVolumeId = \"vol-$volumeNumber\"",
          "            $BlockDevice = $BlockDeviceMappings | Where-Object { $_.Ebs.VolumeId -eq $ebsVolumeId }",
          "            if ($BlockDevice -ne $null) {",
          "                $BlockDeviceName = $BlockDevice.DeviceName",
          "            }",
          "        }",
          "        elseif ($DiskDrive.PNPDeviceID -like \"*PROD_PVDISK*\") {",
          "            $BlockDeviceName = Convert-SCSITargetIdToDeviceName($DiskDrive.SCSITargetId)",
          "            $BlockDevice = $BlockDeviceMappings | Where-Object { $_.DeviceName -like (\"*\" + $BlockDeviceName) }",
          "        }",
          "        else {",
          "            $BlockDeviceName = $null",
          "            $BlockDevice = $null",
          "        }",
          "",
          "        $foundWriteableVolume = $false",
          "        foreach ($volume in $Volumes) {",
          "            if ($volume.Access -ne 1) {",
          "                $foundWriteableVolume = $true",
          "            }",
          "        }",
          "",
          "        # Create a disk object with EBS and Windows volume information",
          "        if ($BlockDevice -ne $null -and $BlockDevice.Ebs -ne $null) {",
          "            New-Object PSObject -Property @{",
          "                Disk          = $DiskDrive.Index;",
          "                Partitions    = $DiskDrive.Partitions;",
          "                AccessPath   = If ($Volumes -eq $null) { $null } Else { $Volumes.DeviceID };",
          "                EbsVolumeId   = If ($BlockDevice -eq $null) { $null } Else { $BlockDevice.Ebs.VolumeId };",
          "                Device        = If ($BlockDeviceName -eq $null) { $null } Else { $BlockDeviceName };",
          "                VolumeName    = If ($Volumes -eq $null) { $null } Else { $Volumes.VolumeName };",
          "                IsReadOnly    = If (-not $foundWriteableVolume) { $true } Else { $false };",
          "            }",
          "        }",
          "    } | Sort-Object Disk",
          "",
          "    return $diskList",
          "}",
          "",
          "#",
          "# Retrieve Storage Spaces drive mapping with EBS volume ID for C5 and newer instance types",
          "#",
          "function Get-AwsNvmeStorageSpacesEbsDiskMapping {",
          "    ",
          "    $disklist = @()",
          "    $physicalDisks = @()",
          "",
          "    $physicalDisks += Get-PhysicalDisk | Where-Object {",
          "        (($_.Manufacturer -match 'NVMe') -and ($_.Model -match 'Amazon') -and",
          "        ($_.SerialNumber -match $EBS_VOLUME_MATCH)) -or",
          "        ((Get-Member -InputObject $_ -Name \"AdapterSerialNumber\") -and ($_.AdapterSerialNumber -match $EBS_VOLUME_MATCH2))",
          "    }",
          "    ",
          "    if (!$physicalDisks -or ($physicalDisks.Count -eq 0)) {",
          "        return $null",
          "    }",
          "",
          "    $InstanceId = Get-EC2InstanceMetadata \"meta-data/instance-id\"",
          "",
          "    $BlockDeviceMapping = (Get-EC2Instance -Instance $InstanceId).Instances.BlockDeviceMappings",
          "    ",
          "    foreach ($pd in $physicalDisks) {",
          "",
          "        $pool1 = Get-StoragePool -PhysicalDisk $pd -IsPrimordial $False -ErrorAction SilentlyContinue",
          "",
          "        $volumeNumber = $pd.SerialNumber | Select-String $EBS_VOLUME_MATCH | % { $_.Matches } | % { $_.Value }",
          "        ",
          "        if ($volumeNumber -eq $null) {",
          "            $volumeNumber = $pd.AdapterSerialNumber | Select-String $EBS_VOLUME_MATCH2 | % { $_.Matches } | % { $_.Value }",
          "        }",
          "",
          "        $ebsVolumeId = \"vol-$volumeNumber\"",
          "        $matchingBlockDevice = $BlockDeviceMapping | Where-Object {($_.Ebs -ne $null) -and ($_.Ebs.VolumeId -eq $ebsVolumeId)}",
          "",
          "        foreach ($vd in Get-VirtualDisk) {",
          "            $pool2 = Get-StoragePool -VirtualDisk $vd",
          "            if (($pool1 -like $pool2) -and ($volumeNumber -ne $null)) {",
          "                $disk = ($vd | Get-Disk)",
          "                # Ignore partitions that don't map to Volumes/File Systems we'd want to freeze",
          "                $parts = @($disk | Get-Partition | Where-Object -Property Type -NE Reserved | Where-Object -Property Type -NE \"XINT13 Extended\")",
          "                foreach ($part in $parts) {",
          "                    $vol = ($part | Get-Volume)",
          "                    $isReadOnly = ($pool2.IsReadOnly -or $disk.IsReadOnly -or $part.IsReadOnly)",
          "                    $diskList += New-Object PSObject -Property @{",
          "                        Disk          = If ($pd -eq $null) { $null } Else { $pd.DeviceId };",
          "                        Partitions    = 0;",
          "                        # Get Drive Letter from Volume if possible, otherwise grab Access path from partition (Could be mount path or DOS Device path)",
          "                        AccessPath    = If ($vol -ne $null -and $vol.DriveLetter) { ($vol.DriveLetter + ':') } elseif ($part.AccessPaths) { $part.AccessPaths[0] } else { $null };",
          "                        EbsVolumeId   = If ($pd -eq $null) { $null } Else { $ebsVolumeId };",
          "                        Device        = If ($matchingBlockDevice -eq $null) { $pd.FriendlyName } Else { $matchingBlockDevice.DeviceName };",
          "                        VolumeName    = If ($vol -eq $null) { $null } Else { $vol.FileSystemLabel };",
          "                        IsReadOnly    = $isReadOnly;",
          "                    }",
          "                }",
          "            }",
          "        }",
          "    }",
          "",
          "    return $disklist",
          "}",
          "",
          "",
          "#",
          "# Retrieve EBS volumes associated with a Storage Spaces pool ",
          "#",
          "function Get-XenStorageSpacesEbsDiskMapping {",
          "    ",
          "    $disklist = @()",
          "    $physicalDisks = @()",
          "",
          "    # Older versions of XenVBD use the attachment point to determine serial number",
          "    $ATTACHMENT_ORDER_MATCH = '^(\\d{4})$'",
          "",
          "    $physicalDisks += Get-PhysicalDisk | Where-Object {",
          "        ($_.SerialNumber -match $ATTACHMENT_ORDER_MATCH -and $_.SerialNumber -ne '0000') -or",
          "        (($_.SerialNumber -match $EBS_VOLUME_MATCH2) -and",
          "         ($_.Manufacturer -match 'AWS' -and $_.Model -match 'PVDISK'))",
          "    }",
          "    ",
          "    if (!$physicalDisks -or ($physicalDisks.Count -eq 0)) {",
          "        return $null",
          "    }",
          "",
          "    $InstanceId = Get-EC2InstanceMetadata \"meta-data/instance-id\"",
          "",
          "    $BlockDeviceMapping = (Get-EC2Instance -Instance $InstanceId).Instances.BlockDeviceMappings",
          "",
          "    foreach ($pd in $physicalDisks) {",
          "        $volumeNumber = $pd.SerialNumber | Select-String $EBS_VOLUME_MATCH2 | % { $_.Matches } | % { $_.Value }",
          "        if ($volumeNumber -ne $null) {",
          "            $ebsVolumeId = \"vol-$volumeNumber\"",
          "            $device = $BlockDeviceMapping | Where-Object { $_.Ebs.VolumeId -eq $ebsVolumeId }",
          "            if ($device -ne $null) {",
          "                $BlockDeviceName = $device.DeviceName",
          "            }",
          "            else {",
          "                Write-Host \"Found disk with unrecognized volume id: $ebsVolumeId. Ignoring as instance store\"",
          "                $BlockDeviceName = $null",
          "                $ebsVolumeId = $null",
          "            }",
          "        }",
          "        elseif ($pd.SerialNumber -match $ATTACHMENT_ORDER_MATCH) {",
          "            $BlockDeviceName = Convert-SCSITargetIdToDeviceName $pd.SerialNumber",
          "            $device = $BlockDeviceMapping | Where-Object {$_.DeviceName -like (\"*\" + $BlockDeviceName)}",
          "            if ($device -ne $null) {",
          "                $ebsVolumeId = $device.Ebs.VolumeId",
          "            }",
          "            else {",
          "                Write-Host \"Found disk with unrecognized block device: $BlockDeviceName. Ignoring as instance store\"",
          "                $ebsVolumeId = $null",
          "            }",
          "        }",
          "        else {",
          "            Write-Host \"Found disk with unrecognized serial number: $($pd.SerialNumber). Will ignore.\"",
          "            $BlockDeviceName = $null",
          "            $ebsVolumeId = $null",
          "        }",
          "",
          "        $pool1 = Get-StoragePool -PhysicalDisk $pd -IsPrimordial $False -ErrorAction SilentlyContinue",
          "",
          "        foreach ($vd in Get-VirtualDisk) {",
          "            $pool2 = Get-StoragePool -VirtualDisk $vd",
          "            if (($pool1 -like $pool2) -and ($ebsVolumeId -ne $null)) {",
          "                $disk = ($vd | Get-Disk)",
          "                # Ignore partitions that don't map to Volumes/File Systems we'd want to freeze",
          "                $parts = @($disk | Get-Partition | Where-Object -Property Type -NE Reserved | Where-Object -Property Type -NE \"XINT13 Extended\")",
          "                foreach ($part in $parts) {",
          "                    $vol = ($part | Get-Volume)",
          "                    $isReadOnly = ($pool2.IsReadOnly -or $disk.IsReadOnly -or $part.IsReadOnly)",
          "                    $diskList += New-Object PSObject -Property @{",
          "                        Disk          = If ($pd -eq $null) { $null } Else { $pd.DeviceId };",
          "                        Partitions    = 0;",
          "                        # Get Drive Letter from Volume if possible, otherwise grab Access path from partition (Could be mount path or DOS Device path)",
          "                        AccessPath    = If ($vol -ne $null -and $vol.DriveLetter) { ($vol.DriveLetter + ':') } elseif ($part.AccessPaths) { $part.AccessPaths[0] } else { $null };",
          "                        EbsVolumeId   = If ($pd -eq $null) { $null } Else { $ebsVolumeId };",
          "                        Device        = If ($pd -eq $null) { $null } Else { $BlockDeviceName };",
          "                        VolumeName    = If ($vol -eq $null) { $null } Else { $vol.FileSystemLabel };",
          "                        IsReadOnly    = $isReadOnly;",
          "                    }",
          "                }",
          "            }",
          "        }",
          "    }",
          "",
          "    return $disklist",
          "}",
          "",
          "",
          "#",
          "# Helper function to collect connected EBS volumes attached to local EC2 instance.",
          "#",
          "function Get-EbsDiskMapping {",
          "",
          "    $disklist = @()",
          "    $physicalDisks = @()",
          "",
          "    # Older versions of XenVBD use the attachment point to determine serial number",
          "    $ATTACHMENT_ORDER_MATCH = '^(\\d{4})$'",
          "",
          "    $physicalDisks += Get-PhysicalDisk | Where-Object {",
          "        ($_.SerialNumber -match $ATTACHMENT_ORDER_MATCH) -or",
          "        (($_.SerialNumber -match $EBS_VOLUME_MATCH2) -and",
          "         ($_.Manufacturer -match 'AWS' -and $_.Model -match 'PVDISK')) -or",
          "        ($_.SerialNumber -match $EBS_VOLUME_MATCH)",
          "    }",
          "    ",
          "    if (!$physicalDisks -or ($physicalDisks.Count -eq 0)) {",
          "        return $null",
          "    }",
          "",
          "    $InstanceId = Get-EC2InstanceMetadata \"meta-data/instance-id\"",
          "",
          "    $BlockDeviceMapping = (Get-EC2Instance -Instance $InstanceId).Instances.BlockDeviceMappings",
          "",
          "    foreach ($pd in $physicalDisks) {",
          "        $volumeNumber = $pd.SerialNumber | Select-String $EBS_VOLUME_MATCH | % { $_.Matches } | % { $_.Value }",
          "        if ($volumeNumber -eq $null) {",
          "            $volumeNumber = $pd.SerialNumber | Select-String $EBS_VOLUME_MATCH2 | % { $_.Matches } | % { $_.Value }",
          "        }",
          "        if ($volumeNumber -ne $null) {",
          "            $ebsVolumeId = \"vol-$volumeNumber\"",
          "            $device = $BlockDeviceMapping | Where-Object { $_.Ebs.VolumeId -eq $ebsVolumeId }",
          "            if ($device -ne $null) {",
          "                $BlockDeviceName = $device.DeviceName",
          "            }",
          "            else {",
          "                Write-Host \"Found disk with unrecognized volume id: $ebsVolumeId. Ignoring as instance store\"",
          "                $BlockDeviceName = $null",
          "                $ebsVolumeId = $null",
          "            }",
          "        }",
          "        elseif ($pd.SerialNumber -match $ATTACHMENT_ORDER_MATCH) {",
          "            $BlockDeviceName = Convert-SCSITargetIdToDeviceName $pd.SerialNumber",
          "            $device = $BlockDeviceMapping | Where-Object {$_.DeviceName -like (\"*\" + $BlockDeviceName)}",
          "            if ($device -ne $null) {",
          "                $ebsVolumeId = $device.Ebs.VolumeId",
          "            }",
          "            else {",
          "                Write-Host \"Found disk with unrecognized block device: $BlockDeviceName. Ignoring as instance store\"",
          "                $ebsVolumeId = $null",
          "            }",
          "        }",
          "        else {",
          "            Write-Host \"Found disk with unrecognized serial number: $($pd.SerialNumber). Will ignore.\"",
          "            $BlockDeviceName = $null",
          "            $ebsVolumeId = $null",
          "        }",
          "",
          "",
          "        $disk = ($pd | Get-Disk -ErrorAction Ignore) # Physical disks in storage pools don't map to logical disks with Get-Disk, but ignore those",
          "        # Ignore partitions that don't map to Volumes/File Systems we'd want to freeze",
          "        $parts = @($disk | Get-Partition | Where-Object -Property Type -NE Reserved | Where-Object -Property Type -NE \"XINT13 Extended\")",
          "        foreach ($part in $parts) {",
          "            $vol = ($part | Get-Volume)",
          "            $isReadOnly = ($disk.IsReadOnly -or $part.IsReadOnly)",
          "            $diskList += New-Object PSObject -Property @{",
          "                Disk          = If ($pd -eq $null) { $null } Else { $pd.DeviceId };",
          "                Partitions    = 0;",
          "                # Get Drive Letter from Volume if possible, otherwise grab Access path from partition (Could be mount path or DOS Device path)",
          "                AccessPath    = If ($vol -ne $null -and $vol.DriveLetter) { ($vol.DriveLetter + ':') } elseif ($part.AccessPaths) { $part.AccessPaths[0] } else { $null };",
          "                EbsVolumeId   = If ($pd -eq $null) { $null } Else { $ebsVolumeId };",
          "                Device        = If ($pd -eq $null) { $null } Else { $BlockDeviceName };",
          "                VolumeName    = If ($vol -eq $null) { $null } Else { $vol.FileSystemLabel };",
          "                IsReadOnly    = $isReadOnly;",
          "            }",
          "        }",
          "    }",
          "",
          "    return $disklist",
          "}",
          "",
          "",
          "#",
          "# Get a mapping of the local drives to EBS volumes",
          "#",
          "function Get-EbsConnectedVolume",
          "{",
          "    $diskList = @()",
          "",
          "    # If any of the functions return $null it will be added to the disk list which we do not want!",
          "    $disks = Get-EbsDiskMapping",
          "    if ($disks) {",
          "        $diskList += $disks",
          "    }",
          "",
          "    $disks =  Get-XenStorageSpacesEbsDiskMapping",
          "    if ($disks) {",
          "        $diskList += $disks",
          "    }",
          "",
          "    $disks =  Get-AwsNvmeStorageSpacesEbsDiskMapping",
          "    if ($disks) {",
          "        $diskList += $disks",
          "    }",
          "",
          "    $disks =  Get-DynamicDiskPartitionsOnEBSVolumes",
          "    if ($disks) {",
          "        $diskList += $disks",
          "    }",
          "",
          "    return $diskList",
          "}",
          "",
          "# Returns the OS Version Number in decimal form",
          "function Get-OSVersionNumber {",
          "    return ([Decimal]([environment]::OSVersion.Version).Major + [Decimal]([environment]::OSVersion.Version).Minor * .1)",
          "}",
          "",
          "#",
          "# Complete the vss freeze",
          "#",
          "function VssFreeze() {",
          "    param(",
          "        [string[]]$Devices,",
          "        [string[]]$Volumes,",
          "        [boolean]$CopyOnly,",
          "        [boolean]$NoWriters,",
          "        [uint32]$waitForFreezeTimeout=180",
          "    )",
          "",
          "    # Exit if we are not on at least Server 2012",
          "    if ((Get-OSVersionNumber) -lt 6.2) {",
          "        Write-Host \"Error: Must be running on Windows Server 2012 or later. Please target an older version of this document.\"",
          "        Write-Host \"For more details see: https://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/application-consistent-snapshots-prereqs.html\"",
          "        return $false",
          "    }",
          "",
          "    if (!(Test-Path $vssAgentPath)) {",
          "        Write-Host 'ec2-vss-agent.exe is not installed. To install, run command AWS-ConfigureAWSPackage with package AwsVssComponents'",
          "        return $false",
          "    }",
          "",
          "    $volumeList = Get-EbsConnectedVolume",
          "",
          "    $DrivesToFreeze = @()",
          "    foreach ($v in $volumeList) {",
          "        if ( ($v.AccessPath -ne $null)) {",
          "            if ((($v.Device -ne $null) -and ($Devices.Contains($v.Device)) -or  ($Devices.Contains('/dev/' + $v.Device))) -or",
          "                (($v.EbsVolumeId -ne $null) -and $Volumes.Contains($v.EbsVolumeId))) {  ",
          "                $DrivesToFreeze += $v.AccessPath",
          "            }",
          "        }",
          "    }",
          "    if ($Devices.Contains(\"/dev/sda1\")) {",
          "        Write-Error \"Freeze of the root volume is not supported through this command, use AWSEC2-CreateVssSnapshot to include the root volume\"",
          "        return $false",
          "    }",
          "    if ($DrivesToFreeze.Count -eq 0) {",
          "        Write-Error \"No mounted EBS drives detected\"",
          "        return $false",
          "    }",
          "    $DrivesToFreezeString = ($DrivesToFreeze | sort -Unique) -join ' '",
          "    Write-Host \"Beginning Freeze for drives:\" $DrivesToFreezeString",
          "    ",
          "    return EbsVssFreeze $DrivesToFreezeString $CopyOnly $NoWriters $waitForFreezeTimeout",
          "}",
          "",
          "#",
          "# Complete the vss thaw",
          "#",
          "function VssThaw() {",
          "",
          "    $process = get-process \"ec2-vss-agent\" -ea SilentlyContinue",
          "    if (!$process) { ",
          "        Write-Host \"ec2-vss-agent is not running, Freeze command must be run first, and Thaw must run within 10 seconds of completion\" ",
          "        return $false",
          "    }",
          "",
          "    $AppConsistent = EbsVssThaw",
          "    if ($AppConsistent) {",
          "        Write-Host 'Thaw successful'",
          "    } else {",
          "        Write-Host 'Thaw unsuccessful, snapshots may not be app consistent, see event log for more details'",
          "    }",
          "",
          "    return $AppConsistent",
          "}",
          "",
          "",
          "",
          "",
          "",
          "$Action = \"{{Action}}\"",
          "Write-Host \"Starting AWSWindows-ManageVssIo $Action $(Get-Date)\"",
          "",
          "if ($Action -eq \"Freeze\") {",
          "    $DevicesString = '{{Devices}}'",
          "    $Devices = $DevicesString.Split(\",\").Trim()",
          "    $VolumesString = '{{Volumes}}'",
          "    $Volumes = $VolumesString.Split(\",\").Trim()",
          "    Write-Host $Devices",
          "    Write-Host $Volumes",
          "",
          "    [boolean]$CopyOnly = [System.Convert]::ToBoolean(\"{{CopyOnly}}\")",
          "",
          "    [boolean]$NoWriters = [System.Convert]::ToBoolean(\"{{NoWriters}}\")",
          "",
          "    [uint32]$executionTimeout = {{executionTimeout}}",
          "    [uint32]$waitForFreezeTimeout = $executionTimeout - 60",
          "",
          "    VssFreeze $Devices $Volumes $CopyOnly $NoWriters $waitForFreezetimeout",
          "} else {",
          "    $AppConsistent = VssThaw",
          "    exit [int](-not $AppConsistent)",
          "}",
          "",
          ""
        ]
      },
      "name": "runPowerShellScript",
      "action": "aws:runPowerShellScript",
      "precondition": {
        "StringEquals": [
          "platformType",
          "Windows"
        ]
      }
    }
  ]
}
