{
  "description": "#### Document Name - AWS-DisableIncomingSSHOnPort22\n\n## What does this document do?\nThis document disables unrestricted incoming SSH traffic on port 22 for EC2 security groups.\nTraffic to the targeted security groups is restricted by removing the ingress rule that allows unrestricted incoming SSH traffic from anywhere ('0.0.0.0/0' and '::/0').\n\n## Input Parameters\n* SecurityGroupIds: (Required) A comma separated list of security group IDs to restrict SSH traffic for.\n* AutomationAssumeRole: (Optional) The ARN of the role that allows Automation to perform the actions on your behalf.\n\n## Output Parameters\n* DisableIncomingSSHTemplate.RestrictedSecurityGroupIds: The list of the security group IDs with disabled incoming SSH on port 22.\n\n## Minimum Permissions Required\n* `ec2:DescribeSecurityGroups` and `ec2:RevokeSecurityGroupIngress` on the target security groups\n",
  "schemaVersion": "0.3",
  "assumeRole": "{{AutomationAssumeRole}}",
  "parameters": {
    "SecurityGroupIds": {
      "type": "StringList",
      "description": "(Required) A comma separated list of security group IDs to restrict SSH traffic for.",
      "allowedPattern": "^sg-[a-z0-9]{8,17}$"
    },
    "AutomationAssumeRole": {
      "type": "String",
      "description": "(Optional) The ARN of the role that allows Automation to perform the actions on your behalf.",
      "default": "",
      "allowedPattern": "^arn:aws(-cn|-us-gov)?:iam::\\d{12}:role\\/[\\w+=,.@_\\/-]+|^$"
    }
  },
  "outputs": [
    "DisableIncomingSSHTemplate.RestrictedSecurityGroupIds"
  ],
  "mainSteps": [
    {
      "name": "DisableIncomingSSHTemplate",
      "action": "aws:executeScript",
      "onFailure": "Abort",
      "isCritical": true,
      "isEnd": false,
      "timeoutSeconds": 600,
      "description": "## DisableIncomingSSHTemplate\nDisables all incoming traffic on port 22 on the security groups.\n## Inputs\n* SecurityGroupIds: The list of targeted security group IDs.\n## Outputs\n* RestrictedSecurityGroupIds: The list of the security group IDs with disabled incoming SSH on port 22.\n",
      "inputs": {
        "Runtime": "python3.11",
        "Handler": "disable_incoming_ssh_handler",
        "InputPayload": {
          "SecurityGroupIds": "{{SecurityGroupIds}}"
        },
        "Script": "import boto3\n\nSSH_PORT = 22\nTCP = 'tcp'\nPUBLIC_IPV4_CIDR = '0.0.0.0/0'\nPUBLIC_IPV6_CIDR = '::/0'\n\nec2_resource = boto3.resource(\"ec2\")\nec2_client = boto3.client(\"ec2\")\n\n\ndef find_open_ssh_ip_in_sg(sg_description):\n  has_unrestricted = False\n  unrestricted_ipv4_ranges = []\n  unrestricted_ipv6_ranges = []\n  for rule in sg_description[\"SecurityGroups\"][0][\"IpPermissions\"]:\n    if ('FromPort' in rule and rule['FromPort'] == SSH_PORT) and ('ToPort' in rule and rule['ToPort'] == SSH_PORT):\n      for ip_range in rule['IpRanges']:\n        if ip_range['CidrIp'] == PUBLIC_IPV4_CIDR:\n          unrestricted_ipv4_ranges.append(ip_range)\n          has_unrestricted = True\n      for ip_range in rule['Ipv6Ranges']:\n        if ip_range['CidrIpv6'] == PUBLIC_IPV6_CIDR:\n          unrestricted_ipv6_ranges.append(ip_range)\n          has_unrestricted = True\n  \n  return has_unrestricted, unrestricted_ipv4_ranges, unrestricted_ipv6_ranges\n\n\ndef disable_incoming_ssh_handler(event, context):\n  sg_ids = event[\"SecurityGroupIds\"]\n  Restricted_sg_ids = []\n  Unrestricted_sg_ids = []\n  errorMsg = \"N/A\"\n  currentSg = None\n  successful = True\n  try:\n    for sg_id in sg_ids:\n      currentSg = sg_id\n      sg_description = ec2_client.describe_security_groups(GroupIds=[sg_id])\n      sg_resource = ec2_resource.SecurityGroup(sg_id)\n      has_unrestricted, unrestricted_ipv4_ranges, unrestricted_ipv6_ranges = find_open_ssh_ip_in_sg(sg_description)\n      \n      if has_unrestricted:\n        revoke_response = sg_resource.revoke_ingress(\n        GroupId=sg_id,\n        IpPermissions=[{\n        'FromPort': SSH_PORT,\n        'IpProtocol': TCP,\n        'ToPort': SSH_PORT,\n        'IpRanges': unrestricted_ipv4_ranges,\n        'Ipv6Ranges': unrestricted_ipv6_ranges\n      }],\n        DryRun=False\n        )\n        if revoke_response and 'Return' in revoke_response and revoke_response['Return']:\n          Restricted_sg_ids.append(sg_id)\n        else:\n          successful = False\n          Unrestricted_sg_ids.append(sg_id)\n  \n  except Exception as e:\n    errorMsg = str(e)\n    successful = False\n    if \"InvalidGroup.NotFound\" in errorMsg:\n      errorMsg = \"The security group '{}' does not exist\".format(currentSg)\n  \n  if not successful:\n      raise Exception(\n        \"Unable to restrict one or more of the security groups Unrestricted_sg_ids: '{}', Restricted_sg_ids: '{}'. errorMsg: '{}'\".format(\n                Unrestricted_sg_ids, Restricted_sg_ids, errorMsg))\n\n  return {\n  \"RestrictedSecurityGroupIds\": Restricted_sg_ids\n}\n"
      },
      "outputs": [
        {
          "Name": "RestrictedSecurityGroupIds",
          "Selector": "$.Payload.RestrictedSecurityGroupIds",
          "Type": "StringList"
        }
      ]
    },
    {
      "name": "DisableIncomingSSHPrefixListTemplate",
      "action": "aws:executeScript",
      "onFailure": "Continue",
      "isCritical": false,
      "isEnd": true,
      "timeoutSeconds": 600,
      "description": "This script analyzes and modifies EC2 security groups to restrict incoming SSH access \nthrough prefix lists. It removes prefix lists containing only public CIDRs and flags \nthose with mixed public/private CIDRs for manual review.\n## Inputs\n* SecurityGroupIds: The list of security groups to restrict incoming traffic for.\n## Outputs\n* RestrictedSecurityGroupIds: A list of the security groups which were successfully restricted.\n",
      "inputs": {
        "Runtime": "python3.11",
        "Handler": "disable_incoming_ssh_prefix_lists_handler",
        "InputPayload": {
          "SecurityGroupIds": "{{SecurityGroupIds}}"
        },
        "Script": "import boto3\n\nSSH_PORT = 22\nTCP = 'tcp'\nPUBLIC_IPV4_CIDR = '0.0.0.0/0'\nPUBLIC_IPV6_CIDR = '::/0'\n\nec2_resource = boto3.resource(\"ec2\")\nec2_client = boto3.client(\"ec2\")\n\ndef analyze_prefix_list(prefix_list_id):\n    \"\"\"\n    Analyzes a prefix list to determine if it contains only public CIDR,\n    mixed CIDRs, or no public CIDRs.\n    \"\"\"\n    try:\n      has_public_cidr = False\n      has_other_cidrs = False\n      paginator = ec2_client.get_paginator('get_managed_prefix_list_entries')\n\n      for page in paginator.paginate(PrefixListId=prefix_list_id):\n          for entry in page['Entries']:\n              if entry['Cidr'] in [PUBLIC_IPV4_CIDR, PUBLIC_IPV6_CIDR]:\n                  has_public_cidr = True\n              else:\n                  has_other_cidrs = True\n\n              # Stop processing if we've found both types\n              if has_public_cidr and has_other_cidrs:\n                  return {\n                      'public_cidr': False,\n                      'public_and_private_cidr': True\n                  }\n\n      return {\n          'public_cidr': has_public_cidr and not has_other_cidrs,\n          'public_and_private_cidr': has_public_cidr and has_other_cidrs\n      }\n    except Exception as e:\n        print(f\"Error checking prefix list {prefix_list_id}: {str(e)}\")\n        raise e\n\ndef find_open_ssh_prefix_lists(sg_description):\n    \"\"\"\n    Identifies prefix lists that need to be removed or require manual review.\n    \"\"\"\n    prefix_lists_to_remove = []\n    prefix_lists_requiring_review = []\n    \n    for rule in sg_description[\"SecurityGroups\"][0][\"IpPermissions\"]:\n        if ('FromPort' in rule and rule['FromPort'] == SSH_PORT) and ('ToPort' in rule and rule['ToPort'] == SSH_PORT):\n            if 'PrefixListIds' in rule:\n                for prefix_list in rule['PrefixListIds']:\n                    prefix_list_id = prefix_list['PrefixListId']\n                    analysis = analyze_prefix_list(prefix_list_id)\n                    if analysis['public_cidr']:\n                        prefix_lists_to_remove.append(prefix_list)\n                    elif analysis['public_and_private_cidr']:\n                        prefix_lists_requiring_review.append(prefix_list_id)\n    return prefix_lists_to_remove, prefix_lists_requiring_review\n\ndef disable_incoming_ssh_prefix_lists_handler(event, context):\n    \"\"\"\n    Lambda handler to process security groups and remove prefix lists containing only public CIDRs.\n    Raises exception for prefix lists containing mixed CIDRs.\n    \"\"\"\n    security_group_ids = event[\"SecurityGroupIds\"]\n    restricted_sg_ids = []\n    unrestricted_sg_ids = []\n    manual_review_required = []\n    error_msg = \"N/A\"\n    current_sg = None\n    successful = True\n    \n    try:\n        for sg_id in security_group_ids:\n            current_sg = sg_id\n            sg_description = ec2_client.describe_security_groups(GroupIds=[sg_id])\n            sg_resource = ec2_resource.SecurityGroup(sg_id)\n            \n            prefix_lists_to_remove, prefix_lists_requiring_review = find_open_ssh_prefix_lists(sg_description)\n            if prefix_lists_requiring_review:\n                manual_review_required.append({\n                    'security_group': sg_id,\n                    'prefix_lists': prefix_lists_requiring_review\n                })\n\n            if prefix_lists_to_remove:\n                ip_permissions = {\n                    'FromPort': SSH_PORT,\n                    'IpProtocol': TCP,\n                    'ToPort': SSH_PORT,\n                    'PrefixListIds': prefix_lists_to_remove\n                }\n\n                revoke_response = sg_resource.revoke_ingress(\n                    GroupId=sg_id,\n                    IpPermissions=[ip_permissions],\n                    DryRun=False\n                )\n                \n                if revoke_response and 'Return' in revoke_response and revoke_response['Return']:\n                    restricted_sg_ids.append(sg_id)\n                else:\n                    successful = False\n                    unrestricted_sg_ids.append(sg_id)\n\n    except Exception as e:\n        error_msg = str(e)\n        successful = False\n        if \"InvalidGroup.NotFound\" in error_msg:\n            error_msg = \"The security group '{}' does not exist\".format(current_sg)\n\n    if manual_review_required:\n        raise Exception(\n            \"Manual review required for the following security groups and prefix lists: {}\".format(\n                manual_review_required\n            )\n        )\n\n    if not successful:\n        raise Exception(\n            \"Unable to restrict prefix lists in security groups. \"\n            \"Unrestricted_sg_ids: '{}', Restricted_sg_ids: '{}'. \"\n            \"errorMsg: '{}'\".format(unrestricted_sg_ids, restricted_sg_ids, error_msg))\n\n    return {\n        \"RestrictedSecurityGroupIds\": restricted_sg_ids\n    }\n"
      },
      "outputs": [
        {
          "Name": "RestrictedSecurityGroupIds",
          "Selector": "$.Payload.RestrictedSecurityGroupIds",
          "Type": "StringList"
        }
      ]
    }
  ]
}
