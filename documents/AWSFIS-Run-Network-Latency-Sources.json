{
  "description": "### Document name - AWSFIS-Run-Network-Latency-Sources\n\n## What does this document do?\nIt adds latency with jitter using tc, to outgoing or incoming traffic from a configurable list of sources (Supported: IPv4, IPv4/CIDR, Domain name, DYNAMODB|S3). If tc is not already installed on the instance, this SSM document will install it together with other dependencies listed below.\nThis SSM document supports Amazon Linux and Ubuntu operating systems only.\n\n## Dependencies installed by this SSM Document\n* tc\n* jq\n* atd\n* dig\nNote: This SSM document does not uninstall dependencies once installed. If you don't want this SSM document to install any dependencies, set InstallDependencies to False and bake the dependencies into your EC2 instance. For example, by using image-builder (https://aws.amazon.com/image-builder/).\nNote: Before you run this document, enable the kernel module sch_netem. To check if installed, run the following command on your instance - lsmod | grep sch_netem. On success, you will see sch_netem as output. If there is no output, run depmod -a to build a list of modules, and then run modprobe sch_netem. If you get an error, then the module is not available. If you are using Amazon Linux and the module is not available, verify that you are using the latest AMI and that you have installed the latest updates.\n\n\n## Input Parameters\n* Interface: The interface to add delay to (default: eth0).\n* DelayMilliseconds: The delay - in milliseconds - to add to the interface (default: 200).\n* JitterMilliseconds: The jitter -  in milliseconds - to add to the delay (default: 10).\n* Sources: (Required) Specify a comma separated list of sources to add delay to (Supported: IPv4, IPv4/CIDR, Domain name, DYNAMODB|S3) - e.g. \"DYNAMODB,www.example.com,72.21.198.64/32,72.21.198.67\".\n* TrafficType: The type of traffic to delay (default: ingress).\n* DurationSeconds: (Required) The duration - in seconds - of the test.\n* InstallDependencies: If set to True, Systems Manager installs the required dependencies on the target instances. (default: True).\n\n## Output Parameters\nNone.",
  "schemaVersion": "2.2",
  "parameters": {
    "Interface": {
      "type": "String",
      "description": "The interface to add delay to (default: eth0).",
      "default": "eth0",
      "allowedPattern": "^[0-9a-zA-Z\\-]{1,15}$"
    },
    "Sources": {
      "type": "String",
      "description": "(Required) Specify a comma separated list of sources to add delay to (Supported: IPv4, IPv4/CIDR, Domain name, DYNAMODB|S3).",
      "allowedPattern": "^[0-9a-zA-Z./,-]+$"
    },
    "TrafficType": {
      "type": "String",
      "description": "Specify the type of traffic to delay (egress|ingress) (default: ingress).",
      "default": "ingress",
      "allowedValues": [
        "egress",
        "ingress"
      ]
    },
    "DelayMilliseconds": {
      "type": "String",
      "description": "The delay - in milliseconds - to add to the interface (default: 200).",
      "default": "200",
      "allowedPattern": "^[0-9]+$"
    },
    "JitterMilliseconds": {
      "type": "String",
      "description": "The jitter -  in milliseconds - to add to the delay (default: 10).",
      "default": "10",
      "allowedPattern": "^[0-9]+$"
    },
    "DurationSeconds": {
      "type": "String",
      "description": "(Required) The duration - in seconds - of the test.",
      "allowedPattern": "^[0-9]+$"
    },
    "InstallDependencies": {
      "type": "String",
      "description": "If set to True, Systems Manager installs the required dependencies on the target instances. (default: True).",
      "default": "True",
      "allowedValues": [
        "True",
        "False"
      ]
    }
  },
  "mainSteps": [
    {
      "action": "aws:runShellScript",
      "name": "InstallDependencies",
      "precondition": {
        "StringEquals": [
          "platformType",
          "Linux"
        ]
      },
      "description": "## Parameter: InstallDependencies\nIf set to True, this step installs the required dependecy via operating system's repository. It supports both\nDebian (apt) and CentOS (yum) based package managers.\n",
      "inputs": {
        "onFailure": "exit",
        "runCommand": [
          "#!/bin/bash\n\n\nif [[ \"$( command -v atd 2>/dev/null )\" && \"$( command -v dig 2>/dev/null )\" && \"$( command -v jq 2>/dev/null )\" && \"$( command -v kmod 2>/dev/null )\" && \"$( command -v lsof 2>/dev/null )\" && \"$( command -v tc 2>/dev/null )\" ]]; then\n    if [[ -n \"True\" ]] ; then\n        depmod -a\n        if modprobe sch_netem; then\n          exit\n        fi\n    else\n        echo Dependency is already installed. ; exit ;\n    fi\nfi\nif  [[ \"{{ InstallDependencies }}\" == True ]] ; then\n  echo \"Installing required dependencies\"\n  if [ -f  \"/etc/system-release\" ] && grep -i 'Amazon Linux' /etc/system-release  ; then\n    if ! grep -Fiq 'VERSION_ID=\"2023\"' /etc/os-release ; then\n      # Use amazon-linux-extras if available (Amazon Linux 2). Don't need it otherwise (Amazon Linux 1)\n      command -v amazon-linux-extras 2>/dev/null 1>&2 && amazon-linux-extras install testing\n      yum -y install at bind-utils jq kmod lsof tc\n    elif grep -Fiq 'ID=\"amzn\"' /etc/os-release && grep -Fiq 'VERSION_ID=\"2023\"' /etc/os-release ; then\n      \n########################################################################################################################\n # This script builds a list of available modules and enables sch_netem                                                #\n # sch_netem kernel module is responsible for emulating traffic,                                                       #\n # FIS SSM Documents use this module when creating network faults, such as the packet loss fault and the latency fault #\n #######################################################################################################################\n# Build a list of the available modules\nif ! command -v depmod &> /dev/null; then\n  echo \"WARN depmod is not available. Command could fail due to missing sch_netem\"\nelse\n  depmod -a\n  # Enable the sch_netem module, if there is a failure, exit\n  if ! modprobe sch_netem; then\n      echo \"WARN Cannot enable sch_netem\"\n      echo \"WARN Command could fail due to missing sch_netem\"\n  fi\nfi\n\n      yum -y install at bind-utils jq kmod lsof iproute-tc\n    else\n      echo \"Exiting - This SSM document supports: Amazon Linux 2023, Amazon Linux 2, Amazon Linux, Ubuntu, CentOS (8, 9) and RHEL (8, 9) operating systems\"\n      exit 1\n    fi\n\n  elif grep -Fiq 'ID=\"centos\"' /etc/os-release  || grep -Fiq 'ID=\"rhel\"' /etc/os-release ; then\n    # Fetch OS Version\n    os_version_number=$(grep -oP '(?<=^VERSION_ID=).+' /etc/os-release | tr -d '\"')\n    # if the version has a decimal, this line will remove it\n    os_major_version_number=${os_version_number%.*}\n    # Replace with version number in the url if required\n    if ! rpm --quiet -q epel-release &&  [ -n \"https://dl.fedoraproject.org/pub/epel/epel-release-latest-VERSION.noarch.rpm\" ] ; then\n      epel_dl_url=\"https://dl.fedoraproject.org/pub/epel/epel-release-latest-VERSION.noarch.rpm\"\n      epel_with_version=\"${epel_dl_url/VERSION/$os_major_version_number}\"\n      yum -y install $epel_with_version\n    fi\n    rhel_package=\"at bind-utils jq kmod lsof iproute-tc\"\n    \n#################################\n#       Dependency Logic        #\n#################################\n\nfunction install_sch_netem_module() {\n  ssm_working_dir=$(pwd)\n  # Work from a directory that Amazon SSM Agent creates\n  cd /etc/amazon/ssm/\n  current_working_dir=$(pwd)\n  kernel_version=$(uname -r)\n  # Default location of sch_netem module\n  sched_module_local_path=/lib/modules/\"$kernel_version\"/kernel/net/sched/\n  sch_netem_kernel_module_file=sch_netem.ko\n  # Check if there is no compressed and uncompressed version of the module\n  if  [ ! -f \"${sched_module_local_path}$sch_netem_kernel_module_file\" ] && [ ! -f \"${sched_module_local_path}$sch_netem_kernel_module_file\".xz ] ; then\n      echo \"sch_netem does not exist, installing\"\n      # We will download and install the sch_netem kernel module to avoid the need for a reboot, as\n      # would be required if we used `yum install kernel-modules-extra`.\n      temp_dir=kernel-lib\n      # If the yumdownloader comes back with no module available, then fail\n      if yumdownloader kernel-modules-extra-\"$kernel_version\" --destdir \"$temp_dir\" |& grep \"No package kernel-modules-extra-$kernel_version available.\" ; then\n        echo \"No sch_netem module for the kernel version $kernel_version\"\n        echo \"Exiting - Unable to install sch_netem. kernel module sch_netem must be installed for this document to run\"\n        rm -rf \"$temp_dir\"\n        exit 1\n      fi\n      # We need to CD into the temp_dir for cpio since it does not work with absolute or relative paths well\n      cd \"$temp_dir\"\n      # Unpacks the modules into lib/\n      # version is downloaded but will differ from $kernel_version, depending OS.\n      rpm2cpio kernel-modules-extra-\"$kernel_version\".rpm | cpio -id\n      # Move back to the working dir.\n      cd \"$current_working_dir\"\n      # if sch_netem exists in the rpm lib, move it to /etc/amazon/ssm\n      sch_netem_path=$(find \"$temp_dir\"/lib -name \"$sch_netem_kernel_module_file\".xz)\n      if [ -n \"${sch_netem_path}\" ] ; then\n          echo \"Downloaded Kernel Modules, and sch_netem exists. Loading Module\"\n          mv \"${sch_netem_path}\" \"$current_working_dir\"\n          # Do not need the rest of the temp_dir\n          rm -rf \"$temp_dir\"\n          echo \"Unpacking sch_netem\"\n          xz -d \"$sch_netem_kernel_module_file\".xz\n          rm -f \"$sch_netem_kernel_module_file\".xz\n          # Create a symlink to the default location so that the module can be added to the list of available modules by depmod\n          ln -s \"$current_working_dir\"/$sch_netem_kernel_module_file /lib/modules/\"$kernel_version\"/\"$sch_netem_kernel_module_file\"\n          echo \"Loading sch_netem\"\n          # Refresh the list of available modules\n          depmod -a\n          modprobe sch_netem\n          # Check if loaded successfully\n          if lsmod | grep -wq \"sch_netem\" ; then\n            echo \"$sch_netem_kernel_module_file module installed and loaded\"\n          else\n            echo \"Exiting - Error loading module, kernel module sch_netem.ko must be installed for this document to run\"\n            exit 1\n          fi\n      else\n          # make sure our temp file deleted.\n          rm -rf \"$temp_dir\"\n          echo \"Exiting - Unable to install sch_netem. kernel module sch_netem must be installed for this document to run\"\n          exit 1\n      fi\n  # Check if the module exists and enable it\n  elif [[ -f \"${sched_module_local_path}/$sch_netem_kernel_module_file\" ]] ; then\n      if modinfo ${sched_module_local_path}/$sch_netem_kernel_module_file -F vermagic | awk '{print $1}' | grep -Fi \"$kernel_version\"; then\n        # Lets build an updated list of available modules first\n        depmod -a\n        # Insert module\n        modprobe sch_netem\n      fi\n  # if the compressed module exist, uncompress and enable\n  elif [[ -f \"${sched_module_local_path}$sch_netem_kernel_module_file\".xz ]] &&  [ ! -f \"${sched_module_local_path}$sch_netem_kernel_module_file\" ] ; then\n      # Module exists, so we need to unpack it and insert the module in the kernel it\n      xz -d -k \"${sched_module_local_path}/$sch_netem_kernel_module_file\".xz\n      if modinfo ${sched_module_local_path}/$sch_netem_kernel_module_file -F vermagic | awk '{print $1}' | grep -Fi \"$kernel_version\"; then\n          # Lets build an updated list of available modules first\n          depmod -a\n          # Insert module\n          modprobe sch_netem\n      fi\n  fi\n  cd \"$ssm_working_dir\"\n}\n\n# If this Document uses the tc command we need to make sure netem is enabled.\n# when we use tc, we add netem on the qdisk\n# netem comes with kernel-modules-extra package is centos/rhel 8+, but not loaded in version 7\n# netem emulates network delay, loss etc\nif [[ -n \"True\" ]] ; then\n    if ! lsmod | grep -wq \"sch_netem\" ; then\n        # To avoid issues with SELinux we wrap everything in sudo.\n        # In order to call the install_sch_netem_module function wrapped with sudo,\n        # we need to pass it as a command rather than a function call.\n        SUDOINSTALL=$(declare -f install_sch_netem_module)\n        sudo bash -c \"$SUDOINSTALL; install_sch_netem_module\" 2>&1\n        # Check if loaded\n        if lsmod | grep -wq \"sch_netem\" ; then\n          echo \"sch_netem.ko Module loaded\"\n        else\n          echo \"Exiting - Error loading module, kernel module sch_netem.ko must be installed for this document to run\"\n          exit 1\n        fi\n    fi\nfi\n\n# For centos/rhel 7 the package is iproute, so remove the suffix if iproute is there\n# since this command is directly related to the use of sch_netem.\nif [[ ${rhel_package} == *iproute-tc* ]] && [ \"$os_major_version_number\" -eq \"7\" ] ; then\n  rhel_package=${rhel_package/iproute-tc/iproute}\nfi\n\n    yum -y install $rhel_package\n\n  elif grep -i \"Ubuntu\" /etc/issue ; then\n    apt-get update -y\n    # when installing, sometimes ubuntu has stderr that are not breaking errors.\n    install_error=$(apt-get install -y at dnsutils jq kmod lsof iproute2) 2>&1\n    if [[ -n \"$install_error\" ]]  ; then\n        echo \"$install_error\"\n    fi\n    ubuntu_commands=( atd dig jq kmod lsof tc )\n    for dependency_command in \"${ubuntu_commands[@]}\"\n    do\n       if ! command -v $dependency_command >/dev/null 2>&1 ; then\n            echo \"Exiting - $dependency_command not installed\"\n            exit 1\n       fi\n    done\n  else\n    echo \"Exiting - This SSM document supports: Amazon Linux 2023, Amazon Linux 2, Amazon Linux, Ubuntu, CentOS (8, 9) and RHEL (8, 9) operating systems\"\n    exit 1\n  fi\n  if [[ -n \"True\" ]] ; then\n    if ! systemctl is-enabled atd || ! systemctl is-active atd; then\n        echo \"Enabling and starting atd\"\n        systemctl enable atd\n        systemctl start atd\n    fi\n  fi\nelse\n  echo \"Dependencies are not installed - Please set InstallDependencies to True.\"\n  exit 1\nfi\n"
        ]
      }
    },
    {
      "action": "aws:runShellScript",
      "name": "FaultInjection",
      "precondition": {
        "StringEquals": [
          "platformType",
          "Linux"
        ]
      },
      "description": "## Parameters: Sources, TrafficType, Interface, DelayMilliseconds, JitterMilliseconds and DurationSeconds\nThis step starts by extracting the IP for all the `Sources` provided and adds a `DelayMilliseconds` with `JitterMilliseconds` delay to `TrafficType` traffic on the `Interface` for the given `DurationSeconds`, using the `tc` (Traffic Control) command.\nThe script will inject latency on the `TrafficType` traffic for the `Sources`, and wait for the given duration to remove that. It has two rollback mechanisms in place:\n* It will listen for exit signals (SIGINT and SIGTERM), and will stop the latency injection if any of them is received.\n* It will periodically enqueue rollback checks into a queue (using `at` command). This way, if the command is stopped and the rollback\nwas not executed, the enqueued commands will try to stop it. (for example, if the command is stopped using kill -9). This is just\nan extra safety check to avoid having the latency remain injected after the script is no longer running.\n",
      "inputs": {
        "maxAttempts": 1,
        "timeoutSeconds": 43200,
        "runCommand": [
          "#!/bin/bash\n\n\n# Treat unset variables as an error\nset -o nounset\n\n\n########################\n# Fault-specific logic #\n########################\n\nINTERFACE={{ Interface }}\nDELAYMILLISECONDS={{ DelayMilliseconds }}\nJITTERMILLISECONDS={{ JitterMilliseconds }}\nDURATION={{ DurationSeconds }}\nSOURCES={{ Sources }}\nTRAFFIC={{ TrafficType }}\n\nif ! [[ \"$( ip a ls $INTERFACE 2>/dev/null )\" ]] ; then\n  echo \"Interface $INTERFACE does not exist.\" >&2\n  exit 1\nfi\n\nif [ $DURATION -lt 1 ] || [ $DURATION -gt 43200 ]; then\n  echo \"Parameter DurationSeconds must be between 1 and 43200, was: '$DURATION'\" >&2\n  exit 1\nfi\n\nif [ $DELAYMILLISECONDS -lt 1 ]; then\n  echo \"Parameter DelayMilliseconds must be a positive value, was: '$DELAYMILLISECONDS'\" >&2\n  exit 1\nfi\n\nif [ $JITTERMILLISECONDS -lt 1 ]; then\n  echo \"Parameter JitterMilliseconds must be a positive value, was: '$JITTERMILLISECONDS'\" >&2\n  exit 1\nfi\n\nif [[ -z \"${AWS_SSM_REGION_NAME}\" ]]; then\n  echo \"Environment variable AWS_SSM_REGION_NAME is not set. Run this script as part of an SSM document.\" >&2\n  exit 1\nfi\n\nFAULT_NAME=\"Run-Network-Latency-Sources\"\n\nif [ \"$TRAFFIC\" = \"ingress\" ]; then\n  ip a ls ifb0 1>/dev/null 2>&1 && { echo \"Fault might be already running (Interface ifb0 already exists). Exiting...\" 1>&2 ; exit 1; }\nfi\n\nIP_CIDR_REGEX=\"^(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\/(3[0-2]|[1-2][0-9]|[0-9]))$\"\nIP_REGEX=\"^(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])$\"\nIMDS_IP=169.254.169.254\n\n# Get the REGION of the instance\nEC2_REGION=$AWS_SSM_REGION_NAME\n\n##################################\n#       Regional Endpoints       #\n##################################\n\nSSMMESSAGES_ENDPOINT=ssmmessages.us-east-1.amazonaws.com\nSSM_ENDPOINT=ssm.us-east-1.amazonaws.com\nEC2MESSAGES_ENDPOINT=ec2messages.us-east-1.amazonaws.com\n\n##################################\n\n##################################\n#            IP Ranges           #\n##################################\n\nIP_RANGES_URL=https://ip-ranges.amazonaws.com/ip-ranges.json\n\n##################################\n\nIP_ADDRESSES=()\nIP_ADDRESSES_SSM_ENDPOINTS=()\nINVALID_SOURCE=()\n\nDELETE_MSG=\"#delete-after-fault-injection\"\n\n# List of endpoint we want to preserve (SSM API)\nENDPOINTS=(\n  \"${SSMMESSAGES_ENDPOINT}\"\n  \"${SSM_ENDPOINT}\"\n  \"${EC2MESSAGES_ENDPOINT}\"\n)\n\n# Only on EC2 instances add EC2 metadata. On-premise instances will be prefixed with \"mi-\"\nif [[ \"$AWS_SSM_INSTANCE_ID\" =~ ^i-.* ]]; then\n  echo \"Running on EC2 instance. Adding EC2 metadata IP to ENDPOINTS\"\n  ENDPOINTS+=(\"${IMDS_IP}\")\nfi\n\nforce_dns()\n{\n    # Force any new DNS resolution for that host to the latest known IPs\n    params=(\"$@\")\n    hostname=${params[0]}   # Hostname is expected as first argument\n    ips=(\"${params[@]:1}\")  # The rest will be the IPs\n    for ip in $(echo \"${ips[@]}\"); do\n      echo \"$ip $hostname $DELETE_MSG\" >> /etc/hosts\n    done\n}\n\nget_ips()\n{\n    # Returns if the input is a valid IP/CIDR string, empty otherwise\n    local var_ip_cidr=$(grep -E \"$IP_CIDR_REGEX\" <<< \"$1\")\n    [  -z \"$var_ip_cidr\" ] || { echo $var_ip_cidr ; return ;}\n\n    # Returns if the input is a valid IP string, empty otherwise\n    local var_ip=$(grep -E \"$IP_REGEX\" <<< \"$1\")\n    [  -z \"$var_ip\" ] || { echo $var_ip ; return ;}\n\n    # Returns IPs of the domain and force DNS resolution to that IP, empty otherwise\n    # Since `dig` can return different IPs, we call it 10 times to maximize the chances of covering as many IPs as possible for the provided domain\n    local var_dns=()\n    for i in $(seq 1 10)\n    do\n        dig_output=( $(dig +short $1 | grep -v '[[:alpha:]]') )\n        [ ${#dig_output[@]} -eq 0 ] || var_dns+=(\"${dig_output[@]}\")\n    done\n    var_unique_dns=( $(printf '%s\\n' \"${var_dns[@]}\" | sort -u) )\n    [ ${#var_unique_dns[@]} -eq 0 ] || { echo \"${var_unique_dns[@]}\" ; force_dns $1 \"${var_unique_dns[@]}\" ; return ;}\n\n    # Only accepting DYNAMODB and S3 from ip-range service\n    if [[ \"$1\" =~ ^(\"DYNAMODB\"|\"S3\")$ ]]; then\n      # Return IPS of the Service, empty otherwise\n      curl -s \"${IP_RANGES_URL}\" --connect-timeout 5 | jq -r '.prefixes[] | select(.region==\"'$EC2_REGION'\") | select(.service==\"'$1'\") | .ip_prefix'\n    fi\n}\n\n# Prepare the sources and get IPs for all of them\nfor source in ${SOURCES//,/ }\ndo\n    ips=$(get_ips $source)\n    if [ -n \"$ips\" ]; then\n      for ip in ${ips[*]}\n        do\n        IP_ADDRESSES+=(\"${ip}\")\n      done\n    else\n        INVALID_SOURCE+=(\"${source}\")\n    fi\ndone\n\nif [ ${#INVALID_SOURCE[@]} -gt 0 ]; then\n  echo \"Invalid sources (malformed service name, DNS or IP address): ${INVALID_SOURCE[*]}\" >&2\n  exit 1\nfi\necho \"Target IPs and ranges: ${IP_ADDRESSES[*]}\"\n\n# Getting IPs from SSM endpoints\nfor e in ${ENDPOINTS[*]};\n  do\n    var_endpoint=$(get_ips $e)\n    IP_ADDRESSES_SSM_ENDPOINTS+=(\"${var_endpoint[@]}\")\ndone\n\n# Getting IPs from existing SSM connections\nif pgrep ssm > /dev/null\nthen\n    var_ssm_connections=( $(lsof -a -nPi4 -c /ssm/ -Fn | awk '$1 ~ /^n/' | awk -F'->' '{print $2}' | awk -F':' '{print $1}' | awk \"/$IP_REGEX/\" | awk NF) )\n    [ ${#var_ssm_connections[@]} -eq 0 ] || IP_ADDRESSES_SSM_ENDPOINTS+=(\"${var_ssm_connections[@]}\")\nfi\n\n# Removes duplicates\nIP_ADDRESSES_SSM_ENDPOINTS=($(for ip in \"${IP_ADDRESSES_SSM_ENDPOINTS[@]}\"; do echo \"${ip}\"; done | sort -u))\n\n#Check if any of the SSM endpoint IPs are in the sources and exiting if true\nfor e in ${IP_ADDRESSES[*]}; do\n  for ip in ${IP_ADDRESSES_SSM_ENDPOINTS[*]}; do\n    [[ \"$e\" = \"$ip\" ]] && \n    { \n      echo \"Sources contain protected SSM endpoint: ${e} - exiting\" >&2\n      temp_file=$(mktemp)\n      sed \"/$DELETE_MSG/d\" /etc/hosts > $temp_file\n      cat $temp_file > /etc/hosts\n      rm -f $temp_file\n      exit 1\n    }\ndone; done;\n\n\n# Adds Latency to Outgoing traffic if TrafficType is egress\nif [ \"$TRAFFIC\" = \"egress\" ]; then read -r -d '' ENABLE_FAULT_COMMAND <<'EOF'\n  # Exit if FIS network fault is already running\n  test_file_exit() {\n      if [ \"$(ls $1 2>/dev/null | wc -l)\" -ge \"2\" ]; then { echo \"Fault might be already running (Found flag file matching \"$1\"). Exiting...\" 1>&2 ; exit 1; } ; fi;\n  }\n  test_file_exit \"/var/lib/amazon/ssm/Run-Network-*.flag\"\n\n  echo \"Injecting fault...\"\n  # Send all traffic by default to the band 1:3\n  tc qdisc add dev $INTERFACE root handle 1: prio priomap 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2\n  exit_code=$?\n  if [[ $exit_code -ne 0 ]]; then\n    echo \"Traffic Rule could not be created, perhaps you lack the permission required.\";\n    echo \"tc exited with exit code $exit_code. Exiting.\";\n    exit \"$exit_code\"; \n  fi\n\n  # Redirect the matching ip addresses to the band 1:3 where is no network impairments\n  for k in ${IP_ADDRESSES_SSM_ENDPOINTS[*]}; do\n      tc filter add dev $INTERFACE protocol ip parent 1:0 prio 1 u32 match ip dst $k flowid 1:3\n  done\n\n  # Creates the qdisc in the band 1:1, but since all traffic goes to band 3, it does not affect it\n  tc qdisc add dev $INTERFACE parent 1:1 handle 10: netem delay \"${DELAYMILLISECONDS}\"ms \"${JITTERMILLISECONDS}\"ms\n  for k in ${IP_ADDRESSES[*]}; do\n      # Redirect the matching ip addresses to the band 1:1\n      tc filter add dev $INTERFACE protocol ip parent 1:0 prio 2 u32 match ip dst $k flowid 1:1\n  done\nEOF\n\n# Removes Latency to Outgoing traffic if TrafficType is egress\nread -r -d '' DISABLE_FAULT_COMMAND <<EOF\n  echo \"Rolling back...\"\n  tc qdisc del dev $INTERFACE parent 1:1 handle 10:\n  tc qdisc del dev $INTERFACE root handle 1: prio\n  temp_file=\\$(mktemp)\n  sed \"/$DELETE_MSG/d\" /etc/hosts > \\$temp_file\n  cat \\$temp_file > /etc/hosts\n  rm -f \\$temp_file\nEOF\nfi\n\n# Adds Latency from Incoming traffic if TrafficType is ingress\nif [ \"$TRAFFIC\" = \"ingress\" ]; then read -r -d '' ENABLE_FAULT_COMMAND <<'EOF'\n  # Exit if FIS network fault is already running\n  test_file_exit() {\n      if [ \"$(ls $1 2>/dev/null | wc -l)\" -ge \"2\" ]; then { echo \"Fault might be already running (Found flag file matching \"$1\"). Exiting...\" 1>&2 ; exit 1; } ; fi;\n  }\n  test_file_exit \"/var/lib/amazon/ssm/Run-Network-*.flag\"\n\n  echo \"Injecting fault...\"\n  # tc can only add latency on egress traffic so we use an intermediate device ifb\n  # Loading the ifb module (Intermediate Functional Block device)\n  modprobe ifb numifbs=2\n  exit_code=$?\n  if [[ $exit_code -ne 0 ]]; then\n    echo \"Traffic Rule could not be created, perhaps you lack the permission required.\";\n    echo \"modprobe exited with exit code $exit_code. Exiting.\";\n    exit \"$exit_code\"; \n  fi\n\n  # Limiting the use of set to the following line to ensure it fails the execution in case of failure\n  set -o xtrace\n  set -o errexit\n\n  # Bring up the interface\n  ip link set dev ifb0 up\n\n  set +o xtrace\n  set +o errexit\n\n  # Add an ingress queue to the interface\n  tc qdisc add dev $INTERFACE ingress\n  for k in ${IP_ADDRESSES_SSM_ENDPOINTS[*]}; do\n      tc filter add dev $INTERFACE parent ffff: protocol ip prio 1 u32 match ip src $k flowid 1:1\n  done\n  for k in ${IP_ADDRESSES[*]}; do\n      # Redirect matching traffic to ifb\n      tc filter add dev $INTERFACE parent ffff: protocol ip prio 2 u32 match ip src $k flowid 1:1 action mirred egress redirect dev ifb0\n  done\n  # Apply latency to the ifb interface, leaving the rest untouched\n  tc qdisc add dev ifb0 root netem delay \"${DELAYMILLISECONDS}\"ms \"${JITTERMILLISECONDS}\"ms\nEOF\n\n# Removes Latency from Incoming traffic if TrafficType is ingress\nread -r -d '' DISABLE_FAULT_COMMAND <<EOF\n  echo \"Rolling back...\"\n  tc qdisc del dev $INTERFACE ingress\n  tc qdisc del dev ifb0 root\n  rmmod ifb\n  temp_file=\\$(mktemp)\n  sed \"/$DELETE_MSG/d\" /etc/hosts > \\$temp_file\n  cat \\$temp_file > /etc/hosts\n  rm -f \\$temp_file\nEOF\nfi\n\n\n#################################\n# General fault-execution logic #\n#################################\n\nSTOP_TIME=$(( $(date +%s) + $DURATION ))\n\nMAX_FLAG_AGE_SECONDS=10\nATTEMPT_ROLLBACK_AT_SECONDS=20\nINJECTION_LOOP_SLEEP_SECONDS=5\n\nRANDOM_STRING=$(cat /dev/urandom | tr -dc 'a-zA-Z0-9' | head -c 32)\nFLAG_PATH=\"/var/lib/amazon/ssm/$FAULT_NAME-$RANDOM_STRING.flag\"\nROLLBACK_PATH=\"/var/lib/amazon/ssm/$FAULT_NAME-$RANDOM_STRING-Rollback.sh\"\n\n# Creating a file with rollback check command to be executed by atd\ncat << EOF > \"$ROLLBACK_PATH\"\n#!/bin/bash\n# Dont sleep if run in terminal\nif ! [ -t 0 ] ; then\n  sleep $ATTEMPT_ROLLBACK_AT_SECONDS\nfi\nif ! [ -f \"$FLAG_PATH\" ] || [ \"\\$(( \\$(date +%s) - \\$(stat -c \"%Y\" \"$FLAG_PATH\") ))\" -gt $MAX_FLAG_AGE_SECONDS ] || [ -t 0 ]; then\n  $DISABLE_FAULT_COMMAND\n  rm -f \"$FLAG_PATH\"\n  # Dont delete rollback script if run in terminal\n  if ! [ -t 0 ] ; then\n    rm -f \"$ROLLBACK_PATH\"\n  fi\nfi\nEOF\necho \"Temporary rollback file created: $ROLLBACK_PATH\"\n\n# Enqueue a rollback check after $ATTEMPT_ROLLBACK_AT_SECONDS seconds\nschedule_rollback_attempt() {\n  echo \"bash $ROLLBACK_PATH\" | at now 2> >(sed '/warning: commands will be executed using \\/bin\\/sh/d' )\n}\n\n# Function to delete the flag file and rollback the fault injection\nrollback() {\n  rm \"$FLAG_PATH\"\n  rm \"$ROLLBACK_PATH\"\n  eval \"$DISABLE_FAULT_COMMAND\" ; STATUS=$?\n  echo Rollback done.\n  exit $STATUS\n}\n\n# Binding the rollback function to these exit signals\ntrap rollback INT\ntrap rollback TERM\n\necho \"Making sure atd daemon is running\"\n# atd must be running in order to use \"at\" later\natd || { echo Failed to run atd daemon, exiting... 1>&2 ; exit 1; }\n\necho \"Scheduling rollback\"\nschedule_rollback_attempt\n\n# Injecting fault\necho \"Enabling fault injection\"\ntouch \"$FLAG_PATH\"\neval \"$ENABLE_FAULT_COMMAND\"\n\n# For the duration of the injection, the flag file is updated, and a rollback check is enqueued\nwhile [[ $(date +%s) -lt $STOP_TIME ]] ; do\n  # If the background rollback process fires, it will delete the script\n  # from disk containing the rollback logic.  That should not happen while\n  # this script is running, but if it does, we immediately fail the script\n  # to prevent the script from continuing to run as if the fault were active.\n  if ! [ -f \"$ROLLBACK_PATH\" ]; then\n    echo Fault rollback script was deleted from disk prematurely, exiting... 1>&2\n    # though the rollback likely already happened, we attempt rollback again since\n    # the rollback script might have been deleted by some unanticipated mechanism\n    eval \"$DISABLE_FAULT_COMMAND\"\n    exit 1\n  fi\n  touch \"$FLAG_PATH\"\n  schedule_rollback_attempt\n  sleep $INJECTION_LOOP_SLEEP_SECONDS\ndone\n\n# After the desired duration, the fault injection is removed\nrollback\n"
        ]
      }
    }
  ]
}
