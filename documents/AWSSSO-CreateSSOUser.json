{
  "schemaVersion": "2.2",
  "description": "Generates private and public keys for users to access instance through RDP protocol.",
  "parameters": {
    "Username": {
      "type": "String",
      "description": "The name of the user for whom a password is created or reset.",
      "allowedPattern": "^[^\"'\\/\\\\\\[\\]:;|=,+*?<>@\\r\\n]+$",
      "maxChars": 32
    },
    "RsaParameters": {
      "type": "String",
      "description": "A Modulus and Exponent that can be used to generate an RSA public key.",
      "allowedPattern": "^([0-9,a-z.]{6})([A-Za-z0-9-_\\/+]{4})*([A-Za-z0-9-_\\/+]{4}|[A-Za-z0-9-_\\/+]{3}=|[A-Za-z0-9-_\\/+]{2}==)$"
    },
    "PerformAction": {
      "type": "String",
      "description": "(Optional) Set this to 'Yes' to perform the action.",
      "default": "No",
      "allowedValues": [
        "No",
        "Yes"
      ]
    }
  },
  "mainSteps": [
    {
      "precondition": {
        "StringEquals": [
          "platformType",
          "Windows"
        ]
      },
      "action": "aws:runPowerShellScript",
      "name": "InvokeWindowsScript",
      "inputs": {
        "runCommand": [
          "$ErrorActionPreference = 'Stop'\n\n# NetAPI32 Error Code Constants\n$NERR_Success = 0             # The operation completed successfully\n$NERR_UserExists = 2224       # The user account already exists\n$NERR_PasswordTooShort = 2245 # The password does not meet the password policy requirements\n\nAdd-Type -TypeDefinition @\"\nusing System;\nusing System.Runtime.InteropServices;\nusing System.Security;\nusing System.Security.Cryptography;\n\npublic class NetAPI32 {\n    // Constants\n    private const uint UF_ACCOUNT_ENABLED = 0x10021;\n\n    // Password character sets\n    private const string CHARSET_LOWER = \"abcdefghijklmnopqrstuvwxyz\";\n    private const string CHARSET_UPPER = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n    private const string CHARSET_DIGITS = \"0123456789\";\n    private const string CHARSET_SYMBOLS = \"!@^&*(),.?<>;:+-_=|\";\n    private const string CHARSET_ALL = CHARSET_LOWER + CHARSET_UPPER + CHARSET_DIGITS + CHARSET_SYMBOLS;\n\n    // NetAPI32 Info Levels\n    private const uint USER_INFO_LEVEL_1 = 1;                      // Basic user information structure\n    private const uint USER_INFO_LEVEL_1003 = 1003;                // Password-only structure\n    private const uint USER_INFO_LEVEL_1008 = 1008;                // User flags structure\n    private const uint LOCALGROUP_MEMBERS_INFO_LEVEL_3 = 3;        // Group member domain and name structure\n\n    // Structs\n    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]\n    public struct USER_INFO_1 {\n        public string usri1_name;\n        public string usri1_password;\n        public uint usri1_password_age;\n        public uint usri1_priv;\n        public string usri1_home_dir;\n        public string usri1_comment;\n        public uint usri1_flags;\n        public string usri1_script_path;\n    }\n\n    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]\n    public struct USER_INFO_1003 {\n        public string usri1003_password;\n    }\n\n    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]\n    public struct USER_INFO_1008 {\n        public uint usri1008_flags;\n    }\n\n    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]\n    public struct LOCALGROUP_MEMBERS_INFO_3 {\n        public string lgrmi3_domainandname;\n    }\n\n    // Nested Classes\n    public class UserResult {\n        private uint errorCode;\n        private string output;\n\n        public uint ErrorCode {\n            get { return errorCode; }\n        }\n\n        public string StandardOutput {\n            get { return output; }\n        }\n\n        public UserResult(uint errorCode, string encryptedPassword, string paddingMode) {\n            this.errorCode = errorCode;\n            this.output = string.Format(\"{{\\\"paddingMode\\\":\\\"{0}\\\",\\\"cipherText\\\":\\\"{1}\\\"}}\",\n                                        paddingMode ?? \"\",\n                                        encryptedPassword ?? \"\");\n        }\n    }\n\n    // P/Invoke Declarations\n    [DllImport(\"netapi32.dll\", CharSet = CharSet.Unicode, SetLastError = true)]\n    private static extern uint NetUserAdd(\n        string servername,\n        uint level,\n        ref USER_INFO_1 userinfo,\n        out uint parm_err\n    );\n\n    [DllImport(\"netapi32.dll\", CharSet = CharSet.Unicode, SetLastError = true)]\n    private static extern uint NetUserSetInfo(\n        string servername,\n        string username,\n        uint level,\n        ref USER_INFO_1003 userinfo,\n        out uint parm_err\n    );\n\n    [DllImport(\"netapi32.dll\", CharSet = CharSet.Unicode, SetLastError = true, EntryPoint = \"NetUserSetInfo\")]\n    private static extern uint NetUserSetInfoFlags(\n        string servername,\n        string username,\n        uint level,\n        ref USER_INFO_1008 userinfo,\n        out uint parm_err\n    );\n\n    [DllImport(\"netapi32.dll\", CharSet = CharSet.Unicode, SetLastError = true)]\n    private static extern uint NetLocalGroupAddMembers(\n        string servername,\n        string groupname,\n        uint level,\n        ref LOCALGROUP_MEMBERS_INFO_3 buf,\n        uint totalentries\n    );\n\n    // Public API\n    public static UserResult CreateOrUpdateUser(string username, string rsaParameters) {\n        SecureString password = GenerateSecurePassword(32);\n        uint result = CreateUser(username, password);\n\n        // If password too complex, try with 14-character password\n        if (result == 2245) {\n            password = GenerateSecurePassword(14);\n            result = CreateUser(username, password);\n        }\n\n        if (result == 2224) {\n            result = UpdateExistingUser(username, password);\n        }\n\n        string encryptedPassword = \"\";\n        string paddingMode = \"\";\n\n        if (result == 0) {\n            AddUserToAdministrators(username);\n            EncryptPassword(password, rsaParameters, out encryptedPassword, out paddingMode);\n        }\n\n        return new UserResult(result, encryptedPassword, paddingMode);\n    }\n\n    private static SecureString GenerateSecurePassword(int length) {\n        if (length < 14 || length > 32) {\n            throw new ArgumentOutOfRangeException(\"length\", \"Password length must be between 14 and 32 characters inclusive\");\n        }\n\n        RNGCryptoServiceProvider rng = new RNGCryptoServiceProvider();\n        char[] tempChars = new char[length];\n        try {\n            SecureString secure = new SecureString();\n\n            do {\n                // Generate random password\n                for (int i = 0; i < length; i++) {\n                    int index = GetSecureRandomIndex(rng, CHARSET_ALL.Length);\n                    tempChars[i] = CHARSET_ALL[index];\n                }\n\n                // Secure shuffle using Fisher-Yates\n                for (int i = tempChars.Length - 1; i > 0; i--) {\n                    int j = GetSecureRandomIndex(rng, i + 1);\n                    char temp = tempChars[i];\n                    tempChars[i] = tempChars[j];\n                    tempChars[j] = temp;\n                }\n\n            } while (!ValidatePasswordComplexity(tempChars, CHARSET_LOWER, CHARSET_UPPER, CHARSET_DIGITS, CHARSET_SYMBOLS));\n\n            for (int i = 0; i < tempChars.Length; i++) {\n                secure.AppendChar(tempChars[i]);\n            }\n\n            return secure;\n        }\n        finally {\n            // Clear sensitive data\n            Array.Clear(tempChars, 0, tempChars.Length);\n        }\n    }\n\n    // Private Implementation\n    private static void EncryptPassword(SecureString password, string rsaParameters, out string encryptedPassword, out string paddingMode) {\n        encryptedPassword = \"\";\n        paddingMode = \"\";\n\n        // Parse RSA parameters from format \"[Exponent].[Modulus]\" BEFORE decrypting password\n        string[] keyParts = rsaParameters.Split('.');\n        if (keyParts.Length != 2) return;\n\n        // Parse exponent\n        string[] exponentParts = keyParts[0].Split(',');\n        byte[] exponent = new byte[exponentParts.Length];\n        for (int i = 0; i < exponentParts.Length; i++) {\n            exponent[i] = byte.Parse(exponentParts[i]);\n        }\n\n        // Parse modulus\n        byte[] modulus = Convert.FromBase64String(keyParts[1]);\n\n        // Create RSA with parameters\n        RSACryptoServiceProvider rsa = new RSACryptoServiceProvider();\n        RSAParameters rsaParams = new RSAParameters();\n        rsaParams.Exponent = exponent;\n        rsaParams.Modulus = modulus;\n        rsa.ImportParameters(rsaParams);\n\n        // NOW decrypt password only when we're ready to encrypt it immediately\n        IntPtr passwordPtr = IntPtr.Zero;\n        try {\n            passwordPtr = Marshal.SecureStringToGlobalAllocUnicode(password);\n            string plaintextPassword = Marshal.PtrToStringUni(passwordPtr);\n\n            // Convert password to bytes and encrypt immediately\n            byte[] passwordBytes = System.Text.Encoding.UTF8.GetBytes(plaintextPassword);\n            plaintextPassword = null; // Clear reference to help GC\n\n            // Try OaepSHA1 first, fallback to Pkcs1\n            byte[] encryptedBytes;\n            try {\n                encryptedBytes = rsa.Encrypt(passwordBytes, true); // true = OAEP\n                paddingMode = \"OaepSHA1\";\n            } catch {\n                encryptedBytes = rsa.Encrypt(passwordBytes, false); // false = PKCS1\n                paddingMode = \"Pkcs1\";\n            }\n\n            Array.Clear(passwordBytes, 0, passwordBytes.Length);\n            encryptedPassword = Convert.ToBase64String(encryptedBytes);\n        } finally {\n            if (passwordPtr != IntPtr.Zero) {\n                Marshal.ZeroFreeGlobalAllocUnicode(passwordPtr);\n            }\n            ForceGarbageCollection();\n        }\n    }\n\n    private static void ForceGarbageCollection() {\n        GC.Collect();\n        GC.WaitForPendingFinalizers();\n        GC.Collect();\n    }\n\n    private static bool ValidatePasswordComplexity(char[] password, string lower, string upper, string digits, string symbols) {\n        int lowerCount = 0, upperCount = 0, digitCount = 0, symbolCount = 0;\n\n        for (int i = 0; i < password.Length; i++) {\n            char c = password[i];\n            if (lower.IndexOf(c) >= 0) lowerCount++;\n            else if (upper.IndexOf(c) >= 0) upperCount++;\n            else if (digits.IndexOf(c) >= 0) digitCount++;\n            else if (symbols.IndexOf(c) >= 0) symbolCount++;\n        }\n\n        return lowerCount >= 2 && upperCount >= 2 && digitCount >= 2 && symbolCount >= 2;\n    }\n\n    private static int GetSecureRandomIndex(RNGCryptoServiceProvider rng, int maxValue) {\n        if (maxValue <= 1) return 0;\n\n        byte[] bytes = new byte[4];\n        uint exclusionZone = uint.MaxValue - (uint.MaxValue % (uint)maxValue);\n        uint result;\n\n        do {\n            rng.GetBytes(bytes);\n            result = BitConverter.ToUInt32(bytes, 0);\n        } while (result >= exclusionZone);\n\n        // Clear the byte array\n        Array.Clear(bytes, 0, bytes.Length);\n        return (int)(result % (uint)maxValue);\n    }\n\n    private static uint UpdateExistingUser(string username, SecureString password) {\n        uint result = SetUserPassword(username, password);\n        if (result == 0) {\n            result = EnableAccount(username);\n        }\n        return result;\n    }\n\n    private static void AddUserToAdministrators(string username) {\n        AddUserToGroup(username, \"Administrators\");\n    }\n\n    private static uint CreateUser(string username, SecureString password) {\n        IntPtr passwordPtr = IntPtr.Zero;\n        try {\n            passwordPtr = Marshal.SecureStringToGlobalAllocUnicode(password);\n            string plaintextPassword = Marshal.PtrToStringUni(passwordPtr);\n\n            USER_INFO_1 userInfo = new USER_INFO_1();\n            userInfo.usri1_name = username;\n            userInfo.usri1_password = plaintextPassword;\n            userInfo.usri1_priv = 1;\n            userInfo.usri1_flags = UF_ACCOUNT_ENABLED;\n            uint parmErr;\n            uint result = NetUserAdd(null, USER_INFO_LEVEL_1, ref userInfo, out parmErr);\n\n            userInfo.usri1_password = string.Empty;\n            plaintextPassword = null;\n\n            return result;\n        }\n        finally {\n            if (passwordPtr != IntPtr.Zero) {\n                Marshal.ZeroFreeGlobalAllocUnicode(passwordPtr);\n            }\n            ForceGarbageCollection();\n        }\n    }\n\n    private static uint SetUserPassword(string username, SecureString password) {\n        IntPtr passwordPtr = IntPtr.Zero;\n        try {\n            passwordPtr = Marshal.SecureStringToGlobalAllocUnicode(password);\n            string plaintextPassword = Marshal.PtrToStringUni(passwordPtr);\n\n            USER_INFO_1003 passwordInfo = new USER_INFO_1003();\n            passwordInfo.usri1003_password = plaintextPassword;\n            uint parmErr;\n            uint result = NetUserSetInfo(null, username, USER_INFO_LEVEL_1003, ref passwordInfo, out parmErr);\n\n            passwordInfo.usri1003_password = string.Empty;\n            plaintextPassword = null;\n\n            return result;\n        }\n        finally {\n            if (passwordPtr != IntPtr.Zero) {\n                Marshal.ZeroFreeGlobalAllocUnicode(passwordPtr);\n            }\n            ForceGarbageCollection();\n        }\n    }\n\n    private static uint SetUserFlags(string username, uint flags) {\n        USER_INFO_1008 flagsInfo = new USER_INFO_1008();\n        flagsInfo.usri1008_flags = flags;\n        uint parmErr;\n        return NetUserSetInfoFlags(null, username, USER_INFO_LEVEL_1008, ref flagsInfo, out parmErr);\n    }\n\n    private static uint EnableAccount(string username) {\n        return SetUserFlags(username, UF_ACCOUNT_ENABLED);\n    }\n\n    private static uint AddUserToGroup(string username, string groupname) {\n        LOCALGROUP_MEMBERS_INFO_3 memberInfo = new LOCALGROUP_MEMBERS_INFO_3();\n        memberInfo.lgrmi3_domainandname = username;\n        return NetLocalGroupAddMembers(null, groupname, LOCALGROUP_MEMBERS_INFO_LEVEL_3, ref memberInfo, 1);\n    }\n}\n\"@\n\nFunction ParseInputParameter {\n    param (\n        [string]$Name,\n        [string]$Value,\n        [string]$Regex\n    )\n\n    $ValidParameterRegex = '^--%[ +{|{].*}( +)?$'\n    if ($Value -notmatch $ValidParameterRegex) {\n        ExitWithFailureMessage -Message \"Invalid syntax for the parameter $Name\" -PrintJson\n    }\n    $parameterValue = $Value.Substring(3)\n\n    $trimmedParameterValue = $parameterValue.TrimStart().TrimEnd()\n    $trimmedParameterValue = $trimmedParameterValue.Substring(1)\n    $trimmedParameterValue = $trimmedParameterValue.Substring(0, $trimmedParameterValue.Length - 1)\n\n    if ($Regex -and $trimmedParameterValue -notmatch $Regex) {\n        ExitWithFailureMessage -Message \"Invalid syntax for the parameter $Name\" -PrintJson\n    } else {\n        $trimmedParameterValue\n    }\n}\n\nfunction ExitWithFailureMessage {\n    param (\n        [string]$Message,\n        [string]$ExceptionMessage,\n        [Switch]$PrintJson,\n        [int]$ExitCode = 1\n    )\n    if ([string]::IsNullOrWhitespace($ExceptionMessage)) {\n        $errorMessage = $Message\n    } else {\n        $errorMessage = '{0} {1}' -f $Message, $ExceptionMessage\n    }\n    if ($PrintJson) { ConvertTo-Json -InputObject @{error = $errorMessage } -Compress }\n    WriteStandardError -Message $errorMessage\n    [System.Environment]::Exit($ExitCode)\n}\n\nfunction WriteStandardError {\n    param (\n        [string]$Message\n    )\n    $Host.UI.WriteErrorLine($Message)\n}\n\nfunction TestPerformAction {\n    param ( [string]$PerformAction )\n    if ($PerformAction -ne 'Yes') {\n        ExitWithFailureMessage -Message \"No action was taken because the PerformAction parameter is set to $PerformAction. To make the desired change, set this parameter to Yes.\" -PrintJson\n    }\n}\n\n$Username = Write-Output --%{{{ Username }}}\n$Username = ParseInputParameter -Name 'Username' -Value $Username\n\n$RsaParameters = Write-Output --%{{{ RsaParameters }}}\n$RsaParameters = ParseInputParameter -Name 'RsaParameters' -Value $RsaParameters\n\n$PerformAction = Write-Output --%{{{ PerformAction }}}\n$PerformAction = ParseInputParameter -Name 'PerformAction' -Value $PerformAction -Regex '(Yes|No)'\nTestPerformAction -PerformAction $PerformAction\n\n# Fail if the current system is a domain controller.\n$domainRole = (Get-WmiObject -Class 'Win32_ComputerSystem' -Property 'DomainRole').DomainRole\nif ($domainRole -ge 4) {\n    ExitWithFailureMessage -Message 'The SSO functionality is not supported on domain controllers. You can only connect with the username/password method.' -PrintJson\n}\n\n$userResult = [NetAPI32]::CreateOrUpdateUser($Username, $RsaParameters)\nif ($userResult.ErrorCode -ne $NERR_Success) {\n    switch ($userResult.ErrorCode) {\n        $NERR_PasswordTooShort { ExitWithFailureMessage -Message \"Failed to reset the SSO user's password\" -PrintJson }\n        $NERR_UserExists { ExitWithFailureMessage -Message \"Failed to reset the SSO user's password\" -PrintJson }\n        default { ExitWithFailureMessage -Message \"Failed to create the SSO user\" -PrintJson }\n    }\n}\n\n# Return encrypted password and padding mode\n$userResult.StandardOutput\n"
        ]
      }
    }
  ]
}
