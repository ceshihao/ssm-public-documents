{
  "schemaVersion": "0.3",
  "description": "The **AWSSupport-CloneXenEC2InstanceAndMigrateToNitro** automation runbook clones, prepares and migrates the cloned Amazon EC2 Linux instance, currently running on Amazon EC2 Xen platform, to run on [Amazon EC2 Nitro platform](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html#ec2-nitro-instances). This automation is divided into three different branches, details of which are as follows:\n\n\n### 1. Preliminary Checks\n\nIn this branch, automation evaluates all of the following pre-requisites to proceed with the migration. If any of the steps fails, automation stops.\n\n- Checks if the target EC2 instance is already running on Nitro platform\n- Determines if the [lifecycle](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-purchasing-options.html#check-instance-lifecycle) of the target EC2 instance is Spot\n- Checks if any [instance-store-volume](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/InstanceStorage.html#instance-store-volumes) is attached with the target EC2 instance\n- Validates if the Operating System is Linux\n- Determines if the target EC2 instance is a part of the AWS Auto Scaling. If yes, the EC2 instance should be in the [Standby state](https://docs.aws.amazon.com/autoscaling/ec2/userguide/as-enter-exit-standby.html)\n- Checks if the target EC2 instance is connected with SSM and configured to use AWS Systems Manager Run Command\n\n\n### 2. Test \n\nThe automation uses this phase as sanity test by creating a test Amazon Machine Image (AMI) from the target EC2 instance and launching a test EC2 instance using this AMI. \n\nIf the test EC2 instance passes the status checks, automation is temporarily paused and approval from the designated principals is requested via Amazon Simple Notification Service (SNS) notification. If approval is provided, automation stops the target EC2 instance.\n\n*Note:*\n\n*- Before providing approval, ensure that all the application(s) running on the target EC2 instance are gracefully closed.*\n\n*- If the EC2 does not have an Elastic IP addresses associated, the automatic public IPv4 address will change once the instance is stopped and started.*\n\n*- Test AMI & EC2 instance are deleted at the end of this branch*\n\n### 3. CloneAndMigrate \n\nIn this branch, automation creates a clone of your target EC2 instance in the same subnet and migrates the EC2 instance using the following steps:\n\n- Enables the [Enhanced networking (ENA) attribute](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/enhanced-networking-ena.html#enable-enhanced-networking-ena-AL)\n- Installs the latest version of ENA drivers\n- Verifies if the NVMe module is installed and loaded in the initramfs. If not, adds the module in initramfs and rebuilds it. However, if the NVMe module is not installed, automation fails.\n- Analyzes */etc/fstab* and replaces entries with block device names(/dev/sd\\* or /dev/xvd\\*) with their respective UUIDs. Before modifying the configuration, the runbook creates a backup of the file at path */etc/fstab**\n- Disables [predictable interface naming](https://www.freedesktop.org/wiki/Software/systemd/PredictableNetworkInterfaceNames/) by adding the ``net.ifnames=0`` option to the ``GRUB_CMDLINE_LINUX`` line in */etc/default/grub*, if exists OR to the ``kernel`` in */boot/grub/menu.lst*\n- Removes */etc/udev/rules.d/70-persistent-net.rules* file, if exists. Before removing, creates a backup at path */etc/udev/rules.d/*\n\nAfter validating all the requirements, the cloned EC2 instance type is changed to the desired Nitro type.  Once the cloned instance passes the Status Checks on Nitro platform, automation seeks for designated principal's approval to create an AMI. If approval is denied, automation stops, leaving cloned EC2 instance.\n\n\n\n### Prerequisites:\n\nTarget EC2 instance requires outbound access to the repositories to install drivers and dependencies such as *kernel-devel, gcc,patch, rpm-build. wget,dracut, make, linux-headers,unzip* using package manager if needed.\n\n\n### Supported Operating Systems:\n* Red Hat Enterprise Linux (RHEL) 8 and 9\n* Amazon Linux 2 and Amazon Linux 2023\n* Ubuntu Server 18.04 LTS, 20.04 and 22.04\n* Debian 11 and 12 (AWS partition only)\n* SUSE12SP5 and SUSE15SP(5,6)\n\n\n### Disclaimer:\n\n* Executing this runbook, may incur extra charges to your account for the EC2 instance, EBS Volumes & Amazon Machine Images(AMIs). Please refer to the [Amazon EC2 Pricing](https://aws.amazon.com/ec2/pricing/) & [Amazon EBS pricing](https://aws.amazon.com/ebs/pricing/) for more details.",
  "assumeRole": "{{ AutomationAssumeRole }}",
  "parameters": {
    "AutomationAssumeRole": {
      "type": "AWS::IAM::Role::Arn",
      "description": "(Optional) The Amazon Resource Name (ARN) of the AWS Identity and Access Management (IAM) role that allows Systems Manager Automation to perform the actions on your behalf. If no role is specified, Systems Manager Automation uses the permissions of the user that starts this runbook.",
      "default": ""
    },
    "TargetInstanceId": {
      "type": "AWS::EC2::Instance::Id",
      "description": "(Required) Instance ID of the target EC2 instance you want to migrate to Nitro platform."
    },
    "NitroInstanceType": {
      "type": "String",
      "default": "m5.xlarge",
      "description": "(Optional) Enter the destination Nitro instance type. Note: Only Nitro M5, M6, C5, C6, R5, R6 and T3 instances are supported (e.g. t3.small). For more details about the available Nitro instance types, please refer to the link: https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html .",
      "allowedPattern": "^(m5a?z?d?n?|c5a?d?n?|r5a?d?n?b?|(c|m|r)6(a|i)?d?)\\.(2|4|8|12|16|24|32)?xlarge$|^t3a?\\.((x|2x)?large|nano|micro|small|medium)$"
    },
    "SNSTopicArn": {
      "type": "String",
      "description": "(Required) Provide the ARN of the SNS Topic for Approval notification. This SNS topic is used to send approval notifications during required during the automation execution.",
      "allowedPattern": "^arn:(aws|aws-cn|aws-us-gov|aws-iso(-[a-z])?):sns:(us(-gov|-isob?)?|ap|ca|af|me|cn|eu|sa)-(central|(north|south)?(east|west)?)-\\d:\\d{12}:[a-zA-Z0-9_.-]{1,256}$"
    },
    "ApproverIAM": {
      "type": "StringList",
      "description": "(Required) Provide a list of AWS authenticated principals who are able to either approve or reject the action. The maximum number of approvers is 10. You can specify principals by using any of these formats, 1) An AWS Identity and Access Management (IAM) user name 2) An IAM user ARN 3) An IAM role ARN 4) An IAM assume role user ARN.",
      "allowedPattern": "^[a-zA-Z0-9_+=,.@\\-/]{1,128}$|^arn:(aws|aws-cn|aws-us-gov|aws-iso(-[a-z])?):(sts|iam)::[0-9]{12}:[a-zA-Z0-9_+=,.@\\-/]{1,256}$"
    },
    "MinimumRequiredApprovals": {
      "type": "Integer",
      "default": 1,
      "description": "(Optional) The minimum number of approvals required to resume the automation. If you don't specify a value, the system defaults to `1`. The value for this parameter must be a positive number. The value for this parameter can't exceed the number of approvers defined by the ApproverIAM parameter.",
      "allowedValues": [
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        10
      ]
    },
    "DeleteResourcesOnFailure": {
      "type": "Boolean",
      "default": true,
      "description": "(Optional) Whether to terminate the cloned EC2 instance and Amazon Machine Image (AMI) if the automation fails.",
      "allowedValues": [
        false,
        true
      ]
    },
    "Acknowledgement": {
      "type": "String",
      "description": "(Required) Please read the complete details of the actions performed by this automation runbook and write 'Yes, I understand and acknowledge' if you acknowledge the steps.",
      "allowedPattern": "^Yes, I understand and acknowledge$"
    },
    "AllowInstanceStoreInstances": {
      "type": "String",
      "description": "(Optional) If you specify `yes`, the runbook runs on instances that have instance store volumes attached. **Warning:** data in the instance store volumes is lost when the instance is stopped. This parameter helps avoid accidental data loss.",
      "default": "no",
      "allowedValues": [
        "no",
        "yes"
      ]
    }
  },
  "mainSteps": [
    {
      "name": "checkConcurrency",
      "action": "aws:executeScript",
      "description": "Ensures there is only one execution of this runbook targeting the current EC2 instance. If the runbook finds another in progress execution targeting the same EC2 instance, it returns an error and ends.",
      "timeoutSeconds": 600,
      "onFailure": "Abort",
      "nextStep": "startOfPreliminaryChecksBranch",
      "inputs": {
        "InputPayload": {
          "TargetInstanceId": "{{ TargetInstanceId }}"
        },
        "Handler": "checkConcurrency.check_concurrency_handler",
        "Runtime": "python3.11",
        "Attachment": "attachment.zip"
      },
      "outputs": [
        {
          "Name": "NoExecutionFound",
          "Selector": "$.Payload.NoExecutionFound",
          "Type": "String"
        }
      ]
    },
    {
      "name": "startOfPreliminaryChecksBranch",
      "action": "aws:sleep",
      "description": "Start of Preliminary checks branch and Start of Testing branch",
      "onFailure": "step:getTargetInstanceProperties",
      "nextStep": "getTargetInstanceProperties",
      "isCritical": false,
      "inputs": {
        "Duration": "PT5S"
      }
    },
    {
      "name": "getTargetInstanceProperties",
      "action": "aws:executeAwsApi",
      "description": "Fetches the details of the target EC2 instance",
      "onFailure": "Abort",
      "maxAttempts": 3,
      "nextStep": "checkIfNitroInstanceTypeIsSupportedInAZ",
      "inputs": {
        "Service": "ec2",
        "Api": "DescribeInstances",
        "InstanceIds": [
          "{{ TargetInstanceId }}"
        ]
      },
      "outputs": [
        {
          "Name": "PlatformType",
          "Selector": "$.Reservations[0].Instances[0].Platform",
          "Type": "String"
        },
        {
          "Name": "InstanceSubnetId",
          "Selector": "$.Reservations[0].Instances[0].SubnetId",
          "Type": "String"
        },
        {
          "Name": "SecurityGroup",
          "Selector": "$.Reservations[0].Instances[0].SecurityGroups[0].GroupId",
          "Type": "String"
        },
        {
          "Name": "InstanceProfileArn",
          "Selector": "$.Reservations[0].Instances[0].IamInstanceProfile.Arn",
          "Type": "String"
        },
        {
          "Name": "InstanceProfileName",
          "Selector": "$.Reservations[0].Instances[0].IamInstanceProfile.Name",
          "Type": "String"
        },
        {
          "Name": "AvailabilityZone",
          "Selector": "$.Reservations[0].Instances[0].Placement.AvailabilityZone",
          "Type": "String"
        },
        {
          "Name": "RootDeviceName",
          "Selector": "$.Reservations[0].Instances[0].RootDeviceName",
          "Type": "String"
        },
        {
          "Name": "RootVolumeType",
          "Selector": "$.Reservations[0].Instances[0].RootDeviceType",
          "Type": "String"
        },
        {
          "Name": "InstanceType",
          "Selector": "$.Reservations[0].Instances[0].InstanceType",
          "Type": "String"
        },
        {
          "Name": "ENAAttrib",
          "Selector": "$.Reservations[0].Instances[0].EnaSupport",
          "Type": "Boolean"
        },
        {
          "Name": "InstanceLifecycle",
          "Selector": "$.Reservations[0].Instances[0].InstanceLifecycle",
          "Type": "String"
        },
        {
          "Name": "InstanceState",
          "Selector": "$.Reservations[0].Instances[0].State.Name",
          "Type": "String"
        }
      ]
    },
    {
      "name": "checkIfNitroInstanceTypeIsSupportedInAZ",
      "action": "aws:assertAwsResourceProperty",
      "description": "Determines if the target Nitro instance type is supported in the same Availability Zone as the Target EC2 instance ",
      "onFailure": "Abort",
      "isCritical": true,
      "maxAttempts": 3,
      "nextStep": "getXenInstanceTypeDetails",
      "inputs": {
        "Service": "ec2",
        "Api": "DescribeInstanceTypeOfferings",
        "LocationType": "availability-zone",
        "Filters": [
          {
            "Name": "instance-type",
            "Values": [
              "{{ NitroInstanceType }}"
            ]
          },
          {
            "Name": "location",
            "Values": [
              "{{ getTargetInstanceProperties.AvailabilityZone }}"
            ]
          }
        ],
        "PropertySelector": "$.InstanceTypeOfferings[0].Location",
        "DesiredValues": [
          "{{ getTargetInstanceProperties.AvailabilityZone }}"
        ]
      }
    },
    {
      "name": "getXenInstanceTypeDetails",
      "action": "aws:executeAwsApi",
      "description": "Fetches the details of the the Xen (source) Instance type",
      "onFailure": "Abort",
      "maxAttempts": 3,
      "nextStep": "branchOnInstanceHypervisorIsNitroAlready",
      "inputs": {
        "Service": "ec2",
        "Api": "DescribeInstanceTypes",
        "InstanceTypes": [
          "{{ getTargetInstanceProperties.InstanceType }}"
        ]
      },
      "outputs": [
        {
          "Name": "Hypervisor",
          "Selector": "$.InstanceTypes[0].Hypervisor",
          "Type": "String"
        },
        {
          "Name": "NVMeSupport",
          "Selector": "$.InstanceTypes[0].InstanceStorageInfo.NvmeSupport",
          "Type": "String"
        },
        {
          "Name": "InstanceStorageSupported",
          "Selector": "$.InstanceTypes[0].InstanceStorageSupported",
          "Type": "Boolean"
        }
      ]
    },
    {
      "name": "branchOnInstanceHypervisorIsNitroAlready",
      "action": "aws:branch",
      "description": "Checks if the target EC2 instance is already running on Nitro platform",
      "isEnd": true,
      "isCritical": true,
      "inputs": {
        "Choices": [
          {
            "NextStep": "branchOnTargetInstanceLifecycleIsSpot",
            "Variable": "{{ getXenInstanceTypeDetails.Hypervisor }}",
            "StringEquals": "xen"
          }
        ]
      }
    },
    {
      "name": "branchOnTargetInstanceLifecycleIsSpot",
      "action": "aws:branch",
      "description": "Checks if the Lifecycle of the target EC2 instance is Spot",
      "isCritical": true,
      "isEnd": true,
      "onFailure": "Abort",
      "inputs": {
        "Choices": [
          {
            "NextStep": "branchOnOperatingSystemIsLinux",
            "Not": {
              "Variable": "{{ getTargetInstanceProperties.InstanceLifecycle }}",
              "StringEquals": "spot"
            }
          }
        ]
      }
    },
    {
      "name": "branchOnOperatingSystemIsLinux",
      "action": "aws:branch",
      "description": "Checks if the target EC2 instance is based on Linux Operating System",
      "isEnd": true,
      "isCritical": true,
      "inputs": {
        "Choices": [
          {
            "NextStep": "verifySSMConnectivityForTargetInstance",
            "Not": {
              "Variable": "{{ getTargetInstanceProperties.PlatformType }}",
              "StringEquals": "windows"
            }
          }
        ]
      }
    },
    {
      "name": "verifySSMConnectivityForTargetInstance",
      "action": "aws:runCommand",
      "description": "Verifies if the target EC2 instance is connected with AWS Systems Manager and configured to use RunCommand",
      "onFailure": "Abort",
      "isCritical": true,
      "maxAttempts": 3,
      "timeoutSeconds": 180,
      "nextStep": "checkOSSupport",
      "inputs": {
        "InstanceIds": [
          "{{ TargetInstanceId }}"
        ],
        "DocumentName": "AWS-RunShellScript",
        "TimeoutSeconds": 300,
        "Parameters": {
          "commands": [
            "#!/bin/bash",
            "echo \"EC2 connected with AWS SSM, configured to use RunCommand\""
          ]
        }
      }
    },
    {
      "name": "checkOSSupport",
      "action": "aws:runCommand",
      "description": "Validates if the Operating System(OS) is supported by this automation.",
      "onFailure": "Abort",
      "isCritical": true,
      "maxAttempts": 3,
      "timeoutSeconds": 180,
      "nextStep": "branchOnEphemeralVolumesAreSupported",
      "inputs": {
        "InstanceIds": [
          "{{ TargetInstanceId }}"
        ],
        "DocumentName": "AWS-RunShellScript",
        "TimeoutSeconds": 300,
        "Parameters": {
          "commands": [
            "#!/bin/bash",
            "",
            "",
            "",
            "get_os_version(){",
            "    if [ -f /etc/os-release ]; then",
            "        linux_dist_name=$(grep -w \"NAME=\" /etc/os-release | awk -F'=' '{print $2}'|tr -d '\"')",
            "        linux_dist_ver=$(grep -E \"VER_ID|VERSION_ID\" /etc/os-release | awk -F'=' '{print $2}' | tr -d '\"')",
            "        linux_major_ver=$(echo \"$linux_dist_ver\" | awk -F'.' '{print $1}'|tr -d '\"')",
            "        linux_minor_ver=$(echo \"$linux_dist_ver\" | awk -F'.' '{print $2}'|tr -d '\"')",
            "    fi",
            "}",
            "",
            "check_supported_os_versions(){",
            "    if [ \"$linux_dist_name\" = \"Ubuntu\" ] && [ \"$linux_major_ver\" -lt 16 ]; then",
            "        unsupported_os",
            "    elif [ \"$linux_dist_name\" = \"Red Hat Enterprise Linux\" ] && [ \"$linux_major_ver\" -lt 7 ]; then",
            "        unsupported_os",
            "    elif [ \"$linux_dist_name\" = \"Amazon Linux\" ] && [ \"$(echo \"${linux_dist_ver} != 2018.03\"| bc)\" -eq 1 ] && [ \"$linux_major_ver\" -lt 2 ]; then",
            "        unsupported_os",
            "    elif [ \"$linux_dist_name\" = \"SLES\" ] && { { [ \"$linux_major_ver\" -lt 15 ] && [ \"$linux_minor_ver\" -lt 2 ]; } || { [ \"$linux_major_ver\" -lt 12 ] && [ \"$linux_minor_ver\" -lt 5 ]; };}; then",
            "        unsupported_os",
            "    elif [ \"$linux_dist_name\" = \"Debian GNU/Linux\" ] && [ \"$linux_dist_ver\" -lt 11 ] && [ \"$linux_dist_ver\" -gt 12 ]; then",
            "        unsupported_os",
            "    else",
            "        echo \"[INFO] Linux version is supported by this automation\"",
            "    fi ",
            "}",
            "",
            "unsupported_os() {",
            "        echo \"[ERROR] Linux version is not supported by this automation.\"",
            "        exit 1",
            "}",
            "",
            "",
            "get_os_version",
            "check_supported_os_versions"
          ]
        }
      }
    },
    {
      "name": "branchOnEphemeralVolumesAreSupported",
      "action": "aws:branch",
      "description": "Checks if the target EC2 instance supports the Instance Store (Ephemeral) volumes",
      "isEnd": false,
      "isCritical": true,
      "inputs": {
        "Choices": [
          {
            "NextStep": "verifyIfTargetInstanceHasEphemeralVolumesAttached",
            "Variable": "{{ getXenInstanceTypeDetails.InstanceStorageSupported }}",
            "BooleanEquals": true
          }
        ],
        "Default": "branchOnRootVolumeIsEBS"
      }
    },
    {
      "name": "verifyIfTargetInstanceHasEphemeralVolumesAttached",
      "action": "aws:runCommand",
      "description": "Verifies if the target EC2 instance has Instance Store(Ephemeral) Volumes attached",
      "onFailure": "Abort",
      "isCritical": true,
      "maxAttempts": 3,
      "timeoutSeconds": 600,
      "nextStep": "branchOnRootVolumeIsEBS",
      "inputs": {
        "InstanceIds": [
          "{{ TargetInstanceId }}"
        ],
        "DocumentName": "AWS-RunShellScript",
        "TimeoutSeconds": 300,
        "Parameters": {
          "commands": [
            "#!/bin/bash",
            "",
            "NVME_SUPPORT='{{getXenInstanceTypeDetails.NVMeSupport}}'",
            "ALLOW_INSTANCE_STORE_VOLUMES='{{AllowInstanceStoreInstances}}'",
            "ERROR=\"\\n [ERROR] UnSupported Instance Type: instance store volumes attached. Exiting... \\n\"",
            "INFO=\"\\n [INFO] No instance store volumes are attached with the EC2 instance \\n\"",
            "BYPASS_INFO=\"\\n [INFO] Instance store volumes detected, but check bypassed due to AllowInstanceStoreInstances set to yes \\n\"",
            "",
            "if [[ \"${AWS_SSM_INSTANCE_ID}\" =~ ^[i]-[a-z0-9]{8,17}$ ]]; then",
            "    # If user has explicitly allowed instance store volumes, bypass the check",
            "    if [ \"${ALLOW_INSTANCE_STORE_VOLUMES}\" = \"yes\" ]; then",
            "        echo -e \"$BYPASS_INFO\"",
            "        exit 0",
            "    fi",
            "",
            "    if [ \"${NVME_SUPPORT}\" = \"required\" ]; then",
            "        if [ \"$(ls -l /dev/disk/by-id/ | grep Amazon_EC2_NVMe_Instance_Storage | grep -wv ns-1 | awk '{ print $11 }' | sed 's/[./]//g' > /dev/null; echo $?)\" == \"0\" ]; then",
            "                echo -en \"$ERROR\"",
            "                exit 1",
            "        else",
            "                echo -en \"$INFO\"",
            "        fi",
            "    elif [ $NVME_SUPPORT = \"unsupported\" ]; then",
            "        TOKEN=\"$(curl -s -X PUT \"http://169.254.169.254/latest/api/token\" -H \"X-aws-ec2-metadata-token-ttl-seconds: 21600\")\" && curl -s -H \"X-aws-ec2-metadata-token: $TOKEN\" http://169.254.169.254/latest/meta-data/block-device-mapping/ | grep -vE 'ami|root|swap' > /dev/null; echo $?",
            "        if [ \"${TOKEN}\" = \"0\" ]; then",
            "                echo -en \"$ERROR\"",
            "                exit 1",
            "        else",
            "                echo -en \"$INFO\"",
            "            fi",
            "    else",
            "        echo -en \"[ERROR] Unknown Error \\n\"",
            "        exit 1",
            "    fi",
            "else",
            "    echo -en \"[ERROR] InstanceID ${AWS_SSM_INSTANCE_ID} is not an EC2 instance\"",
            "    exit 1",
            "fi"
          ]
        }
      }
    },
    {
      "name": "branchOnRootVolumeIsEBS",
      "action": "aws:branch",
      "description": "Checks if target EC2 instance's root volume type is EBS",
      "isCritical": true,
      "isEnd": true,
      "onFailure": "Abort",
      "inputs": {
        "Choices": [
          {
            "NextStep": "checkIfTargetInstanceIsInASG",
            "Variable": "{{ getTargetInstanceProperties.RootVolumeType }}",
            "StringEquals": "ebs"
          }
        ]
      }
    },
    {
      "name": "checkIfTargetInstanceIsInASG",
      "action": "aws:executeScript",
      "description": "Checks if the target EC2 instance is a part of any Amazon AutoScaling Group(ASG)",
      "nextStep": "startOfTestBranch",
      "isCritical": true,
      "maxAttempts": 1,
      "onFailure": "Abort",
      "inputs": {
        "InputPayload": {
          "TargetInstanceId": "{{ TargetInstanceId }}"
        },
        "Handler": "checkAutoScaling.check_auto_scaling_handler",
        "Runtime": "python3.11",
        "Attachment": "attachment.zip"
      }
    },
    {
      "name": "startOfTestBranch",
      "action": "aws:sleep",
      "description": "End of Preliminary checks branch and Start of Testing branch",
      "onFailure": "Abort",
      "nextStep": "createTestImage",
      "isCritical": false,
      "inputs": {
        "Duration": "PT5S"
      }
    },
    {
      "name": "createTestImage",
      "action": "aws:createImage",
      "description": "Creates a test Amazon Machine Image(AMI) from the provided instance",
      "maxAttempts": 1,
      "nextStep": "launchTestInstanceInSameSubnet",
      "onFailure": "step:branchOnFailureType",
      "inputs": {
        "InstanceId": "{{ TargetInstanceId }}",
        "ImageName": "CloneXenEC2InstanceAndMigrateToNitro_TestImage_{{ TargetInstanceId }}_{{ global:DATE_TIME }}",
        "NoReboot": true,
        "ImageDescription": "SSMAutomationID-{{ automation:EXECUTION_ID }}"
      }
    },
    {
      "name": "launchTestInstanceInSameSubnet",
      "action": "aws:executeScript",
      "description": "Launches a test EC2 instance from the test AMI using the same configuration as target EC2 instance",
      "isCritical": true,
      "maxAttempts": 1,
      "onFailure": "step:cleanupTestInstance",
      "nextStep": "waitForTestInstanceStatusChecks",
      "inputs": {
        "InputPayload": {
          "ImageId": "{{ createTestImage.ImageId }}",
          "InstanceType": "{{ getTargetInstanceProperties.InstanceType }}",
          "IamInstanceProfileArn": "{{ getTargetInstanceProperties.InstanceProfileArn }}",
          "SubnetId": "{{ getTargetInstanceProperties.InstanceSubnetId }}",
          "SecurityGroupIds": [
            "{{ getTargetInstanceProperties.SecurityGroup }}"
          ],
          "TargetInstanceId": "{{ TargetInstanceId }}",
          "BranchType": "Test"
        },
        "Handler": "launchEC2Instance.launch_instance_in_same_subnet_handler",
        "Runtime": "python3.11",
        "Attachment": "attachment.zip"
      },
      "outputs": [
        {
          "Name": "TestInstanceId",
          "Selector": "$.Payload.launchedInstanceId",
          "Type": "String"
        }
      ]
    },
    {
      "name": "waitForTestInstanceStatusChecks",
      "action": "aws:waitForAwsResourceProperty",
      "description": "Waits for the test EC2 instance to pass the 2/2 Status Checks",
      "onFailure": "step:cleanupTestInstance",
      "isCritical": true,
      "timeoutSeconds": 1200,
      "nextStep": "cleanupTestInstance",
      "inputs": {
        "Service": "ec2",
        "Api": "DescribeInstanceStatus",
        "InstanceIds": [
          "{{ launchTestInstanceInSameSubnet.TestInstanceId }}"
        ],
        "PropertySelector": "$.InstanceStatuses..InstanceStatus.Status",
        "DesiredValues": [
          "ok"
        ]
      }
    },
    {
      "name": "cleanupTestInstance",
      "action": "aws:changeInstanceState",
      "description": "Terminates the test EC2 instance",
      "maxAttempts": 3,
      "nextStep": "checkIfTestingBranchSucceeded",
      "isCritical": true,
      "timeoutSeconds": 300,
      "onFailure": "Abort",
      "inputs": {
        "InstanceIds": [
          "{{ launchTestInstanceInSameSubnet.TestInstanceId }}"
        ],
        "CheckStateOnly": false,
        "DesiredState": "terminated"
      }
    },
    {
      "name": "checkIfTestingBranchSucceeded",
      "action": "aws:executeScript",
      "description": "Checks the status of testing branch",
      "isCritical": true,
      "maxAttempts": 1,
      "onFailure": "Abort",
      "nextStep": "approvalToStopTargetInstance",
      "inputs": {
        "InputPayload": {
          "StepName": "waitForTestInstanceStatusChecks"
        },
        "Handler": "checkStepStatus.check_step_status_handler",
        "Runtime": "python3.11",
        "Attachment": "attachment.zip"
      }
    },
    {
      "name": "approvalToStopTargetInstance",
      "action": "aws:approve",
      "description": "Waits for designated principals approval to stop the target instance",
      "timeoutSeconds": 3600,
      "onFailure": "Abort",
      "nextStep": "stopTargetEC2Instance",
      "inputs": {
        "NotificationArn": "{{ SNSTopicArn }}",
        "Message": "Test EC2 instance launched from the target EC2 instance successfully passed the 2/2 status checks. Provide approval to stop the target EC2 instance {{ TargetInstanceId }} in order to proceed with the automation. If approved, target EC2 instance will be stopped. Before providing approval, make sure 1) Elastic IP address is assigned to the EC2 instance, if not Public IP will be changed, once the instance is stopped. This step will automatically timeout after 3600s if no action is taken.",
        "MinRequiredApprovals": "{{ MinimumRequiredApprovals }}",
        "Approvers": [
          "{{ ApproverIAM }}"
        ]
      }
    },
    {
      "name": "stopTargetEC2Instance",
      "action": "aws:changeInstanceState",
      "description": "Stops the target EC2 instance",
      "maxAttempts": 1,
      "timeoutSeconds": 300,
      "onFailure": "step:forceStopTargetEC2Instance",
      "inputs": {
        "InstanceIds": [
          "{{ TargetInstanceId }}"
        ],
        "CheckStateOnly": false,
        "DesiredState": "stopped"
      },
      "nextStep": "startOfCloneAndMigrateBranch"
    },
    {
      "name": "forceStopTargetEC2Instance",
      "action": "aws:changeInstanceState",
      "description": "Forces stop the target EC2 instance, only if the step 'stopTargetEC2Instance' fails to stop",
      "maxAttempts": 1,
      "timeoutSeconds": 300,
      "onFailure": "step:branchOnFailureType",
      "inputs": {
        "InstanceIds": [
          "{{ TargetInstanceId }}"
        ],
        "CheckStateOnly": false,
        "DesiredState": "stopped",
        "Force": true
      },
      "nextStep": "startOfCloneAndMigrateBranch"
    },
    {
      "name": "startOfCloneAndMigrateBranch",
      "action": "aws:sleep",
      "description": "End of Tests branch and Start of CloneAndMigrate branch",
      "onFailure": "Abort",
      "nextStep": "createBackupImage",
      "isCritical": false,
      "inputs": {
        "Duration": "PT5S"
      }
    },
    {
      "name": "createBackupImage",
      "action": "aws:createImage",
      "description": "Creates an Amazon Machine Image (AMI) from the provided instance for backup",
      "maxAttempts": 1,
      "nextStep": "launchInstanceInSameSubnet",
      "onFailure": "step:branchOnFailureType",
      "inputs": {
        "InstanceId": "{{ TargetInstanceId }}",
        "ImageName": "CloneXenEC2InstanceAndMigrateToNitro_BackupImage_{{ TargetInstanceId }}_{{ global:DATE_TIME }}",
        "NoReboot": true,
        "ImageDescription": "SSMAutomationID-{{ automation:EXECUTION_ID }}"
      }
    },
    {
      "name": "launchInstanceInSameSubnet",
      "action": "aws:executeScript",
      "description": "Launches a new EC2 instance from the backup AMI using the same configuration as source EC2 instance",
      "isCritical": true,
      "onFailure": "step:branchOnFailureType",
      "nextStep": "waitForClonedInstanceToPassStatusChecks",
      "inputs": {
        "InputPayload": {
          "ImageId": "{{ createBackupImage.ImageId }}",
          "InstanceType": "{{ getTargetInstanceProperties.InstanceType }}",
          "IamInstanceProfileArn": "{{ getTargetInstanceProperties.InstanceProfileArn }}",
          "SubnetId": "{{ getTargetInstanceProperties.InstanceSubnetId }}",
          "SecurityGroupIds": [
            "{{ getTargetInstanceProperties.SecurityGroup }}"
          ],
          "TargetInstanceId": "{{ TargetInstanceId }}",
          "BranchType": "CloneAndMigrate"
        },
        "Handler": "launchEC2Instance.launch_instance_in_same_subnet_handler",
        "Runtime": "python3.11",
        "Attachment": "attachment.zip"
      },
      "outputs": [
        {
          "Name": "ClonedInstanceId",
          "Selector": "$.Payload.launchedInstanceId",
          "Type": "String"
        }
      ]
    },
    {
      "name": "waitForClonedInstanceToPassStatusChecks",
      "action": "aws:waitForAwsResourceProperty",
      "description": "Waits for the cloned EC2 instance to pass the 2/2 Status Checks",
      "onFailure": "step:branchOnFailureType",
      "isCritical": true,
      "timeoutSeconds": 1200,
      "nextStep": "verifySSMConnectivityForClonedInstance",
      "inputs": {
        "Service": "ec2",
        "Api": "DescribeInstanceStatus",
        "InstanceIds": [
          "{{ launchInstanceInSameSubnet.ClonedInstanceId }}"
        ],
        "PropertySelector": "$.InstanceStatuses..InstanceStatus.Status",
        "DesiredValues": [
          "ok"
        ]
      }
    },
    {
      "name": "verifySSMConnectivityForClonedInstance",
      "action": "aws:runCommand",
      "description": "Verifies if the cloned EC2 instance is connected with AWS Systems Manager and configured to use RunCommand",
      "onFailure": "step:branchOnFailureType",
      "isCritical": true,
      "timeoutSeconds": 180,
      "maxAttempts": 1,
      "nextStep": "checkAndInstallENADrivers",
      "inputs": {
        "InstanceIds": [
          "{{ launchInstanceInSameSubnet.ClonedInstanceId }}"
        ],
        "DocumentName": "AWS-RunShellScript",
        "TimeoutSeconds": 300,
        "Parameters": {
          "commands": [
            "#!/bin/bash",
            "echo \"EC2 connected with AWS SSM, configured to use RunCommand\""
          ]
        }
      }
    },
    {
      "name": "checkAndInstallENADrivers",
      "action": "aws:runCommand",
      "description": "Determines the availability of Enhanced Networking Adapter (ENA) drivers on the EC2 instance and installs, if missing",
      "isCritical": true,
      "nextStep": "checkAndAddNVMEDrivers",
      "onFailure": "step:branchOnFailureType",
      "inputs": {
        "InstanceIds": [
          "{{ launchInstanceInSameSubnet.ClonedInstanceId }}"
        ],
        "DocumentName": "AWS-RunShellScript",
        "TimeoutSeconds": 3600,
        "Parameters": {
          "commands": [
            "#!/bin/bash",
            "",
            "readonly AUTOMATION_DIR='/var/lib/amazon/ssm/xen_to_nitro_automation'",
            "readonly UDEV_RULES_FILE='/etc/udev/rules.d/70-persistent-net.rules'",
            "TIMESTAMP=$(date +%F-%H:%M:%S)",
            "",
            "error_exit()",
            "{",
            "    echo \"[ERROR] The Execution did not complete successfully: ${1}\"",
            "    exit 1",
            "}",
            "",
            "unsupported_os() {",
            "        error_exit \"Unsupported Operating System. Stopping installation\"",
            "}",
            "",
            "reboot_operating_system(){",
            "    mkdir \"$AUTOMATION_DIR\"",
            "    cd \"$AUTOMATION_DIR\" || error_exit \"Changing directory to $AUTOMATION_DIR failed\"",
            "    touch \"$AUTOMATION_DIR\"/REBOOT_ISSUED",
            "    echo \"[INFO] Rebooting after kernel installation\"",
            "    exit 194",
            "}",
            "",
            "cleanup(){",
            "    rm -rf \"$AUTOMATION_DIR\"",
            "}",
            "",
            "# To check if this file exists and if it does remove it to prevent booting issues from new AMI",
            "# If your instance operating system contains an /etc/udev/rules.d/70-persistent-net.rules file, you must delete it before creating the AMI. This file contains the MAC address for the Ethernet adapter of the original instance. If another instance boots with this file, the operating system will be unable to find the device and eth0 might fail, causing boot issues. This file is regenerated at the next boot cycle, and any instances launched from the AMI create their own version of the file.",
            "check_persistent_rules(){",
            "if [ -f $UDEV_RULES_FILE ]; then",
            "    echo \"[WARNING] EC2 instance contains $UDEV_RULES_FILE file, which must be deleted before migrating to Nitro platform. Creating file backup...\"",
            "    mv $UDEV_RULES_FILE \"$UDEV_RULES_FILE.$TIMESTAMP\"",
            "    echo \"[INFO] Backup of the $UDEV_RULES_FILE created at the same path\"",
            "else",
            "    echo \"[INFO] Operating System is not using $UDEV_RULES_FILE\"",
            "fi",
            "}",
            "",
            "fix_predictable_network_interface_names(){",
            "    if [ \"$linux_dist_name\" = \"Ubuntu\" ]; then",
            "        systemd_version=$(dpkg -l | grep -E 'udev|systemd'|tail -1|awk '{print $3}'|cut -d \"-\" -f 1)",
            "    else",
            "        systemd_version=$(rpm -qa | grep -e '^systemd-[0-9]\\+\\|^udev-[0-9]\\+' | tail -1|cut -d \"-\" -f 2)",
            "    fi",
            "",
            "    if [ \"$(echo $systemd_version|awk '{printf \"%.0f\",$1}')\" -gt 197 ]; then",
            "        echo \"[INFO] Fixing predictable network interface naming issue as systemd/udev version is $systemd_version\"",
            "        if [ -f /etc/default/grub ]; then",
            "            cp /etc/default/grub \"/etc/default/grub.$TIMESTAMP\"",
            "            if ! grep -q \"net.ifnames\" /etc/default/grub ; then sed -i '/^GRUB\\_CMDLINE\\_LINUX/s/\\\"$/\\ net\\.ifnames\\=0\\\"/' /etc/default/grub; fi",
            "            if ! grep -q \"biosdevname\" /etc/default/grub; then sed -i '/^GRUB\\_CMDLINE\\_LINUX/s/\\\"$/\\ biosdevname\\=0\\\"/' /etc/default/grub; fi",
            "            if [ -f /etc/debian_version ]; then # added if statement as grub2-mkconfig doesn't work on ubuntu to update grub config",
            "                update-grub || error_exit \"[ERROR] Error occurred while updating GRUB\"",
            "            else",
            "                grub2-mkconfig -o /boot/grub2/grub.cfg || error_exit \"[ERROR] Error occurred while updating GRUB\"",
            "            fi",
            "        elif [ -f /boot/grub/menu.lst ]; then # added this just in case",
            "            cp /boot/grub/menu.lst \"/boot/grub/menu.lst.$TIMESTAMP\"",
            "            if ! grep -q \"net.ifnames\" /boot/grub/menu.lst ; then sed -i '/^kernel/s/$/ net\\.ifnames\\=0/' /boot/grub/menu.lst; fi    ",
            "            if ! grep -q \"biosdevname\" /boot/grub/menu.lst; then sed -i '/^kernel/s/$/ biosdevname\\=0\\\"/' /boot/grub/menu.lst; fi",
            "        fi",
            "    else",
            "        echo \"[INFO] No need to fix predictable network interface naming issues for this version of systemd/udev\"",
            "    fi",
            "}",
            "",
            "get_os_version(){",
            "    if [ -f /etc/os-release ]; then",
            "        linux_dist_name=$(cat /etc/os-release | grep -w \"NAME=\" | awk -F'=' '{print $2}'|tr -d '\"')",
            "        linux_dist_ver=$(cat /etc/os-release | grep -E \"VER_ID|VERSION_ID\" | awk -F'=' '{print $2}' | tr -d '\"')",
            "        linux_major_ver=$(echo \"$linux_dist_ver\" | awk -F'.' '{print $1}'|tr -d '\"')",
            "        linux_minor_ver=$(echo \"$linux_dist_ver\" | awk -F'.' '{print $2}'|tr -d '\"')",
            "",
            "        echo \"[INFO] LINUX_DIST >> $linux_dist_name\"",
            "        echo \"[INFO] linux_dist_ver >> $linux_dist_ver\"",
            "    else",
            "        error_exit \"Unable to get Operating System(OS) version. Missing /etc/os-release file.\"",
            "    fi",
            "}",
            "",
            "get_ena_version(){",
            "    ena_version=$(modinfo ena|grep -Eo '^version:.*|^vermagic:.*' | awk '{print $2}')",
            "",
            "    if [ -z \"$ena_version\" ];then",
            "        echo \"[WARNING] Unable to get ENA version. Execute 'modinfo ena' command manually on the EC2 instance to find the version.\"",
            "        return 1",
            "    fi",
            "}",
            "",
            "installation_yum(){",
            "",
            "    if [ \"$1\" == \"update\" ]; then",
            "        echo \"[WARNING] Updating kernel version to install ENA\"",
            "        if yum update kernel -y;then",
            "            echo \"[INFO] Kernel successfully updated\"",
            "            reboot_operating_system",
            "        else",
            "            error_exit \"Kernel update failed\"",
            "        fi",
            "    else",
            "        echo \"[WARNING] Re-installing kernel version to install ENA\"",
            "        if yum remove kernel-\"$kernel_version\" && yum install kernel-\"$kernel_version\";then",
            "            echo \"[INFO] Kernel successfully re-installed\"",
            "            reboot_operating_system",
            "        else",
            "            error_exit \"Kernel re-installation failed\"",
            "        fi",
            "    fi",
            "}",
            "",
            "install_ena_redhat(){",
            "    echo \"[WANRING] RHEL 7.4 and later AMIs come preinstalled with the module needed for enhanced networking with ENA.\"",
            "    echo \"[INFO] Current kernel version is\" \"$kernel_version\"",
            "    if [ \"$linux_major_ver\" -le 7 ] && [ \"$linux_minor_ver\" -lt 4 ]; then",
            "        installation_yum \"update\"",
            "    else",
            "        installation_yum \"reinstall\"",
            "    fi",
            "}",
            "",
            "install_ena_amzn() {",
            "    printf \"[INFO] Amazon Linux AMI 2018.03 & Amazon Linux 2 AMIs include the required ENA module and have ENA support enabled\"",
            "    installation_yum \"update\"",
            "}",
            "",
            "",
            "install_ena_sles(){",
            "    echo \"[INFO] SUSE SLES 12 SP2 and later include ENA 2.02 by default, so you are not required to download and compile the ENA driver\"",
            "    echo \"[INFO] Reinstalling the same kernel to fix this\"",
            "    zypper refresh",
            "    echo \"[INFO] Current kernel version is\" \"$kernel_version\" ",
            "    trimmed_kernel_version=$(echo \"$kernel_version\" | sed -r 's/-default/.1/g')",
            "    if zypper install -f -y kernel-default-\"$trimmed_kernel_version\"; then",
            "        echo \"[INFO] Kernel reinstalled\"",
            "        reboot_operating_system",
            "    else",
            "        error_exit \"Kernel re-installation failed\" ",
            "    fi",
            "}",
            "",
            "install_ena_ubuntu(){",
            "    echo \"[INFO] Ubuntu 14.04 or later with linux-aws kernel includes ENA by default, so you are not required to download and compile the ENA driver\"",
            "    echo \"[INFO] Reinstalling the same kernel to fix this\"",
            "    echo \"[INFO[ Current kernel version is\" \"$kernel_version\" ",
            "    trimmed_kernel_version=$(echo \"$kernel_version\" | sed -r 's/-default/.1/g')",
            "    if apt update && apt install --reinstall linux-image-\"$trimmed_kernel_version\"; then",
            "        echo \"[INFO] Kernel reinstalled\"",
            "        reboot_operating_system",
            "    else",
            "        error_exit \"Kernel re-installation failed\" ",
            "    fi",
            "}",
            "",
            "",
            "main(){",
            "",
            "    get_os_version",
            "    kernel_version=\"$(uname -r)\"",
            "    if modinfo ena > /dev/null 2>&1;then",
            "        if get_ena_version; then",
            "            echo \"[PASSED] ENA Module with version $ena_version is installed and available on your EC2 instance.\"",
            "        fi",
            "    else",
            "        echo \"[WARNING] ENA Module is not installed on your instance.\"",
            "        if [ ! -f \"$AUTOMATION_DIR\"/REBOOT_ISSUED ]; then",
            "            if [ \"$linux_dist_name\" = \"Red Hat Enterprise Linux\" ]; then",
            "                install_ena_redhat",
            "            elif [ \"$linux_dist_name\" = \"SLES\" ];then",
            "                install_ena_sles",
            "            elif [ \"$linux_dist_name\" = \"Amazon Linux\" ];then",
            "                install_ena_amzn",
            "            elif [ \"$linux_dist_name\" = \"Ubuntu\" ];then",
            "                install_ena_ubuntu",
            "            fi",
            "        else",
            "            error_exit",
            "        fi",
            "    fi",
            "    check_persistent_rules",
            "    fix_predictable_network_interface_names",
            "    cleanup",
            "}",
            "",
            "main"
          ]
        }
      }
    },
    {
      "name": "checkAndAddNVMEDrivers",
      "action": "aws:runCommand",
      "description": "Determines the availability of NVMe drivers on the cloned EC2 instance and installs, if missing",
      "timeoutSeconds": 3600,
      "nextStep": "checkAndModifyFSTABEntries",
      "onFailure": "step:branchOnFailureType",
      "inputs": {
        "DocumentName": "AWS-RunShellScript",
        "InstanceIds": [
          "{{ launchInstanceInSameSubnet.ClonedInstanceId }}"
        ],
        "Parameters": {
          "commands": [
            "#!/bin/bash",
            "",
            "#CODES MAP",
            "#240 - initramfs/initrd needs to be re-regenerated. ",
            "",
            "readonly LOADED_INFO_MSG=\"[INFO] NVMe Module loaded successfully in initramfs/initrd for kernel version\"",
            "readonly ALREADY_LOADED_INFO_MSG=\"[INFO] NVMe Module already loaded in initramfs/initrd for kernel version.\"",
            "readonly ADD_FAIL_ERROR=\"Failed to add NVMe drivers to newly built initramfs/initrd\"",
            "KERNEL_VERSION=\"$(uname -r)\" ",
            "readonly KERNEL_VERSION",
            "readonly PATH_TO_INITRAMFS_YUM=\"/boot/initramfs-${KERNEL_VERSION}.img\"",
            "readonly PATH_TO_INITRD_SUSE=\"/boot/initrd-${KERNEL_VERSION}\"",
            "readonly PATH_TO_INITRAMFS_DEB=\"/boot/initrd.img-${KERNEL_VERSION}\"",
            "",
            "error_exit()",
            "{",
            "    echo \"[ERROR] The Execution did not complete successfully: ${1}\"",
            "    exit 1",
            "}",
            "",
            "check_NVMe_omitted () {",
            "    ",
            "    nvme_results=$(lsinitrd \"$1\"| grep -w nvme)",
            "    if ! echo \"$nvme_results\" | grep -w nvme; then ",
            "        return 240",
            "    elif echo \"$nvme_results\" | grep -e \"--omit-drivers\" -e \"-o\" | grep -w nvme > /dev/null 2>&1; then",
            "        echo \"[WARNING] NVMe module omitted in initramfs, ${1}, using parameter --omit-drivers or -o\"",
            "        return 240",
            "    elif grep -R 'omit' /etc/dracut.conf* | grep nvme; then",
            "        error_exit \"NVMe module is omitted in the dracut configuration file\"",
            "    else",
            "        echo \"$ALREADY_LOADED_INFO_MSG $KERNEL_VERSION\"",
            "    fi",
            "}",
            "",
            "is_NVMe_blocklisted(){",
            "    if ! modprobe --showconfig | grep blacklist | grep nvme; then",
            "        echo \"[INFO] NVMe module is not blocklisted.\"",
            "    else",
            "        error_exit \"NVMe module is blocklisted.\"",
            "    fi",
            "}",
            "",
            "add_nvme_driver(){",
            "    echo \"[WARNING] NVMe Module not loaded in initramfs/initrd, ${2}, recreating initramfs/initrd\"",
            "    if [ \"$1\" = \"debian\" ]; then",
            "        update-initramfs -c -k all",
            "    else",
            "        echo 'add_drivers+=\" nvme \"' >> /etc/dracut.conf.d/nvme.conf",
            "        echo 'add_drivers+=\" nvme_core \"' >> /etc/dracut.conf.d/nvme_core.conf",
            "        dracut -f -v",
            "        depmod -a",
            "    fi",
            "    echo \"[INFO] Verifying changes..\"",
            "",
            "    if ! lsinitrd \"$2\" | grep -w nvme | grep -v nvmem; then",
            "        error_exit \"$ADD_FAIL_ERROR\"",
            "    else",
            "        echo \"$LOADED_INFO_MSG\"",
            "    fi",
            "}",
            "",
            "check_and_add_NVMe_in_initrd () {",
            "    echo \"[INFO] Checking if NVME module loaded in initramfs/initrd\"",
            "    if [ -f /etc/redhat-release ] ; then",
            "        is_NVMe_blocklisted",
            "        check_NVMe_omitted \"$PATH_TO_INITRAMFS_YUM\"",
            "        if [ $? -eq 240 ]; then        ",
            "            add_nvme_driver \"rhel\" \"$PATH_TO_INITRAMFS_YUM\"",
            "        fi",
            "    elif grep 'SUSE Linux' /etc/os-release > /dev/null 2>&1; then",
            "        is_NVMe_blocklisted",
            "        check_NVMe_omitted \"$PATH_TO_INITRD_SUSE\"",
            "        if [ $? -eq 240 ]; then        ",
            "            add_nvme_driver \"suse\" \"$PATH_TO_INITRD_SUSE\"",
            "        fi",
            "    elif [ -f /etc/debian_version ] ; then",
            "        is_NVMe_blocklisted",
            "        check_NVMe_omitted \"$PATH_TO_INITRAMFS_DEB\"",
            "        if [ $? -eq 240 ]; then        ",
            "            add_nvme_driver \"debian\" \"$PATH_TO_INITRAMFS_DEB\"",
            "        fi",
            "    elif grep 'Amazon Linux' /etc/os-release 1>/dev/null 2>/dev/null; then",
            "        is_NVMe_blocklisted",
            "        check_NVMe_omitted \"$PATH_TO_INITRAMFS_DEB\"",
            "        if [ $? -eq 240 ]; then        ",
            "            add_nvme_driver \"amznlinux\" \"$PATH_TO_INITRAMFS_YUM\"",
            "        fi",
            "    else",
            "        error_exit \"Unsupported Operating System\"",
            "    fi",
            "}",
            "",
            "main() ",
            "{",
            "    if ! grep -w 'nvme' /lib/modules/\"$KERNEL_VERSION\"/modules.builtin > /dev/null 2>&1",
            "        then",
            "        if ! modinfo nvme > /dev/null 2>&1",
            "            then",
            "            # NVMe Module is not installed. ",
            "            echo \"[ERROR] NVMe Module not available on instance. \\n\\t- Please install NVMe module before changing instance type to Nitro. View link for further guidance:\"",
            "            echo \"\\t> https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/nvme-ebs-volumes.html\"",
            "            exit 1",
            "",
            "        else",
            "            echo \"[OK] NVMe module is installed on instance for kernel version ${KERNEL_VERSION}\"",
            "            check_and_add_NVMe_in_initrd",
            "        fi",
            "    else",
            "        echo \"[OK] NVMe module is present as a builtin module in kernel version ${KERNEL_VERSION}\"",
            "    fi",
            "}",
            "",
            "main"
          ]
        }
      }
    },
    {
      "name": "checkAndModifyFSTABEntries",
      "action": "aws:runCommand",
      "description": "Determines if the device name are used in /etc/fstab and replaces them with their UUIDs, if found",
      "timeoutSeconds": 3600,
      "onFailure": "step:branchOnFailureType",
      "nextStep": "stopClonedInstance",
      "inputs": {
        "DocumentName": "AWS-RunShellScript",
        "InstanceIds": [
          "{{ launchInstanceInSameSubnet.ClonedInstanceId }}"
        ],
        "Parameters": {
          "commands": [
            "#!/bin/bash",
            "",
            "TIMESTAMP=$(date +%F-%H:%M:%S)",
            "TEMP_DIR=\"/tmp/xen_to_nitro_automation\"",
            "TEMP_DEVICES_FILE_NAME=\"$TEMP_DIR/device_names\"",
            "FSTAB_MODIFIED_FILE_NAME=\"$TEMP_DIR/etc_fstab.modified.$TIMESTAMP\"",
            "BACKUP_FSTAB_FILE_PATH=\"/etc/fstab.backup.$TIMESTAMP\"",
            "",
            "mkdir -p $TEMP_DIR",
            "cp -p /etc/fstab \"$FSTAB_MODIFIED_FILE_NAME\"",
            "",
            "grep '^/dev' /etc/fstab | grep -E 'sd[a-z]|xvd[a-z]|nvme([0-9]|1[0-9]|2[0-7])n1p?' | awk -F '/' '{print $3}'>\"$TEMP_DEVICES_FILE_NAME\"",
            "",
            "while read -r LINE; do ",
            "    UUID=$(ls -l /dev/disk/by-uuid | grep \"$LINE\" | sed -n \"s/^.* \\([^ ]*\\) -> .*$/\\1/p\");",
            "    if [ -n \"$UUID\" ]",
            "    then ",
            "        sed -i \"s|^/dev/${LINE}|UUID=${UUID}|\" \"$FSTAB_MODIFIED_FILE_NAME\"",
            "    fi",
            "done < \"$TEMP_DEVICES_FILE_NAME\"",
            "",
            "if [ -s /var/lib/amazon/ssm/xen_to_nitro_automation/device_names ]; then",
            "    echo -e \"[WARNING] /etc/fstab file contains device names. Partitions must be using UUIDs before changing the EC2 instance type to Nitro instances.\"",
            "    echo -e \"[INFO] Replacing device names with UUID in /etc/fstab file to avoid boot issues.\"",
            "    cp -p /etc/fstab \"$BACKUP_FSTAB_FILE_PATH\"",
            "",
            "    echo -e \"[INFO] Original /etc/fstab file is backed up at path $BACKUP_FSTAB_FILE_PATH\"",
            "    echo -e \"[INFO] Writing changes to /etc/fstab\"",
            "    cp -p \"$FSTAB_MODIFIED_FILE_NAME\" /etc/fstab",
            "    echo -e \"[INFO] Device name entries converted to UUIDs\"",
            "    ",
            "    rm -rf \"$TEMP_DIR\"",
            "else",
            "    rm -rf \"$BACKUP_FSTAB_FILE_PATH\"",
            "    rm -rf \"$TEMP_DIR\"",
            "    echo -e \"[INFO] /etc/fstab file is fine and does not contain any device names\"",
            "fi",
            "",
            "",
            ""
          ]
        }
      }
    },
    {
      "name": "stopClonedInstance",
      "action": "aws:changeInstanceState",
      "description": "Stops the cloned EC2 instance",
      "maxAttempts": 1,
      "timeoutSeconds": 300,
      "onFailure": "step:forceStopClonedInstance",
      "inputs": {
        "InstanceIds": [
          "{{ launchInstanceInSameSubnet.ClonedInstanceId }}"
        ],
        "CheckStateOnly": false,
        "DesiredState": "stopped"
      },
      "nextStep": "branchOnENAAttributeForClonedInstance"
    },
    {
      "name": "forceStopClonedInstance",
      "action": "aws:changeInstanceState",
      "description": "Forces stop the cloned EC2 instance, only if the step 'stopClonedInstance' fails to stop",
      "maxAttempts": 1,
      "timeoutSeconds": 300,
      "onFailure": "step:branchOnFailureType",
      "inputs": {
        "InstanceIds": [
          "{{ launchInstanceInSameSubnet.ClonedInstanceId }}"
        ],
        "CheckStateOnly": false,
        "DesiredState": "stopped",
        "Force": true
      },
      "nextStep": "branchOnENAAttributeForClonedInstance"
    },
    {
      "name": "branchOnENAAttributeForClonedInstance",
      "action": "aws:branch",
      "description": "Checks if the Enhanced Networking Adapter (ENA) attribute is enabled on the cloned EC2 instance",
      "isCritical": true,
      "isEnd": false,
      "onFailure": "step:branchOnFailureType",
      "inputs": {
        "Choices": [
          {
            "NextStep": "setNitroInstanceTypeForClonedInstance",
            "Variable": "{{ getTargetInstanceProperties.ENAAttrib }}",
            "BooleanEquals": true
          }
        ],
        "Default": "enableENAAttributeForClonedInstance"
      }
    },
    {
      "name": "enableENAAttributeForClonedInstance",
      "action": "aws:executeAwsApi",
      "description": "Enables the Enhanced Networking Adapter (ENA) attribute for the cloned instance, if not enabled already",
      "nextStep": "setNitroInstanceTypeForClonedInstance",
      "onFailure": "step:branchOnFailureType",
      "maxAttempts": 1,
      "inputs": {
        "Service": "ec2",
        "Api": "ModifyInstanceAttribute",
        "InstanceId": "{{ launchInstanceInSameSubnet.ClonedInstanceId }}",
        "EnaSupport": {
          "Value": true
        }
      }
    },
    {
      "name": "setNitroInstanceTypeForClonedInstance",
      "action": "aws:executeAwsApi",
      "description": "Sets the provided Target EC2 instance type for the cloned EC2 instance",
      "onFailure": "step:branchOnFailureType",
      "nextStep": "startClonedInstance",
      "maxAttempts": 1,
      "inputs": {
        "Service": "ec2",
        "Api": "ModifyInstanceAttribute",
        "InstanceId": "{{ launchInstanceInSameSubnet.ClonedInstanceId }}",
        "InstanceType": {
          "Value": "{{ NitroInstanceType }}"
        }
      }
    },
    {
      "name": "startClonedInstance",
      "action": "aws:changeInstanceState",
      "description": "Starts the cloned EC2 instance",
      "maxAttempts": 1,
      "timeoutSeconds": 900,
      "isCritical": true,
      "onFailure": "step:branchOnFailureType",
      "inputs": {
        "InstanceIds": [
          "{{ launchInstanceInSameSubnet.ClonedInstanceId }}"
        ],
        "CheckStateOnly": false,
        "DesiredState": "running"
      },
      "nextStep": "approvalForCreatingImageAfterDriversInstallation"
    },
    {
      "name": "approvalForCreatingImageAfterDriversInstallation",
      "action": "aws:approve",
      "description": "Waits for user approval if the cloned EC2 instance successfully boots on Nitro platform. If provided, creates an Amazon Machine Image(AMI) which can be used as Golden Image to launch Nitro instances",
      "timeoutSeconds": 3600,
      "onFailure": "Abort",
      "nextStep": "createImageAfterDriversInstallation",
      "inputs": {
        "NotificationArn": "{{ SNSTopicArn }}",
        "Message": "Cloned EC2 Instance {{ launchInstanceInSameSubnet.ClonedInstanceId }}, created from target EC2 instance {{ TargetInstanceId }}, has been successfully migrated to {{ NitroInstanceType }}. Provide approval to create an Amazon Machine Image(AMI) which can be used as a Golden Image to launch EC2 nitro instances. In case of 'Reject/Deny', the Automation will stop with Failed status. This step will automatically timeout after 3600s if no action is taken.",
        "MinRequiredApprovals": "{{ MinimumRequiredApprovals }}",
        "Approvers": [
          "{{ ApproverIAM }}"
        ]
      }
    },
    {
      "name": "createImageAfterDriversInstallation",
      "action": "aws:createImage",
      "description": "Creates an Image from the new EC2 instance only if the new EC2 instance successfully boots on Nitro Platform",
      "maxAttempts": 1,
      "nextStep": "cleanupTestImage",
      "onFailure": "step:branchOnFailureType",
      "isCritical": true,
      "inputs": {
        "InstanceId": "{{ launchInstanceInSameSubnet.ClonedInstanceId }}",
        "ImageName": "CloneXenEC2InstanceAndMigrateToNitro_NitroImage_{{ TargetInstanceId}}_{{ global:DATE_TIME }}",
        "NoReboot": true,
        "ImageDescription": "Image created after driver installation - SSMAutomationID-{{ automation:EXECUTION_ID }}"
      }
    },
    {
      "name": "cleanupTestImage",
      "action": "aws:deleteImage",
      "description": "Deregisters the Image (AMI) created for testing",
      "maxAttempts": 3,
      "isEnd": true,
      "onFailure": "Continue",
      "isCritical": true,
      "inputs": {
        "ImageId": "{{ createTestImage.ImageId }}"
      }
    },
    {
      "name": "branchOnFailureType",
      "action": "aws:branch",
      "description": "Checks if the user has chosen to terminate resources on failure",
      "isEnd": true,
      "isCritical": true,
      "inputs": {
        "Choices": [
          {
            "NextStep": "onFailureTerminateClonedInstance",
            "Variable": "{{ DeleteResourcesOnFailure }}",
            "BooleanEquals": true
          }
        ]
      }
    },
    {
      "name": "onFailureTerminateClonedInstance",
      "action": "aws:changeInstanceState",
      "description": "Terminates the cloned EC2 instance, in case of automation failure",
      "maxAttempts": 1,
      "isCritical": true,
      "timeoutSeconds": 300,
      "nextStep": "onFailurecleanupTestImage",
      "onFailure": "Continue",
      "inputs": {
        "InstanceIds": [
          "{{ launchInstanceInSameSubnet.ClonedInstanceId }}"
        ],
        "CheckStateOnly": false,
        "DesiredState": "terminated"
      }
    },
    {
      "name": "onFailurecleanupTestImage",
      "action": "aws:deleteImage",
      "description": "Deregisters the Image (AMI) created for testing",
      "maxAttempts": 3,
      "onFailure": "Continue",
      "nextStep": "onFailureApprovalToStartTargetInstance",
      "isCritical": true,
      "inputs": {
        "ImageId": "{{ createTestImage.ImageId }}"
      }
    },
    {
      "name": "onFailureApprovalToStartTargetInstance",
      "action": "aws:approve",
      "description": "If automation fails, waits for designated principal's approval to start the target EC2 instance",
      "timeoutSeconds": 3600,
      "onFailure": "Abort",
      "nextStep": "onFailureStartTargetInstance",
      "inputs": {
        "NotificationArn": "{{ SNSTopicArn }}",
        "Message": "Automation failed while migrating cloned EC2 Xen based instance to Nitro platform. Provide approval to start the target EC2 instance. In case of 'Reject/Deny', the Automation will stop with Failed status. This step will automatically timeout after 3600s if no action is taken.",
        "MinRequiredApprovals": "{{ MinimumRequiredApprovals }}",
        "Approvers": [
          "{{ ApproverIAM }}"
        ]
      }
    },
    {
      "name": "onFailureStartTargetInstance",
      "action": "aws:changeInstanceState",
      "description": "If automation fails, starts the target EC2 instance",
      "maxAttempts": 1,
      "timeoutSeconds": 900,
      "isCritical": true,
      "onFailure": "Abort",
      "isEnd": true,
      "inputs": {
        "InstanceIds": [
          "{{ TargetInstanceId }}"
        ],
        "CheckStateOnly": false,
        "DesiredState": "running"
      }
    }
  ],
  "files": {
    "attachment.zip": {
      "checksums": {
        "SHA256": "0310603eb226e4ba7a1c92e8fdc498604715c45ab2af588b1dc9a8bd7803e2ed"
      }
    }
  },
  "outputs": [
    "launchInstanceInSameSubnet.ClonedInstanceId",
    "createBackupImage.ImageId",
    "createImageAfterDriversInstallation.ImageId"
  ]
}
