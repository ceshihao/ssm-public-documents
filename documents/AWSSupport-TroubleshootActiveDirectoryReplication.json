{
  "description": "The **AWSSupport-TroubleshootActiveDirectoryReplication** helps troubleshoot Microsoft Active Directory (AD) domain controller replication failures by checking common settings on a target domain controller instance. **Note:** AWS Managed Microsoft AD is not in the scope of this runbook. This runbook runs a series of PowerShell commands against the provided domain controller instance to check the current replication status and report errors that can potentially cause domain replication issues. The runbook can optionally start replication critical services (`Netlogon`, `RPCSS`, `W32Time`, and `KDC`) if they are stopped and synchronize the system time by running `w32tm /resync /force` on the target instance.\n\n### Important:\n\nWhile the automation is running commands on the target instance, changes are made to the target instance file system. These changes include the creation of the log directory (`$env:ProgramData\\TroubleshootActiveDirectoryReplication`) and report files.\n\n### AWS Secrets Manager setup:\n\nThe check replication PowerShell script connects to the target Microsoft Active Directory domain controller by retrieving the username and password with a runtime call to AWS Secrets Manager. Follow the steps in [Create an AWS Secrets Manager secret](https://docs.aws.amazon.com/secretsmanager/latest/userguide/create_secret.html) to create a new AWS Secrets Manager secret. Make sure that the username and password are stored using a key/value pair in the format `{\"username\":\"EXAMPLE-USER\",\"password\":\"EXAMPLE-PASSWORD\"}\"`. After creating the AWS Secrets Manager secret, make sure you grant the `secretsmanager:GetSecretValue` permission on the secret ARN to your target domain controller IAM instance profile role. **Important:** Please refer to [Authentication and access control for AWS Secrets Manager](https://docs.aws.amazon.com/secretsmanager/latest/userguide/auth-and-access.html) for information about to secure access to secrets and [Permissions policy examples for AWS Secrets Manager](https://docs.aws.amazon.com/secretsmanager/latest/userguide/auth-and-access_examples.html#auth-and-access_examples_read) to grant permission to retrieve secret values.",
  "schemaVersion": "0.3",
  "assumeRole": "{{ AutomationAssumeRole }}",
  "parameters": {
    "AutomationAssumeRole": {
      "type": "AWS::IAM::Role::Arn",
      "description": "(Optional) The Amazon Resource Name (ARN) of the AWS Identity and Access Management (IAM) role that allows Systems Manager Automation to perform the actions on your behalf. If no role is specified, Systems Manager Automation uses the permissions of the user that starts this runbook.",
      "default": ""
    },
    "InstanceId": {
      "type": "AWS::EC2::Instance::Id",
      "description": "(Required) The ID of the Amazon EC2 domain controller instance that you want to troubleshoot Active Directory replication issues. Note that the provided instance has to be a domain controller."
    },
    "SecretsManagerArn": {
      "type": "String",
      "description": "(Required) The ARN of your AWS Secrets Manager secret containing an Active Directory username and password with Enterprise Admin or equivalent permissions to access your Active Directory domain and forest configuration. Make sure that the username and password are stored using a key/value pair in the format `{\"username\":\"EXAMPLE-USER\",\"password\":\"EXAMPLE-PASSWORD\"}\"`. Make sure to attach the `secretsmanager:GetSecretValue` permission on the secret ARN to your target domain controller IAM instance profile role.",
      "allowedPattern": "^arn:(aws|aws-cn|aws-us-gov|aws-iso|aws-iso-b):secretsmanager:[a-z0-9-]{2,20}:[0-9]{12}:secret:[a-zA-Z0-9]{1}[a-zA-Z0-9\\/_+=.@-]{1,256}$"
    },
    "TimeSync": {
      "type": "String",
      "description": "(Optional) Select `Check` or `Sync`. If you select `Check`, the runbook prints out the current system time sync status. If `Sync` is selected, the runbook will attempt a force time resync by running `w32tm /resync /force` on the target instance.",
      "default": "Check",
      "allowedValues": [
        "Check",
        "Sync"
      ]
    },
    "ServiceAction": {
      "type": "String",
      "description": "(Optional) Select `Check` or `Fix`. If you select `Check`, the runbook prints out the current status of the `Netlogon`, `Windows Time service (W32Time)`, `Remote Procedure Call (RPC) Service`, and `Key Distribution Center (KDC)` services. If `Fix` is selected the runbook will attempt to start these services if any is stopped.",
      "default": "Check",
      "allowedValues": [
        "Check",
        "Fix"
      ]
    },
    "LogDestination": {
      "type": "AWS::S3::Bucket::Name",
      "description": "(Required) The Amazon S3 bucket in your AWS account to upload the command outputs."
    }
  },
  "mainSteps": [
    {
      "name": "assertIfOperatingSystemIsWindows",
      "action": "aws:assertAwsResourceProperty",
      "description": "Checks if the operating system of the provided target EC2 instance is Windows.",
      "maxAttempts": 3,
      "onFailure": "Abort",
      "timeoutSeconds": 600,
      "inputs": {
        "Service": "ec2",
        "Api": "DescribeInstances",
        "InstanceIds": [
          "{{ InstanceId }}"
        ],
        "PropertySelector": "$.Reservations[0].Instances[0].Platform",
        "DesiredValues": [
          "windows"
        ]
      },
      "nextStep": "assertifInstanceIsSsmManaged"
    },
    {
      "name": "assertifInstanceIsSsmManaged",
      "action": "aws:assertAwsResourceProperty",
      "description": "Ensures the EC2 instance is managed by AWS Systems Manager (SSM), otherwise the automation ends.",
      "maxAttempts": 3,
      "onFailure": "Abort",
      "timeoutSeconds": 300,
      "inputs": {
        "Service": "ssm",
        "Api": "DescribeInstanceInformation",
        "InstanceInformationFilterList": [
          {
            "key": "InstanceIds",
            "valueSet": [
              "{{ InstanceId }}"
            ]
          }
        ],
        "PropertySelector": "$.InstanceInformationList[0].PingStatus",
        "DesiredValues": [
          "Online"
        ]
      },
      "nextStep": "checkReplication"
    },
    {
      "name": "checkReplication",
      "action": "aws:runCommand",
      "description": "Runs a PowerShell script on the specified domain controller instance to get the Active Directory domain replication configuration and status.",
      "onFailure": "Abort",
      "inputs": {
        "DocumentName": "AWS-RunPowerShellScript",
        "InstanceIds": [
          "{{ InstanceId }}"
        ],
        "Parameters": {
          "commands": [
            "# Copyright 2024 Amazon.com, Inc. or its affiliates. All Rights Reserved.",
            "# SPDX-License-Identifier: LicenseRef-.amazon.com.-AmznSL-1.0",
            "# Licensed under the Amazon Software License  http://aws.amazon.com/asl/",
            "",
            "$basePath = $env:ProgramData",
            "$executionId = \"{{ automation:EXECUTION_ID }}\"",
            "$logBase = \"$env:ProgramData\\TroubleshootActiveDirectoryReplication\"",
            "$logDir = \"$logBase\\$executionId\"",
            "$SecretArn = \"{{ SecretsManagerArn }}\"",
            "",
            "",
            "function GenerateCredential {",
            "    try {",
            "        $securePassword = (ConvertFrom-Json -InputObject (Get-SECSecretValue -SecretId $SecretArn).SecretString).password | ConvertTo-SecureString -AsPlainText -Force",
            "        $domainUserName = (ConvertFrom-Json -InputObject (Get-SECSecretValue -SecretId $SecretArn).SecretString).username",
            "    } catch {",
            "        throw \"An error occurred while retrieving the service account credentials: $($_.Exception.Message)\"",
            "    }",
            "",
            "    try {",
            "        $credential = New-Object System.Management.Automation.PSCredential ($domainUserName, $securePassword)",
            "    } catch {",
            "        Write-Host Failed to generate credential to run command: $_.Exception.Message",
            "        exit 1",
            "    }",
            "",
            "    return $credential",
            "}",
            "",
            "",
            "function CreateTemporaryLogDir {",
            "    if (!(Test-Path $logDir)) {",
            "        try {",
            "            New-Item -type directory -path $logDir | out-null",
            "        } catch {",
            "            Write-Host Failed to create temporary directory: $_.Exception.Message",
            "            exit 1",
            "        }",
            "    }",
            "}",
            "",
            "",
            "function CheckCurrentReplicationStatus {",
            "    try {",
            "        $credential = GenerateCredential",
            "        $repadminRaw, $results = Invoke-Command -ComputerName . -Credential $credential -ScriptBlock ${Function:RunRepadmin}",
            "    }",
            "    catch {",
            "        Write-Host Failed to invoke command: $_.Exception.Message",
            "        exit 1",
            "    }",
            "    # Invoke-Command does not capture exit code, therefore check for custom error message",
            "    if ($results -match \"Execution of repadmin failed:\") {",
            "        Write-Host $results",
            "        exit 1",
            "    }",
            "",
            "    try {",
            "        $repadminRaw | Out-File $logDir\\repadmin.txt",
            "    } catch {",
            "        Write-Host Failed to write rapadmin output to a file: $_.Exception.Message",
            "    }",
            "",
            "    $out = \"<h2>Repadmin</h2>\"",
            "    $out += $results | ConvertTo-Html -Property SourceDC,DestinationDC,NamingContext,LastAttemptStatus,TransportType,NumberOfFailures,LastFailureTime,LastSuccessTime,LastFailureStatus",
            "",
            "    Write-Host \"Repadmin:`n\"",
            "    $failedReplications = $results | Where-Object { $_.LastAttemptStatus -eq \"Failed\" }",
            "    if ($failedReplications) {",
            "        Write-Host \"The following failures were detected:`n\"",
            "        Write-Host ($failedReplications | Select SourceDC,DestinationDC,NamingContext,LastFailureStatus)",
            "    } else {",
            "        Write-Host \"No replication failures were detected.`n\"",
            "    }",
            "",
            "    return $out",
            "}",
            "",
            "",
            "function RunRepadmin {",
            "    try {",
            "        $repadminRaw = repadmin /showrepl *",
            "        $repadminCsv = repadmin /showrepl * /csv",
            "    } catch {",
            "        return Execution of repadmin failed: $_.Exception.Message",
            "    }",
            "",
            "    # Parse csv rows",
            "    $results = @()",
            "    $csvParsed = $repadminCsv | ConvertFrom-Csv",
            "    Foreach ($row in $csvParsed) {",
            "        $lastAttemptStatus = \"Success\"",
            "        $lastFailureTime = $row.\"Last Failure Time\"",
            "        $lastSuccessTime = $row.\"Last Success Time\"",
            "",
            "        # If last success time is empty, set status to unknown",
            "        if (!($lastSuccessTime)) {",
            "            $lastAttemptStatus = \"Unknown\"",
            "        }",
            "        # If last failure time is more recent than last success time, last attempt failed",
            "        elseif ($lastFailureTime -and",
            "            $lastFailureTime -ne \"0\" -and",
            "            (Get-Date $lastFailureTime) -gt (Get-Date $lastSuccessTime)) {",
            "            $lastAttemptStatus = \"Failed\"",
            "        }",
            "",
            "        $rowProperties = @{",
            "            SourceDC = $row.\"Source DSA\"",
            "            DestinationDC = $row.\"Destination DSA\"",
            "            NamingContext = $row.\"Naming Context\"",
            "            LastAttemptStatus = $lastAttemptStatus",
            "            TransportType = $row.\"Transport Type\"",
            "            NumberOfFailures = $row.\"Number of Failures\"",
            "            LastFailureTime = $lastFailureTime",
            "            LastSuccessTime = $lastSuccessTime",
            "            LastFailureStatus = $row.\"Last Failure Status\"",
            "        }",
            "        $rowObject = New-Object PSObject -Property $rowProperties",
            "        $results += $rowObject",
            "    }",
            "",
            "    return $repadminRaw, $results",
            "}",
            "",
            "",
            "function CheckConnectivity {",
            "    Write-Host \"===== Connectivity =====`n\"",
            "    $out = \"<h2>Connectivity</h2>\"",
            "",
            "    # Connectivity test for TCP ports",
            "    try {",
            "        $out += \"<h3>TCP Connectivity Tests:</h3>\"",
            "        $credential = GenerateCredential",
            "        Write-Host \"Running connectivity test for TCP ports...`n\"",
            "        $connectivityResults = Invoke-Command -ComputerName . -Credential $credential -ScriptBlock ${Function:RunTcpTest}",
            "        $out += $connectivityResults | ConvertTo-Html -Property DCName,Port,TcpTestSucceeded",
            "    }",
            "    catch {",
            "        Write-Host Failed to invoke command: $_.Exception.Message",
            "        exit 1",
            "    }",
            "",
            "    # For UDP ports and port ranges, check for possible rules blocking the traffic",
            "    Write-Host \"Checking firewall rules for UDP ports and port ranges...`n\"",
            "    $out += \"<h3>Firewall Tests:</h3>\"",
            "    $checks = @(",
            "        @(\"UDP\", \"53\"),",
            "        @(\"UDP\", \"88\"),",
            "        @(\"UDP\", \"123\"),",
            "        @(\"TCP\", \"49152\"),",
            "        @(\"TCP\", \"65535\")",
            "    )",
            "    $firewallResults = GetFirewallPortBlocks($checks)",
            "    Write-Host \"The following rules might be blocking replication traffic: `n\"",
            "    Write-Host ($firewallResults | Format-Table | Out-String)",
            "    $out += $firewallResults | ConvertTo-Html -Property Name,Direction,Protocol,Port",
            "",
            "    return $out",
            "}",
            "",
            "function RunTcpTest {",
            "    $tcpPorts = @(135, 389, 445, 636, 3268, 3269)",
            "    # Fetch domain controller host names",
            "    $dcNameList = Get-ADDomainController -filter * | Select-Object name -ExpandProperty Name",
            "    $rootDomain = Get-ADDomainController | Select-Object name -ExpandProperty Domain",
            "    $currentDC = Get-ADDomainController | Select-Object name -ExpandProperty Name",
            "    $results = @()",
            "",
            "    Foreach ($dcName in $dcNameList) {",
            "        if ($dcName -eq $currentDC) {",
            "            continue",
            "        }",
            "        # For TCP ports, test conectivity with TNC",
            "        ForEach ($port in $tcpPorts) {",
            "            $dcHostName = $dcName + '.' + $rootDomain",
            "            $connTest = Test-NetConnection $dcHostName -Port $port",
            "            $tcpTestResult = $connTest | Select-Object name -ExpandProperty TcpTestSucceeded",
            "            $resultObject = New-Object PSObject -Property @{",
            "                DCName = $dcName",
            "                Port = $port",
            "                TcpTestSucceeded = $tcpTestResult",
            "            }",
            "            $results += $resultObject",
            "        }",
            "    }",
            "",
            "    Write-Host ($results | Format-Table | Out-String)",
            "    return $results",
            "}",
            "",
            "",
            "function GetFirewallPortBlocks($checks){",
            "    # Get all enabled block rules for Any|Domain profile",
            "    try {",
            "        $inboundRules = Get-NetFirewallRule -Enabled true -Action Block -Direction Inbound -ErrorAction Stop | Where-Object {$_.Profile -match \"Any|Domain\"}",
            "    } catch {",
            "        $inboundRules = @()",
            "    }",
            "",
            "    try {",
            "        $outboundRules = Get-NetFirewallRule -Enabled true -Action Block -Direction Outbound -ErrorAction Stop | Where-Object {$_.Profile -match \"Any|Domain\"}",
            "    } catch {",
            "        $outboundRules = @()",
            "    }",
            "",
            "    $blockingRules = @()",
            "    Foreach ($check in $checks) {",
            "        $Protocol = $check[0]",
            "        $Port = $check[1]",
            "        ForEach ($rule in $inboundRules) {",
            "            $localPort =  $rule | Get-NetFirewallPortFilter | Select-Object name -ExpandProperty LocalPort",
            "            $inboundFound, $inboundBlockObject = GetRuleBlock -Rule $rule -Protocol $Protocol -RulePort $localPort -Port $Port",
            "            if ($inboundFound) {",
            "                $blockingRules += $inboundBlockObject",
            "            }",
            "        }",
            "",
            "        ForEach ($rule in $outboundRules) {",
            "            $remotePort =  $rule | Get-NetFirewallPortFilter | Select-Object name -ExpandProperty RemotePort",
            "            $outboundFound, $outboundBlockObject = GetRuleBlock -Rule $rule -Protocol $Protocol -RulePort $remotePort -Port $Port",
            "            if ($outboundFound) {",
            "                $blockingRules += $outboundBlockObject",
            "            }",
            "        }",
            "    }",
            "",
            "    return $blockingRules",
            "}",
            "",
            "function GetRuleBlock {",
            "    Param(",
            "        $Rule,",
            "        $Protocol,",
            "        $RulePort,",
            "        $Port",
            "    )",
            "",
            "    $ruleDirection = $Rule | Select-Object name -ExpandProperty Direction",
            "    $ruleProtocol = $rule | Get-NetFirewallPortFilter | Select-Object name -ExpandProperty Protocol",
            "    $name = $Rule | Select-Object name -ExpandProperty DisplayName",
            "",
            "    ## Look for specific port number",
            "    if (($RulePort -match $Port) -and ($ruleProtocol -match $Protocol)) {",
            "        $blockingObject = New-Object PSObject -Property @{",
            "            Name = $name",
            "            Direction = $ruleDirection",
            "            Protocol = $protocol",
            "            Ports = $RulePort",
            "            Action = \"Block\"",
            "        }",
            "        return $true, $blockingObject",
            "    }",
            "",
            "    ## Look for port ranges",
            "    $portRanges =  (Select-String \"\\d+-\\d+\" -input $RulePort -AllMatches).Matches.Value",
            "    foreach ($range in $portRanges) {",
            "        $rangeStart = [int]($range.split(\"-\")[0])",
            "        $rangeEnd = [int]($range.split(\"-\")[1])",
            "        if (($rangeStart -le $Port -and $rangeEnd -ge $Port) -and ($ruleProtocol -match $Protocol)) {",
            "            $blockingObject = New-Object PSObject -Property @{",
            "                Name = $name",
            "                Direction = $ruleDirection",
            "                Protocol = $protocol",
            "                Ports = $RulePort",
            "                Action = \"Block\"",
            "            }",
            "            return $true, $blockingObject",
            "        }",
            "    }",
            "",
            "    return $false, @()",
            "}",
            "",
            "",
            "function CheckDnsConfiguration {",
            "    try {",
            "        $credential = GenerateCredential",
            "        $result = Invoke-Command -ComputerName . -Credential $credential -ScriptBlock ${Function:RunDnsTest}",
            "    }",
            "    catch {",
            "        Write-Host Failed to invoke command: $_.Exception.Message",
            "        exit 1",
            "    }",
            "    # Invoke-Command does not capture exit code, therefore check for custom error message",
            "    if ($result -match \"RunDnsTest failed:\") {",
            "        Write-Host $result",
            "        exit 1",
            "    }",
            "",
            "    $out = \"<h2>DNS Tests</h2>\"",
            "    $out += $result | ConvertTo-Html -Property DCName,Test,Result,Message",
            "",
            "    # For Automation output",
            "    Write-Host \"DNS test results:`n\"",
            "    $failedTests = $result | where {$_.Result -eq \"Failed\"} | Select DCName,Result",
            "    if ($failedTests) {",
            "        Write-Host \"Following domain controllers failed DNS test.`n\"",
            "        Write-Host ($failedTests | Format-Table | Out-String)",
            "    } else {",
            "        Write-Host \"All domain controllers passed DNS test.`n\"",
            "    }",
            "",
            "    return $out",
            "}",
            "",
            "",
            "function RunDnsTest {",
            "    try {",
            "        $dcNameList = (Get-ADDomainController -filter * | Select-Object name -ExpandProperty name)",
            "        $dnsTestReport = (dcdiag /test:DNS /e /v)",
            "    } catch {",
            "        return RunDnsTest failed: $_.Exception.Message",
            "    }",
            "",
            "    # Write raw output to file",
            "    try {",
            "        $executionId = \"{{ automation:EXECUTION_ID }}\"",
            "        $logBase = \"$env:ProgramData\\TroubleshootActiveDirectoryReplication\"",
            "        $logDir = \"$logBase\\$executionId\"",
            "        $dnsTestReport | Out-File $logBase\\$executionId\\dns_test.txt",
            "    } catch {",
            "        Write-Host Failed to write dns test output to a file: $_.Exception.Message",
            "    }",
            "",
            "    $results = @()",
            "    $testResult = $dnsTestReport | select-string -pattern '\\. (.*) \\b(passed|failed)\\b test (.*)'",
            "    $testMessageAnchors = $dnsTestReport -match 'DC:|Summary of test results'",
            "    $testMessageIndexList = 0..($dnsTestReport.Count - 1) | Where { $dnsTestReport[$_] -match 'DC:|Summary of test results' }",
            "    ForEach ($dcName in $dcNameList) {",
            "        $r = ($testResult | select-string -pattern $dcName) -match \"DNS\"",
            "        $message = \"\"",
            "        if ($r -match \"passed\") {",
            "            $status = \"Passed\"",
            "        } else {",
            "            $status = \"Failed\"",
            "            $messages = @()",
            "            $testMessageStartIndex =  0..($testMessageAnchors.Count-1) | Where { $testMessageAnchors[$_] -match $dcName }",
            "            for ($i=$testMessageIndexList[$testMessageStartIndex]; $i -lt $testMessageIndexList[$testMessageStartIndex+1]; $i++) {",
            "                $messages += $dnsTestReport[$i]",
            "            }",
            "            $message = $messages | Out-String",
            "        }",
            "        $resultObject = New-Object PSObject -Property @{DCName=$dcName;Test=\"DNS\";Result=$status;Message=$message}",
            "        $results += $resultObject",
            "    }",
            "",
            "    return $results",
            "}",
            "",
            "",
            "function RunDcDiagnostics {",
            "    try {",
            "        $dcNameList = Get-ADDomainController -filter * | Select-Object name -ExpandProperty name",
            "    } catch {",
            "        return RunDcDiagnostics failed: $_.Exception.Message",
            "    }",
            "",
            "    $testName = \"\"",
            "    $resultArray = @()",
            "    $rawOutput = @()",
            "    ForEach ($dcName in $dcNameList) {",
            "        $diagnostics = dcdiag /s:$dcName /v",
            "        $rawOutput += $diagnostics",
            "",
            "        $startingTestIndex = 0..($diagnostics.Count - 1) | Where { $diagnostics[$_] -match 'Starting test:' }",
            "        $testResultIndex = 0..($diagnostics.Count - 1) | Where {",
            "            $diagnostics[$_] -match '\\. (.*) \\b(passed|failed)\\b test (.*)' -and $diagnostics[$_] -match $dcName",
            "        }",
            "",
            "        $detail = @()",
            "        for ($i=0; $i -lt $testResultIndex.Length; $i++) {",
            "            # Test output should be located in between \"Starting test:\" and \"{DC Name} passed|failed test.\"",
            "            for ($j=$startingTestIndex[$i]+1; $j -lt $testResultIndex[$i]; $j++) {",
            "                $detail += $diagnostics[$j]",
            "            }",
            "",
            "            # If failed, get test output",
            "            $message = \"\"",
            "            $testResult = \"Passed\"",
            "            if ($diagnostics[$testResultIndex[$i]] -match \"failed\") {",
            "                $message = $detail | Out-String",
            "                $testResult = \"Failed\"",
            "            }",
            "",
            "            # Convert result to PSObject and add to list",
            "            $resultProperties = @{",
            "                DCName = $dcName",
            "                TestName = $diagnostics[$startingTestIndex[$i]].split(\":\")[1]",
            "                TestResult = $testResult",
            "                Message = $message",
            "            }",
            "            $resultObject = New-Object PSObject -Property $resultProperties",
            "            $resultArray += $resultObject",
            "            # Flush",
            "            $detail = @()",
            "        }",
            "    }",
            "",
            "    return $resultArray, $rawOutput",
            "}",
            "",
            "",
            "function CheckDcDiagnostics {",
            "    try {",
            "        $credential = GenerateCredential",
            "        $results, $rawOutput = Invoke-Command -ComputerName . -Credential $credential -ScriptBlock ${Function:RunDcDiagnostics}",
            "    }",
            "    catch {",
            "        Write-Host Failed to invoke command: $_.Exception.Message",
            "        exit 1",
            "    }",
            "    # Invoke-Command does not capture exit code, therefore check for custom error message",
            "    if ($results -match \"RunDcDiagnostics failed:\") {",
            "        Write-Host $results",
            "        exit 1",
            "    }",
            "",
            "    # Write raw output to file",
            "    try {",
            "        $rawOutput | Out-File $logDir\\dcdiag.txt",
            "    } catch {",
            "        Write-Host Failed to write dcdiag output to a file: $_.Exception.Message",
            "    }",
            "",
            "    $out = \"<h2>DCDIAG</h2>\"",
            "    $out += $results | ConvertTo-Html -Property DCName,TestName,TestResult,Message",
            "",
            "    Write-Host \"Dcdiag:`n\"",
            "    $failedDiagnostics = $results | Where-Object { $_.TestResult -eq \"Failed\" }",
            "    if ($failedDiagnostics) {",
            "        Write-Host \"The following tests failed.`n\"",
            "        Write-Host ($failedDiagnostics | Select DCName,TestName | Format-Table | Out-String)",
            "    } else {",
            "        Write-Host \"No failed tests detected.`n\"",
            "    }",
            "",
            "    return $out",
            "}",
            "",
            "",
            "function CheckEventLog {",
            "    $startDate = (Get-Date).AddDays(-7)",
            "    $endDate = Get-Date",
            "    $out = \"<h2>Event Log</h2>\"",
            "    $logFound = $true",
            "",
            "    try {",
            "        $replicationEvents = Get-WinEvent -FilterHashTable @{",
            "            LogName = \"Directory Service\"",
            "            ProviderName = \"Microsoft-Windows-ActiveDirectory_DomainService\"",
            "            Level = 2,3",
            "            StartTime = $startDate",
            "            EndTime = $endDate",
            "        }",
            "    }",
            "    catch [Exception] {",
            "        if ($_.Exception -match \"No events were found\") {",
            "            out += \"<p>No Warning/Error events related to Active Directory replication found in Directory Service event log.</p>\"",
            "            $logFound = $false",
            "        } else {",
            "            Write-Host Failed to get Windows event log: $_.Exception.Message",
            "            exit 1",
            "        }",
            "    }",
            "",
            "    Write-Host \"Event logs:`n\"",
            "    $replicationEventsFiltered = $replicationEvents | Where-Object {",
            "        $_.TaskDisplayName -match 'Replication|Knowledge Consistency Checker|DS RPC Client'",
            "    }",
            "    if ($logFound -and $replicationEventsFiltered) {",
            "        $out += \"<p>The following Warning/Error events were found in Directory Service event log.</p>\"",
            "        $out += $replicationEventsFiltered | ConvertTo-Html -Property TimeCreated,ProviderName,LevelDisplayName,Id,TaskDisplayName,Message",
            "",
            "        Write-Host \"The following Warning/Error events were found in Directory Service event log. (showing recent 5 events)`n\"",
            "        # Only print recent 5 events to avoid truncation",
            "        Write-Host ($replicationEventsFiltered[0..4] | Select TimeCreated,ProviderName,LevelDisplayName,Id | Format-Table | Out-String)",
            "",
            "    } else {",
            "        $out += \"<p>No Warning/Error events related to Active Directory replication found in Directory Service event log.</p>\"",
            "        Write-Host \"No Warning/Error events related to Active Directory replication found in Directory Service event log.`n\"",
            "    }",
            "",
            "    return $out",
            "}",
            "",
            "",
            "function CheckWindowsService {",
            "    $out = \"<h2>Service Status</h2>\"",
            "    try {",
            "        $services = Get-Service w32time,netlogon,kdc,rpcss",
            "    } catch {",
            "        Write-Host Failed to get service status: $_.Exception.Message",
            "        exit 1",
            "    }",
            "    $out += $services | select ServiceName, Status, StartType | ConvertTo-Html -Property ServiceName, Status, StartType",
            "",
            "    # For automation output",
            "    Write-Host \"Service status: `n\"",
            "    Write-Host ($services | Format-Table | Out-String)",
            "",
            "    return $out",
            "}",
            "",
            "",
            "function CheckTimeSync {",
            "    try {",
            "        $timeSyncStatus = w32tm /query /status /verbose",
            "    } catch {",
            "        Write-Host Failed to time sync status and configuration: $_.Exception.Message",
            "        exit 1",
            "    }",
            "",
            "    try {",
            "        $timeSyncStatus | Out-File $logDir\\time_sync.txt",
            "    } catch {",
            "        Write-Host Failed to write time sync status output to a file: $_.Exception.Message",
            "    }",
            "",
            "    # Extract status information",
            "    try {",
            "        $leapIndicator = ($timeSyncStatus -match \"Leap Indicator:\")[0].split(\":\")[1].Trim()",
            "        $lastSuccessfulSyncTime = ($timeSyncStatus -match \"Last Successful Sync Time:\")[0].split(\":\")[1].Trim()",
            "        $source = ($timeSyncStatus -match \"Source:\")[0].split(\":\")[1].Trim()",
            "        $lastSyncError = ($timeSyncStatus -match \"Last Sync Error:\")[0].split(\":\")[1].Trim()",
            "        $timeSyncLastSync = ($timeSyncStatus -match \"Time since Last Good Sync Time:\")[0].split(\":\")[1].Trim()",
            "",
            "        $TimeSyncProperties = @{",
            "            LeapIndicator = $leapIndicator",
            "            LastSuccessfulSyncTime = $lastSuccessfulSyncTime",
            "            Source = $source",
            "            LastSyncError = $lastSyncError",
            "            TimeSinceLastGoodSyncTime = $timeSyncLastSync",
            "        }",
            "        $TimeSyncObject = New-Object PSObject -Property $TimeSyncProperties",
            "        $out = \"<h2>Time Sync Status</h2>\" + ($TimeSyncObject | ConvertTo-Html)",
            "",
            "        # For Automation output",
            "        Write-Host \"Time sync status: `n\"",
            "        Write-Host ($TimeSyncObject | Format-Table | Out-String)",
            "",
            "        return $out",
            "    } catch {",
            "        return \"\"",
            "    }",
            "",
            "}",
            "",
            "",
            "function Main {",
            "    CreateTemporaryLogDir",
            "",
            "    # Generate HTML report",
            "    $report = \"\"",
            "    $htmlHeader = \"<style type='text/css'>",
            "    table {font-family:tahoma,arial,sans-serif;font-size:12px;color:#333333;border-width: 1px;border-color: #729ea5;border-collapse: collapse;}",
            "    th {font-family:tahoma,arial,sans-serif;font-size:12px;background-color:#89CFF0;border-width: 1px;padding: 8px;border-style: solid;border-color: #729ea5;text-align:left;}",
            "    tr {font-family:tahoma,arial,sans-serif;background-color:#ffffff;}",
            "    td {font-family:tahoma,arial,sans-serif;font-size:12px;border-width: 1px;padding: 8px;border-style: solid;border-color: #729ea5;}",
            "    </style>\"",
            "    $report += ConvertTo-Html -Head $htmlHeader",
            "    $report += CheckCurrentReplicationStatus",
            "    $report += CheckEventLog",
            "    $report += CheckConnectivity",
            "    $report += CheckDnsConfiguration",
            "    $report += CheckWindowsService",
            "    $report += CheckTimeSync",
            "    $report += CheckDcDiagnostics",
            "",
            "    # Write to file",
            "    try {",
            "        $report | Out-File $logDir\\report.html",
            "    } catch {",
            "        Failed to write report to a file: $_.Exception.Message",
            "        exit 1",
            "    }",
            "}",
            "",
            "",
            "Main"
          ]
        }
      },
      "nextStep": "checkInstanceSgAndNacl"
    },
    {
      "name": "checkInstanceSgAndNacl",
      "action": "aws:executeScript",
      "description": "Checks whether traffic to the replication partners are allowed by the security group and network ACL associated to the target domain controller instance.",
      "onFailure": "Abort",
      "inputs": {
        "InputPayload": {
          "InstanceId": "{{ InstanceId }}"
        },
        "Handler": "check_sg_nacl.script_handler",
        "Runtime": "python3.11",
        "Attachment": "artifact.zip"
      },
      "outputs": [
        {
          "Type": "String",
          "Name": "Output",
          "Selector": "$.Payload.Output"
        }
      ],
      "nextStep": "troubleshootReplication"
    },
    {
      "name": "troubleshootReplication",
      "action": "aws:runCommand",
      "description": "Runs a PowerShell script to troubleshoot time synchronization and critical services status.",
      "onFailure": "Abort",
      "inputs": {
        "DocumentName": "AWS-RunPowerShellScript",
        "InstanceIds": [
          "{{ InstanceId }}"
        ],
        "Parameters": {
          "commands": [
            "# Copyright 2024 Amazon.com, Inc. or its affiliates. All Rights Reserved.",
            "# SPDX-License-Identifier: LicenseRef-.amazon.com.-AmznSL-1.0",
            "# Licensed under the Amazon Software License  http://aws.amazon.com/asl/",
            "",
            "$TimeSync = '{{ TimeSync }}'",
            "$ServiceAction = '{{ ServiceAction }}'",
            "",
            "function TroubleshootTimeSync {",
            "    if ($TimeSync -eq \"Sync\") {",
            "        try {",
            "            Write-Host \"Attempting force time resync...\"",
            "            w32tm /resync /force",
            "            Write-Host \"Force time resync successful.\"",
            "        } catch {",
            "            Write-Host \"Force time resync faild: $_\"",
            "            exit 1",
            "        }",
            "    } else {",
            "        Write-Host \"TimeSync parameter set to 'Check.' Skipping time sync.\"",
            "    }",
            "}",
            "",
            "function TroubleshootServiceStatus {",
            "    if ($ServiceAction -eq \"Fix\") {",
            "        CheckStartService(\"Netlogon\")",
            "        CheckStartService(\"RPCSS\")",
            "        CheckStartService(\"W32Time\")",
            "        CheckStartService(\"KDC\")",
            "    } else {",
            "        Write-Host \"ServiceAction parameter set to 'Check.' Skipping service troubleshooting.\"",
            "    }",
            "}",
            "",
            "function CheckStartService($name) {",
            "    if ((Get-Service -Name $name).Status -eq 'Stopped') {",
            "        try {",
            "            Start-Service -Name $name",
            "            Write-Host \"Successfully started $name service.\"",
            "        }",
            "        catch {",
            "            Write-Host \"Failed to start $name service: $_\"",
            "        }",
            "    } else {",
            "        Write-Host \"$name service is currently running.\"",
            "    }",
            "}",
            "",
            "TroubleshootTimeSync",
            "TroubleshootServiceStatus"
          ]
        }
      },
      "nextStep": "verifyS3BucketPublicStatus"
    },
    {
      "name": "verifyS3BucketPublicStatus",
      "action": "aws:executeScript",
      "description": "Checks if the Amazon S3 bucket specified in `LogDestination` allows anonymous, or public read or write access permissions.",
      "onFailure": "Abort",
      "inputs": {
        "InputPayload": {
          "Bucket": "{{ LogDestination }}",
          "BucketOwnerAccount": "{{ global:ACCOUNT_ID }}",
          "AutomationAssumeRole": "{{ AutomationAssumeRole }}"
        },
        "Handler": "s3_bucket_public_status.check_bucket_public_status",
        "Runtime": "python3.11",
        "Attachment": "artifact2.zip"
      },
      "outputs": [],
      "nextStep": "runUploadScript"
    },
    {
      "name": "runUploadScript",
      "action": "aws:runCommand",
      "description": "Runs a PowerShell script to upload the log archive to the Amazon S3 bucket specified in the `LogDestination` parameter and deletes the archived log file from OS. The log files can be used for troubleshooting or to be shared with AWS Support when troubleshooting replication issues.",
      "onFailure": "Abort",
      "inputs": {
        "DocumentName": "AWS-RunPowerShellScript",
        "InstanceIds": [
          "{{ InstanceId }}"
        ],
        "Parameters": {
          "commands": [
            "# Copyright 2024 Amazon.com, Inc. or its affiliates. All Rights Reserved.",
            "# SPDX-License-Identifier: LicenseRef-.amazon.com.-AmznSL-1.0",
            "# Licensed under the Amazon Software License  http://aws.amazon.com/asl/",
            "",
            "$s3BucketName = \"{{ LogDestination }}\"",
            "$executionId = \"{{ automation:EXECUTION_ID }}\"",
            "$s3KeyPrefix =  \"TroubleshootActiveDirectoryReplication/$executionId\"",
            "$logBase = \"$env:ProgramData\\TroubleshootActiveDirectoryReplication\"",
            "$logDir = \"$logBase\\$executionId\"",
            "",
            "function UploadLogToS3 {",
            "    try {",
            "        Compress-Archive -Path $logDir -DestinationPath \"$logBase\\output_$executionId.zip\"",
            "        Write-S3Object -BucketName $s3BucketName -Key \"$s3KeyPrefix/output_$executionId.zip\" -File \"$logBase\\output_$executionId.zip\"",
            "        Write-Host \"Successfully uploaded the execution results to bucket: $s3BucketName under key prefix: $s3KeyPrefix\"",
            "        CleanUpFolder",
            "    }",
            "    catch {",
            "        Write-Host \"Failed to upload log files to the specified S3 bucket: $_.Exception.Message\"",
            "        exit 1",
            "    }",
            "}",
            "",
            "function CleanUpFolder {",
            "    if (Test-Path -Path $logDir) {",
            "        Remove-Item \"$logBase\\output_$executionId.zip\" -Force -ErrorAction Ignore",
            "        Remove-Item -Recurse -Force $logDir -ErrorAction Ignore",
            "    } else {",
            "        Write-Host \"Log directory: $logDir does not exist. Skipping cleanup.\"",
            "    }",
            "}",
            "",
            "UploadLogToS3"
          ]
        }
      },
      "isEnd": true
    }
  ],
  "outputs": [
    "checkReplication.Output",
    "checkInstanceSgAndNacl.Output",
    "troubleshootReplication.Output",
    "runUploadScript.Output"
  ],
  "files": {
    "artifact.zip": {
      "checksums": {
        "SHA256": "bccb39b71baf0ad14c3434486e2582981e7df7421e55a1da3c99988b8337a909"
      }
    },
    "artifact2.zip": {
      "checksums": {
        "SHA256": "e303420d655fab9f4f93aae981e761bcf31b514433d1138e23142595daf4d31b"
      }
    }
  }
}
