{
  "description": "### Document name - AWSFIS-Run-Network-Latency\n\n## What does this document do?\nIt adds latency to the network traffic using tc. If tc is not already installed on the instance, this SSM document will install it together with other dependencies listed below.\nThis SSM document supports Amazon Linux and Ubuntu operating systems only.\n\n## Dependencies installed by this SSM Document\n* tc\n* atd\nNote: This SSM document does not uninstall dependencies once installed. If you don't want this SSM document to install any dependencies, set InstallDependencies to False and bake the dependencies into your EC2 instance. For example, by using image-builder (https://aws.amazon.com/image-builder/).\n\n\n## Input Parameters\n* Interface: The interface to add delay to (default: eth0).\n* DelayMilliseconds: The delay - in milliseconds - to add to the interface (default: 200).\n* DurationSeconds: (Required) The duration - in seconds - of the test.\n* InstallDependencies: If set to True, Systems Manager installs the required dependencies on the target instances. (default: True).\n\n## Output Parameters\nNone.",
  "schemaVersion": "2.2",
  "parameters": {
    "Interface": {
      "type": "String",
      "description": "The interface to add delay to (default: eth0).",
      "default": "eth0",
      "allowedPattern": "^[0-9a-zA-Z\\-]{1,15}$"
    },
    "DelayMilliseconds": {
      "type": "String",
      "description": "The delay - in milliseconds - to add to the interface (default: 200).",
      "default": "200",
      "allowedPattern": "^[0-9]+$"
    },
    "DurationSeconds": {
      "type": "String",
      "description": "(Required) The duration - in seconds - of the fault injection.",
      "allowedPattern": "^[0-9]+$"
    },
    "InstallDependencies": {
      "type": "String",
      "description": "If set to True, Systems Manager installs the required dependencies on the target instances. (default: True).",
      "default": "True",
      "allowedValues": [
        "True",
        "False"
      ]
    }
  },
  "mainSteps": [
    {
      "action": "aws:runShellScript",
      "name": "InstallDependencies",
      "precondition": {
        "StringEquals": [
          "platformType",
          "Linux"
        ]
      },
      "description": "## Parameter: InstallDependencies\nIf set to True, this step installs the required dependecy via operating system's repository. It supports both\nDebian (apt) and CentOS (yum) based package managers.\n",
      "inputs": {
        "onFailure": "exit",
        "runCommand": [
          "#!/bin/bash\n\nif [[ \"$( command -v atd 2>/dev/null )\" && \"$( command -v dig 2>/dev/null )\" && \"$( command -v tc 2>/dev/null )\" ]] ; then echo Dependency is already installed. ; exit ; fi\nif  [[ \"{{ InstallDependencies }}\" == True ]] ; then\n  echo \"Installing required dependencies\"\n  if [ -f  \"/etc/system-release\" ] ; then\n    if cat /etc/system-release | grep -i 'Amazon Linux' && ! grep -Fiq 'VERSION_ID=\"2023\"' /etc/os-release ; then\n      # Use amazon-linux-extras if available (Amazon Linux 2). Don't need it otherwise (Amazon Linux 1)\n      command -v amazon-linux-extras 2>/dev/null 1>&2 && amazon-linux-extras install testing\n      yum -y install at bind-utils tc\n    elif grep -Fiq 'ID=\"amzn\"' /etc/os-release && grep -Fiq 'VERSION_ID=\"2023\"' /etc/os-release ; then\n      \n      yum -y install at bind-utils iproute-tc\n    else\n      echo \"Exiting - This SSM document supports Amazon Linux and Ubuntu operating systems only.\"\n      exit 1\n    fi\n  elif cat /etc/issue | grep -i Ubuntu ; then\n    apt-get update -y\n    DEBIAN_FRONTEND=noninteractive apt-get install -y at dnsutils iproute2\n  else\n    echo \"Exiting - This SSM document supports Amazon Linux and Ubuntu operating systems only.\"\n    exit 1\n  fi\nelse\n  echo \"Dependencies are not installed - Please set InstallDependencies to True.\"\n  exit 1\nfi\n"
        ]
      }
    },
    {
      "action": "aws:runShellScript",
      "name": "FaultInjection",
      "precondition": {
        "StringEquals": [
          "platformType",
          "Linux"
        ]
      },
      "description": "## Parameters: Interface, DelayMilliseconds and DurationSeconds\nThis step adds a `DelayMilliseconds` delay to `Interface` for the given `DurationSeconds`, using the `tc` (Traffic Control) command.\nThe script will inject latency on the network, and wait for the given duration to remove that. It has two rollback mechanisms in place:\n* It will listen for exit signals (SIGINT and SIGTERM), and will stop the latency injection if any of them is received.\n* It will periodically enqueue rollback checks into a queue (using `at` command). This way, if the command is stopped and the rollback\nwas not executed, the enqueued commands will try to stop it. (for example, if the command is stopped using kill -9). This is\na safety check to avoid latency to remain injected after the script is no longer running.\n",
      "inputs": {
        "maxAttempts": 1,
        "runCommand": [
          "#!/bin/bash\n\n########################\n# Fault-specific logic #\n########################\n\nINTERFACE={{ Interface }}\nDELAYMILLISECONDS={{ DelayMilliseconds }}\nDURATION={{ DurationSeconds }}\n\nif ! [[ \"$( ip a ls $INTERFACE 2>/dev/null )\" ]] ; then\n  echo \"Interface $INTERFACE does not exist.\"\n  exit 1\nfi\n\nif [ $DURATION -lt 1 ] || [ $DURATION -gt 43200 ]; then\n  echo \"Parameter DurationSeconds must be between 1 and 43200, was: '$DURATION'\"\n  exit 1\nfi\n\nif [ $DELAYMILLISECONDS -lt 1 ] ; then\n  echo \"Parameter Delay must be a positive value\"\n  exit 1\nfi\n\nif [[ -z \"${AWS_SSM_REGION_NAME}\" ]]; then\n  echo \"Environment variable AWS_SSM_REGION_NAME is not set. Run this script as part of an SSM document.\"\n  exit 1\nfi\n\nFAULT_NAME=\"Run-Network-Latency\"\n\nMAX_FLAG_AGE_SECONDS=5\nATTEMPT_ROLLBACK_AT_SECONDS=10\nSTOP_TIME=$(( $(date +%s) + $DURATION ))\n\nIP_CIDR_REGEX=\"^(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\/(3[0-2]|[1-2][0-9]|[0-9]))$\"\nIP_REGEX=\"^(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])$\"\nIMDS_IP=169.254.169.254\n\n# Get the REGION of the instance\nEC2_REGION=$AWS_SSM_REGION_NAME\n\nIP_ADDRESSES_SSM_ENDPOINTS=()\n\nDELETE_MSG=\"#delete-after-fault-injection\"\n\n# List of endpoint we want to preserve (SSM API)\nENDPOINTS=(\n  \"ssmmessages.$EC2_REGION.amazonaws.com\"\n  \"ssm.$EC2_REGION.amazonaws.com\"\n  \"ec2messages.$EC2_REGION.amazonaws.com\"\n)\n\n# Only on EC2 instances add EC2 metadata. On-premise instances will be prefixed with \"mi-\"\nif [[ \"$AWS_SSM_INSTANCE_ID\" =~ ^i-.* ]]; then\n  echo \"Running on EC2 instance. Adding EC2 metadata IP to ENDPOINTS\"\n  ENDPOINTS=(\"${ENDPOINTS[@]}\" \"${IMDS_IP}\")\nfi\n\nforce_dns()\n{\n    # Force any new DNS resolution for that host to the latest known IPs\n    params=(\"$@\")\n    hostname=${params[0]}   # Hostname is expected as first argument\n    ips=(\"${params[@]:1}\")  # The rest will be the IPs\n    for ip in $(echo \"${ips[@]}\"); do\n      echo \"$ip $hostname $DELETE_MSG\" >> /etc/hosts\n    done\n}\n\nget_ips()\n{\n    # Returns if the input is a valid IP/CIDR string, empty otherwise\n    local var_ip_cidr=$(grep -E \"$IP_CIDR_REGEX\" <<< \"$1\")\n    [  -z \"$var_ip_cidr\" ] || { echo $var_ip_cidr ; return ;}\n\n    # Returns if the input is a valid IP string, empty otherwise\n    local var_ip=$(grep -E \"$IP_REGEX\" <<< \"$1\")\n    [  -z \"$var_ip\" ] || { echo $var_ip ; return ;}\n\n    # Returns IPs of the domain and force DNS resolution to that IP, empty otherwise\n    # Since `dig` can return different IPs, we call it 10 times to maximize the chances of covering as many IPs as possible for the provided domain\n    local var_dns=()\n    for i in $(seq 1 10)\n    do\n        dig_output=( $(dig +short $1 | grep -v '[[:alpha:]]') )\n        var_dns=(\"${var_dns[@]}\" \"${dig_output[@]}\")\n    done\n    var_unique_dns=( $(printf '%s\\n' \"${var_dns[@]}\" | sort -u) )\n    [  -z \"$var_unique_dns\" ] || { echo \"${var_unique_dns[@]}\" ; force_dns $1 \"${var_unique_dns[@]}\" ; return ;}\n}\n\n# Getting IPs from SSM endpoints\nfor e in ${ENDPOINTS[*]}; do\n    var_endpoint=$(get_ips $e)\n    IP_ADDRESSES_SSM_ENDPOINTS=(\"${IP_ADDRESSES_SSM_ENDPOINTS[@]}\" \"${var_endpoint[@]}\")\ndone\n\n# Adds Latency to the network interface\nread -r -d '' ENABLE_FAULT_COMMAND <<'EOF'\n  # Exit if FIS network fault is already running\n  test_file_exit() {\n      if [ \"$(ls \"$1\" 2>/dev/null | wc -l)\" -ge \"1\" ]; then { echo \"Fault might be already running (Found flag file matching \"$1\"). Exiting...\" 1>&2 ; exit 1; } ; fi;\n  }\n  test_file_exit /var/lib/amazon/ssm/Run-Network-*.flag\n\n  echo \"Injecting fault...\"\n  # Send all traffic by default to the band 1:3\n  tc qdisc add dev $INTERFACE root handle 1: prio priomap 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2\n  for k in ${IP_ADDRESSES_SSM_ENDPOINTS[*]}; do\n      # Redirect the matching ip addresses to the band 0 where is no filters\n      tc filter add dev $INTERFACE protocol ip parent 1:0 prio 1 u32 match ip dst $k flowid 1:1\n  done\n  # Creates the qdisc in the band 3, affecting all the rest of the traffic\n  tc qdisc add dev $INTERFACE parent 1:3 handle 10: netem delay \"${DELAYMILLISECONDS}\"ms\nEOF\n\n# Removes Packet Loss from the network interface\nread -r -d '' DISABLE_FAULT_COMMAND <<EOF\n  echo \"Rolling back...\"\n  tc filter del dev $INTERFACE prio 1\n  tc qdisc del dev $INTERFACE parent 1:3 handle 10:\n  tc qdisc del dev $INTERFACE root handle 1: prio\n  cat /etc/hosts | sed \"/$DELETE_MSG/d\" | tee /etc/hosts\nEOF\n\n\n#################################\n# General fault-execution logic #\n#################################\n\nSTOP_TIME=$(( $(date +%s) + $DURATION ))\n\nMAX_FLAG_AGE_SECONDS=5\nATTEMPT_ROLLBACK_AT_SECONDS=20\n\nRANDOM_STRING=$(cat /dev/urandom | tr -dc 'a-zA-Z0-9' | head -c 32)\nFLAG_PATH=\"/var/lib/amazon/ssm/$FAULT_NAME-$RANDOM_STRING.flag\"\nROLLBACK_PATH=\"/var/lib/amazon/ssm/$FAULT_NAME-$RANDOM_STRING-Rollback.sh\"\n\n# Creating a file with rollback check command to be executed by atd\ncat << EOF > \"$ROLLBACK_PATH\"\n#!/bin/bash\n# Dont sleep if run in terminal\nif ! [ -t 0 ] ; then\n  sleep $ATTEMPT_ROLLBACK_AT_SECONDS\nfi\nif ! [ -f \"$FLAG_PATH\" ] || [ \"\\$(( \\$(date +%s) - \\$(stat -c \"%Y\" \"$FLAG_PATH\") ))\" -gt $MAX_FLAG_AGE_SECONDS ] || [ -t 0 ]; then\n  $DISABLE_FAULT_COMMAND\n  rm -f \"$FLAG_PATH\"\n  # Dont delete rollback script if run in terminal\n  if ! [ -t 0 ] ; then\n    rm -f \"$ROLLBACK_PATH\"\n  fi\nfi\nEOF\necho \"Temporary rollback file created: $ROLLBACK_PATH\"\n\n# Enqueue a rollback check after $ATTEMPT_ROLLBACK_AT_SECONDS seconds\nschedule_rollback_attempt() {\n  echo \"bash $ROLLBACK_PATH\" | at now 2> >(sed '/warning: commands will be executed using \\/bin\\/sh/d' )\n}\n\n# Function to delete the flag file and rollback the fault injection\nrollback() {\n  rm \"$FLAG_PATH\"\n  rm \"$ROLLBACK_PATH\"\n  eval \"$DISABLE_FAULT_COMMAND\" ; STATUS=$?\n  echo Rollback done.\n  exit $STATUS\n}\n\n# Binding the rollback function to these exit signals\ntrap rollback INT\ntrap rollback TERM\n\necho \"Making sure atd daemon is running\"\n# atd must be running in order to use \"at\" later\natd || { echo Failed to run atd daemon, exiting... 1>&2 ; exit 1; }\n\necho \"Scheduling rollback\"\nschedule_rollback_attempt\n\n# Injecting fault\necho \"Enabling fault injection\"\neval \"$ENABLE_FAULT_COMMAND\"\n\n# For the duration of the injection, the flag file is updated, and a rollback check is enqueued\nwhile [[ $(date +%s) -lt $STOP_TIME ]] ; do\n  touch \"$FLAG_PATH\"\n  schedule_rollback_attempt\n  sleep $MAX_FLAG_AGE_SECONDS\ndone\n\n# After the desired duration, the fault injection is removed\nrollback\n"
        ]
      }
    }
  ]
}
