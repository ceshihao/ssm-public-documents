{
  "description": "The **AWSSupport-CheckAndMountEFS** runbook verifies the prerequisites to mount your Amazon Elastic File System (Amazon EFS) file system and mounts the file system on the Amazon Elastic Compute Cloud (Amazon EC2) instance you specify. This runbook supports mounting your Amazon EFS file system with the DNS name, or using the mount target's IP address.",
  "schemaVersion": "0.3",
  "outputs": [
    "FinalOutput.output"
  ],
  "assumeRole": "{{ AutomationAssumeRole }}",
  "parameters": {
    "InstanceId": {
      "type": "String",
      "description": "(Required) The ID of the Amazon EC2 instance on which you want to mount the file system.",
      "allowedPattern": "^[m]{0,1}i-[a-z0-9]{8,17}$"
    },
    "AutomationAssumeRole": {
      "type": "AWS::IAM::Role::Arn",
      "description": "(Optional) The Amazon Resource Name (ARN) of the AWS Identity and Access Management (IAM) role that allows Systems Manager Automation to perform the actions on your behalf. If no role is specified, Systems Manager Automation uses the permissions of the user that starts this runbook.",
      "default": ""
    },
    "EfsId": {
      "type": "String",
      "description": "(Required) The ID of the file system you want to mount.",
      "allowedPattern": "(^fs-[0-9a-f]{8,8})$|((^fs-[0-9a-f]{17,17}))$|()$"
    },
    "MountTargetIP": {
      "type": "String",
      "description": "(Optional) The mount target's IP address. Mounting by IP address works in environments where DNS is disabled, such as virtual private clouds (VPCs) with DNS hostnames disabled. Also, you can use this option if your environment uses a DNS provider other than Amazon Route 53 (Route 53).",
      "allowedPattern": "^(^$|((25[0-5]|2[0-4][0-9]|[0-1]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[0-1]?[0-9]?[0-9]))$",
      "default": ""
    },
    "MountOptions": {
      "type": "String",
      "description": "(Optional) The options supported by the Amazon EFS mount helper that you want to use when mounting the file system. If you specify the tls option, verify stunnel has been upgraded on the target instance.",
      "default": "_netdev",
      "allowedValues": [
        "_netdev",
        "tls,_netdev",
        "iam,tls,_netdev"
      ]
    },
    "Region": {
      "type": "String",
      "description": "(Required) The AWS Region where the Amazon EC2 instance and file system are located.",
      "allowedPattern": "^$|^[a-zA-Z]{2}-[a-zA-Z-]+-[1-9]$"
    },
    "MountPoint": {
      "type": "String",
      "description": "(Optional) The directory where you want to mount the file system. If you specify the Check value for the Action parameter, this parameter should not be specified.",
      "default": "",
      "allowedPattern": "(^$|(/[a-zA-Z/]*))"
    },
    "Action": {
      "type": "String",
      "description": "(Optional) Determines whether the runbook verifies prerequisites (`Check`), or verifies prerequisites and mounts the file system (`CheckandMount`).",
      "default": "Check",
      "allowedValues": [
        "Check",
        "CheckandMount"
      ]
    }
  },
  "mainSteps": [
    {
      "name": "EC2Script",
      "action": "aws:executeScript",
      "description": "Gathers details about the Amazon EC2 instance you specify in the InstanceId parameter.",
      "onFailure": "Abort",
      "timeoutSeconds": 300,
      "maxAttempts": 1,
      "nextStep": "EFSScript",
      "inputs": {
        "InputPayload": {
          "GetInstance": "{{InstanceId}}",
          "GetRegion": "{{Region}}"
        },
        "Handler": "script_handler",
        "Runtime": "python3.11",
        "Script": "from typing import Any, Dict, List\n\nimport boto3\nfrom botocore.exceptions import ClientError\n\n\ndef script_handler(events: Dict[str, str], context: Any) -> Dict[str, str]:\n    \"\"\"\n    Retrieves and returns information about an EC2 instance.\n\n    This function gets details about the specified EC2 instance including\n    subnet ID, availability zone, and security groups.\n\n    Args:\n        events: Dictionary containing input parameters:\n            - GetInstance: EC2 instance ID\n            - GetRegion: AWS region\n        context: Lambda context object (not used)\n\n    Returns:\n        Dict[str, str]: Dictionary with a 'message' key containing the instance details\n    \"\"\"\n\n    instance = events[\"GetInstance\"]\n    efs_region = events[\"GetRegion\"]\n\n    try:\n        groups_details: List[str] = []\n        ec2 = boto3.client(\"ec2\", region_name=efs_region)\n        response = ec2.describe_instances(InstanceIds=[instance])\n\n        instance_details = response[\"Reservations\"][0][\"Instances\"][0]\n        subnetdetails: str = instance_details[\"SubnetId\"]\n        az_details: str = instance_details[\"Placement\"][\"AvailabilityZone\"]\n\n        allsg = instance_details[\"SecurityGroups\"]\n\n        # Collect all security groups\n        for instancesg in allsg:\n            security_groups_details: str = instancesg[\"GroupId\"]\n            groups_details.append(security_groups_details)\n\n        # Create output string\n        sginstrings: str = \",\".join(groups_details)\n        printoutput: str = (\n            f\"Instance subnet is {subnetdetails} | \" f\"Security Groups are {sginstrings} | \" f\"AZ is {az_details}\"\n        )\n\n        return {\"message\": printoutput}\n\n    except ClientError as e:\n        raise RuntimeError(f\"Unexpected error getting EC2 instance details: {str(e)}\") from None\n"
      },
      "outputs": [
        {
          "Name": "output",
          "Selector": "$.Payload.message",
          "Type": "String"
        }
      ]
    },
    {
      "name": "EFSScript",
      "action": "aws:executeScript",
      "description": "Gathers details about the file system you specify in the `EfsId` parameter.",
      "onFailure": "Abort",
      "timeoutSeconds": 300,
      "maxAttempts": 1,
      "nextStep": "EvaluateEFSSecurityRules",
      "inputs": {
        "InputPayload": {
          "EFSFilesystemID": "{{EfsId}}",
          "GetRegion": "{{Region}}"
        },
        "Handler": "script_handler",
        "Runtime": "python3.11",
        "Script": "from typing import Any, Dict, List\n\nimport boto3\nfrom botocore.exceptions import ClientError\n\n\ndef script_handler(events: Dict[str, str], context: Any) -> Dict[str, str]:\n    \"\"\"\n    Retrieves and returns information about an EFS filesystem and its mount targets.\n\n    This function gets details about the specified EFS filesystem including mount targets,\n    security groups, and filesystem policy.\n\n    Args:\n        events: Dictionary containing input parameters:\n            - EFSFilesystemID: EFS filesystem ID\n            - GetRegion: AWS region\n        context: Lambda context object (not used)\n\n    Returns:\n        Dict[str, str]: Dictionary with a 'message' key containing the EFS details\n    \"\"\"\n\n    # Assigning variables\n    efs_file_id = events[\"EFSFilesystemID\"]\n    efs_region = events[\"GetRegion\"]\n    mounttargetids: List[str] = []\n    printoutput: str = \"\"\n    i: int = 1\n\n    # Get Mount Target IDs List\n    try:\n        efs = boto3.client(\"efs\", region_name=efs_region)\n        response = efs.describe_mount_targets(FileSystemId=efs_file_id)\n        for item in response[\"MountTargets\"]:\n            id_value = str(item[\"MountTargetId\"])\n            mounttargetids.append(id_value)\n\n    except ClientError as e:\n        if e.response[\"Error\"][\"Code\"] == \"FileSystemNotFound\":\n            policy_output = \"EFS ID provided cannot be found in the region.\"\n            printoutput = printoutput + policy_output + \"\\n\"\n            raise RuntimeError(printoutput) from None\n        else:\n            raise RuntimeError(f\"Unexpected error: {e}\") from None\n\n    # Running loop and getting security group details\n    for mount_id in mounttargetids:\n        response = efs.describe_mount_targets(MountTargetId=mount_id)\n        output = efs.describe_mount_target_security_groups(MountTargetId=mount_id)\n        for mounttargetdetails in response[\"MountTargets\"]:\n            subnet = mounttargetdetails[\"SubnetId\"]\n            mount_ip = mounttargetdetails[\"IpAddress\"]\n            az = mounttargetdetails[\"AvailabilityZoneName\"]\n            output_str = f\" {i}. {subnet}  |  {az}  |  {mount_id}  |  {mount_ip}  |  \" + \",\".join(\n                output[\"SecurityGroups\"]\n            )\n            printoutput = printoutput + output_str + \"\\n\"\n            i += 1\n    printoutput = printoutput + \"\\n\"\n\n    # Checking Filesystem Policy\n    try:\n        efs = boto3.client(\"efs\", region_name=efs_region)\n        results = efs.describe_file_system_policy(FileSystemId=efs_file_id)\n        is_non_empty = bool(results)\n        policy_output = (\n            f\"c. Does File System Policy Exist for this EFS? {is_non_empty}. \"\n            \"Ensure the filesystem policy allows mounting of the EFS. \"\n            \"Refer: https://docs.aws.amazon.com/efs/latest/ug/access-control-overview.html\"\n        )\n        printoutput = printoutput + policy_output + \"\\n\"\n\n    except ClientError as e:\n        if e.response[\"Error\"][\"Code\"] == \"PolicyNotFound\":\n            policy_output = \"c. Does File System Policy Exist for this EFS? False\"\n            printoutput = printoutput + policy_output\n        else:\n            raise RuntimeError(f\"Unexpected error: {e}\") from None\n\n    return {\"message\": printoutput}\n"
      },
      "outputs": [
        {
          "Name": "output",
          "Selector": "$.Payload.message",
          "Type": "String"
        }
      ]
    },
    {
      "name": "EvaluateEFSSecurityRules",
      "action": "aws:executeScript",
      "description": "Verifies the security group associated with the file system allows traffic on port 2049 from the Amazon EC2 instance you specify in the `InstanceId` parameter.",
      "onFailure": "Abort",
      "timeoutSeconds": 300,
      "maxAttempts": 1,
      "nextStep": "VerifySSMConnectivity",
      "inputs": {
        "InputPayload": {
          "EFSFilesystemID": "{{EfsId}}",
          "GetInstance": "{{InstanceId}}",
          "GetRegion": "{{Region}}"
        },
        "Handler": "script_handler",
        "Runtime": "python3.11",
        "Script": "import ipaddress\nfrom typing import Any, Dict, List\n\nimport boto3\n\n\ndef script_handler(events: Dict[str, str], context: Any) -> Dict[str, str]:\n    \"\"\"\n    Evaluates if the security groups associated with an EFS mount target allow traffic from an EC2 instance.\n\n    This function checks if the security groups attached to an EFS mount target have rules that allow\n    NFS traffic (port 2049) from the specified EC2 instance, either via IP address or security group.\n\n    Args:\n        events: Dictionary containing input parameters:\n            - GetInstance: EC2 instance ID\n            - EFSFilesystemID: EFS filesystem ID\n            - GetRegion: AWS region\n        context: Lambda context object (not used)\n\n    Returns:\n        Dict[str, str]: Dictionary with a 'message' key containing the evaluation result\n    \"\"\"\n\n    # Handling events\n    instance = events[\"GetInstance\"]\n    efs_file_id = events[\"EFSFilesystemID\"]\n    efs_region = events[\"GetRegion\"]\n    groups_details: List[str] = []\n\n    # Getting Instance IP and Security Groups\n    ec2 = boto3.client(\"ec2\", region_name=efs_region)\n    ec2response = ec2.describe_instances(InstanceIds=[instance])\n    for getinstances in ec2response[\"Reservations\"]:\n        for instance_details in getinstances[\"Instances\"]:\n            instance_ip: str = instance_details[\"PrivateIpAddress\"]\n            az_details: str = instance_details[\"Placement\"][\"AvailabilityZone\"]\n            instance_subnet: str = instance_details[\"SubnetId\"]\n            allsg = instance_details[\"SecurityGroups\"]\n            for instancesg in allsg:\n                security_groups_details: str = instancesg[\"GroupId\"]\n                groups_details.append(security_groups_details)\n\n    # Print instance details\n    print(f\"Instance subnet is {instance_subnet}\")\n    print(f\"Instance is launched in {az_details}\")\n\n    # Getting EFS Mount Target ID for the same AZ of Instance and store in mount_id variable\n    mount_id: str = \"\"\n    efs = boto3.client(\"efs\", region_name=efs_region)\n    efsresponse = efs.describe_mount_targets(FileSystemId=efs_file_id)\n    for item in efsresponse[\"MountTargets\"]:\n        if item[\"AvailabilityZoneName\"] == az_details:\n            mount_id = item[\"MountTargetId\"]\n            break\n        else:\n            continue\n    if not mount_id:\n        return {\"message\": \"FAILED: No Mount Target found in the same AZ as Instance\"}\n\n    print(f\"Mount target ID found in the same AZ as Instance is {mount_id}\")\n\n    output = efs.describe_mount_target_security_groups(MountTargetId=mount_id)\n    mount_target_sg: str = \",\".join(output[\"SecurityGroups\"])\n\n    print(f\"Mount Target {mount_id} has security group {mount_target_sg}\")\n\n    # Getting security group rules of the Mount target ID and constructing a dictionary for it.\n    # First Creating an empty dictionary. SG rules will be added on it as per the evaluation below.\n    sg_rules_dict: Dict[str, List[str]] = {}\n\n    for efssg in output[\"SecurityGroups\"]:\n        response = ec2.describe_security_groups(GroupIds=[efssg])\n        for describe in response[\"SecurityGroups\"]:\n            for rules in describe[\"IpPermissions\"]:\n                if rules[\"IpProtocol\"] == \"-1\":  # For ALL TRAFFIC\n                    if (\n                        len(rules[\"UserIdGroupPairs\"]) == 0 and len(rules[\"IpRanges\"]) != 0\n                    ):  # Source can be Security group or IPRanges\n                        key = \"ALL\"\n                        list_source: List[str] = []\n                        for entries in rules[\"IpRanges\"]:\n                            cidr = entries[\"CidrIp\"]\n                            list_source.append(cidr)\n                        sg_rules_dict.update({key: list_source})\n                    elif len(rules[\"IpRanges\"]) == 0 and len(rules[\"UserIdGroupPairs\"]) != 0:\n                        key = \"ALL\"\n                        list_source: List[str] = []\n                        for entries in rules[\"UserIdGroupPairs\"]:\n                            sg_id = entries[\"GroupId\"]\n                            list_source.append(sg_id)\n                        sg_rules_dict.update({key: list_source})\n                    elif len(rules[\"IpRanges\"]) != 0 and len(rules[\"UserIdGroupPairs\"]) != 0:\n                        key = \"ALL\"\n                        list_source: List[str] = []\n                        for entries in rules[\"UserIdGroupPairs\"]:\n                            sg_id = entries[\"GroupId\"]\n                            list_source.append(sg_id)\n                        for m in rules[\"IpRanges\"]:\n                            cidr = m[\"CidrIp\"]\n                            list_source.append(cidr)\n                        sg_rules_dict.update({key: list_source})\n                elif (\n                    rules[\"FromPort\"] == 0 and rules[\"ToPort\"] == 65535 and rules[\"IpProtocol\"] == \"tcp\"\n                ):  # For ALL TCP Traffic\n                    if (\n                        len(rules[\"UserIdGroupPairs\"]) == 0 and len(rules[\"IpRanges\"]) != 0\n                    ):  # Source can be Security group or IPRanges\n                        key = \"ALLTCP\"\n                        list_source: List[str] = []\n                        for entries in rules[\"IpRanges\"]:\n                            cidr = entries[\"CidrIp\"]\n                            list_source.append(cidr)\n                        sg_rules_dict.update({key: list_source})\n                    elif len(rules[\"IpRanges\"]) == 0 and len(rules[\"UserIdGroupPairs\"]) != 0:\n                        key = \"ALLTCP\"\n                        list_source: List[str] = []\n                        for entries in rules[\"UserIdGroupPairs\"]:\n                            sg_id = entries[\"GroupId\"]\n                            list_source.append(sg_id)\n                        sg_rules_dict.update({key: list_source})\n                    elif len(rules[\"IpRanges\"]) != 0 and len(rules[\"UserIdGroupPairs\"]) != 0:\n                        key = \"ALLTCP\"\n                        list_source: List[str] = []\n                        for entries in rules[\"UserIdGroupPairs\"]:\n                            sg_id = entries[\"GroupId\"]\n                            list_source.append(sg_id)\n                        for m in rules[\"IpRanges\"]:\n                            cidr = m[\"CidrIp\"]\n                            list_source.append(cidr)\n                        sg_rules_dict.update({key: list_source})\n                else:\n                    if len(rules[\"UserIdGroupPairs\"]) == 0:\n                        key = str(rules[\"FromPort\"])\n                        list_source: List[str] = []\n                        for entries in rules[\"IpRanges\"]:\n                            cidr = entries[\"CidrIp\"]\n                            list_source.append(cidr)\n                        sg_rules_dict.update({key: list_source})\n                    elif len(rules[\"IpRanges\"]) == 0 and len(rules[\"UserIdGroupPairs\"]) != 0:\n                        key = str(rules[\"FromPort\"])\n                        list_source: List[str] = []\n                        for entries in rules[\"UserIdGroupPairs\"]:\n                            sg_id = entries[\"GroupId\"]\n                            list_source.append(sg_id)\n                        sg_rules_dict.update({key: list_source})\n                    elif len(rules[\"IpRanges\"]) != 0 and len(rules[\"UserIdGroupPairs\"]) != 0:\n                        key = str(rules[\"FromPort\"])\n                        list_source: List[str] = []\n                        for entries in rules[\"UserIdGroupPairs\"]:\n                            sg_id = entries[\"GroupId\"]\n                            list_source.append(sg_id)\n                        for m in rules[\"IpRanges\"]:\n                            cidr = m[\"CidrIp\"]\n                            list_source.append(cidr)\n                        sg_rules_dict.update({key: list_source})\n\n    print(\"\")\n    print(sg_rules_dict)\n\n    # Creating a source list which is allowed for NFS PORT\n    nfs_source_all: List[str] = []\n    for key in sg_rules_dict:\n        if key == \"2049\" or key == \"ALLTCP\" or key == \"ALL\":\n            ip_value = sg_rules_dict[key]\n            nfs_source_all.extend(ip_value)\n\n    if not nfs_source_all:\n        access = f\"FAILED: Port 2049 not opened in any of the security groups associated with Mount target {mount_id}\"\n        return {\"message\": access}\n\n    # Breaking the Source list into IPs and Security group lists\n    access: str = \"\"\n    nfs_source_sg: List[str] = []\n    nfs_source_ips: List[str] = []\n    for items in nfs_source_all:\n        if items.startswith(\"sg-\"):\n            nfs_source_sg.append(items)\n        else:\n            nfs_source_ips.append(items)\n\n    # Checking if Instance IP belongs to the Source list\n    for iplist in nfs_source_ips:\n        if iplist == \"0.0.0.0/0\" or ipaddress.ip_address(instance_ip) in ipaddress.ip_network(iplist):\n            access = \"True\"\n            break\n        else:\n            access = \"False\"\n\n    if access == \"True\":\n        return {\n            \"message\": \"PASSED: Security Groups associated with the EFS Mount target are configured to ALLOW traffic from Instance.\"\n        }\n\n    sg_check = any(sg in nfs_source_sg for sg in groups_details)\n    if sg_check:\n        return {\n            \"message\": \"PASSED: Security Groups associated with the EFS Mount target are configured to ALLOW traffic from Instance.\"\n        }\n    else:\n        return {\n            \"message\": \"FAILED: Security Groups associated with the EFS Mount target are NOT configured to allow traffic from Instance.\"\n        }\n"
      },
      "outputs": [
        {
          "Name": "output",
          "Selector": "$.Payload.message",
          "Type": "String"
        }
      ]
    },
    {
      "name": "VerifySSMConnectivity",
      "action": "aws:assertAwsResourceProperty",
      "description": "Verifies the Amazon EC2 instance you specify in the `InstanceId` parameter is managed by Systems Manager and that the status is Online.",
      "onFailure": "Abort",
      "maxAttempts": 1,
      "isCritical": true,
      "nextStep": "BranchOnAction",
      "inputs": {
        "Service": "ssm",
        "Api": "DescribeInstanceInformation",
        "InstanceInformationFilterList": [
          {
            "key": "InstanceIds",
            "valueSet": [
              "{{ InstanceId }}"
            ]
          }
        ],
        "PropertySelector": "$.InstanceInformationList[0].PingStatus",
        "DesiredValues": [
          "Online"
        ]
      }
    },
    {
      "name": "BranchOnAction",
      "action": "aws:branch",
      "description": "Branches based on the value you specify for the Action parameter.",
      "isEnd": true,
      "inputs": {
        "Choices": [
          {
            "NextStep": "OnlyCheck",
            "Variable": "{{ Action }}",
            "StringEquals": "Check"
          },
          {
            "NextStep": "CheckEFSandMountEFS",
            "Variable": "{{ Action }}",
            "StringEquals": "CheckandMount"
          }
        ]
      }
    },
    {
      "name": "OnlyCheck",
      "action": "aws:runCommand",
      "description": "Verifies prerequisites for mounting the file system you specify in the `EfsId` parameter.",
      "onFailure": "Abort",
      "maxAttempts": 1,
      "nextStep": "FinalOutput",
      "inputs": {
        "DocumentName": "AWS-RunShellScript",
        "InstanceIds": [
          "{{InstanceId}}"
        ],
        "Parameters": {
          "commands": [
            "#!/bin/bash",
            "",
            "NFSPORT=2049",
            "REGION=\"{{ Region }}\"",
            "PARTITION=\"{{global:AWS_PARTITION}}\"",
            "efs_filesystem_id=\"{{ EfsId }}\"",
            "mountip=\"{{MountTargetIP}}\"",
            "",
            "# Set URL based on partition",
            "if [ \"$PARTITION\" = \"aws-us-gov\" ]; then",
            "    URL=\"amazonaws.com\"",
            "elif [ \"$PARTITION\" = \"aws-cn\" ]; then",
            "    URL=\"amazonaws.com.cn\"",
            "else",
            "    URL=\"amazonaws.com\"",
            "fi",
            "",
            "file_system_id_dns=$efs_filesystem_id.efs.$REGION.$URL",
            "echo  \" \"",
            "echo \"Instance and EFS details:\"",
            "echo \" \"",
            "echo \"a. Instance ID is: {{InstanceId}}\"",
            "echo \"b. {{EC2Script.output}}\"",
            "echo  \" \"",
            "echo \"a. EFS DNS is $file_system_id_dns\"",
            "echo \"b. EFS Mount Target details are as follows:\"",
            "echo  \" \"",
            "echo \"{{EFSScript.output}}\"",
            "",
            "# Checking if EFS is already mounted on the instance",
            "cat /etc/mtab | grep $efs_filesystem_id > /dev/null 2>/dev/null",
            "if [ $? -eq 0 ]; then",
            "  echo \"d. Is EFS already mounted on the Instance? ${efs_filesystem_id} is already mounted. Continuing with the checks...\"",
            "  cat /etc/mtab | grep $efs_filesystem_id | head -n 1",
            "else",
            " echo \"d. Is EFS already mounted on the Instance: ${efs_filesystem_id} is NOT mounted.\"",
            "fi",
            "echo  \" \"",
            "",
            "echo \"--------------------------------------------\"",
            "echo \"|  Evaluating EFS security groups rules    |\"",
            "echo \"--------------------------------------------\"",
            "Result1=\"{{EvaluateEFSSecurityRules.output}}\"",
            "echo ${Result1}",
            "echo  \" \"",
            "",
            "echo \"-------------------------------\"",
            "echo \"|  Testing DNS resolution     |\"",
            "echo \"-------------------------------\"",
            "if [ -f /usr/bin/dig ]; then",
            " ip=`dig +short $file_system_id_dns`",
            "    if [ -n \"$ip\" ]; then",
            "        Result2=\"PASSED: Resolvable to IP: $ip\"",
            "        echo ${Result2}",
            "    else",
            "        Result2=\"FAILED: Could NOT resolve hostname. Check the DNS server configured on the Instance is working or not. Note: Custom DNS servers cannot resolve the internal names of the EFS by default\"",
            "        echo ${Result2}",
            "    fi",
            "else",
            "  host $file_system_id_dns",
            "  if [ $? -ne 0 ]; then",
            "   Result2=\"FAILED: Could NOT resolve hostname. Check the DNS server configured on the Instance is working or not. Note: Custom DNS servers cannot resolve the internal names of the EFS by default\"",
            "   echo ${Result2}",
            "  else",
            "   Result2=\"PASSED: EFS is Resolvable\"",
            "   echo ${Result2}",
            "  fi",
            "fi",
            "echo  \" \"",
            "echo \"-----------------------------------------------------\"",
            "echo \"|  Testing NFS connectivity to EFS DNS Name         |\"",
            "echo \"-----------------------------------------------------\"",
            "timeout 3 bash -c \"cat < /dev/null > /dev/tcp/$file_system_id_dns/2049\"",
            "exitcode=$?",
            "if [ $exitcode -eq 0 ]; then",
            "  Result3=\"PASSED: Connection to ${file_system_id_dns}:${NFSPORT} is SUCCESSFUL.\"",
            "  echo ${Result3}",
            "elif [ $exitcode -eq 124 ]; then",
            "  Result3=\"FAILED: Connection to ${file_system_id_dns}:${NFSPORT} is UNSUCCESSFUL. Check the security group attached to the instance and EFS. Also, check the OS level firewall configuration if any. Port 2049 is NOT Reachable.\"",
            "  echo ${Result3}",
            "else",
            "  Result3=\"FAILED: Invalid argument provided. Wrong EFS ID or DNS resolution NOT working.\"",
            "  echo ${Result3}",
            "fi",
            "echo  \" \"",
            "if [ \"$mountip\" != \"\" ]; then",
            " echo \"------------------------------------------------------\"",
            " echo \"|  Testing NFS connectivity to Mount Target IP       |\"",
            " echo \"------------------------------------------------------\"",
            " timeout 3 bash -c \"cat < /dev/null > /dev/tcp/$mountip/2049\"",
            " exitcode=$?",
            " if [ $exitcode -eq 0 ]; then",
            "   Result4=\"PASSED: Connection to ${mountip}:${NFSPORT} is SUCCESSFUL.\"",
            "   echo \"${Result4}\"",
            " else",
            "   Result4=\"FAILED: Connection to ${mountip}:${NFSPORT} is UNSUCCESSFUL. Check the security group attached to the instance and EFS. Also, check the OS level firewall configuration if any.\"",
            "   echo \"${Result4}\"",
            " fi",
            "else",
            " Result4=\"SKIPPED\"",
            "fi",
            "echo \"--------------------------------------------------\"",
            "echo \"|  Checking if EFS/NFS-Utils are installed       |\"",
            "echo \"--------------------------------------------------\"",
            "if [ -f /usr/bin/yum ]; then",
            " rpm -qa | grep amazon-efs-utils &> /dev/null",
            " if [ $? -eq 0 ]; then",
            "  efsversion=`rpm -qa | grep amazon-efs-utils`",
            "  Result5a=\"PASSED: ${efsversion} is installed on the instance.\"",
            " else",
            "  Result5a=\"FAILED: amazon-efs-utils is NOT installed on the instance.\"",
            " fi",
            " rpm -qa | grep NFS-Utils &> /dev/null",
            " if [ $? -eq 0 ]; then",
            "  nfsversion=`rpm -qa | grep NFS-Utils`",
            "  Result5b=\"PASSED: ${nfsversion} is installed on the instance.\"",
            " else",
            "  Result5b=\"FAILED: nfs-utils is NOT installed on the instance.\"",
            " fi",
            "elif [ -f /usr/bin/zypper ]; then",
            " rpm -qa | grep amazon-efs-utils  &> /dev/null",
            " if [ $? -eq 0 ]; then",
            "  efsversion=`rpm -qa | grep amazon-efs-utils`",
            "  Result5a=\"PASSED: ${efsversion} is installed on the instance.\"",
            " else",
            "  Result5a=\"FAILED: aws-efs-utils is NOT installed on the instance.\"",
            " fi",
            " rpm -qa | grep nfs-client &> /dev/null",
            " if [ $? -eq 0 ]; then",
            "  nfsversion=`rpm -qa | grep nfs-client`",
            "  Result5b=\"PASSED: ${nfsversion} is installed on the instance.\"",
            " else",
            "  Result5b=\"FAILED: nfs-utils is NOT installed on the instance.\"",
            " fi",
            "else",
            " if [ $(dpkg-query -W -f='${Status}' amazon-efs-utils 2>/dev/null | grep -c \"ok installed\") -eq 1 ]; then",
            "  efsversion=`dpkg-query -W amazon-efs-utils`",
            "  Result5a=\"PASSED: ${efsversion} is installed on the instance.\"",
            " else",
            "  Result5a=\"FAILED: amazon-efs-utils is NOT installed on the instance.\"",
            " fi",
            " if [ $(dpkg-query -W -f='${Status}' nfs-common 2>/dev/null | grep -c \"ok installed\") -eq 1 ]; then",
            "  nfsversion=`dpkg-query -W nfs-common`",
            "  Result5b=\"PASSED: ${nfsversion} is installed on the instance.\"",
            " else",
            "  Result5b=\"FAILED: nfs-common is NOT installed on the instance.\"",
            " fi",
            "fi",
            "",
            "case \"$Result5a\" in",
            "  *PASSED*)",
            "  EFSutilsisInstalled=\"yes\";;",
            "  *)EFSutilsisInstalled=\"no\";;",
            "esac",
            "case \"$Result5b\" in",
            "  *PASSED*)",
            "  NFSutilsisInstalled=\"yes\";;",
            "  *)NFSutilsisInstalled=\"no\";;",
            "esac",
            "",
            "if [ \"${EFSutilsisInstalled}\" == yes ] && [ \"${NFSutilsisInstalled}\" == yes ]; then",
            "   Result5=\"PASSED: EFS utils and NFS Utils are installed.\"",
            "   echo \"${Result5}\"",
            "   echo \"Version is ${efsversion}\"",
            "   echo \"Version is ${nfsversion}\"",
            "elif [ \"${EFSutilsisInstalled}\" == yes ] && [ \"${NFSutilsisInstalled}\" == no ]; then",
            "   Result5=\"PASSED: aws-efs-utils is installed but nfs client utils is missing.\"",
            "   echo \"${Result5}\"",
            "   echo \"Version is ${efsversion}\"",
            "elif [ \"${EFSutilsisInstalled}\" == no ] && [ \"${NFSutilsisInstalled}\" == yes ]; then",
            "   Result5=\"PASSED: NFS client utils is installed but aws-efs-utils utils is missing. To mount without EFS mount helper: https://docs.aws.amazon.com/efs/latest/ug/mounting-fs-old.html\"",
            "   echo \"${Result5}\"",
            "   echo \"Version is ${nfsversion}\"",
            "else",
            "   Result5=\"FAILED: Both aws-efs-utils and nfs client utils are missing. Install: https://docs.aws.amazon.com/efs/latest/ug/manage-efs-utils-with-aws-sys-manager.html\"",
            "   echo \"${Result5}\"",
            "fi",
            "echo  \" \"",
            "echo \"------------------------------------------------------------\"",
            "echo \"|  Checking if this Linux Distribution supports NFSv4      |\"",
            "echo \"------------------------------------------------------------\"",
            "grep -x -e \"CONFIG_NFS_V4=m\" -e \"CONFIG_NFS_V4=y\" -e \"CONFIG_NFS_V4_1=m\" -e \"CONFIG_NFS_V4_1=y\" /boot/config-$(uname -r)",
            "exitcode=$?",
            "if [ $exitcode -eq 0 ]; then",
            "  Result6=\"PASSED: This Instance supports Network File System versions 4.0 or 4.1 (NFSv4).\"",
            "  echo ${Result6}",
            "else",
            "  Result6=\"FAILED: This Instance doesn't support Network File System versions 4.0 or 4.1 (NFSv4)\"",
            "  echo ${Result6}",
            "fi"
          ]
        }
      }
    },
    {
      "name": "CheckEFSandMountEFS",
      "action": "aws:runCommand",
      "description": "Verifies prerequisites for mounting the file system you specify in the `EfsId` parameter, and mounts the file system on the Amazon EC2 instance you specify in the `InstanceId` parameter.",
      "onFailure": "Abort",
      "maxAttempts": 1,
      "nextStep": "FinalOutput",
      "inputs": {
        "DocumentName": "AWS-RunShellScript",
        "InstanceIds": [
          "{{InstanceId}}"
        ],
        "Parameters": {
          "commands": [
            "",
            "#!/bin/bash",
            "",
            "NFSPORT=2049",
            "REGION=\"{{ Region }}\"",
            "PARTITION=\"{{global:AWS_PARTITION}}\"",
            "efs_filesystem_id=\"{{ EfsId }}\"",
            "efs_mount_point=\"{{ MountPoint }}\"",
            "mountip=\"{{MountTargetIP}}\"",
            "restricted_dir=\"/ /var /etc /home /sys /dev /bin /sbin /usr /run /boot\"",
            "",
            "# Set URL based on partition",
            "if [ \"$PARTITION\" = \"aws-us-gov\" ]; then",
            "    URL=\"amazonaws.com\"",
            "elif [ \"$PARTITION\" = \"aws-cn\" ]; then",
            "    URL=\"amazonaws.com.cn\"",
            "else",
            "    URL=\"amazonaws.com\"",
            "fi",
            "",
            "file_system_id_dns=$efs_filesystem_id.efs.$REGION.$URL",
            "",
            "echo  \" \" ",
            "echo \"Instance and EFS details: \" ",
            "echo \" \" ",
            "echo \"a. Instance ID is: {{InstanceId}}\" ",
            "echo \"b. {{EC2Script.output}}\" ",
            "echo  \" \" ",
            "echo \"a. EFS DNS is $file_system_id_dns\" ",
            "echo \"b. EFS Mount Target details are as follows:\" ",
            "echo  \" \" ",
            "echo \"{{EFSScript.output}}\" ",
            "echo \"d. {{EvaluateEFSSecurityRules.output}}\" ",
            "echo  \" \"",
            "echo \"---------------------\" ",
            "echo \"|  Mounting EFS     |\" ",
            "echo \"---------------------\"",
            "",
            "# Validating the Mount directory provided",
            "if [ \"$efs_mount_point\" = \"\" ]; then",
            "  echo \"FAILED: No Mount Directory Provided. Exiting...\"",
            "  exit 1",
            "fi",
            "",
            "# Validating if the efs mount point is in the restricted lists",
            "for item in $restricted_dir; do",
            " if [ \"$efs_mount_point\" = \"$item\" ]; then",
            "   echo \"FAILED: Cannot mount in this directory. It is restricted.\"",
            "   exit 1",
            " fi",
            "done",
            "",
            "# Checking if Mount point provided is already mounted",
            "mountpoint $efs_mount_point &> /dev/null",
            "exitcode=$?",
            "if [ ${exitcode} -eq 0 ]; then",
            "  echo \"Mountpoint provided is already mounted.\"",
            "  exit 1",
            "fi",
            "",
            "# Mounting",
            "mkdir -p \"${efs_mount_point}\"",
            "if [ \"$mountip\" = \"\" ]; then",
            "   test -f \"/sbin/mount.efs\" && mount -t efs -o {{MountOptions}} ${efs_filesystem_id}:/ ${efs_mount_point} || mount -t nfs4 -o {{MountOptions}} ${file_system_id_dns}:/ ${efs_mount_point}",
            "else",
            "   mount -t nfs4 -o nfsvers=4.1,rsize=1048576,wsize=1048576,hard,timeo=600,retrans=2,noresvport,_netdev ${mountip}:/ ${efs_mount_point}",
            "fi",
            "",
            "if [ $? -eq 0 ]; then ",
            " echo \"Mount was SUCCESSFUL.\" ",
            " echo  \" \"",
            " echo \"Verifying from /etc/mtab:\" ",
            " cat /etc/mtab | grep $efs_filesystem_id",
            " echo  \" \" ",
            " echo  \" --------------------- \"",
            " echo  \" --- Auto Mounting --- \" ",
            " echo  \" --------------------- \" ",
            " echo  \" \" ",
            " echo \"If you need EFS to mount automatically on next boot, you can add the below lines in /etc/fstab.\" ",
            " echo  \" \" ",
            " echo \"${efs_filesystem_id}:/ ${efs_mount_point} efs {{MountOptions}}  0 0\"",
            " echo \" OR \" ",
            " echo \"${file_system_id_dns}:/ ${efs_mount_point} nfs4 nfsvers=4.1,rsize=1048576,wsize=1048576,hard,timeo=600,retrans=2,noresvport,_netdev 0 0\"",
            " echo  \" \" ",
            " echo \"You can replace Filesystem ID with Mount target IP in the above lines when using Custom DNS.\"",
            "else",
            " echo \"Mount was unsuccessful. Run the Check Action to see if the Instance meets the prerequisites to mount EFS.\"",
            " exit 1",
            "fi"
          ]
        }
      }
    },
    {
      "name": "FinalOutput",
      "action": "aws:executeScript",
      "description": "Processes and formats the output from the previous steps to provide a consolidated result of the operation.",
      "onFailure": "Abort",
      "timeoutSeconds": 300,
      "maxAttempts": 1,
      "isEnd": true,
      "inputs": {
        "InputPayload": {
          "onlycheckstep": "{{OnlyCheck.Output}}",
          "checkandmountstep": "{{CheckEFSandMountEFS.Output}}"
        },
        "Handler": "script_handler",
        "Runtime": "python3.11",
        "Script": "from typing import Any, Dict\n\n\ndef script_handler(events: Dict[str, str], context: Any) -> Dict[str, str]:\n    \"\"\"\n    Processes the output from previous steps and generates a final summary.\n\n    This function takes the output from the onlycheckstep and checkandmountstep,\n    and generates a final summary based on the results.\n\n    Args:\n        events: Dictionary containing input parameters:\n            - onlycheckstep: Output from the only check step\n            - checkandmountstep: Output from the check and mount step\n        context: Lambda context object (not used)\n\n    Returns:\n        Dict[str, str]: Dictionary with an 'output' key containing the final summary\n    \"\"\"\n    onlycheckoutput = events[\"onlycheckstep\"]\n    checkandmountoutput = events[\"checkandmountstep\"]\n    substring = \"OnlyCheck\"\n\n    if substring in onlycheckoutput:\n        return {\"output\": checkandmountoutput}\n    else:\n        splitoutput = onlycheckoutput.split()\n        passed_value: str = str(splitoutput.count(\"PASSED:\"))\n        failed_value: str = str(splitoutput.count(\"FAILED:\"))\n\n        if failed_value == \"0\":\n            summary: str = \"RESULT: Meets all the prerequisites.\\n\\n\"\n        else:\n            summary: str = \"RESULT: Does not meet all the prerequisites.\\n\\n\"\n\n        results: str = (\n            summary + \"Passed: \" + passed_value + \"\\nFailed: \" + failed_value + \"\\n\\nSummary:\\n\" + onlycheckoutput\n        )\n\n        return {\"output\": results}\n"
      },
      "outputs": [
        {
          "Name": "output",
          "Selector": "$.Payload.output",
          "Type": "String"
        }
      ]
    }
  ]
}
