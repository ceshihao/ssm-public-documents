{
  "schemaVersion": "0.3",
  "description": "Creates a Linux Managed Instance",
  "assumeRole": "{{AutomationAssumeRole}}",
  "parameters": {
    "AmiId": {
      "type": "String",
      "description": "(Required) AMI id to use for launching the instance."
    },
    "VpcId": {
      "type": "String",
      "description": "(Required) New instance will be deployed into this vpc or in the default vpc if not specified.",
      "default": "Default"
    },
    "RoleName": {
      "type": "String",
      "description": "(Required) Role Name to create.",
      "default": "SSMManagedInstanceProfileRole"
    },
    "GroupName": {
      "type": "String",
      "description": "(Required) Security Group Name to create.",
      "default": "SSMSecurityGroupForLinuxInstances"
    },
    "InstanceType": {
      "type": "String",
      "description": "(Required) Type of instance to launch. Default is t2.medium.",
      "default": "t2.medium"
    },
    "KeyPairName": {
      "type": "String",
      "description": "(Required) Key pair to use when creating instance."
    },
    "RemoteAccessCidr": {
      "type": "String",
      "description": "(Required) Creates Security group with port for SSH(Port range 22) open to IPs specified by CIDR (default is 0.0.0.0/0). If the security group already exists it will not be modified and rules will not be changed.",
      "default": "0.0.0.0/0"
    },
    "StackName": {
      "type": "String",
      "description": "(Optional) Specify stack name used by this document",
      "default": "CreateManagedInstanceStack{{automation:EXECUTION_ID}}"
    },
    "AutomationAssumeRole": {
      "type": "String",
      "description": "(Optional) The ARN of the role that allows Automation to perform the actions on your behalf",
      "default": ""
    },
    "SubnetId": {
      "type": "String",
      "description": "(Required) New instance will be deployed into this subnet or in the default subnet if not specified.",
      "default": "Default"
    }
  },
  "mainSteps": [
    {
      "name": "createManagedInstanceStack",
      "action": "aws:createStack",
      "maxAttempts": 1,
      "onFailure": "Abort",
      "inputs": {
        "OnFailure": "ROLLBACK",
        "Capabilities": [
          "CAPABILITY_IAM"
        ],
        "Parameters": [
          {
            "ParameterKey": "AmiId",
            "ParameterValue": "{{AmiId}}"
          },
          {
            "ParameterKey": "InstanceType",
            "ParameterValue": "{{InstanceType}}"
          },
          {
            "ParameterKey": "RoleName",
            "ParameterValue": "{{RoleName}}"
          },
          {
            "ParameterKey": "GroupName",
            "ParameterValue": "{{GroupName}}"
          },
          {
            "ParameterKey": "VpcId",
            "ParameterValue": "{{VpcId}}"
          },
          {
            "ParameterKey": "SubnetId",
            "ParameterValue": "{{SubnetId}}"
          },
          {
            "ParameterKey": "LambdaRoleArn",
            "ParameterValue": "{{AutomationAssumeRole}}"
          },
          {
            "ParameterKey": "KeyName",
            "ParameterValue": "{{KeyPairName}}"
          },
          {
            "ParameterKey": "RemoteAccessCidr",
            "ParameterValue": "{{RemoteAccessCidr}}"
          }
        ],
        "StackName": "{{StackName}}",
        "TemplateBody": "AWSTemplateFormatVersion: '2010-09-09'\nConditions:\n  IsVerbose:\n    Fn::Equals:\n    - {Ref: Verbose}\n    - 'true'\n  IsVerboseAndLambdaRoleNotSpecified:\n    Fn::And:\n    - {Condition: LambdaAssumeRoleNotSpecified}\n    - {Condition: IsVerbose}\n  KeyNameSpecified:\n    Fn::And:\n    - Fn::Not:\n      - Fn::Equals:\n        - {Ref: KeyName}\n        - ''\n    - Fn::Not:\n      - Fn::Equals:\n        - {Ref: KeyName}\n        - undefined\n  LambdaAssumeRoleNotSpecified:\n    Fn::Or:\n    - Fn::Equals:\n      - {Ref: LambdaRoleArn}\n      - ''\n    - Fn::Equals:\n      - {Ref: LambdaRoleArn}\n      - undefined\n  RemoteAccessSpecified:\n    Fn::And:\n    - Fn::Not:\n      - Fn::Equals:\n        - {Ref: RemoteAccessCidr}\n        - ''\n    - Fn::Not:\n      - Fn::Equals:\n        - {Ref: RemoteAccessCidr}\n        - undefined\nParameters:\n  AmiId: {Description: AMI ID to be deploy., Type: String}\n  GroupName: {Description: (Required) Security Group Name to use or create if it does\n      not exists., Type: String}\n  InstanceType: {Description: Instance Type to deploy., Type: String}\n  KeyName: {Default: '', Description: Name of an existing EC2-VPC KeyPair, Type: String}\n  LambdaRoleArn: {Default: '', Description: 'Assume role used by the lambda function.\n      If not specified this template will create a temporarily role to be used by\n      the lambda created in this template.\n\n      ', Type: String}\n  RemoteAccessCidr: {Default: '', Description: 'CIDR block allowed access to SSH or\n      RDP to the instance that is deployed. Only added to ingress if a new security\n      group is created.\n\n      ', Type: String}\n  RoleName: {Description: (Required) Role name to use or create if it does not exists.,\n    Type: String}\n  SubnetId: {Description: Subnet to deploy the instance in., Type: String}\n  Verbose:\n    AllowedValues: ['true', 'false']\n    Default: 'true'\n    Description: 'Verbose setting\n\n      '\n    Type: String\n  VpcId: {Description: VPC to deploy the instance in., Type: String}\nResources:\n  CollectInformation:\n    Properties:\n      AmiId: {Ref: AmiId}\n      ServiceToken:\n        Fn::GetAtt: [CollectInformationLambda, Arn]\n      VpcId: {Ref: VpcId}\n    Type: Custom::CollectInformation\n  CollectInformationLambda:\n    Properties:\n      Code: {ZipFile: \"import base64\\nimport boto3\\nimport traceback\\n\\nimport cfnresponse\\n\\\n          \\nLINUX_USER_DATA = \\\"\\\"\\\"#!/bin/bash\\n\\nfunction get_contents() {\\n\\tif\\\n          \\ [ -x \\\"$(which curl)\\\" ]; then\\n\\t\\tcurl -s -f \\\"$1\\\"\\n\\telif [ -x \\\"\\\n          $(which wget)\\\" ]; then\\n\\t\\twget \\\"$1\\\" -O -\\n\\telse\\n\\t\\tdie \\\"No download\\\n          \\ utility (curl, wget)\\\"\\n\\tfi\\n}\\n\\nreadonly TOKEN_URL=\\\"http://169.254.169.254/latest/api/token\\\"\\\n          \\nfunction get_contents_IMDSv2() {\\n\\tif [ -x \\\"$(which curl)\\\" ]; then\\n\\\n          \\t\\treadonly TOKEN=$(curl -s -f -X PUT -H \\\"X-aws-ec2-metadata-token-ttl-seconds:\\\n          \\ 21600\\\" \\\"$TOKEN_URL\\\")\\n\\t\\tcurl -s -f -H \\\"X-aws-ec2-metadata-token:\\\n          \\ $TOKEN\\\" \\\"$1\\\"\\n\\telif [ -x \\\"$(which wget)\\\" ]; then\\n\\t\\t# wget doesn't\\\n          \\ support --method flag in many cases, so fall back on IMDSv1\\n\\t\\twget\\\n          \\ \\\"$1\\\" -O -\\n\\telse\\n\\t\\tdie \\\"No download utility (curl, wget)\\\"\\n\\t\\\n          fi\\n}\\n\\nreadonly IDENTITY_URL=\\\"http://169.254.169.254/2016-06-30/dynamic/instance-identity/document/\\\"\\\n          \\nreadonly TRUE_REGION=$(get_contents_IMDSv2 \\\"$IDENTITY_URL\\\" | awk -F\\\\\\\n          \\\\\\\" '/region/ { print $4 }')\\nreadonly DEFAULT_REGION=\\\"us-east-1\\\"\\nreadonly\\\n          \\ REGION=\\\"${TRUE_REGION:-$DEFAULT_REGION}\\\"\\n\\nreadonly SCRIPT_NAME=\\\"\\\n          aws-install-ssm-agent\\\"\\n SCRIPT_URL=\\\"https://aws-ssm-downloads-$REGION.s3.amazonaws.com/scripts/$SCRIPT_NAME\\\"\\\n          \\n\\nif [ \\\"$REGION\\\" == \\\"cn-north-1\\\" -o \\\"$REGION\\\" == \\\"cn-northwest-1\\\"\\\n          \\ ]; then\\n  SCRIPT_URL=\\\"https://aws-ssm-downloads-$REGION.s3.$REGION.amazonaws.com.cn/scripts/$SCRIPT_NAME\\\"\\\n          \\nfi\\n\\nif [ \\\"$REGION\\\" == \\\"us-gov-west-1\\\" -o \\\"$REGION\\\" == \\\"us-gov-east-1\\\"\\\n          \\ ]; then\\n  SCRIPT_URL=\\\"https://aws-ssm-downloads-$REGION.s3.$REGION.amazonaws.com/scripts/$SCRIPT_NAME\\\"\\\n          \\nfi\\n\\ncd /tmp\\nFILE_SIZE=0\\nMAX_RETRY_COUNT=3\\nRETRY_COUNT=0\\n\\nwhile\\\n          \\ [ $RETRY_COUNT -lt $MAX_RETRY_COUNT ] ; do\\n  echo AWS-UpdateLinuxAmi:\\\n          \\ Downloading script from $SCRIPT_URL\\n  get_contents \\\"$SCRIPT_URL\\\" >\\\n          \\ \\\"$SCRIPT_NAME\\\"\\n  FILE_SIZE=$(du -k /tmp/$SCRIPT_NAME | cut -f1)\\n \\\n          \\ echo AWS-UpdateLinuxAmi: Finished downloading script, size: $FILE_SIZE\\n\\\n          \\  if [ $FILE_SIZE -gt 0 ]; then\\n\\tbreak\\n  else\\n\\tif [[ $RETRY_COUNT\\\n          \\ -lt MAX_RETRY_COUNT ]]; then\\n\\t  RETRY_COUNT=$((RETRY_COUNT+1));\\n\\t\\\n          \\  echo AWS-UpdateLinuxAmi: FileSize is 0, retryCount: $RETRY_COUNT\\n\\t\\\n          fi\\n  fi \\ndone\\n\\nif [ $FILE_SIZE -gt 0 ]; then\\n  chmod +x \\\"$SCRIPT_NAME\\\"\\\n          \\n  echo AWS-UpdateLinuxAmi: Running UpdateSSMAgent script now ....\\n  ./\\\"\\\n          $SCRIPT_NAME\\\" --region \\\"$REGION\\\"\\nelse\\n  echo AWS-UpdateLinuxAmi: Unable\\\n          \\ to download script, quitting ....\\nfi\\n\\\"\\\"\\\"\\n\\ndef handler_ami_info(event,\\\n          \\ context):\\n\\ttry:\\n\\t\\tec2 = boto3.client('ec2')\\n\\t\\tami_id = event[\\\"\\\n          ResourceProperties\\\"].get(\\\"AmiId\\\", None)\\n\\t\\tvpc_id = event[\\\"ResourceProperties\\\"\\\n          ].get(\\\"VpcId\\\", \\\"\\\")\\n\\t\\tif ami_id is None:\\n\\t\\t\\traise Exception(\\\"\\\n          AMI id must be provided\\\")\\n\\n\\t\\tdata = {}\\n\\n\\t\\t# find platform based\\\n          \\ on ami\\n\\t\\timages = ec2.describe_images(ImageIds=[ami_id])[\\\"Images\\\"\\\n          ]\\n\\t\\tif len(images) == 0:\\n\\t\\t\\traise Exception(\\\"No image found with\\\n          \\ \\\" + ami_id)\\n\\t\\tdata[\\\"Platform\\\"] = images[0].get(\\\"Platform\\\", \\\"\\\n          linux\\\")\\n\\t\\tdata[\\\"UserData\\\"] = \\\"\\\" if data[\\\"Platform\\\"] == \\\"windows\\\"\\\n          \\ else base64.b64encode(LINUX_USER_DATA.encode('utf-8')).decode('utf-8')\\n\\\n          \\t\\t# find default vpc id if non is specified\\n\\t\\tif len(vpc_id) == 0 or\\\n          \\ vpc_id == \\\"Default\\\":\\n\\t\\t\\tvpc_id = \\\"\\\"\\n\\t\\t\\tfor vpc in ec2.describe_vpcs().get('Vpcs',\\\n          \\ []):\\n\\t\\t\\t\\tif vpc.get('IsDefault', False):\\n\\t\\t\\t\\t\\tvpc_id = vpc['VpcId']\\n\\\n          \\t\\t\\t\\t\\tbreak\\n\\t\\t\\tif len(vpc_id) == 0:\\n\\t\\t\\t\\traise Exception(\\\"\\\n          Unable to find default vpc\\\")\\n\\t\\tdata[\\\"VpcId\\\"] = vpc_id\\n\\n\\t\\tcfnresponse.send(event,\\\n          \\ context, cfnresponse.SUCCESS, data, event.get(\\\"PhysicalResourceId\\\",\\\n          \\ None))\\n\\texcept Exception as e:\\n\\t\\tprint(str(e))\\n\\t\\ttraceback.print_exc()\\n\\\n          \\t\\tcfnresponse.send(event, context, cfnresponse.FAILED, {}, event.get(\\\"\\\n          PhysicalResourceId\\\", None))\\n\\n\\ndef handler_delete(event, context):\\n\\t\\\n          # Nothing to do... this is a informational lambda and no resource is created.\\n\\\n          \\tcfnresponse.send(event, context, cfnresponse.SUCCESS, {}, event[\\\"PhysicalResourceId\\\"\\\n          ])\\n\\n\\ndef handler(event, context):\\n\\tif event[\\\"RequestType\\\"] in [\\\"\\\n          Create\\\", \\\"Update\\\"]:\\n\\t\\thandler_ami_info(event, context)\\n\\telif event[\\\"\\\n          RequestType\\\"] in [\\\"Delete\\\"]:\\n\\t\\thandler_delete(event, context)\\n\"}\n      Handler: index.handler\n      MemorySize: 128\n      Role:\n        Fn::If:\n        - LambdaAssumeRoleNotSpecified\n        - Fn::GetAtt: [LambdaRole, Arn]\n        - {Ref: LambdaRoleArn}\n      Runtime: python3.7\n      Timeout: 60\n    Type: AWS::Lambda::Function\n  CollectSubnetInfoLambda:\n    Properties:\n      Code: {ZipFile: \"import boto3\\nimport traceback\\n\\nimport cfnresponse\\n\\n\\n\\\n          def handler_subnet_info(event, context):\\n\\ttry:\\n\\t\\tec2 = boto3.client('ec2')\\n\\\n          \\t\\tvpc_id = event[\\\"ResourceProperties\\\"].get(\\\"VpcId\\\", \\\"\\\")\\n\\t\\tsubnet_id\\\n          \\ = event[\\\"ResourceProperties\\\"].get(\\\"SubnetId\\\", \\\"\\\")\\n\\n\\t\\tdata =\\\n          \\ {}\\n\\n\\t\\tif len(subnet_id) == 0 or subnet_id == \\\"Default\\\":\\n\\t\\t\\t\\\n          subnet_id = \\\"\\\"\\n\\t\\t\\tfor subnet in ec2.describe_subnets(Filters=[{'Name':\\\n          \\ 'vpc-id', 'Values': [vpc_id]}]).get('Subnets'):\\n\\t\\t\\t\\tif subnet.get('DefaultForAz',\\\n          \\ False) and subnet['VpcId'] == vpc_id:\\n\\t\\t\\t\\t\\tsubnet_id = subnet['SubnetId']\\n\\\n          \\t\\t\\t\\t\\tbreak\\n\\t\\t\\tif len(subnet_id) == 0:\\n\\t\\t\\t\\traise Exception(\\\"\\\n          Unable to find default subnet for vpc\\\")\\n\\t\\tdata[\\\"SubnetId\\\"] = subnet_id\\n\\\n          \\n\\t\\tcfnresponse.send(event, context, cfnresponse.SUCCESS, data, event.get(\\\"\\\n          PhysicalResourceId\\\", None))\\n\\texcept Exception as e:\\n\\t\\tprint(str(e))\\n\\\n          \\t\\ttraceback.print_exc()\\n\\t\\tcfnresponse.send(event, context, cfnresponse.FAILED,\\\n          \\ {}, event.get(\\\"PhysicalResourceId\\\", None))\\n\\n\\ndef handler_delete(event,\\\n          \\ context):\\n\\t# Nothing to do... this is a informational lambda and no\\\n          \\ resource is created.\\n\\tcfnresponse.send(event, context, cfnresponse.SUCCESS,\\\n          \\ {}, event[\\\"PhysicalResourceId\\\"])\\n\\n\\ndef handler(event, context):\\n\\\n          \\tif event[\\\"RequestType\\\"] in [\\\"Create\\\", \\\"Update\\\"]:\\n\\t\\thandler_subnet_info(event,\\\n          \\ context)\\n\\telif event[\\\"RequestType\\\"] in [\\\"Delete\\\"]:\\n\\t\\thandler_delete(event,\\\n          \\ context)\\n\"}\n      Handler: index.handler\n      MemorySize: 128\n      Role:\n        Fn::If:\n        - LambdaAssumeRoleNotSpecified\n        - Fn::GetAtt: [LambdaRole, Arn]\n        - {Ref: LambdaRoleArn}\n      Runtime: python3.7\n      Timeout: 60\n    Type: AWS::Lambda::Function\n  CollectSubnetInformation:\n    Properties:\n      ServiceToken:\n        Fn::GetAtt: [CollectSubnetInfoLambda, Arn]\n      SubnetId: {Ref: SubnetId}\n      VpcId:\n        Fn::GetAtt: [CollectInformation, VpcId]\n    Type: Custom::CollectSubnetInformation\n  CreateInstance:\n    DeletionPolicy: Retain\n    Properties:\n      IamInstanceProfile: {Ref: RoleName}\n      ImageId: {Ref: AmiId}\n      InstanceType: {Ref: InstanceType}\n      KeyName:\n        Fn::If:\n        - KeyNameSpecified\n        - {Ref: KeyName}\n        - {Ref: 'AWS::NoValue'}\n      SecurityGroupIds:\n      - Fn::GetAtt: [CreateSecurityGroup, SecurityGroupId]\n      SubnetId:\n        Fn::GetAtt: [CollectSubnetInformation, SubnetId]\n      UserData:\n        Fn::GetAtt: [CollectInformation, UserData]\n    Type: AWS::EC2::Instance\n  CreateInstanceRole:\n    Properties:\n      InstanceProfileName: {Ref: RoleName}\n      ServiceToken:\n        Fn::GetAtt: [InstanceProfileLambda, Arn]\n    Type: Custom::InstanceProfile\n  CreateSecurityGroup:\n    Properties:\n      AccessCidr: {Ref: RemoteAccessCidr}\n      GroupName: {Ref: GroupName}\n      Platform:\n        Fn::GetAtt: [CollectInformation, Platform]\n      ServiceToken:\n        Fn::GetAtt: [SecurityGroupLambda, Arn]\n      VpcId:\n        Fn::GetAtt: [CollectInformation, VpcId]\n    Type: Custom::SecurityGroup\n  InstanceProfileLambda:\n    Properties:\n      Code: {ZipFile: \"import os\\nimport json\\nimport boto3\\n\\nimport cfnresponse\\n\\\n          \\nPOLICY_ARNS = ['arn:aws:iam::aws:policy/AmazonSSMManagedInstanceCore']\\n\\\n          \\n\\ndef handler_create(event, context):\\n\\tname = event[\\\"ResourceProperties\\\"\\\n          ].get(\\\"InstanceProfileName\\\", None)\\n\\tiam = boto3.client('iam')\\n\\ttry:\\n\\\n          \\t\\tif name is None:\\n\\t\\t\\traise Exception(\\\"InstanceProfileName must be\\\n          \\ defined\\\")\\n\\n\\t\\ttry:\\n\\t\\t\\tif iam.get_instance_profile(InstanceProfileName=name):\\n\\\n          \\t\\t\\t\\tcfnresponse.send(event, context, cfnresponse.SUCCESS, {}, \\\"existing:{}\\\"\\\n          .format(name))\\n\\t\\t\\t\\treturn\\n\\t\\texcept iam.exceptions.NoSuchEntityException:\\n\\\n          \\t\\t\\tpass\\n\\n\\t\\tprint(\\\"Role \\\" + name + \\\" does not exist. Creating\\\"\\\n          )\\n\\n\\t\\tis_china_region = os.environ['AWS_REGION'].startswith('cn-')\\n\\t\\\n          \\tec2_service_principal = \\\"ec2.amazonaws.com.cn\\\" if is_china_region else\\\n          \\ \\\"ec2.amazonaws.com\\\"\\n\\n\\t\\tmy_access_control_policy = {\\n\\t\\t\\t\\\"Version\\\"\\\n          : \\\"2012-10-17\\\",\\n\\t\\t\\t\\\"Statement\\\": [\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\\"Effect\\\"\\\n          : \\\"Allow\\\",\\n\\t\\t\\t\\t\\t\\\"Principal\\\": {\\n\\t\\t\\t\\t\\t\\t\\\"Service\\\": [\\n\\t\\\n          \\t\\t\\t\\t\\t\\t\\\"ssm.amazonaws.com\\\",\\n\\t\\t\\t\\t\\t\\t\\tec2_service_principal\\n\\\n          \\t\\t\\t\\t\\t\\t]\\n\\t\\t\\t\\t\\t},\\n\\t\\t\\t\\t\\t\\\"Action\\\": \\\"sts:AssumeRole\\\"\\n\\t\\\n          \\t\\t\\t}\\n\\t\\t\\t]\\n\\t\\t}\\n\\n\\t\\t# Get the desired role\\n\\t\\tiam.create_role(\\n\\\n          \\t\\t\\tRoleName=name,\\n\\t\\t\\tDescription='Role created from Lambda',\\n\\t\\t\\\n          \\tAssumeRolePolicyDocument=json.dumps(my_access_control_policy))\\n\\n\\t\\t\\\n          for policy in POLICY_ARNS:\\n\\t\\t\\tiam.attach_role_policy(RoleName=name,\\\n          \\ PolicyArn=policy)\\n\\t\\tprint(\\\"Role \\\" + name + \\\" created\\\")\\n\\n\\t\\t\\\n          # create the instance profile\\n\\t\\tiam.create_instance_profile(InstanceProfileName=name)\\n\\\n          \\n\\t\\tiam.add_role_to_instance_profile(InstanceProfileName=name, RoleName=name)\\n\\\n          \\t\\tprint(\\\"Instance profile \\\" + name + \\\" created\\\")\\n\\t\\tcfnresponse.send(event,\\\n          \\ context, cfnresponse.SUCCESS, {}, \\\"created:{}\\\".format(name))\\n\\texcept\\\n          \\ Exception as e:\\n\\t\\tprint(str(e))\\n\\t\\tdelete_all(iam, name)\\n\\t\\tcfnresponse.send(event,\\\n          \\ context, cfnresponse.FAILED, {}, \\\"created:{}\\\".format(name))\\n\\n\\ndef\\\n          \\ handler_update(event, context):\\n\\tcfnresponse.send(event, context, cfnresponse.FAILED,\\\n          \\ {}, event[\\\"PhysicalResourceId\\\"])\\n\\n\\ndef handler_delete(event, context):\\n\\\n          \\tcf = boto3.client(\\\"cloudformation\\\")\\n\\tstack = cf.describe_stacks(StackName=event[\\\"\\\n          StackId\\\"])[\\\"Stacks\\\"][0]\\n\\tresource_id = event[\\\"PhysicalResourceId\\\"\\\n          ]\\n\\tif resource_id.startswith(\\\"existing:\\\") or stack[\\\"StackStatus\\\"]\\\n          \\ == \\\"DELETE_IN_PROGRESS\\\":\\n\\t\\tcfnresponse.send(event, context, cfnresponse.SUCCESS,\\\n          \\ {}, event[\\\"PhysicalResourceId\\\"])\\n\\t\\treturn\\n\\t_, name = event[\\\"PhysicalResourceId\\\"\\\n          ].split(\\\":\\\")\\n\\n\\ttry:\\n\\t\\tdelete_all(boto3.client('iam'), name)\\n\\t\\t\\\n          cfnresponse.send(event, context, cfnresponse.SUCCESS, {}, resource_id)\\n\\\n          \\texcept Exception as e:\\n\\t\\tprint(str(e))\\n\\t\\tdelete_all(boto3.client('iam'),\\\n          \\ name)\\n\\t\\tcfnresponse.send(event, context, cfnresponse.FAILED, {}, resource_id)\\n\\\n          \\n\\ndef delete_all(iam, name):\\n\\tclean_policies(iam, name)\\n\\tclean_instance_profile(iam,\\\n          \\ name)\\n\\tdelete_instance_profile(iam, name)\\n\\tdelete_role(iam, name)\\n\\\n          \\n\\ndef clean_policies(iam, name):\\n\\ttry:\\n\\t\\tattached = iam.list_attached_role_policies(RoleName=name)\\n\\\n          \\t\\tfor policy in attached[\\\"AttachedPolicies\\\"]:\\n\\t\\t\\tiam.detach_role_policy(RoleName=name,\\\n          \\ PolicyArn=policy[\\\"PolicyArn\\\"])\\n\\texcept Exception as e:\\n\\t\\tprint(str(e))\\n\\\n          \\n\\ndef clean_instance_profile(iam, name):\\n\\ttry:\\n\\t\\tinstance_profile\\\n          \\ = iam.get_instance_profile(InstanceProfileName=name)\\n\\t\\tfor role in\\\n          \\ instance_profile[\\\"InstanceProfile\\\"].get(\\\"Roles\\\", []):\\n\\t\\t\\tiam.remove_role_from_instance_profile(\\n\\\n          \\t\\t\\t\\tInstanceProfileName=name,\\n\\t\\t\\t\\tRoleName=role[\\\"RoleName\\\"]\\n\\\n          \\t\\t\\t)\\n\\texcept Exception as e:\\n\\t\\tprint(str(e))\\n\\n\\ndef delete_instance_profile(iam,\\\n          \\ name):\\n\\ttry:\\n\\t\\tiam.delete_instance_profile(InstanceProfileName=name)\\n\\\n          \\texcept Exception as e:\\n\\t\\tprint(str(e))\\n\\n\\ndef delete_role(iam, name):\\n\\\n          \\ttry:\\n\\t\\tiam.delete_role(RoleName=name)\\n\\texcept Exception as e:\\n\\t\\\n          \\tprint(str(e))\\n\\n\\ndef handler(event, context):\\n\\tif event[\\\"RequestType\\\"\\\n          ] == \\\"Create\\\":\\n\\t\\thandler_create(event, context)\\n\\telif event[\\\"RequestType\\\"\\\n          ] == \\\"Update\\\":\\n\\t\\thandler_update(event, context)\\n\\telse:\\n\\t\\thandler_delete(event,\\\n          \\ context)\\n\"}\n      Handler: index.handler\n      MemorySize: 128\n      Role:\n        Fn::If:\n        - LambdaAssumeRoleNotSpecified\n        - Fn::GetAtt: [LambdaRole, Arn]\n        - {Ref: LambdaRoleArn}\n      Runtime: python3.7\n      Timeout: 60\n    Type: AWS::Lambda::Function\n  LambdaLogPolicy:\n    Condition: IsVerboseAndLambdaRoleNotSpecified\n    Properties:\n      PolicyDocument:\n        Statement:\n          Action: ['log:CreateLogStream', 'log:PutLogEvents', 'log:CreateLogGroup']\n          Effect: Allow\n          Resource: {'Fn::Sub': 'arn:${AWS::Partition}:logs:${AWS::Region}:${AWS::AccountId}:*'}\n        Version: '2012-10-17'\n      PolicyName: lambda-log-access\n      Roles:\n      - {Ref: LambdaRole}\n    Type: AWS::IAM::Policy\n  LambdaRole:\n    Condition: LambdaAssumeRoleNotSpecified\n    Properties:\n      AssumeRolePolicyDocument:\n        Statement:\n        - Action: ['sts:AssumeRole']\n          Effect: Allow\n          Principal:\n            Service: [lambda.amazonaws.com]\n        Version: '2012-10-17'\n      ManagedPolicyArns:\n      - {'Fn::Sub': 'arn:${AWS::Partition}:iam::aws:policy/AWSCloudFormationReadOnlyAccess'}\n      - {'Fn::Sub': 'arn:${AWS::Partition}:iam::aws:policy/AWSLambdaExecute'}\n      - {'Fn::Sub': 'arn:${AWS::Partition}:iam::aws:policy/AmazonSSMFullAccess'}\n      - {'Fn::Sub': 'arn:${AWS::Partition}:iam::aws:policy/IAMFullAccess'}\n      - {'Fn::Sub': 'arn:${AWS::Partition}:iam::aws:policy/AmazonEC2FullAccess'}\n      Path: /\n    Type: AWS::IAM::Role\n  SecurityGroupLambda:\n    Properties:\n      Code: {ZipFile: \"import boto3\\nimport traceback\\nimport cfnresponse\\n\\n\\ndef\\\n          \\ find_security_groups(ec2, vpc_id, group_name):\\n\\tsecurity_groups = ec2.describe_security_groups(Filters=[\\n\\\n          \\t\\t{\\\"Name\\\": \\\"group-name\\\", \\\"Values\\\": [group_name]},\\n\\t\\t{\\\"Name\\\"\\\n          : \\\"vpc-id\\\", \\\"Values\\\": [vpc_id]}\\n\\t])[\\\"SecurityGroups\\\"]\\n\\tfor security_group\\\n          \\ in security_groups:\\n\\t\\tif security_group[\\\"GroupName\\\"] == group_name\\\n          \\ and security_group[\\\"VpcId\\\"] == vpc_id:\\n\\t\\t\\treturn security_group\\n\\\n          \\treturn None\\n\\n\\ndef handler_create(event, context):\\n\\tgroup_name = event[\\\"\\\n          ResourceProperties\\\"].get(\\\"GroupName\\\", None)\\n\\tcidr = event[\\\"ResourceProperties\\\"\\\n          ].get(\\\"AccessCidr\\\", \\\"\\\")\\n\\tvpc_id = event[\\\"ResourceProperties\\\"].get(\\\"\\\n          VpcId\\\", None)\\n\\tplatform = event[\\\"ResourceProperties\\\"].get(\\\"Platform\\\"\\\n          , None)\\n\\n\\tec2 = boto3.client('ec2')\\n\\tsecurity_group_id = None\\n\\ttry:\\n\\\n          \\t\\tsecurity_group = find_security_groups(ec2, vpc_id, group_name)\\n\\t\\t\\\n          if security_group is not None:\\n\\t\\t\\tdata = {\\\"SecurityGroupId\\\": security_group[\\\"\\\n          GroupId\\\"]}\\n\\t\\t\\tcfnresponse.send(event, context, cfnresponse.SUCCESS,\\\n          \\ data, \\\"existing:{}:{}\\\".format(vpc_id, group_name))\\n\\t\\t\\treturn\\n\\n\\\n          \\t\\tresponse = ec2.create_security_group(\\n\\t\\t\\tGroupName=group_name,\\n\\\n          \\t\\t\\tDescription='Security Group created from Lambda',\\n\\t\\t\\tVpcId=vpc_id)\\n\\\n          \\t\\tsecurity_group_id = response['GroupId']\\n\\n\\t\\tif len(cidr) > 0:\\n\\t\\\n          \\t\\tif platform == 'windows':\\n\\t\\t\\t\\tdata = ec2.authorize_security_group_ingress(\\n\\\n          \\t\\t\\t\\t\\tGroupId=security_group_id,\\n\\t\\t\\t\\t\\tIpPermissions=[\\n\\t\\t\\t\\t\\\n          \\t\\t{'IpProtocol': 'tcp',\\n\\t\\t\\t\\t\\t\\t 'FromPort': 3389,\\n\\t\\t\\t\\t\\t\\t\\\n          \\ 'ToPort': 3389,\\n\\t\\t\\t\\t\\t\\t 'IpRanges': [{'CidrIp': cidr}]}\\n\\t\\t\\t\\t\\\n          \\t])\\n\\t\\t\\t\\tprint('Ingress Successfully Set %s' % data)\\n\\t\\t\\telse:\\n\\\n          \\t\\t\\t\\tdata = ec2.authorize_security_group_ingress(\\n\\t\\t\\t\\t\\tGroupId=security_group_id,\\n\\\n          \\t\\t\\t\\t\\tIpPermissions=[\\n\\t\\t\\t\\t\\t\\t{'IpProtocol': 'tcp',\\n\\t\\t\\t\\t\\t\\\n          \\t 'FromPort': 22,\\n\\t\\t\\t\\t\\t\\t 'ToPort': 22,\\n\\t\\t\\t\\t\\t\\t 'IpRanges':\\\n          \\ [{'CidrIp': cidr}]}\\n\\t\\t\\t\\t\\t])\\n\\t\\t\\t\\tprint('Ingress Successfully\\\n          \\ Set %s' % data)\\n\\n\\t\\tdata = {\\\"SecurityGroupId\\\": security_group_id}\\n\\\n          \\t\\tcfnresponse.send(event, context, cfnresponse.SUCCESS, data, \\\"created:{}:{}\\\"\\\n          .format(vpc_id, security_group_id))\\n\\texcept Exception as e:\\n\\t\\tprint(str(e))\\n\\\n          \\t\\ttraceback.print_exc()\\n\\t\\tdelete_all(ec2, vpc_id, security_group_id)\\n\\\n          \\t\\tcfnresponse.send(event, context, cfnresponse.FAILED, {}, \\\"created:{}:{}\\\"\\\n          .format(vpc_id, security_group_id))\\n\\n\\ndef handler_update(event, context):\\n\\\n          \\tcfnresponse.send(event, context, cfnresponse.FAILED, {}, event[\\\"PhysicalResourceId\\\"\\\n          ])\\n\\n\\ndef handler_delete(event, context):\\n\\tcf = boto3.client(\\\"cloudformation\\\"\\\n          )\\n\\tstack = cf.describe_stacks(StackName=event[\\\"StackId\\\"])[\\\"Stacks\\\"\\\n          ][0]\\n\\tresource_id = event[\\\"PhysicalResourceId\\\"]\\n\\tif resource_id.startswith(\\\"\\\n          existing:\\\") or stack[\\\"StackStatus\\\"] == \\\"DELETE_IN_PROGRESS\\\":\\n\\t\\t\\\n          cfnresponse.send(event, context, cfnresponse.SUCCESS, {}, event[\\\"PhysicalResourceId\\\"\\\n          ])\\n\\t\\treturn\\n\\t_, vpc_id, group_id = event[\\\"PhysicalResourceId\\\"].split(\\\"\\\n          :\\\")\\n\\n\\ttry:\\n\\t\\tdelete_all(boto3.client('ec2'), vpc_id, group_id)\\n\\n\\\n          \\t\\tcfnresponse.send(event, context, cfnresponse.SUCCESS, {}, resource_id)\\n\\\n          \\texcept Exception as e:\\n\\t\\tprint(str(e))\\n\\t\\tcfnresponse.send(event,\\\n          \\ context, cfnresponse.FAILED, {}, resource_id)\\n\\n\\ndef delete_all(ec2,\\\n          \\ vpc_id, group_id):\\n\\tif group_id is not None:\\n\\t\\ttry:\\n\\t\\t\\tec2.delete_security_group(GroupId=group_id)\\n\\\n          \\t\\texcept Exception as e:\\n\\t\\t\\tstr(e)\\n\\n\\ndef handler(event, context):\\n\\\n          \\tif event[\\\"RequestType\\\"] == \\\"Create\\\":\\n\\t\\thandler_create(event, context)\\n\\\n          \\telif event[\\\"RequestType\\\"] == \\\"Update\\\":\\n\\t\\thandler_update(event,\\\n          \\ context)\\n\\telse:\\n\\t\\thandler_delete(event, context)\\n\"}\n      Handler: index.handler\n      MemorySize: 128\n      Role:\n        Fn::If:\n        - LambdaAssumeRoleNotSpecified\n        - Fn::GetAtt: [LambdaRole, Arn]\n        - {Ref: LambdaRoleArn}\n      Runtime: python3.7\n      Timeout: 60\n    Type: AWS::Lambda::Function\n",
        "TimeoutInMinutes": 30
      }
    },
    {
      "name": "deleteManagedInstanceStack",
      "action": "aws:deleteStack",
      "maxAttempts": 1,
      "onFailure": "Abort",
      "inputs": {
        "StackName": "{{StackName}}"
      }
    }
  ]
}
