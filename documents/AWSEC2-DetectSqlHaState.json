{
  "schemaVersion": "2.2",
  "description": "Collect SQL Server HA metadata on customer instance and map output to JSON.",
  "parameters": {
    "executionTimeout": {
      "type": "String",
      "default": "300",
      "description": "Command execution time limit.",
      "allowedPattern": "([1-9][0-9]{0,3})|(1[0-9]{1,4})|(2[0-7][0-9]{1,3})|(28[0-7][0-9]{1,2})|(28800)"
    },
    "secretArn": {
      "type": "String",
      "default": "",
      "description": "AWS secret ARN containing credentials to connect to SQL Server.",
      "allowedPattern": "|arn:aws[a-z-]*:secretsmanager:[a-z0-9-]*:[0-9]{12}:secret:[a-zA-Z0-9/_+=.@-]+"
    },
    "compress": {
      "type": "String",
      "default": "true",
      "description": "Compress SSM command output results with gzip.",
      "allowedValues": [
        "true",
        "false"
      ]
    },
    "limit": {
      "type": "String",
      "default": "2500",
      "description": "Character limit for SSM command output.",
      "allowedPattern": "[0-9]{0,6}"
    },
    "nextToken": {
      "type": "String",
      "default": "",
      "description": "Continuation token for SSM command output.",
      "allowedPattern": "[A-Za-z0-9+/=]*"
    }
  },
  "mainSteps": [
    {
      "precondition": {
        "StringEquals": [
          "platformType",
          "Windows"
        ]
      },
      "action": "aws:runPowerShellScript",
      "name": "runPowerShellScript",
      "inputs": {
        "runCommand": [
          "## 1.0.0.0",
          "",
          "Add-Type -AssemblyName System.Security",
          "",
          "<# Constants #>",
          "",
          "# Error Messages",
          "$ERR_MSG_UNSUPPORTED_WINDOWS_VERSION = \"Windows Server version is not supported. Windows Server 2019 or later is required.\"",
          "$ERR_MSG_UNSUPPORTED_POWERSHELL_VERSION = \"PowerShell version is not supported. Windows PowerShell 5.1 or later is required.\"",
          "$ERR_MSG_UNSUPPORTED_SQL_SERVER_VERSION = \"SQL Server version is not supported. SQL Server 2017 or later is required.\"",
          "$ERR_MSG_SQL_SERVER_NOT_INSTALLED = \"Windows Registry key for Microsoft SQL Server cannot be found on instance. SQL Server may not be installed.\"",
          "$ERR_MSG_NO_SQL_SERVER_INSTANCE_STATUSES = \"Cannot get statuses for SQL Server instances on instance.\"",
          "$ERR_MSG_NO_FCI_GROUP_ID = \"Cannot get unique ID for Always On Failover Cluster Instance from Windows Registry.\"",
          "$ERR_MSG_SECRET_INVALID_SCHEMA = \"Secret value for secret {{secretArn}} has an invalid schema. The expected plaintext format for the secret value is {`\"username`\":`\"your-username`\",`\"password`\":`\"your-password`\"} for a local user or {`\"username`\":`\"DOMAIN\\\\your-username`\",`\"password`\":`\"your-password`\"} for a domain user.\"",
          "$ERR_MSG_SECRET_INVALID_WINDOWS_CREDENTIALS = \"Windows user logon failed due to invalid username or password in secret {{secretArn}}. The expected plaintext format for the secret value is {`\"username`\":`\"your-username`\",`\"password`\":`\"your-password`\"} for a local user or {`\"username`\":`\"DOMAIN\\\\your-username`\",`\"password`\":`\"your-password`\"} for a domain user.\"",
          "$ERR_MSG_WINDOWS_LOGON_FAILED = \"Windows user logon using credentials from secret {{secretArn}} failed with the following error: \"",
          "$ERR_MSG_SECRET_INVALID_SQL_SERVER_CREDENTIALS = \"Windows user cannot login to one or more SQL Server instances. Create a SQL Server login for this Windows user on each SQL Server instance.\"",
          "$ERR_MSG_SQL_QUERY_EXECUTION = \"SQL query on instance failed with the following error: \"",
          "$ERR_MSG_INVALID_NEXT_TOKEN = \"Internal error: Invalid next token provided in SSM command execution.\"",
          "$ERR_MSG_COMMAND_OUTPUT_LIMIT = \"Internal error: Failed to return SQL Server metadata fitting within the SSM command output limit {{limit}}.\"",
          "",
          "# Log file path",
          "$PROGRAM_DATA_PATH = \"$env:ProgramData\"",
          "$LOG_FILE = \"$PROGRAM_DATA_PATH\" + '\\Amazon\\SQL_HA\\SQLHaSSMDocument.log'",
          "",
          "# Computer name",
          "$COMPUTER_NAME = \"$env:computername\"",
          "",
          "# Regex patterns",
          "$SQL_SERVER_INSTANCE_PATTERN = '^[a-zA-Z][a-zA-Z0-9_$]{0,15}$'",
          "$DATABASE_NAME_PATTERN = '^[a-zA-Z0-9@#_][a-zA-Z0-9@#_$]{0,127}$'",
          "$REPLICA_ID_PATTERN = '^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-4[0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$'",
          "",
          "# DB record properties",
          "$SQL_SERVER_INSTANCE = 'sqlServerInstance'",
          "$REPLICA_ID = 'replicaId'",
          "$GROUP_ID = 'groupId'",
          "$DATABASE_NAME = 'databaseName'",
          "$SECONDARY_ROLE_ALLOW_CONNECTIONS = 'secondaryRoleAllowConnections'",
          "$ROLE_DESC = 'roleDesc'",
          "$IS_LOCAL = 'isLocal'",
          "$HA_TYPE = 'haType'",
          "",
          "# Role description types",
          "$PRIMARY = 'PRIMARY'",
          "$SECONDARY = 'SECONDARY'",
          "",
          "# HA types",
          "$AVAILABILITY_GROUP = 'AVAILABILITY_GROUP'",
          "$FCI = 'FCI'",
          "$STANDALONE = 'STANDALONE'",
          "",
          "# SQL Server instance statuses",
          "$RUNNING = 'Running'",
          "",
          "# Command output properties",
          "$BODY = 'body'",
          "$INSTANCE_ID = 'instanceId'",
          "$SQL_DATABASES = 'sqlDatabases'",
          "$NEXT_TOKEN = 'nextToken'",
          "$VERSION = 'version'",
          "",
          "$DOC_VERSION = '1'",
          "",
          "<# AWS Secrets Manager #>",
          "",
          "# Windows impersonation",
          "$LOGON32_LOGON_INTERACTIVE = 2",
          "$LOGON32_PROVIDER_DEFAULT = 0",
          "Add-Type -TypeDefinition @\"",
          "using System;",
          "using System.Runtime.InteropServices;",
          "using System.Management.Automation;",
          "using System.Security.Authentication;",
          "",
          "public class Win32 {",
          "    private const int ERROR_LOGON_FAILURE = 1326;",
          "",
          "    [DllImport(\"advapi32.dll\", SetLastError = true)]",
          "    public static extern bool LogonUser(string lpszUsername, string lpszDomain, string lpszPassword,",
          "        int dwLogonType, int dwLogonProvider, out IntPtr phToken);",
          "",
          "    [DllImport(\"kernel32.dll\", CharSet = CharSet.Auto)]",
          "    public extern static bool CloseHandle(IntPtr handle);",
          "",
          "    public static IntPtr LogonUserWithCredential(PSCredential credential, int logonType, int logonProvider) {",
          "        string username = credential.UserName;",
          "        IntPtr passwordPtr = IntPtr.Zero;",
          "        string domain = \".\";",
          "",
          "        try {",
          "            int backslashIndex = username.IndexOf('\\\\');",
          "            if (backslashIndex > 0) {",
          "                domain = username.Substring(0, backslashIndex);",
          "                username = username.Substring(backslashIndex + 1);",
          "            }",
          "",
          "            IntPtr token;",
          "            passwordPtr = Marshal.SecureStringToGlobalAllocUnicode(credential.Password);",
          "            bool result = LogonUser(username, domain, Marshal.PtrToStringUni(passwordPtr), logonType, logonProvider, out token);",
          "            if (!result) {",
          "                int errorCode = Marshal.GetLastWin32Error();",
          "                if (errorCode == ERROR_LOGON_FAILURE) {",
          "                    throw new InvalidCredentialException();",
          "                }",
          "                throw new System.ComponentModel.Win32Exception(errorCode);",
          "            }",
          "",
          "            return token;",
          "        }",
          "        finally {",
          "            if (passwordPtr != IntPtr.Zero) {",
          "                Marshal.ZeroFreeGlobalAllocUnicode(passwordPtr);",
          "            }",
          "        }",
          "    }",
          "}",
          "\"@",
          "",
          "Add-Type -TypeDefinition @\"",
          "using System;",
          "using System.Security;",
          "using System.Web.Script.Serialization;",
          "using System.Collections.Generic;",
          "using System.Management.Automation;",
          "",
          "public static class SecretHelper {",
          "    public static PSCredential CreatePSCredential(object awsResponse) {",
          "        string json = awsResponse.GetType().GetProperty(\"SecretString\").GetValue(awsResponse).ToString();",
          "        var serializer = new JavaScriptSerializer();",
          "        Dictionary<string, object> data = null;",
          "",
          "        try {",
          "            data = serializer.DeserializeObject(json) as Dictionary<string, object>;",
          "            if (data == null || !data.ContainsKey(\"username\") || !data.ContainsKey(\"password\"))",
          "                throw new ArgumentException();",
          "",
          "            var secureString = new SecureString();",
          "            for (int i = 0; i < data[\"password\"].ToString().Length; i++) {",
          "                secureString.AppendChar(data[\"password\"].ToString()[i]);",
          "                data[\"password\"] = data[\"password\"].ToString().Remove(i, 1).Insert(i, \"\\0\");",
          "            }",
          "            secureString.MakeReadOnly();",
          "            return new PSCredential(data[\"username\"].ToString(), secureString);",
          "        }",
          "        finally {",
          "            json = null;",
          "            if (data != null) {",
          "                var keys = new string[data.Keys.Count];",
          "                data.Keys.CopyTo(keys, 0);",
          "                foreach (var key in keys) {",
          "                    data[key] = null;",
          "                }",
          "            }",
          "        }",
          "    }",
          "}",
          "\"@ -ReferencedAssemblies System.Web.Extensions, System.Management.Automation",
          "",
          "<# T-SQL #>",
          "",
          "# SQL Server system errors",
          "$SQL_SERVER_LOGON_FAILED = 18456",
          "",
          "# SQL Server database connection property",
          "$SQL_DB_NAME = 'master'",
          "",
          "# SQL query parameters",
          "$START_DATABASE_NAME = '@StartDatabaseName'",
          "$START_REPLICA_ID = '@StartReplicaId'",
          "",
          "# SQL query for retrieving availability group metadata",
          "$AG_SQL_QUERY = \"SELECT * INTO #databases FROM sys.databases with (nolock)",
          "  SELECT * INTO #dm_hadr_database_replica_states FROM sys.dm_hadr_database_replica_states with (nolock)",
          "  SELECT * INTO #availability_databases_cluster FROM sys.availability_databases_cluster with (nolock)",
          "  SELECT * INTO #availability_groups FROM sys.availability_groups with (nolock) ",
          "  SELECT * INTO #availability_replicas FROM sys.availability_replicas with (nolock) ",
          "  SELECT * INTO #dm_hadr_availability_replica_states FROM sys.dm_hadr_availability_replica_states with (nolock)",
          "",
          "SELECT ar.replica_id AS $REPLICA_ID,",
          "ar.group_id AS $GROUP_ID,",
          "db.name AS $DATABASE_NAME,",
          "ar.secondary_role_allow_connections AS $SECONDARY_ROLE_ALLOW_CONNECTIONS,",
          "ars.role_desc AS $ROLE_DESC,",
          "drs.is_local AS $IS_LOCAL,",
          "db.state_desc AS stateDesc,",
          "CASE",
          "WHEN ag.name IS NOT NULL THEN '$AVAILABILITY_GROUP'",
          "ELSE '$STANDALONE'",
          "END AS '$HA_TYPE'",
          "INTO #RawData",
          "FROM #databases AS db with (nolock)",
          "LEFT JOIN #dm_hadr_database_replica_states AS drs with (nolock) ON db.database_id = drs.database_id",
          "LEFT JOIN #availability_databases_cluster AS adc with (nolock) ON drs.group_id = adc.group_id AND drs.group_database_id = adc.group_database_id",
          "LEFT JOIN #availability_groups AS ag with (nolock) ON ag.group_id = drs.group_id",
          "LEFT JOIN #availability_replicas AS ar with (nolock) ON drs.group_id = ar.group_id AND drs.replica_id = ar.replica_id",
          "LEFT JOIN #dm_hadr_availability_replica_states AS ars with (nolock) ON drs.group_id = ars.group_id AND drs.replica_id = ars.replica_id",
          "",
          "IF EXISTS(SELECT 1 FROM tempdb.sys.objects WHERE name like('#RawData%')) ",
          "SELECT * FROM #RawData",
          "  WHERE stateDesc NOT IN('RESTORING','RECOVERING','RECOVERY_PENDING','OFFLINE','SUSPECT','EMERGENCY')",
          "  AND LOWER($DATABASE_NAME) NOT IN('master','model','msdb','tempdb')",
          "  AND ($START_DATABASE_NAME IS NULL OR",
          "       ($DATABASE_NAME > $START_DATABASE_NAME) OR",
          "       ($DATABASE_NAME = $START_DATABASE_NAME AND",
          "        ($START_REPLICA_ID IS NULL OR $REPLICA_ID >= $START_REPLICA_ID)))",
          "  ORDER BY $DATABASE_NAME, $REPLICA_ID;\"",
          "",
          "# Record schema for availability group SQL query",
          "$AG_SQL_QUERY_RECORD_SCHEMA = @(",
          "    $DATABASE_NAME,",
          "    $REPLICA_ID,",
          "    $GROUP_ID,",
          "    $SECONDARY_ROLE_ALLOW_CONNECTIONS,",
          "    $ROLE_DESC,",
          "    $IS_LOCAL,",
          "    $HA_TYPE",
          ")",
          "",
          "# Create log file",
          "Function Initialize-LogFile {",
          "    try {",
          "        # Check if the log file directory exists, if not create it",
          "        $LogFileDirectory = Split-Path -Path $LOG_FILE -Parent",
          "        if (-not (Test-Path -Path $LogFileDirectory)) {",
          "            New-Item -ItemType Directory -Path $LogFileDirectory -Force | Out-Null",
          "        }",
          "",
          "        # Check if the log file exists",
          "        if (Test-Path -Path $LOG_FILE) {",
          "            $LogFileInfo = Get-Item -Path $LOG_FILE",
          "",
          "            # Check if the log file is larger than 5KB",
          "            if ($LogFileInfo.Length -gt 5KB) {",
          "                Remove-Item -Path $LOG_FILE -Force",
          "                New-Item -ItemType File -Path $LOG_FILE -Force | Out-Null",
          "            }",
          "        } else {",
          "            # If the log file doesn't exist, create it",
          "            New-Item -ItemType File -Path $LOG_FILE -Force | Out-Null",
          "        }",
          "    }",
          "    catch {",
          "        # Error creating log file",
          "    }",
          "}",
          "",
          "# Write message to log file with ISO timestamp",
          "Function Log-Write {",
          "    Param ([string] $logString)",
          "    try {",
          "        $timeStamp = Get-Date -Format \"o\"",
          "        Add-content $LOG_FILE -value \"$timeStamp : $logString\"",
          "    } catch {",
          "        # Error writing to log file",
          "    }",
          "}",
          "",
          "Function Assert-WindowsVersion {",
          "    # https://learn.microsoft.com/en-us/windows/release-health/windows-server-release-info",
          "    if ([System.Environment]::OSVersion.Version.Build -lt 17763) {",
          "        throw $ERR_MSG_UNSUPPORTED_WINDOWS_VERSION",
          "    }",
          "}",
          "",
          "Function Assert-PowerShellVersion {",
          "    if ($PSVersionTable.PSVersion -lt [Version]\"5.1\") {",
          "        throw $ERR_MSG_UNSUPPORTED_POWERSHELL_VERSION",
          "    }",
          "}",
          "",
          "Function Get-SqlServerInstances {",
          "    # Check if registry key exists",
          "    if (Test-Path 'HKLM:\\Software\\Microsoft\\Microsoft SQL Server') {",
          "        # Get all SQL Server instances on the EC2 instance",
          "        $sqlServerInstances = (Get-ItemProperty 'HKLM:\\\\SOFTWARE\\\\Microsoft\\\\Microsoft SQL Server').InstalledInstances | Sort-Object",
          "",
          "        # Validate SQL Server versions",
          "        foreach ($instance in $sqlServerInstances) {",
          "            $instanceName = (Get-ItemProperty 'HKLM:\\\\SOFTWARE\\\\Microsoft\\\\Microsoft SQL Server\\\\Instance Names\\\\SQL').$instance",
          "            # https://learn.microsoft.com/en-us/troubleshoot/sql/releases/download-and-install-latest-updates",
          "            if ((Get-ItemProperty \"HKLM:\\\\SOFTWARE\\\\Microsoft\\\\Microsoft SQL Server\\\\$instanceName\\\\Setup\").Version -lt 14) {",
          "                throw $ERR_MSG_UNSUPPORTED_SQL_SERVER_VERSION",
          "            }",
          "        }",
          "",
          "        return $sqlServerInstances",
          "",
          "    } else {",
          "        throw $ERR_MSG_SQL_SERVER_NOT_INSTALLED",
          "    }",
          "}",
          "",
          "Function Get-SqlServerMetadataFromRegistry {",
          "    Param ([string[]] $sqlServerInstances)",
          "",
          "    # Map SQL Server instance to its port name and cluster name (if it exists in Windows Registry)",
          "    $sqlServerInstanceMetadata = @{}",
          "    foreach ($instance in $sqlServerInstances) {",
          "        $instanceName = (Get-ItemProperty 'HKLM:\\\\SOFTWARE\\\\Microsoft\\\\Microsoft SQL Server\\\\Instance Names\\\\SQL').$instance",
          "",
          "        $portId = if ((Get-ItemProperty \"HKLM:\\\\SOFTWARE\\\\Microsoft\\\\Microsoft SQL Server\\\\$instanceName\\\\MSSQLServer\\\\SuperSocketNetLib\\\\Tcp\\\\IPAll\").TcpPort -ne '') {",
          "            (Get-ItemProperty \"HKLM:\\\\SOFTWARE\\\\Microsoft\\\\Microsoft SQL Server\\\\$instanceName\\\\MSSQLServer\\\\SuperSocketNetLib\\\\Tcp\\\\IPAll\").TcpPort",
          "        } else {",
          "            (Get-ItemProperty \"HKLM:\\\\SOFTWARE\\\\Microsoft\\\\Microsoft SQL Server\\\\$instanceName\\\\MSSQLServer\\\\SuperSocketNetLib\\\\Tcp\\\\IPAll\").TcpDynamicPorts",
          "        }",
          "",
          "        $clusterName = if (Test-Path -Path \"HKLM:\\\\SOFTWARE\\\\Microsoft\\\\Microsoft SQL Server\\\\$instanceName\\\\Cluster\") {",
          "            (Get-ItemProperty \"HKLM:\\\\SOFTWARE\\\\Microsoft\\\\Microsoft SQL Server\\\\$instanceName\\\\Cluster\").ClusterName",
          "        } else {",
          "            $null",
          "        }",
          "",
          "        $sqlServerInstanceMetadata[$instance] = @($portId, $clusterName)",
          "    }",
          "",
          "    return $sqlServerInstanceMetadata",
          "}",
          "",
          "Function Get-SqlServerInstanceStatuses {",
          "    Param ([string[]] $sqlServerInstances)",
          "",
          "    # Map SQL Server instance server name to SQL Server instance",
          "    $serverNameMap = @{}",
          "    foreach ($instance in $sqlServerInstances) {",
          "        $serverName = if ($instance -eq 'MSSQLSERVER') {",
          "            $instance",
          "        } else {",
          "            'MSSQL$' + $instance",
          "        }",
          "        $serverNameMap[$serverName] = $instance",
          "    }",
          "",
          "    # Get statuses of SQL Server instances with server names associated with provided SQL Server instances",
          "    $instanceArray = Get-Service -ComputerName $COMPUTER_NAME  | where { $serverNameMap.ContainsKey($_.Name) }",
          "",
          "    if ($instanceArray) {",
          "        # Map SQL Server instance to its status",
          "        $sqlServerInstanceStatuses = @{}",
          "        foreach ($object in $instanceArray) {",
          "            $sqlServerInstanceStatuses[$serverNameMap[$object.Name]] = $object.Status",
          "        }",
          "        return $sqlServerInstanceStatuses",
          "    } else {",
          "        throw $ERR_MSG_NO_SQL_SERVER_INSTANCE_STATUSES",
          "    }",
          "}",
          "",
          "Function Get-FciGroupId {",
          "    Param ([string] $clusterName)",
          "",
          "    if (Test-Path -Path \"HKLM:\\Cluster\\Resources\") {",
          "        $resources = Get-ItemProperty -Path HKLM:\\Cluster\\Resources\\*",
          "        $networkName = \"SQL Network Name ($clusterName)\"",
          "        foreach ($resource in $resources) {",
          "            if ($networkName -eq $resource.Name) {",
          "                return (($resource.PSPath).Split('\\')[((($resource.PSPath).Split('\\').count)-1)]).ToUpper()",
          "            }",
          "        }",
          "    }",
          "",
          "    throw $ERR_MSG_NO_FCI_GROUP_ID",
          "",
          "}",
          "",
          "Function Get-AWSSecret {",
          "    Param ($secretArn)",
          "",
          "    if ($secretArn -eq $null) { return $null }",
          "",
          "    Log-Write \"Retrieving secret from AWS Secrets Manager.\"",
          "    try {",
          "        return [SecretHelper]::CreatePSCredential((Get-SECSecretValue -SecretId $secretArn))",
          "    }",
          "    catch [System.ArgumentException] {",
          "        throw $ERR_MSG_SECRET_INVALID_SCHEMA",
          "    }",
          "}",
          "",
          "Function Initialize-SqlDataAdapter {",
          "    Param (",
          "        [string] $sqlServerInstance,",
          "        [string] $portId,",
          "        [string] $startSqlServerInstance,",
          "        [string] $startDatabaseName,",
          "        [string] $startReplicaId",
          "    )",
          "    ",
          "    $portString = if ($portId -eq 0 -or $portId -eq '') { '' } else { ',' + $portId }",
          "    $serverName = 'localhost\\\\' +  $sqlServerInstance + $portString",
          "    $connectionString = \"Server = $serverName; Database = $SQL_DB_NAME; Integrated Security = True; Connection Timeout = 60;\"",
          "",
          "    $sqlConnection = New-Object System.Data.SqlClient.SqlConnection",
          "    $sqlConnection.ConnectionString = $connectionString",
          "    $connectionString = $null",
          "",
          "    $sqlCommand = New-Object System.Data.SqlClient.SqlCommand",
          "    $sqlCommand.CommandText = $AG_SQL_QUERY",
          "    $sqlCommand.Connection = $sqlConnection",
          "    $sqlCommand.CommandTimeout = 300;",
          "",
          "    # Declare parameters for continuation from starting SQL Server instance",
          "    $sqlCommand.Parameters.Add($START_DATABASE_NAME, [System.Data.SqlDbType]::NVarChar, 128) | Out-Null",
          "    $sqlCommand.Parameters.Add($START_REPLICA_ID, [System.Data.SqlDbType]::UniqueIdentifier) | Out-Null",
          "",
          "    # Set database name parameter",
          "    if ($sqlServerInstance -eq $startSqlServerInstance -and $startDatabaseName -ne '') {",
          "        $sqlCommand.Parameters[$START_DATABASE_NAME].Value = $startDatabaseName",
          "    } else {",
          "        $sqlCommand.Parameters[$START_DATABASE_NAME].Value = [DBNull]::Value",
          "    }",
          "",
          "    # Set replica ID parameter",
          "    if ($sqlServerInstance -eq $startSqlServerInstance -and $startReplicaId -ne '') {",
          "        $sqlCommand.Parameters[$START_REPLICA_ID].Value = [System.Guid]::Parse($startReplicaId)",
          "    } else {",
          "        $sqlCommand.Parameters[$START_REPLICA_ID].Value = [DBNull]::Value",
          "    }",
          "",
          "    $sqlDataAdapter = New-Object System.Data.SqlClient.SqlDataAdapter",
          "    $sqlDataAdapter.SelectCommand = $sqlCommand",
          "    return $sqlDataAdapter",
          "}",
          "",
          "Function Invoke-CommandAsCustomUser {",
          "    Param (",
          "        [System.Management.Automation.PSCredential]$credential,",
          "        [scriptblock]$scriptBlock",
          "    )",
          "",
          "    $token = [IntPtr]::Zero",
          "    try {",
          "        $token = [Win32]::LogonUserWithCredential($credential, $LOGON32_LOGON_INTERACTIVE, $LOGON32_PROVIDER_DEFAULT)",
          "        $identity = New-Object System.Security.Principal.WindowsIdentity($token)",
          "        $context = $identity.Impersonate()",
          "",
          "        try {",
          "            # Run script block",
          "            $result = & $ScriptBlock",
          "        }",
          "        finally {",
          "            if ($context) {",
          "                $context.Undo()",
          "            }",
          "        }",
          "    }",
          "    finally {",
          "        if ($token -ne [IntPtr]::Zero) {",
          "            [Win32]::CloseHandle($token) | Out-Null",
          "        }",
          "    }",
          "",
          "    return $result",
          "}",
          "",
          "Function Send-SqlQuery {",
          "    Param (",
          "        $sqlDataAdapter,",
          "        $credential",
          "    )",
          "",
          "    try {",
          "        $dataSet = New-Object System.Data.DataSet",
          "",
          "        if ($credential) {",
          "            Log-Write \"Executing SQL query with custom Windows credentials.\"",
          "            $dataSet = Invoke-CommandAsCustomUser -credential $credential -scriptBlock {",
          "                $sqlDataAdapter.Fill($dataSet) | Out-Null",
          "                return $dataSet",
          "            }",
          "            return $dataSet",
          "        }",
          "",
          "        Log-Write \"Executing SQL query with default local user credentials.\"",
          "        $sqlDataAdapter.Fill($dataSet) | Out-Null",
          "        return $dataSet",
          "    } catch [System.Security.Authentication.InvalidCredentialException] {",
          "        throw $ERR_MSG_SECRET_INVALID_WINDOWS_CREDENTIALS",
          "    } catch [System.ComponentModel.Win32Exception] {",
          "        throw $ERR_MSG_WINDOWS_LOGON_FAILED + $_.Exception.Message",
          "    } catch [System.Data.SqlClient.SqlException] {",
          "        switch ($_.Exception.Number) {",
          "            $SQL_SERVER_LOGON_FAILED { throw $ERR_MSG_SECRET_INVALID_SQL_SERVER_CREDENTIALS }",
          "            default { throw $ERR_MSG_SQL_QUERY_EXECUTION + $_.Exception.Message }",
          "        }",
          "    } catch {",
          "        throw $ERR_MSG_SQL_QUERY_EXECUTION + $_.Exception.Message",
          "    } finally {",
          "        $sqlDataAdapter.SelectCommand.Connection.Close()",
          "        Log-Write \"SQL Server database connection closed.\"",
          "    }",
          "}",
          "",
          "Function Read-SqlQueryResult {",
          "    Param (",
          "        [string] $sqlServerInstance,",
          "        $dataSet",
          "    )",
          "",
          "    $dbRecords = @()",
          "    foreach ($row in $dataSet.Tables[0].Rows) {",
          "        $dbRecord = Initialize-DBRecord -sqlServerInstance $sqlServerInstance",
          "        foreach ($property in $AG_SQL_QUERY_RECORD_SCHEMA) {",
          "            $dbRecord[$property] = [String] $row[$property]",
          "        }",
          "        $dbRecords += $dbRecord",
          "    }",
          "    return $dbRecords",
          "}",
          "",
          "Function Initialize-DBRecord {",
          "    Param (",
          "        $sqlServerInstance,",
          "        $replicaId,",
          "        $groupId,",
          "        $databaseName,",
          "        $secondaryRoleAllowConnections,",
          "        $roleDesc,",
          "        $isLocal,",
          "        $haType",
          "    )",
          "",
          "    return @{",
          "        $SQL_SERVER_INSTANCE = $sqlServerInstance;",
          "        $REPLICA_ID = $replicaId;",
          "        $GROUP_ID = $groupId;",
          "        $DATABASE_NAME = $databaseName;",
          "        $SECONDARY_ROLE_ALLOW_CONNECTIONS = $secondaryRoleAllowConnections;",
          "        $ROLE_DESC = $roleDesc;",
          "        $IS_LOCAL = $isLocal;",
          "        $HA_TYPE = $haType;",
          "    }",
          "}",
          "",
          "# Remove data from DB records not needed in command output",
          "Function Compress-DBRecord {",
          "    Param ([hashtable] $dbRecord)",
          "",
          "    # SQL Server instance name and database name are not needed in command output, but are used to build next token",
          "    $compressedDBRecord = $dbRecord.Clone()",
          "    $compressedDBRecord.Remove($SQL_SERVER_INSTANCE)",
          "    $compressedDBRecord.Remove($DATABASE_NAME)",
          "    return $compressedDBRecord",
          "}",
          "",
          "# Compress string with gzip",
          "Function Compress-WithGzip {",
          "    Param ([string] $string)",
          "",
          "    $bytes = [System.Text.Encoding]::UTF8.GetBytes($string)",
          "    $memoryStream = New-Object System.IO.MemoryStream",
          "    $gzipStream = New-Object System.IO.Compression.GZipStream($memoryStream, [System.IO.Compression.CompressionMode]::Compress)",
          "    $gzipStream.Write($bytes, 0, $bytes.Length)",
          "    $gzipStream.Close()",
          "",
          "    $compressedBytes = $memoryStream.ToArray()",
          "    $compressedString = [Convert]::ToBase64String($compressedBytes)",
          "    $memoryStream.Close()",
          "",
          "    return $compressedString",
          "}",
          "",
          "Function Build-NextToken {",
          "    Param(",
          "        [array] $dbRecords,",
          "        [int] $pos",
          "    )",
          "",
          "    # There are no more results to return",
          "    if ($pos -ge $dbRecords.Count - 1) { return '' }",
          "",
          "    $sqlServerInstance = $dbRecords[$pos + 1][$SQL_SERVER_INSTANCE]",
          "    $databaseName = $dbRecords[$pos + 1][$DATABASE_NAME]",
          "    $replicaId = $dbRecords[$pos + 1][$REPLICA_ID]",
          "",
          "    $token = @($sqlServerInstance, $databaseName, $replicaId) | ConvertTo-Json -Compress",
          "",
          "    return [Convert]::ToBase64String([System.Text.Encoding]::UTF8.GetBytes($token))",
          "}",
          "",
          "Function Split-NextToken {",
          "    Param([string] $nextToken)",
          "",
          "    if ([string]::IsNullOrWhiteSpace($nextToken)) { return @('', '', '') }",
          "",
          "    $token = [System.Text.Encoding]::UTF8.GetString([Convert]::FromBase64String($nextToken))",
          "    $components = $token | ConvertFrom-Json",
          "",
          "    # Contains SQL Server instance, database name and replica ID (possibly empty) in this order",
          "    if ($components.Count -ne 3 -or $components[0] -notmatch $SQL_SERVER_INSTANCE_PATTERN -or $components[1] -notmatch $DATABASE_NAME_PATTERN -or ($components[2].Length -gt 0 -and $components[2] -notmatch $REPLICA_ID_PATTERN)) {",
          "        throw $ERR_MSG_INVALID_NEXT_TOKEN",
          "    }",
          "",
          "    return $components",
          "}",
          "",
          "# Format DB records in SSM command output",
          "Function Format-CommandOutput {",
          "    Param (",
          "        [string] $instanceId,",
          "        [array] $dbRecords,",
          "        [bool] $compress,",
          "        [int] $limit",
          "    )",
          "",
          "    $compressedDBRecords = @()",
          "    foreach ($dbRecord in $dbRecords) {",
          "        $compressedDBRecords += Compress-DBRecord $dbRecord",
          "    }",
          "",
          "    # Use binary search to find the largest subset of results that fit within the command output limit",
          "",
          "    $lowerBound = 0",
          "    $upperBound = $dbRecords.Count - 1",
          "    $pos = $upperBound",
          "",
          "    # Guarantee at least one step for any amount of DB records (including zero)",
          "    $maxSteps = [Math]::Ceiling([Math]::Log($dbRecords.Count + 2, 2))",
          "",
          "    $commandOutput = \"\"",
          "    for ($i = 1; $i -le $maxSteps; $i++) {",
          "        # Construct SSM command output",
          "        $tempBody = @{",
          "            $INSTANCE_ID = $instanceId;",
          "            $SQL_DATABASES = if ($dbRecords.Count -eq 0) { ,@() } else { ,@($compressedDBRecords[0..$pos]) };",
          "        }",
          "        if ($compress) {",
          "            $tempBody = Compress-WithGzip (ConvertTo-Json -InputObject $tempBody -Compress -Depth 4)",
          "        }",
          "",
          "        $output = @{",
          "            $VERSION = $DOC_VERSION;",
          "            $BODY = $tempBody;",
          "            $NEXT_TOKEN = Build-NextToken -dbRecords $dbRecords -pos $pos;",
          "        }",
          "        $tempOutput = ConvertTo-Json -InputObject $output -Compress -Depth 4",
          "",
          "        # If there is no command output limit or all results fit within the limit, return the output",
          "        if ($limit -eq $null -or ($tempOutput.Length -le $limit -and $pos -eq ($dbRecords.Count - 1))) {",
          "            $commandOutput = $tempOutput",
          "            break",
          "        }",
          "",
          "        # Adjust size of results with binary search",
          "        if ($tempOutput.Length -gt $limit) {",
          "            $upperBound = $pos",
          "        } else {",
          "            # The current largest subset of results that fit within the command output limit",
          "            $lowerBound = $pos",
          "            $commandOutput = $tempOutput",
          "        }",
          "",
          "        $pos = [Math]::Ceiling(($lowerBound + $upperBound) / 2)",
          "    }",
          "",
          "    if ([string]::IsNullOrWhiteSpace($commandOutput)) {",
          "        throw $ERR_MSG_COMMAND_OUTPUT_LIMIT",
          "    }",
          "",
          "    return $commandOutput",
          "}",
          "",
          "# Main function and entry point for SSM command",
          "Function Main {",
          "",
          "    try {",
          "        Initialize-LogFile",
          "",
          "        Assert-WindowsVersion",
          "        Assert-PowerShellVersion",
          "",
          "        $sqlServerInstances = Get-SqlServerInstances",
          "",
          "        # Start at SQL Server instance provided in next token",
          "        $startSqlServerInstance, $startDatabaseName, $startReplicaId = Split-NextToken \"{{nextToken}}\"",
          "        $sqlServerInstances = $sqlServerInstances | Where-Object { $_ -ge $startSqlServerInstance }",
          "",
          "        $sqlServerInstanceMetadata = Get-SqlServerMetadataFromRegistry $sqlServerInstances",
          "        $sqlServerInstanceStatuses = Get-SqlServerInstanceStatuses $sqlServerInstances",
          "",
          "        # Get secret ARN if it is provided for this instance",
          "        $secretArn = if ([string]::IsNullOrWhiteSpace(\"{{secretArn}}\")) { $null } else { \"{{secretArn}}\" }",
          "        $secret = Get-AWSSecret $secretArn",
          "",
          "        $dbRecords = @()",
          "        foreach ($sqlServerInstance in $sqlServerInstances) {",
          "            $portId, $clusterName = $sqlServerInstanceMetadata[$sqlServerInstance]",
          "",
          "            # Determine logic for metadata retrieval on if cluster name for SQL Server instance is present in Windows Registry",
          "            # If the cluster name is present, fetch metadata for an FCI",
          "            # Else, fetch metadata for AG(s)",
          "            if ($clusterName) {",
          "",
          "                # SQL Server instance is installed as an FCI",
          "",
          "                $groupId = Get-FciGroupId $clusterName",
          "                $roleDesc = if ($sqlServerInstanceStatuses[$sqlServerInstance] -eq $RUNNING) { $PRIMARY } else { $SECONDARY }",
          "",
          "                $dbRecords += Initialize-DBRecord -sqlServerInstance $sqlServerInstance -groupId $groupId -roleDesc $roleDesc -haType $FCI",
          "",
          "            } elseif ($sqlServerInstanceStatuses[$sqlServerInstance] -eq $RUNNING) {",
          "",
          "                # SQL Server instance may host database(s) participating in AG(s)",
          "",
          "                $sqlDataAdapter = Initialize-SqlDataAdapter $sqlServerInstance $portId $startSqlServerInstance $startDatabaseName $startReplicaId",
          "                $dataSet = Send-SqlQuery $sqlDataAdapter $secret",
          "                Log-Write \"Fetched SQL query result.\"",
          "",
          "                $dbRecords += Read-SqlQueryResult $sqlServerInstance $dataSet",
          "",
          "            }",
          "        }",
          "",
          "        $compress = \"{{compress}}\" -eq \"true\"",
          "        $limit = if ([string]::IsNullOrWhiteSpace(\"{{limit}}\")) { $null } else { [int]\"{{limit}}\" }",
          "        $instanceId = $env:AWS_SSM_INSTANCE_ID",
          "",
          "        Write-Host (Format-CommandOutput -instanceId $instanceId -dbRecords $dbRecords -compress $compress -limit $limit)",
          "        Log-Write \"Successfully returned instance metadata.\"",
          "    }",
          "    catch {",
          "        $errorMessage = $($_.Exception.Message)",
          "        Log-Write \"[ERROR] $errorMessage\"",
          "        Write-Host \"$errorMessage\"",
          "        throw",
          "    }",
          "",
          "}",
          "",
          "Main"
        ],
        "workingDirectory": "",
        "timeoutSeconds": "{{executionTimeout}}"
      }
    }
  ]
}
