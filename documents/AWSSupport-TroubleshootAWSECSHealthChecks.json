{
  "description": "The **TroubleshootAWSECSHealthChecks** automation runbook helps diagnose and troubleshoot issues where Amazon Elastic Container Service (Amazon ECS) tasks running on Amazon Elastic Compute Cloud (Amazon EC2) instances or AWS Fargate fail Application Load Balancer (ALB) health checks.\n\nThis runbook performs a systematic analysis by:\n\n1. Verifying network connectivity between ALBs and Amazon ECS tasks\n2. Checking if tasks are exiting unexpectedly\n3. Analyzing target group health status and response codes\n4. Examining ALB configuration and health check settings\n5. Validating service configuration including health check grace periods\n6. Performing custom diagnostics for response code mismatches\n\nFor advanced diagnostics, the runbook deploys temporary Lambda functions within your VPC to simulate health check requests from the same network perspective as your ALB. This allows the runbook to identify network connectivity issues. A Lambda execution role is required for these functions and can either be specified as a parameter or created temporarily by this runbook.",
  "schemaVersion": "0.3",
  "assumeRole": "{{ AutomationAssumeRole }}",
  "parameters": {
    "AutomationAssumeRole": {
      "type": "AWS::IAM::Role::Arn",
      "description": "(Optional) The Amazon Resource Name (ARN) of the AWS Identity and Access Management (IAM) role that allows Systems Manager Automation to perform the actions on your behalf. If no role is specified, Systems Manager Automation uses the permissions of the user that starts this runbook.",
      "default": ""
    },
    "ECSClusterName": {
      "type": "String",
      "description": "(Required) The name of the Amazon ECS cluster.",
      "allowedPattern": "^[a-zA-Z0-9_-]{1,255}$"
    },
    "ECSServiceName": {
      "type": "String",
      "description": "(Required) The name of the Amazon ECS service.",
      "allowedPattern": "^[a-zA-Z0-9_-]{1,255}$"
    },
    "LambdaExecutionRole": {
      "type": "AWS::IAM::Role::Arn",
      "description": "(Optional) The Amazon Resource Name (ARN) of the Lambda execution role that is used for the step of Lambda custom check. If no role is specified, This runbook will skip the step.",
      "default": ""
    }
  },
  "variables": {
    "LambdaExecutionRole": {
      "type": "String",
      "default": "{{ LambdaExecutionRole }}"
    }
  },
  "mainSteps": [
    {
      "name": "CheckPermissions",
      "action": "aws:executeScript",
      "description": "Verifies if the IAM user/role who started the automation has the required IAM permissions. Additionally, it verifies the user/role and Lambda execution role has the required IAM permissions for the Lambda custom check",
      "timeoutSeconds": 600,
      "inputs": {
        "InputPayload": {
          "LambdaExecutionRole": "{{ LambdaExecutionRole }}"
        },
        "Handler": "iam_permission_handler.iam_permission_handler",
        "Runtime": "python3.11",
        "Attachment": "attachments.zip"
      },
      "onFailure": "step:ExecutionResult",
      "isCritical": true,
      "outputs": [
        {
          "Name": "SSMUserPermission",
          "Selector": "$.Payload.ssm_user_perms",
          "Type": "Boolean"
        },
        {
          "Name": "message",
          "Selector": "$.Payload.message",
          "Type": "String"
        },
        {
          "Name": "createLambdaPermission",
          "Selector": "$.Payload.lambda_perms",
          "Type": "Boolean"
        }
      ],
      "nextStep": "BranchOnPermissions"
    },
    {
      "name": "BranchOnPermissions",
      "action": "aws:branch",
      "description": "Branches if the IAM user/role has the required non mutating permissions",
      "isEnd": true,
      "timeoutSeconds": 300,
      "onFailure": "step:ExecutionResult",
      "isCritical": true,
      "maxAttempts": 1,
      "inputs": {
        "Choices": [
          {
            "NextStep": "CheckTargetClusterExistence",
            "Variable": "{{ CheckPermissions.SSMUserPermission }}",
            "BooleanEquals": true
          },
          {
            "NextStep": "ExecutionResult",
            "Variable": "{{ CheckPermissions.SSMUserPermission }}",
            "BooleanEquals": false
          }
        ]
      }
    },
    {
      "name": "CheckTargetClusterExistence",
      "action": "aws:assertAwsResourceProperty",
      "description": "Check if the provided Amazon ECS cluster exists in the account.",
      "onFailure": "step:ExecutionResult",
      "isCritical": true,
      "inputs": {
        "Service": "ecs",
        "Api": "DescribeClusters",
        "clusters": [
          "{{ ECSClusterName }}"
        ],
        "PropertySelector": "$.clusters[0].status",
        "DesiredValues": [
          "ACTIVE"
        ]
      },
      "nextStep": "CheckEcsServiceExistence"
    },
    {
      "name": "CheckEcsServiceExistence",
      "action": "aws:assertAwsResourceProperty",
      "description": "Check if the provided Amazon ECS service exists in the account.",
      "onFailure": "step:ExecutionResult",
      "isCritical": true,
      "maxAttempts": 1,
      "inputs": {
        "Service": "ecs",
        "Api": "DescribeServices",
        "cluster": "{{ ECSClusterName }}",
        "services": [
          "{{ ECSServiceName }}"
        ],
        "PropertySelector": "$.services[0].status",
        "DesiredValues": [
          "ACTIVE"
        ]
      },
      "nextStep": "CheckNetworkConnectivity"
    },
    {
      "name": "CheckNetworkConnectivity",
      "action": "aws:executeScript",
      "description": "Check network connectivity between Application Load Balancer (ALB) and Amazon ECS tasks.",
      "timeoutSeconds": 600,
      "inputs": {
        "InputPayload": {
          "ECSClusterName": "{{ ECSClusterName }}",
          "ECSServiceName": "{{ ECSServiceName }}"
        },
        "Handler": "network_connectivity_handler.network_connectivity_handler",
        "Runtime": "python3.11",
        "Attachment": "attachments.zip"
      },
      "onFailure": "step:ExecutionResult",
      "isCritical": true,
      "outputs": [
        {
          "Name": "result",
          "Selector": "$.Payload.result",
          "Type": "Boolean"
        },
        {
          "Name": "message",
          "Selector": "$.Payload.message",
          "Type": "String"
        },
        {
          "Name": "ALBNetworkSetting",
          "Selector": "$.Payload.alb_network_setting",
          "Type": "MapList"
        },
        {
          "Name": "TargetGroupArns",
          "Selector": "$.Payload..target_group_arn",
          "Type": "StringList"
        },
        {
          "Name": "ALBArn1",
          "Selector": "$.Payload.alb_network_setting[0].alb_arn",
          "Type": "String"
        },
        {
          "Name": "ALBArn2",
          "Selector": "$.Payload.alb_network_setting[1].alb_arn",
          "Type": "String"
        },
        {
          "Name": "SubnetIdsALB1",
          "Selector": "$.Payload.alb_network_setting[0].subnets",
          "Type": "StringList"
        },
        {
          "Name": "SubnetIdsALB2",
          "Selector": "$.Payload.alb_network_setting[1].subnets",
          "Type": "StringList"
        },
        {
          "Name": "SecurityGroupIdsALB1",
          "Selector": "$.Payload.alb_network_setting[0].security_groups_string",
          "Type": "String"
        },
        {
          "Name": "SecurityGroupIdsALB2",
          "Selector": "$.Payload.alb_network_setting[1].security_groups_string",
          "Type": "String"
        }
      ],
      "nextStep": "CheckTasksAreExiting"
    },
    {
      "name": "CheckTasksAreExiting",
      "action": "aws:executeScript",
      "description": "Checks if ECS tasks are exiting.",
      "timeoutSeconds": 600,
      "inputs": {
        "InputPayload": {
          "ECSClusterName": "{{ ECSClusterName }}",
          "ECSServiceName": "{{ ECSServiceName }}"
        },
        "Handler": "task_exiting_handler.task_exiting_handler",
        "Runtime": "python3.11",
        "Attachment": "attachments.zip"
      },
      "onFailure": "step:ExecutionResult",
      "isCritical": true,
      "outputs": [
        {
          "Name": "result",
          "Selector": "$.Payload.result",
          "Type": "Boolean"
        },
        {
          "Name": "message",
          "Selector": "$.Payload.message",
          "Type": "String"
        }
      ],
      "nextStep": "BranchOnTasksAreExiting"
    },
    {
      "name": "BranchOnTasksAreExiting",
      "action": "aws:branch",
      "description": "Branches if ECS tasks are exiting",
      "isEnd": true,
      "timeoutSeconds": 300,
      "onFailure": "step:ExecutionResult",
      "isCritical": true,
      "maxAttempts": 1,
      "inputs": {
        "Choices": [
          {
            "And": [
              {
                "Variable": "{{ CheckTasksAreExiting.result }}",
                "BooleanEquals": true
              },
              {
                "Variable": "{{ CheckNetworkConnectivity.result }}",
                "BooleanEquals": true
              }
            ],
            "NextStep": "CheckTargetHealth"
          }
        ],
        "Default": "ExecuteAdditionalCheck"
      }
    },
    {
      "name": "CheckTargetHealth",
      "action": "aws:executeScript",
      "description": "Checks if Amazon ECS tasks are healthy.",
      "timeoutSeconds": 600,
      "inputs": {
        "InputPayload": {
          "TargetGroupArns": "{{ CheckNetworkConnectivity.TargetGroupArns }}"
        },
        "Handler": "target_health_handler.target_health_handler",
        "Runtime": "python3.11",
        "Attachment": "attachments.zip"
      },
      "onFailure": "step:ExecutionResult",
      "isCritical": true,
      "outputs": [
        {
          "Name": "result",
          "Selector": "$.Payload.result",
          "Type": "Boolean"
        },
        {
          "Name": "message",
          "Selector": "$.Payload.message",
          "Type": "String"
        },
        {
          "Name": "unhealthyTargetGroups",
          "Selector": "$.Payload.unhealthy_targets",
          "Type": "MapList"
        },
        {
          "Name": "unhealthyReasonALB1",
          "Selector": "$.Payload.unhealthy_targets[0].targets[0].reason",
          "Type": "String"
        },
        {
          "Name": "unhealthyReasonALB2",
          "Selector": "$.Payload.unhealthy_targets[1].targets[0].reason",
          "Type": "String"
        }
      ],
      "nextStep": "BranchOnTargetHealthReasonCode"
    },
    {
      "name": "BranchOnTargetHealthReasonCode",
      "action": "aws:branch",
      "description": "Branches if CheckTargetHealth.reasonCode is ResponseCodeMismatch",
      "isEnd": true,
      "timeoutSeconds": 300,
      "onFailure": "step:ExecutionResult",
      "isCritical": true,
      "maxAttempts": 1,
      "inputs": {
        "Choices": [
          {
            "And": [
              {
                "Or": [
                  {
                    "Variable": "{{ CheckTargetHealth.unhealthyReasonALB1 }}",
                    "StringEquals": "Target.ResponseCodeMismatch"
                  },
                  {
                    "Variable": "{{ CheckTargetHealth.unhealthyReasonALB2 }}",
                    "StringEquals": "Target.ResponseCodeMismatch"
                  }
                ]
              },
              {
                "Variable": "{{ CheckPermissions.createLambdaPermission }}",
                "BooleanEquals": true
              }
            ],
            "NextStep": "BranchOnLambdaExecutionRole"
          }
        ],
        "Default": "ExecuteAdditionalCheck"
      }
    },
    {
      "name": "BranchOnLambdaExecutionRole",
      "action": "aws:branch",
      "description": "Branches if Lambda execution role is provided",
      "isEnd": true,
      "timeoutSeconds": 300,
      "onFailure": "step:ExecutionResult",
      "isCritical": true,
      "maxAttempts": 1,
      "inputs": {
        "Choices": [
          {
            "Variable": "{{ variable:LambdaExecutionRole }}",
            "StringEquals": "",
            "NextStep": "CreateLambdaExecutionRole"
          }
        ],
        "Default": "BranchOnTargetHealthReasonCodeALB1"
      }
    },
    {
      "name": "CreateLambdaExecutionRole",
      "action": "aws:createStack",
      "description": "Creates a Lambda execution role.",
      "timeoutSeconds": 600,
      "maxAttempts": 1,
      "onFailure": "step:ExecutionResult",
      "inputs": {
        "StackName": "AWSSupport-TroubleshootAWSECSHealthChecks-{{ automation:EXECUTION_ID }}-lambda-role",
        "OnFailure": "DELETE",
        "TimeoutInMinutes": 30,
        "Capabilities": [
          "CAPABILITY_IAM",
          "CAPABILITY_NAMED_IAM"
        ],
        "TemplateBody": "AWSTemplateFormatVersion: '2010-09-09'\nParameters:\n  ExecutionId:\n    Type: String\n    Description: 'Execution ID of the step function'\n\nResources:\n  LambdaRole:\n    Type: 'AWS::IAM::Role'\n    Properties:\n      RoleName: !Sub 'AWSECSHealthChecks-${ExecutionId}'\n      AssumeRolePolicyDocument:\n        Version: '2012-10-17'\n        Statement:\n          - Effect: Allow\n            Principal:\n              Service: lambda.amazonaws.com\n            Action: sts:AssumeRole\n      ManagedPolicyArns:\n        - !Sub 'arn:${AWS::Partition}:iam::aws:policy/service-role/AWSLambdaVPCAccessExecutionRole'\n",
        "ClientRequestToken": "AWSSupport-TroubleshootAWSECSHealthChecks-{{ automation:EXECUTION_ID }}-lambda-role",
        "Parameters": [
          {
            "ParameterKey": "ExecutionId",
            "ParameterValue": "{{ automation:EXECUTION_ID }}"
          }
        ],
        "Tags": [
          {
            "Key": "Name",
            "Value": "AWSSupport-TroubleshootAWSECSHealthChecks-{{ automation:EXECUTION_ID }}-lambda-role"
          },
          {
            "Key": "AWSSupport-TroubleshootAWSECSHealthChecks-AutomationExecution",
            "Value": "{{ automation:EXECUTION_ID }}"
          }
        ]
      },
      "nextStep": "UpdateLambdaExecutionRole"
    },
    {
      "name": "UpdateLambdaExecutionRole",
      "action": "aws:updateVariable",
      "description": "Updates the variable `LambdaExecutionRole`.",
      "maxAttempts": 3,
      "timeoutSeconds": 180,
      "isCritical": true,
      "onCancel": "Abort",
      "onFailure": "step:DeleteLambdaExecutionRole",
      "inputs": {
        "Name": "variable:LambdaExecutionRole",
        "Value": "arn:{{ global:AWS_PARTITION }}:iam::{{ global:ACCOUNT_ID }}:role/AWSECSHealthChecks-{{ automation:EXECUTION_ID }}"
      },
      "nextStep": "BranchOnTargetHealthReasonCodeALB1"
    },
    {
      "name": "BranchOnTargetHealthReasonCodeALB1",
      "action": "aws:branch",
      "description": "Branches if checkTargetHealth.reasonCode is ResponseCodeMismatch",
      "isEnd": true,
      "timeoutSeconds": 300,
      "onFailure": "step:DeleteLambdaExecutionRole",
      "isCritical": true,
      "maxAttempts": 1,
      "inputs": {
        "Choices": [
          {
            "Variable": "{{ CheckTargetHealth.unhealthyReasonALB1 }}",
            "StringEquals": "Target.ResponseCodeMismatch",
            "NextStep": "LoopCreateLambdaFunctionALB1"
          }
        ],
        "Default": "BranchOnTargetHealthReasonCodeALB2"
      }
    },
    {
      "name": "LoopCreateLambdaFunctionALB1",
      "action": "aws:loop",
      "description": "Loops through each subnet to create a Lambda function per subnet where the ALB is located",
      "onFailure": "step:LoopDeleteLambdaFunctionALB1",
      "nextStep": "BranchOnTargetHealthReasonCodeALB2",
      "inputs": {
        "Iterators": "{{ CheckNetworkConnectivity.SubnetIdsALB1 }}",
        "IteratorDataType": "String",
        "Steps": [
          {
            "name": "CreateLambdaFunctionALB1",
            "action": "aws:createStack",
            "description": "Creates a Lambda function to check HTTP response (status and message) from each unhealthy ECS task.",
            "maxAttempts": 1,
            "timeoutSeconds": 600,
            "onFailure": "step:LoopDeleteLambdaFunctionALB1",
            "inputs": {
              "StackName": "AWSSupport-TroubleshootAWSECSHealthChecks-{{ automation:EXECUTION_ID }}-ALB1-{{ LoopCreateLambdaFunctionALB1.CurrentIteratorValue }}",
              "OnFailure": "DELETE",
              "TimeoutInMinutes": 30,
              "Capabilities": [],
              "TemplateBody": "AWSTemplateFormatVersion: '2010-09-09'\nParameters:\n  ALBArn:\n    Type: String\n    Description: ARN of the Application Load Balancer\n\n  SubnetId:\n    Type: AWS::EC2::Subnet::Id\n    Description: Subnet ID where Lambda functions will be created\n  SecurityGroupIds:\n    Type: List<AWS::EC2::SecurityGroup::Id>\n    Description: List of Security Group IDs for Lambda function\n\n  LambdaExecutionRole:\n    Type: String\n    Description: ARN of the Lambda execution role\n\nResources:\n  LambdaFunction:\n    Type: AWS::Lambda::Function\n    Properties:\n      FunctionName: !Sub\n      - lambda-${SubnetId}-${ALBIdentifier}\n      - ALBIdentifier: !Select [3, !Split [/, !Ref ALBArn]]\n      Handler: index.lambda_handler\n      Role: !Ref LambdaExecutionRole\n      Code:\n        ZipFile: |+\n          import urllib.error as request_error\n\n          import urllib.request as request\n\n          from socket import timeout\n\n          from urllib.parse import urlparse\n\n\n\n\n\n          def is_valid_url(url: str) -> bool:\n\n              try:\n\n                  result = urlparse(url)\n\n\n\n                  # Ensure only http/https schemes are allowed\n\n                  # Prevent security issues with other schemes (e.g., file://)\n\n                  # https://bandit.readthedocs.io/en/latest/blacklists/blacklist_calls.html#b310-urllib-urlopen\n\n                  if result.scheme not in (\"http\", \"https\"):\n\n                      return False\n\n\n\n                  return result.netloc != \"\"\n\n              except ValueError:\n\n                  return False\n\n\n\n\n\n          def lambda_handler(event, context):\n\n              if \"url\" not in event:\n\n                  raise ValueError(\"URL parameter is missing.\")\n\n\n\n              url = event[\"url\"]\n\n              if not is_valid_url(url):\n\n                  raise ValueError(f\"Invalid URL format: {url}\")\n\n\n\n              status: int = 0\n\n              reason: str = \"\"\n\n\n\n              req = request.Request(url)\n\n              try:\n\n                  with request.urlopen(req, timeout=10) as res:  # nosec B310\n\n                      status = res.getcode()\n\n              except request_error.HTTPError as err:\n\n                  # When the response is 4XX or 5XX error.\n\n                  status = err.code\n\n                  reason = err.reason\n\n              except request_error.URLError as err:\n\n                  if isinstance(err.reason, timeout):\n\n                      reason = f\"Connection to {url} timed out.\"\n\n                  else:\n\n                      raise err\n\n\n\n              return {\"response_code\": status, \"reason\": reason}\n\n      Runtime: python3.11\n      Timeout: 30\n      MemorySize: 128\n      VpcConfig:\n        SecurityGroupIds: !Ref SecurityGroupIds\n        SubnetIds:\n        - !Ref SubnetId\n",
              "ClientRequestToken": "AWSSupport-TroubleshootAWSECSHealthChecks-{{ automation:EXECUTION_ID }}-ALB1-{{ LoopCreateLambdaFunctionALB1.CurrentIteratorValue }}",
              "Parameters": [
                {
                  "ParameterKey": "ALBArn",
                  "ParameterValue": "{{ CheckNetworkConnectivity.ALBArn1 }}"
                },
                {
                  "ParameterKey": "SubnetId",
                  "ParameterValue": "{{ LoopCreateLambdaFunctionALB1.CurrentIteratorValue }}"
                },
                {
                  "ParameterKey": "SecurityGroupIds",
                  "ParameterValue": "{{ CheckNetworkConnectivity.SecurityGroupIdsALB1 }}"
                },
                {
                  "ParameterKey": "LambdaExecutionRole",
                  "ParameterValue": "{{ variable:LambdaExecutionRole }}"
                }
              ],
              "Tags": [
                {
                  "Key": "Name",
                  "Value": "AWSSupport-TroubleshootAWSECSHealthChecks-{{ automation:EXECUTION_ID }}-ALB1-{{ LoopCreateLambdaFunctionALB1.CurrentIteratorValue }}"
                },
                {
                  "Key": "AWSSupport-TroubleshootAWSECSHealthChecks-AutomationExecution",
                  "Value": "{{ automation:EXECUTION_ID }}"
                }
              ]
            }
          }
        ]
      }
    },
    {
      "name": "BranchOnTargetHealthReasonCodeALB2",
      "action": "aws:branch",
      "description": "Branches if checkTargetHealth.reasonCode is ResponseCodeMismatch",
      "isEnd": true,
      "timeoutSeconds": 300,
      "onFailure": "step:LoopDeleteLambdaFunctionALB1",
      "isCritical": true,
      "maxAttempts": 1,
      "inputs": {
        "Choices": [
          {
            "Variable": "{{ CheckTargetHealth.unhealthyReasonALB2 }}",
            "StringEquals": "Target.ResponseCodeMismatch",
            "NextStep": "LoopCreateLambdaFunctionALB2"
          }
        ],
        "Default": "ExecuteCustomCheck"
      }
    },
    {
      "name": "LoopCreateLambdaFunctionALB2",
      "action": "aws:loop",
      "description": "Loops through each subnet to create a Lambda function per subnet where the ALB is located",
      "onFailure": "step:LoopDeleteLambdaFunctionALB1",
      "nextStep": "ExecuteCustomCheck",
      "inputs": {
        "Iterators": "{{ CheckNetworkConnectivity.SubnetIdsALB2 }}",
        "IteratorDataType": "String",
        "Steps": [
          {
            "name": "CreateLambdaFunctionALB2",
            "action": "aws:createStack",
            "description": "Creates a Lambda function to check HTTP response (status and message) from each unhealthy ECS task.",
            "maxAttempts": 1,
            "timeoutSeconds": 600,
            "onFailure": "step:LoopDeleteLambdaFunctionALB1",
            "inputs": {
              "StackName": "AWSSupport-TroubleshootAWSECSHealthChecks-{{ automation:EXECUTION_ID }}-ALB2-{{ LoopCreateLambdaFunctionALB2.CurrentIteratorValue }}",
              "OnFailure": "DELETE",
              "TimeoutInMinutes": 30,
              "Capabilities": [],
              "TemplateBody": "AWSTemplateFormatVersion: '2010-09-09'\nParameters:\n  ALBArn:\n    Type: String\n    Description: ARN of the Application Load Balancer\n\n  SubnetId:\n    Type: AWS::EC2::Subnet::Id\n    Description: Subnet ID where Lambda functions will be created\n  SecurityGroupIds:\n    Type: List<AWS::EC2::SecurityGroup::Id>\n    Description: List of Security Group IDs for Lambda function\n\n  LambdaExecutionRole:\n    Type: String\n    Description: ARN of the Lambda execution role\n\nResources:\n  LambdaFunction:\n    Type: AWS::Lambda::Function\n    Properties:\n      FunctionName: !Sub\n      - lambda-${SubnetId}-${ALBIdentifier}\n      - ALBIdentifier: !Select [3, !Split [/, !Ref ALBArn]]\n      Handler: index.lambda_handler\n      Role: !Ref LambdaExecutionRole\n      Code:\n        ZipFile: |+\n          import urllib.error as request_error\n\n          import urllib.request as request\n\n          from socket import timeout\n\n          from urllib.parse import urlparse\n\n\n\n\n\n          def is_valid_url(url: str) -> bool:\n\n              try:\n\n                  result = urlparse(url)\n\n\n\n                  # Ensure only http/https schemes are allowed\n\n                  # Prevent security issues with other schemes (e.g., file://)\n\n                  # https://bandit.readthedocs.io/en/latest/blacklists/blacklist_calls.html#b310-urllib-urlopen\n\n                  if result.scheme not in (\"http\", \"https\"):\n\n                      return False\n\n\n\n                  return result.netloc != \"\"\n\n              except ValueError:\n\n                  return False\n\n\n\n\n\n          def lambda_handler(event, context):\n\n              if \"url\" not in event:\n\n                  raise ValueError(\"URL parameter is missing.\")\n\n\n\n              url = event[\"url\"]\n\n              if not is_valid_url(url):\n\n                  raise ValueError(f\"Invalid URL format: {url}\")\n\n\n\n              status: int = 0\n\n              reason: str = \"\"\n\n\n\n              req = request.Request(url)\n\n              try:\n\n                  with request.urlopen(req, timeout=10) as res:  # nosec B310\n\n                      status = res.getcode()\n\n              except request_error.HTTPError as err:\n\n                  # When the response is 4XX or 5XX error.\n\n                  status = err.code\n\n                  reason = err.reason\n\n              except request_error.URLError as err:\n\n                  if isinstance(err.reason, timeout):\n\n                      reason = f\"Connection to {url} timed out.\"\n\n                  else:\n\n                      raise err\n\n\n\n              return {\"response_code\": status, \"reason\": reason}\n\n      Runtime: python3.11\n      Timeout: 30\n      MemorySize: 128\n      VpcConfig:\n        SecurityGroupIds: !Ref SecurityGroupIds\n        SubnetIds:\n        - !Ref SubnetId\n",
              "ClientRequestToken": "AWSSupport-TroubleshootAWSECSHealthChecks-{{ automation:EXECUTION_ID }}-ALB2-{{ LoopCreateLambdaFunctionALB2.CurrentIteratorValue }}",
              "Parameters": [
                {
                  "ParameterKey": "ALBArn",
                  "ParameterValue": "{{ CheckNetworkConnectivity.ALBArn2 }}"
                },
                {
                  "ParameterKey": "SubnetId",
                  "ParameterValue": "{{ LoopCreateLambdaFunctionALB2.CurrentIteratorValue }}"
                },
                {
                  "ParameterKey": "SecurityGroupIds",
                  "ParameterValue": "{{ CheckNetworkConnectivity.SecurityGroupIdsALB2 }}"
                },
                {
                  "ParameterKey": "LambdaExecutionRole",
                  "ParameterValue": "{{ variable:LambdaExecutionRole }}"
                }
              ],
              "Tags": [
                {
                  "Key": "Name",
                  "Value": "AWSSupport-TroubleshootAWSECSHealthChecks-{{ automation:EXECUTION_ID }}-ALB2-{{ LoopCreateLambdaFunctionALB2.CurrentIteratorValue }}"
                },
                {
                  "Key": "AWSSupport-TroubleshootAWSECSHealthChecks-AutomationExecution",
                  "Value": "{{ automation:EXECUTION_ID }}"
                }
              ]
            }
          }
        ]
      }
    },
    {
      "name": "ExecuteCustomCheck",
      "action": "aws:executeScript",
      "description": "Execute Lambda custom check to troubleshoot Amazon ECS tasks failing the Application Load Balancer health checks.",
      "timeoutSeconds": 600,
      "onFailure": "step:LoopDeleteLambdaFunctionALB1",
      "isCritical": true,
      "inputs": {
        "InputPayload": {
          "ALBNetworkSettings": "{{ CheckNetworkConnectivity.ALBNetworkSetting }}",
          "UnhealthyTargets": "{{ CheckTargetHealth.unhealthyTargetGroups }}"
        },
        "Handler": "custom_check_handler.custom_check_handler",
        "Runtime": "python3.11",
        "Attachment": "attachments.zip"
      },
      "outputs": [
        {
          "Name": "diagnosticResults",
          "Selector": "$.Payload.diagnostic_results",
          "Type": "MapList"
        },
        {
          "Name": "result",
          "Selector": "$.Payload.result",
          "Type": "Boolean"
        },
        {
          "Name": "message",
          "Selector": "$.Payload.message",
          "Type": "String"
        }
      ],
      "nextStep": "LoopDeleteLambdaFunctionALB1"
    },
    {
      "name": "LoopDeleteLambdaFunctionALB1",
      "action": "aws:loop",
      "description": "Loops each subent to delete a Lambda function",
      "onFailure": "step:LoopDeleteLambdaFunctionALB2",
      "nextStep": "LoopDeleteLambdaFunctionALB2",
      "inputs": {
        "Iterators": "{{ CheckNetworkConnectivity.SubnetIdsALB1 }}",
        "IteratorDataType": "String",
        "Steps": [
          {
            "name": "DeleteLambdaFunctionALB1",
            "action": "aws:deleteStack",
            "description": "Deletes the Lambda function.",
            "maxAttempts": 1,
            "timeoutSeconds": 2700,
            "onFailure": "step:LoopDeleteLambdaFunctionALB2",
            "inputs": {
              "StackName": "AWSSupport-TroubleshootAWSECSHealthChecks-{{ automation:EXECUTION_ID }}-ALB1-{{ LoopDeleteLambdaFunctionALB1.CurrentIteratorValue }}"
            }
          }
        ]
      }
    },
    {
      "name": "LoopDeleteLambdaFunctionALB2",
      "action": "aws:loop",
      "description": "Loops each subent to delete a Lambda function",
      "onFailure": "step:DeleteLambdaExecutionRole",
      "nextStep": "DeleteLambdaExecutionRole",
      "inputs": {
        "Iterators": "{{ CheckNetworkConnectivity.SubnetIdsALB2 }}",
        "IteratorDataType": "String",
        "Steps": [
          {
            "name": "DeleteLambdaFunctionALB2",
            "action": "aws:deleteStack",
            "description": "Deletes the Lambda function.",
            "maxAttempts": 1,
            "timeoutSeconds": 2700,
            "onFailure": "step:DeleteLambdaExecutionRole",
            "inputs": {
              "StackName": "AWSSupport-TroubleshootAWSECSHealthChecks-{{ automation:EXECUTION_ID }}-ALB2-{{ LoopDeleteLambdaFunctionALB2.CurrentIteratorValue }}"
            }
          }
        ]
      }
    },
    {
      "name": "DeleteLambdaExecutionRole",
      "action": "aws:deleteStack",
      "description": "Deletes the Lambda execution role.",
      "maxAttempts": 1,
      "timeoutSeconds": 600,
      "onFailure": "step:ExecuteAdditionalCheck",
      "isCritical": true,
      "inputs": {
        "StackName": "AWSSupport-TroubleshootAWSECSHealthChecks-{{ automation:EXECUTION_ID }}-lambda-role"
      },
      "nextStep": "ExecuteAdditionalCheck"
    },
    {
      "name": "ExecuteAdditionalCheck",
      "action": "aws:executeScript",
      "description": "Execute additional check to troubleshoot Amazon ECS tasks failing the Application Load Balancer health checks.",
      "timeoutSeconds": 600,
      "onFailure": "step:ExecutionResult",
      "isCritical": true,
      "inputs": {
        "InputPayload": {
          "ECSClusterName": "{{ ECSClusterName }}",
          "ECSServiceName": "{{ ECSServiceName }}",
          "ALBNetworkSettings": "{{ CheckNetworkConnectivity.ALBNetworkSetting }}"
        },
        "Handler": "additional_check_handler.additional_check_handler",
        "Runtime": "python3.11",
        "Attachment": "attachments.zip"
      },
      "outputs": [
        {
          "Name": "result",
          "Selector": "$.Payload.result",
          "Type": "Boolean"
        },
        {
          "Name": "message",
          "Selector": "$.Payload.message",
          "Type": "String"
        }
      ],
      "nextStep": "ExecutionResult"
    },
    {
      "name": "ExecutionResult",
      "action": "aws:executeScript",
      "description": "Formats the output of the automation to return the results of the all steps to the console.",
      "timeoutSeconds": 600,
      "onFailure": "Abort",
      "isEnd": true,
      "inputs": {
        "InputPayload": {
          "IAMPermission": "{{ CheckPermissions.message }}",
          "NetworkConnectivity": "{{ CheckNetworkConnectivity.message }}",
          "TaskExiting": "{{ CheckTasksAreExiting.message }}",
          "TargetHealth": "{{ CheckTargetHealth.message }}",
          "CustomCheck": "{{ ExecuteCustomCheck.message }}",
          "AdditionalCheck": "{{ ExecuteAdditionalCheck.message }}"
        },
        "Handler": "generate_report.generate_report",
        "Runtime": "python3.11",
        "Attachment": "attachments.zip"
      },
      "outputs": [
        {
          "Name": "message",
          "Selector": "$.Payload.message",
          "Type": "String"
        }
      ]
    }
  ],
  "outputs": [
    "ExecutionResult.message"
  ],
  "files": {
    "attachments.zip": {
      "checksums": {
        "SHA256": "5b3441e22d54a143ee34a45a2c954cc8ab2038258a34e146b410dd2d30bd0867"
      }
    }
  }
}
